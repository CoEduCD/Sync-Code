/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/yorkie-js-sdk";
exports.ids = ["vendor-chunks/yorkie-js-sdk"];
exports.modules = {

/***/ "(ssr)/./node_modules/yorkie-js-sdk/dist/yorkie-js-sdk.js":
/*!**********************************************************!*\
  !*** ./node_modules/yorkie-js-sdk/dist/yorkie-js-sdk.js ***!
  \**********************************************************/
/***/ (function(module) {

eval("/*!\n * \n * yorkie-js-sdk for building collaborative editing applications.\n *  - Version: v0.4.11\n *  - Date: 2023-12-18T02:19Z\n *  - Homepage: https://yorkie.dev\n *\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, () => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 646:\n/***/ ((__unused_webpack_module, exports, __nested_webpack_require_1304__) => {\n\n//\n// Copyright 2022 The Yorkie Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// @generated by protoc-gen-es v1.6.0 with parameter \"target=js+dts,js_import_style=legacy_commonjs\"\n// @generated from file src/api/yorkie/v1/resources.proto (package yorkie.v1, syntax proto3)\n/* eslint-disable */\n// @ts-nocheck\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nconst { proto3, StringValue, Timestamp } = __nested_webpack_require_1304__(532);\n\n/**\n * @generated from enum yorkie.v1.ValueType\n */\nconst ValueType = proto3.makeEnum(\n  \"yorkie.v1.ValueType\",\n  [\n    {no: 0, name: \"VALUE_TYPE_NULL\", localName: \"NULL\"},\n    {no: 1, name: \"VALUE_TYPE_BOOLEAN\", localName: \"BOOLEAN\"},\n    {no: 2, name: \"VALUE_TYPE_INTEGER\", localName: \"INTEGER\"},\n    {no: 3, name: \"VALUE_TYPE_LONG\", localName: \"LONG\"},\n    {no: 4, name: \"VALUE_TYPE_DOUBLE\", localName: \"DOUBLE\"},\n    {no: 5, name: \"VALUE_TYPE_STRING\", localName: \"STRING\"},\n    {no: 6, name: \"VALUE_TYPE_BYTES\", localName: \"BYTES\"},\n    {no: 7, name: \"VALUE_TYPE_DATE\", localName: \"DATE\"},\n    {no: 8, name: \"VALUE_TYPE_JSON_OBJECT\", localName: \"JSON_OBJECT\"},\n    {no: 9, name: \"VALUE_TYPE_JSON_ARRAY\", localName: \"JSON_ARRAY\"},\n    {no: 10, name: \"VALUE_TYPE_TEXT\", localName: \"TEXT\"},\n    {no: 11, name: \"VALUE_TYPE_INTEGER_CNT\", localName: \"INTEGER_CNT\"},\n    {no: 12, name: \"VALUE_TYPE_LONG_CNT\", localName: \"LONG_CNT\"},\n    {no: 13, name: \"VALUE_TYPE_TREE\", localName: \"TREE\"},\n  ],\n);\n\n/**\n * @generated from enum yorkie.v1.DocEventType\n */\nconst DocEventType = proto3.makeEnum(\n  \"yorkie.v1.DocEventType\",\n  [\n    {no: 0, name: \"DOC_EVENT_TYPE_DOCUMENT_CHANGED\", localName: \"DOCUMENT_CHANGED\"},\n    {no: 1, name: \"DOC_EVENT_TYPE_DOCUMENT_WATCHED\", localName: \"DOCUMENT_WATCHED\"},\n    {no: 2, name: \"DOC_EVENT_TYPE_DOCUMENT_UNWATCHED\", localName: \"DOCUMENT_UNWATCHED\"},\n    {no: 3, name: \"DOC_EVENT_TYPE_DOCUMENT_BROADCAST\", localName: \"DOCUMENT_BROADCAST\"},\n  ],\n);\n\n/**\n * ///////////////////////////////////////\n * Messages for Snapshot               //\n * ///////////////////////////////////////\n *\n * @generated from message yorkie.v1.Snapshot\n */\nconst Snapshot = proto3.makeMessageType(\n  \"yorkie.v1.Snapshot\",\n  () => [\n    { no: 1, name: \"root\", kind: \"message\", T: JSONElement },\n    { no: 2, name: \"presences\", kind: \"map\", K: 9 /* ScalarType.STRING */, V: {kind: \"message\", T: Presence} },\n  ],\n);\n\n/**\n * ChangePack is a message that contains all changes that occurred in a document.\n * It is used to synchronize changes between clients and servers.\n *\n * @generated from message yorkie.v1.ChangePack\n */\nconst ChangePack = proto3.makeMessageType(\n  \"yorkie.v1.ChangePack\",\n  () => [\n    { no: 1, name: \"document_key\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 2, name: \"checkpoint\", kind: \"message\", T: Checkpoint },\n    { no: 3, name: \"snapshot\", kind: \"scalar\", T: 12 /* ScalarType.BYTES */ },\n    { no: 4, name: \"changes\", kind: \"message\", T: Change, repeated: true },\n    { no: 5, name: \"min_synced_ticket\", kind: \"message\", T: TimeTicket },\n    { no: 6, name: \"is_removed\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */ },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.Change\n */\nconst Change = proto3.makeMessageType(\n  \"yorkie.v1.Change\",\n  () => [\n    { no: 1, name: \"id\", kind: \"message\", T: ChangeID },\n    { no: 2, name: \"message\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 3, name: \"operations\", kind: \"message\", T: Operation, repeated: true },\n    { no: 4, name: \"presence_change\", kind: \"message\", T: PresenceChange },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.ChangeID\n */\nconst ChangeID = proto3.makeMessageType(\n  \"yorkie.v1.ChangeID\",\n  () => [\n    { no: 1, name: \"client_seq\", kind: \"scalar\", T: 13 /* ScalarType.UINT32 */ },\n    { no: 2, name: \"server_seq\", kind: \"scalar\", T: 3 /* ScalarType.INT64 */, L: 1 /* LongType.STRING */ },\n    { no: 3, name: \"lamport\", kind: \"scalar\", T: 3 /* ScalarType.INT64 */, L: 1 /* LongType.STRING */ },\n    { no: 4, name: \"actor_id\", kind: \"scalar\", T: 12 /* ScalarType.BYTES */ },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.Operation\n */\nconst Operation = proto3.makeMessageType(\n  \"yorkie.v1.Operation\",\n  () => [\n    { no: 1, name: \"set\", kind: \"message\", T: Operation_Set, oneof: \"body\" },\n    { no: 2, name: \"add\", kind: \"message\", T: Operation_Add, oneof: \"body\" },\n    { no: 3, name: \"move\", kind: \"message\", T: Operation_Move, oneof: \"body\" },\n    { no: 4, name: \"remove\", kind: \"message\", T: Operation_Remove, oneof: \"body\" },\n    { no: 5, name: \"edit\", kind: \"message\", T: Operation_Edit, oneof: \"body\" },\n    { no: 6, name: \"select\", kind: \"message\", T: Operation_Select, oneof: \"body\" },\n    { no: 7, name: \"style\", kind: \"message\", T: Operation_Style, oneof: \"body\" },\n    { no: 8, name: \"increase\", kind: \"message\", T: Operation_Increase, oneof: \"body\" },\n    { no: 9, name: \"tree_edit\", kind: \"message\", T: Operation_TreeEdit, oneof: \"body\" },\n    { no: 10, name: \"tree_style\", kind: \"message\", T: Operation_TreeStyle, oneof: \"body\" },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.Operation.Set\n */\nconst Operation_Set = proto3.makeMessageType(\n  \"yorkie.v1.Operation.Set\",\n  () => [\n    { no: 1, name: \"parent_created_at\", kind: \"message\", T: TimeTicket },\n    { no: 2, name: \"key\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 3, name: \"value\", kind: \"message\", T: JSONElementSimple },\n    { no: 4, name: \"executed_at\", kind: \"message\", T: TimeTicket },\n  ],\n  {localName: \"Operation_Set\"},\n);\n\n/**\n * @generated from message yorkie.v1.Operation.Add\n */\nconst Operation_Add = proto3.makeMessageType(\n  \"yorkie.v1.Operation.Add\",\n  () => [\n    { no: 1, name: \"parent_created_at\", kind: \"message\", T: TimeTicket },\n    { no: 2, name: \"prev_created_at\", kind: \"message\", T: TimeTicket },\n    { no: 3, name: \"value\", kind: \"message\", T: JSONElementSimple },\n    { no: 4, name: \"executed_at\", kind: \"message\", T: TimeTicket },\n  ],\n  {localName: \"Operation_Add\"},\n);\n\n/**\n * @generated from message yorkie.v1.Operation.Move\n */\nconst Operation_Move = proto3.makeMessageType(\n  \"yorkie.v1.Operation.Move\",\n  () => [\n    { no: 1, name: \"parent_created_at\", kind: \"message\", T: TimeTicket },\n    { no: 2, name: \"prev_created_at\", kind: \"message\", T: TimeTicket },\n    { no: 3, name: \"created_at\", kind: \"message\", T: TimeTicket },\n    { no: 4, name: \"executed_at\", kind: \"message\", T: TimeTicket },\n  ],\n  {localName: \"Operation_Move\"},\n);\n\n/**\n * @generated from message yorkie.v1.Operation.Remove\n */\nconst Operation_Remove = proto3.makeMessageType(\n  \"yorkie.v1.Operation.Remove\",\n  () => [\n    { no: 1, name: \"parent_created_at\", kind: \"message\", T: TimeTicket },\n    { no: 2, name: \"created_at\", kind: \"message\", T: TimeTicket },\n    { no: 3, name: \"executed_at\", kind: \"message\", T: TimeTicket },\n  ],\n  {localName: \"Operation_Remove\"},\n);\n\n/**\n * @generated from message yorkie.v1.Operation.Edit\n */\nconst Operation_Edit = proto3.makeMessageType(\n  \"yorkie.v1.Operation.Edit\",\n  () => [\n    { no: 1, name: \"parent_created_at\", kind: \"message\", T: TimeTicket },\n    { no: 2, name: \"from\", kind: \"message\", T: TextNodePos },\n    { no: 3, name: \"to\", kind: \"message\", T: TextNodePos },\n    { no: 4, name: \"created_at_map_by_actor\", kind: \"map\", K: 9 /* ScalarType.STRING */, V: {kind: \"message\", T: TimeTicket} },\n    { no: 5, name: \"content\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 6, name: \"executed_at\", kind: \"message\", T: TimeTicket },\n    { no: 7, name: \"attributes\", kind: \"map\", K: 9 /* ScalarType.STRING */, V: {kind: \"scalar\", T: 9 /* ScalarType.STRING */} },\n  ],\n  {localName: \"Operation_Edit\"},\n);\n\n/**\n * NOTE(hackerwins): Select Operation is not used in the current version.\n * In the previous version, it was used to represent selection of Text.\n * However, it has been replaced by Presence now. It is retained for backward\n * compatibility purposes.\n *\n * @generated from message yorkie.v1.Operation.Select\n */\nconst Operation_Select = proto3.makeMessageType(\n  \"yorkie.v1.Operation.Select\",\n  () => [\n    { no: 1, name: \"parent_created_at\", kind: \"message\", T: TimeTicket },\n    { no: 2, name: \"from\", kind: \"message\", T: TextNodePos },\n    { no: 3, name: \"to\", kind: \"message\", T: TextNodePos },\n    { no: 4, name: \"executed_at\", kind: \"message\", T: TimeTicket },\n  ],\n  {localName: \"Operation_Select\"},\n);\n\n/**\n * @generated from message yorkie.v1.Operation.Style\n */\nconst Operation_Style = proto3.makeMessageType(\n  \"yorkie.v1.Operation.Style\",\n  () => [\n    { no: 1, name: \"parent_created_at\", kind: \"message\", T: TimeTicket },\n    { no: 2, name: \"from\", kind: \"message\", T: TextNodePos },\n    { no: 3, name: \"to\", kind: \"message\", T: TextNodePos },\n    { no: 4, name: \"attributes\", kind: \"map\", K: 9 /* ScalarType.STRING */, V: {kind: \"scalar\", T: 9 /* ScalarType.STRING */} },\n    { no: 5, name: \"executed_at\", kind: \"message\", T: TimeTicket },\n    { no: 6, name: \"created_at_map_by_actor\", kind: \"map\", K: 9 /* ScalarType.STRING */, V: {kind: \"message\", T: TimeTicket} },\n  ],\n  {localName: \"Operation_Style\"},\n);\n\n/**\n * @generated from message yorkie.v1.Operation.Increase\n */\nconst Operation_Increase = proto3.makeMessageType(\n  \"yorkie.v1.Operation.Increase\",\n  () => [\n    { no: 1, name: \"parent_created_at\", kind: \"message\", T: TimeTicket },\n    { no: 2, name: \"value\", kind: \"message\", T: JSONElementSimple },\n    { no: 3, name: \"executed_at\", kind: \"message\", T: TimeTicket },\n  ],\n  {localName: \"Operation_Increase\"},\n);\n\n/**\n * @generated from message yorkie.v1.Operation.TreeEdit\n */\nconst Operation_TreeEdit = proto3.makeMessageType(\n  \"yorkie.v1.Operation.TreeEdit\",\n  () => [\n    { no: 1, name: \"parent_created_at\", kind: \"message\", T: TimeTicket },\n    { no: 2, name: \"from\", kind: \"message\", T: TreePos },\n    { no: 3, name: \"to\", kind: \"message\", T: TreePos },\n    { no: 4, name: \"created_at_map_by_actor\", kind: \"map\", K: 9 /* ScalarType.STRING */, V: {kind: \"message\", T: TimeTicket} },\n    { no: 5, name: \"contents\", kind: \"message\", T: TreeNodes, repeated: true },\n    { no: 7, name: \"split_level\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */ },\n    { no: 6, name: \"executed_at\", kind: \"message\", T: TimeTicket },\n  ],\n  {localName: \"Operation_TreeEdit\"},\n);\n\n/**\n * @generated from message yorkie.v1.Operation.TreeStyle\n */\nconst Operation_TreeStyle = proto3.makeMessageType(\n  \"yorkie.v1.Operation.TreeStyle\",\n  () => [\n    { no: 1, name: \"parent_created_at\", kind: \"message\", T: TimeTicket },\n    { no: 2, name: \"from\", kind: \"message\", T: TreePos },\n    { no: 3, name: \"to\", kind: \"message\", T: TreePos },\n    { no: 4, name: \"attributes\", kind: \"map\", K: 9 /* ScalarType.STRING */, V: {kind: \"scalar\", T: 9 /* ScalarType.STRING */} },\n    { no: 5, name: \"executed_at\", kind: \"message\", T: TimeTicket },\n  ],\n  {localName: \"Operation_TreeStyle\"},\n);\n\n/**\n * @generated from message yorkie.v1.JSONElementSimple\n */\nconst JSONElementSimple = proto3.makeMessageType(\n  \"yorkie.v1.JSONElementSimple\",\n  () => [\n    { no: 1, name: \"created_at\", kind: \"message\", T: TimeTicket },\n    { no: 2, name: \"moved_at\", kind: \"message\", T: TimeTicket },\n    { no: 3, name: \"removed_at\", kind: \"message\", T: TimeTicket },\n    { no: 4, name: \"type\", kind: \"enum\", T: proto3.getEnumType(ValueType) },\n    { no: 5, name: \"value\", kind: \"scalar\", T: 12 /* ScalarType.BYTES */ },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.JSONElement\n */\nconst JSONElement = proto3.makeMessageType(\n  \"yorkie.v1.JSONElement\",\n  () => [\n    { no: 1, name: \"json_object\", kind: \"message\", T: JSONElement_JSONObject, oneof: \"body\" },\n    { no: 2, name: \"json_array\", kind: \"message\", T: JSONElement_JSONArray, oneof: \"body\" },\n    { no: 3, name: \"primitive\", kind: \"message\", T: JSONElement_Primitive, oneof: \"body\" },\n    { no: 5, name: \"text\", kind: \"message\", T: JSONElement_Text, oneof: \"body\" },\n    { no: 6, name: \"counter\", kind: \"message\", T: JSONElement_Counter, oneof: \"body\" },\n    { no: 7, name: \"tree\", kind: \"message\", T: JSONElement_Tree, oneof: \"body\" },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.JSONElement.JSONObject\n */\nconst JSONElement_JSONObject = proto3.makeMessageType(\n  \"yorkie.v1.JSONElement.JSONObject\",\n  () => [\n    { no: 1, name: \"nodes\", kind: \"message\", T: RHTNode, repeated: true },\n    { no: 2, name: \"created_at\", kind: \"message\", T: TimeTicket },\n    { no: 3, name: \"moved_at\", kind: \"message\", T: TimeTicket },\n    { no: 4, name: \"removed_at\", kind: \"message\", T: TimeTicket },\n  ],\n  {localName: \"JSONElement_JSONObject\"},\n);\n\n/**\n * @generated from message yorkie.v1.JSONElement.JSONArray\n */\nconst JSONElement_JSONArray = proto3.makeMessageType(\n  \"yorkie.v1.JSONElement.JSONArray\",\n  () => [\n    { no: 1, name: \"nodes\", kind: \"message\", T: RGANode, repeated: true },\n    { no: 2, name: \"created_at\", kind: \"message\", T: TimeTicket },\n    { no: 3, name: \"moved_at\", kind: \"message\", T: TimeTicket },\n    { no: 4, name: \"removed_at\", kind: \"message\", T: TimeTicket },\n  ],\n  {localName: \"JSONElement_JSONArray\"},\n);\n\n/**\n * @generated from message yorkie.v1.JSONElement.Primitive\n */\nconst JSONElement_Primitive = proto3.makeMessageType(\n  \"yorkie.v1.JSONElement.Primitive\",\n  () => [\n    { no: 1, name: \"type\", kind: \"enum\", T: proto3.getEnumType(ValueType) },\n    { no: 2, name: \"value\", kind: \"scalar\", T: 12 /* ScalarType.BYTES */ },\n    { no: 3, name: \"created_at\", kind: \"message\", T: TimeTicket },\n    { no: 4, name: \"moved_at\", kind: \"message\", T: TimeTicket },\n    { no: 5, name: \"removed_at\", kind: \"message\", T: TimeTicket },\n  ],\n  {localName: \"JSONElement_Primitive\"},\n);\n\n/**\n * @generated from message yorkie.v1.JSONElement.Text\n */\nconst JSONElement_Text = proto3.makeMessageType(\n  \"yorkie.v1.JSONElement.Text\",\n  () => [\n    { no: 1, name: \"nodes\", kind: \"message\", T: TextNode, repeated: true },\n    { no: 2, name: \"created_at\", kind: \"message\", T: TimeTicket },\n    { no: 3, name: \"moved_at\", kind: \"message\", T: TimeTicket },\n    { no: 4, name: \"removed_at\", kind: \"message\", T: TimeTicket },\n  ],\n  {localName: \"JSONElement_Text\"},\n);\n\n/**\n * @generated from message yorkie.v1.JSONElement.Counter\n */\nconst JSONElement_Counter = proto3.makeMessageType(\n  \"yorkie.v1.JSONElement.Counter\",\n  () => [\n    { no: 1, name: \"type\", kind: \"enum\", T: proto3.getEnumType(ValueType) },\n    { no: 2, name: \"value\", kind: \"scalar\", T: 12 /* ScalarType.BYTES */ },\n    { no: 3, name: \"created_at\", kind: \"message\", T: TimeTicket },\n    { no: 4, name: \"moved_at\", kind: \"message\", T: TimeTicket },\n    { no: 5, name: \"removed_at\", kind: \"message\", T: TimeTicket },\n  ],\n  {localName: \"JSONElement_Counter\"},\n);\n\n/**\n * @generated from message yorkie.v1.JSONElement.Tree\n */\nconst JSONElement_Tree = proto3.makeMessageType(\n  \"yorkie.v1.JSONElement.Tree\",\n  () => [\n    { no: 1, name: \"nodes\", kind: \"message\", T: TreeNode, repeated: true },\n    { no: 2, name: \"created_at\", kind: \"message\", T: TimeTicket },\n    { no: 3, name: \"moved_at\", kind: \"message\", T: TimeTicket },\n    { no: 4, name: \"removed_at\", kind: \"message\", T: TimeTicket },\n  ],\n  {localName: \"JSONElement_Tree\"},\n);\n\n/**\n * @generated from message yorkie.v1.RHTNode\n */\nconst RHTNode = proto3.makeMessageType(\n  \"yorkie.v1.RHTNode\",\n  () => [\n    { no: 1, name: \"key\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 2, name: \"element\", kind: \"message\", T: JSONElement },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.RGANode\n */\nconst RGANode = proto3.makeMessageType(\n  \"yorkie.v1.RGANode\",\n  () => [\n    { no: 1, name: \"next\", kind: \"message\", T: RGANode },\n    { no: 2, name: \"element\", kind: \"message\", T: JSONElement },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.NodeAttr\n */\nconst NodeAttr = proto3.makeMessageType(\n  \"yorkie.v1.NodeAttr\",\n  () => [\n    { no: 1, name: \"value\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 2, name: \"updated_at\", kind: \"message\", T: TimeTicket },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.TextNode\n */\nconst TextNode = proto3.makeMessageType(\n  \"yorkie.v1.TextNode\",\n  () => [\n    { no: 1, name: \"id\", kind: \"message\", T: TextNodeID },\n    { no: 2, name: \"value\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 3, name: \"removed_at\", kind: \"message\", T: TimeTicket },\n    { no: 4, name: \"ins_prev_id\", kind: \"message\", T: TextNodeID },\n    { no: 5, name: \"attributes\", kind: \"map\", K: 9 /* ScalarType.STRING */, V: {kind: \"message\", T: NodeAttr} },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.TextNodeID\n */\nconst TextNodeID = proto3.makeMessageType(\n  \"yorkie.v1.TextNodeID\",\n  () => [\n    { no: 1, name: \"created_at\", kind: \"message\", T: TimeTicket },\n    { no: 2, name: \"offset\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */ },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.TreeNode\n */\nconst TreeNode = proto3.makeMessageType(\n  \"yorkie.v1.TreeNode\",\n  () => [\n    { no: 1, name: \"id\", kind: \"message\", T: TreeNodeID },\n    { no: 2, name: \"type\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 3, name: \"value\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 4, name: \"removed_at\", kind: \"message\", T: TimeTicket },\n    { no: 5, name: \"ins_prev_id\", kind: \"message\", T: TreeNodeID },\n    { no: 6, name: \"ins_next_id\", kind: \"message\", T: TreeNodeID },\n    { no: 7, name: \"depth\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */ },\n    { no: 8, name: \"attributes\", kind: \"map\", K: 9 /* ScalarType.STRING */, V: {kind: \"message\", T: NodeAttr} },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.TreeNodes\n */\nconst TreeNodes = proto3.makeMessageType(\n  \"yorkie.v1.TreeNodes\",\n  () => [\n    { no: 1, name: \"content\", kind: \"message\", T: TreeNode, repeated: true },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.TreeNodeID\n */\nconst TreeNodeID = proto3.makeMessageType(\n  \"yorkie.v1.TreeNodeID\",\n  () => [\n    { no: 1, name: \"created_at\", kind: \"message\", T: TimeTicket },\n    { no: 2, name: \"offset\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */ },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.TreePos\n */\nconst TreePos = proto3.makeMessageType(\n  \"yorkie.v1.TreePos\",\n  () => [\n    { no: 1, name: \"parent_id\", kind: \"message\", T: TreeNodeID },\n    { no: 2, name: \"left_sibling_id\", kind: \"message\", T: TreeNodeID },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.User\n */\nconst User = proto3.makeMessageType(\n  \"yorkie.v1.User\",\n  () => [\n    { no: 1, name: \"id\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 2, name: \"username\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 3, name: \"created_at\", kind: \"message\", T: Timestamp },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.Project\n */\nconst Project = proto3.makeMessageType(\n  \"yorkie.v1.Project\",\n  () => [\n    { no: 1, name: \"id\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 2, name: \"name\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 3, name: \"public_key\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 4, name: \"secret_key\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 5, name: \"auth_webhook_url\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 6, name: \"auth_webhook_methods\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, repeated: true },\n    { no: 7, name: \"client_deactivate_threshold\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 8, name: \"created_at\", kind: \"message\", T: Timestamp },\n    { no: 9, name: \"updated_at\", kind: \"message\", T: Timestamp },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.UpdatableProjectFields\n */\nconst UpdatableProjectFields = proto3.makeMessageType(\n  \"yorkie.v1.UpdatableProjectFields\",\n  () => [\n    { no: 1, name: \"name\", kind: \"message\", T: StringValue },\n    { no: 2, name: \"auth_webhook_url\", kind: \"message\", T: StringValue },\n    { no: 3, name: \"auth_webhook_methods\", kind: \"message\", T: UpdatableProjectFields_AuthWebhookMethods },\n    { no: 4, name: \"client_deactivate_threshold\", kind: \"message\", T: StringValue },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.UpdatableProjectFields.AuthWebhookMethods\n */\nconst UpdatableProjectFields_AuthWebhookMethods = proto3.makeMessageType(\n  \"yorkie.v1.UpdatableProjectFields.AuthWebhookMethods\",\n  () => [\n    { no: 1, name: \"methods\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, repeated: true },\n  ],\n  {localName: \"UpdatableProjectFields_AuthWebhookMethods\"},\n);\n\n/**\n * @generated from message yorkie.v1.DocumentSummary\n */\nconst DocumentSummary = proto3.makeMessageType(\n  \"yorkie.v1.DocumentSummary\",\n  () => [\n    { no: 1, name: \"id\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 2, name: \"key\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 3, name: \"snapshot\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 4, name: \"created_at\", kind: \"message\", T: Timestamp },\n    { no: 5, name: \"accessed_at\", kind: \"message\", T: Timestamp },\n    { no: 6, name: \"updated_at\", kind: \"message\", T: Timestamp },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.PresenceChange\n */\nconst PresenceChange = proto3.makeMessageType(\n  \"yorkie.v1.PresenceChange\",\n  () => [\n    { no: 1, name: \"type\", kind: \"enum\", T: proto3.getEnumType(PresenceChange_ChangeType) },\n    { no: 2, name: \"presence\", kind: \"message\", T: Presence },\n  ],\n);\n\n/**\n * @generated from enum yorkie.v1.PresenceChange.ChangeType\n */\nconst PresenceChange_ChangeType = proto3.makeEnum(\n  \"yorkie.v1.PresenceChange.ChangeType\",\n  [\n    {no: 0, name: \"CHANGE_TYPE_UNSPECIFIED\", localName: \"UNSPECIFIED\"},\n    {no: 1, name: \"CHANGE_TYPE_PUT\", localName: \"PUT\"},\n    {no: 2, name: \"CHANGE_TYPE_DELETE\", localName: \"DELETE\"},\n    {no: 3, name: \"CHANGE_TYPE_CLEAR\", localName: \"CLEAR\"},\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.Presence\n */\nconst Presence = proto3.makeMessageType(\n  \"yorkie.v1.Presence\",\n  () => [\n    { no: 1, name: \"data\", kind: \"map\", K: 9 /* ScalarType.STRING */, V: {kind: \"scalar\", T: 9 /* ScalarType.STRING */} },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.Checkpoint\n */\nconst Checkpoint = proto3.makeMessageType(\n  \"yorkie.v1.Checkpoint\",\n  () => [\n    { no: 1, name: \"server_seq\", kind: \"scalar\", T: 3 /* ScalarType.INT64 */, L: 1 /* LongType.STRING */ },\n    { no: 2, name: \"client_seq\", kind: \"scalar\", T: 13 /* ScalarType.UINT32 */ },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.TextNodePos\n */\nconst TextNodePos = proto3.makeMessageType(\n  \"yorkie.v1.TextNodePos\",\n  () => [\n    { no: 1, name: \"created_at\", kind: \"message\", T: TimeTicket },\n    { no: 2, name: \"offset\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */ },\n    { no: 3, name: \"relative_offset\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */ },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.TimeTicket\n */\nconst TimeTicket = proto3.makeMessageType(\n  \"yorkie.v1.TimeTicket\",\n  () => [\n    { no: 1, name: \"lamport\", kind: \"scalar\", T: 3 /* ScalarType.INT64 */, L: 1 /* LongType.STRING */ },\n    { no: 2, name: \"delimiter\", kind: \"scalar\", T: 13 /* ScalarType.UINT32 */ },\n    { no: 3, name: \"actor_id\", kind: \"scalar\", T: 12 /* ScalarType.BYTES */ },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.DocEventBody\n */\nconst DocEventBody = proto3.makeMessageType(\n  \"yorkie.v1.DocEventBody\",\n  () => [\n    { no: 1, name: \"topic\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 2, name: \"payload\", kind: \"scalar\", T: 12 /* ScalarType.BYTES */ },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.DocEvent\n */\nconst DocEvent = proto3.makeMessageType(\n  \"yorkie.v1.DocEvent\",\n  () => [\n    { no: 1, name: \"type\", kind: \"enum\", T: proto3.getEnumType(DocEventType) },\n    { no: 2, name: \"publisher\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 3, name: \"body\", kind: \"message\", T: DocEventBody },\n  ],\n);\n\n\nexports.ValueType = ValueType;\nexports.DocEventType = DocEventType;\nexports.Snapshot = Snapshot;\nexports.ChangePack = ChangePack;\nexports.Change = Change;\nexports.ChangeID = ChangeID;\nexports.Operation = Operation;\nexports.Operation_Set = Operation_Set;\nexports.Operation_Add = Operation_Add;\nexports.Operation_Move = Operation_Move;\nexports.Operation_Remove = Operation_Remove;\nexports.Operation_Edit = Operation_Edit;\nexports.Operation_Select = Operation_Select;\nexports.Operation_Style = Operation_Style;\nexports.Operation_Increase = Operation_Increase;\nexports.Operation_TreeEdit = Operation_TreeEdit;\nexports.Operation_TreeStyle = Operation_TreeStyle;\nexports.JSONElementSimple = JSONElementSimple;\nexports.JSONElement = JSONElement;\nexports.JSONElement_JSONObject = JSONElement_JSONObject;\nexports.JSONElement_JSONArray = JSONElement_JSONArray;\nexports.JSONElement_Primitive = JSONElement_Primitive;\nexports.JSONElement_Text = JSONElement_Text;\nexports.JSONElement_Counter = JSONElement_Counter;\nexports.JSONElement_Tree = JSONElement_Tree;\nexports.RHTNode = RHTNode;\nexports.RGANode = RGANode;\nexports.NodeAttr = NodeAttr;\nexports.TextNode = TextNode;\nexports.TextNodeID = TextNodeID;\nexports.TreeNode = TreeNode;\nexports.TreeNodes = TreeNodes;\nexports.TreeNodeID = TreeNodeID;\nexports.TreePos = TreePos;\nexports.User = User;\nexports.Project = Project;\nexports.UpdatableProjectFields = UpdatableProjectFields;\nexports.UpdatableProjectFields_AuthWebhookMethods = UpdatableProjectFields_AuthWebhookMethods;\nexports.DocumentSummary = DocumentSummary;\nexports.PresenceChange = PresenceChange;\nexports.PresenceChange_ChangeType = PresenceChange_ChangeType;\nexports.Presence = Presence;\nexports.Checkpoint = Checkpoint;\nexports.TextNodePos = TextNodePos;\nexports.TimeTicket = TimeTicket;\nexports.DocEventBody = DocEventBody;\nexports.DocEvent = DocEvent;\n\n\n/***/ }),\n\n/***/ 295:\n/***/ ((__unused_webpack_module, exports, __nested_webpack_require_27492__) => {\n\nvar __webpack_unused_export__;\n//\n// Copyright 2020 The Yorkie Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// @generated by protoc-gen-connect-es v1.2.0 with parameter \"target=js+dts,js_import_style=legacy_commonjs\"\n// @generated from file src/api/yorkie/v1/yorkie.proto (package yorkie.v1, syntax proto3)\n/* eslint-disable */\n// @ts-nocheck\n\n\n__webpack_unused_export__ = ({ value: true });\n\nconst { ActivateClientRequest, ActivateClientResponse, AttachDocumentRequest, AttachDocumentResponse, BroadcastRequest, BroadcastResponse, DeactivateClientRequest, DeactivateClientResponse, DetachDocumentRequest, DetachDocumentResponse, PushPullChangesRequest, PushPullChangesResponse, RemoveDocumentRequest, RemoveDocumentResponse, WatchDocumentRequest, WatchDocumentResponse } = __nested_webpack_require_27492__(176);\nconst { MethodKind } = __nested_webpack_require_27492__(532);\n\n/**\n * Yorkie is a service that provides a API for SDKs.\n *\n * @generated from service yorkie.v1.YorkieService\n */\nconst YorkieService = {\n  typeName: \"yorkie.v1.YorkieService\",\n  methods: {\n    /**\n     * @generated from rpc yorkie.v1.YorkieService.ActivateClient\n     */\n    activateClient: {\n      name: \"ActivateClient\",\n      I: ActivateClientRequest,\n      O: ActivateClientResponse,\n      kind: MethodKind.Unary,\n    },\n    /**\n     * @generated from rpc yorkie.v1.YorkieService.DeactivateClient\n     */\n    deactivateClient: {\n      name: \"DeactivateClient\",\n      I: DeactivateClientRequest,\n      O: DeactivateClientResponse,\n      kind: MethodKind.Unary,\n    },\n    /**\n     * @generated from rpc yorkie.v1.YorkieService.AttachDocument\n     */\n    attachDocument: {\n      name: \"AttachDocument\",\n      I: AttachDocumentRequest,\n      O: AttachDocumentResponse,\n      kind: MethodKind.Unary,\n    },\n    /**\n     * @generated from rpc yorkie.v1.YorkieService.DetachDocument\n     */\n    detachDocument: {\n      name: \"DetachDocument\",\n      I: DetachDocumentRequest,\n      O: DetachDocumentResponse,\n      kind: MethodKind.Unary,\n    },\n    /**\n     * @generated from rpc yorkie.v1.YorkieService.RemoveDocument\n     */\n    removeDocument: {\n      name: \"RemoveDocument\",\n      I: RemoveDocumentRequest,\n      O: RemoveDocumentResponse,\n      kind: MethodKind.Unary,\n    },\n    /**\n     * @generated from rpc yorkie.v1.YorkieService.PushPullChanges\n     */\n    pushPullChanges: {\n      name: \"PushPullChanges\",\n      I: PushPullChangesRequest,\n      O: PushPullChangesResponse,\n      kind: MethodKind.Unary,\n    },\n    /**\n     * @generated from rpc yorkie.v1.YorkieService.WatchDocument\n     */\n    watchDocument: {\n      name: \"WatchDocument\",\n      I: WatchDocumentRequest,\n      O: WatchDocumentResponse,\n      kind: MethodKind.ServerStreaming,\n    },\n    /**\n     * @generated from rpc yorkie.v1.YorkieService.Broadcast\n     */\n    broadcast: {\n      name: \"Broadcast\",\n      I: BroadcastRequest,\n      O: BroadcastResponse,\n      kind: MethodKind.Unary,\n    },\n  }\n};\n\n\nexports.V = YorkieService;\n\n\n/***/ }),\n\n/***/ 176:\n/***/ ((__unused_webpack_module, exports, __nested_webpack_require_31089__) => {\n\n//\n// Copyright 2020 The Yorkie Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// @generated by protoc-gen-es v1.6.0 with parameter \"target=js+dts,js_import_style=legacy_commonjs\"\n// @generated from file src/api/yorkie/v1/yorkie.proto (package yorkie.v1, syntax proto3)\n/* eslint-disable */\n// @ts-nocheck\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nconst { proto3 } = __nested_webpack_require_31089__(532);\nconst { ChangePack, DocEvent } = __nested_webpack_require_31089__(646);\n\n/**\n * @generated from message yorkie.v1.ActivateClientRequest\n */\nconst ActivateClientRequest = proto3.makeMessageType(\n  \"yorkie.v1.ActivateClientRequest\",\n  () => [\n    { no: 1, name: \"client_key\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.ActivateClientResponse\n */\nconst ActivateClientResponse = proto3.makeMessageType(\n  \"yorkie.v1.ActivateClientResponse\",\n  () => [\n    { no: 1, name: \"client_id\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.DeactivateClientRequest\n */\nconst DeactivateClientRequest = proto3.makeMessageType(\n  \"yorkie.v1.DeactivateClientRequest\",\n  () => [\n    { no: 1, name: \"client_id\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.DeactivateClientResponse\n */\nconst DeactivateClientResponse = proto3.makeMessageType(\n  \"yorkie.v1.DeactivateClientResponse\",\n  [],\n);\n\n/**\n * @generated from message yorkie.v1.AttachDocumentRequest\n */\nconst AttachDocumentRequest = proto3.makeMessageType(\n  \"yorkie.v1.AttachDocumentRequest\",\n  () => [\n    { no: 1, name: \"client_id\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 2, name: \"change_pack\", kind: \"message\", T: ChangePack },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.AttachDocumentResponse\n */\nconst AttachDocumentResponse = proto3.makeMessageType(\n  \"yorkie.v1.AttachDocumentResponse\",\n  () => [\n    { no: 1, name: \"document_id\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 2, name: \"change_pack\", kind: \"message\", T: ChangePack },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.DetachDocumentRequest\n */\nconst DetachDocumentRequest = proto3.makeMessageType(\n  \"yorkie.v1.DetachDocumentRequest\",\n  () => [\n    { no: 1, name: \"client_id\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 2, name: \"document_id\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 3, name: \"change_pack\", kind: \"message\", T: ChangePack },\n    { no: 4, name: \"remove_if_not_attached\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */ },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.DetachDocumentResponse\n */\nconst DetachDocumentResponse = proto3.makeMessageType(\n  \"yorkie.v1.DetachDocumentResponse\",\n  () => [\n    { no: 2, name: \"change_pack\", kind: \"message\", T: ChangePack },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.WatchDocumentRequest\n */\nconst WatchDocumentRequest = proto3.makeMessageType(\n  \"yorkie.v1.WatchDocumentRequest\",\n  () => [\n    { no: 1, name: \"client_id\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 2, name: \"document_id\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.WatchDocumentResponse\n */\nconst WatchDocumentResponse = proto3.makeMessageType(\n  \"yorkie.v1.WatchDocumentResponse\",\n  () => [\n    { no: 1, name: \"initialization\", kind: \"message\", T: WatchDocumentResponse_Initialization, oneof: \"body\" },\n    { no: 2, name: \"event\", kind: \"message\", T: DocEvent, oneof: \"body\" },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.WatchDocumentResponse.Initialization\n */\nconst WatchDocumentResponse_Initialization = proto3.makeMessageType(\n  \"yorkie.v1.WatchDocumentResponse.Initialization\",\n  () => [\n    { no: 1, name: \"client_ids\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, repeated: true },\n  ],\n  {localName: \"WatchDocumentResponse_Initialization\"},\n);\n\n/**\n * @generated from message yorkie.v1.RemoveDocumentRequest\n */\nconst RemoveDocumentRequest = proto3.makeMessageType(\n  \"yorkie.v1.RemoveDocumentRequest\",\n  () => [\n    { no: 1, name: \"client_id\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 2, name: \"document_id\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 3, name: \"change_pack\", kind: \"message\", T: ChangePack },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.RemoveDocumentResponse\n */\nconst RemoveDocumentResponse = proto3.makeMessageType(\n  \"yorkie.v1.RemoveDocumentResponse\",\n  () => [\n    { no: 1, name: \"change_pack\", kind: \"message\", T: ChangePack },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.PushPullChangesRequest\n */\nconst PushPullChangesRequest = proto3.makeMessageType(\n  \"yorkie.v1.PushPullChangesRequest\",\n  () => [\n    { no: 1, name: \"client_id\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 2, name: \"document_id\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 3, name: \"change_pack\", kind: \"message\", T: ChangePack },\n    { no: 4, name: \"push_only\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */ },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.PushPullChangesResponse\n */\nconst PushPullChangesResponse = proto3.makeMessageType(\n  \"yorkie.v1.PushPullChangesResponse\",\n  () => [\n    { no: 1, name: \"change_pack\", kind: \"message\", T: ChangePack },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.BroadcastRequest\n */\nconst BroadcastRequest = proto3.makeMessageType(\n  \"yorkie.v1.BroadcastRequest\",\n  () => [\n    { no: 1, name: \"client_id\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 2, name: \"document_id\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 3, name: \"topic\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 4, name: \"payload\", kind: \"scalar\", T: 12 /* ScalarType.BYTES */ },\n  ],\n);\n\n/**\n * @generated from message yorkie.v1.BroadcastResponse\n */\nconst BroadcastResponse = proto3.makeMessageType(\n  \"yorkie.v1.BroadcastResponse\",\n  [],\n);\n\n\nexports.ActivateClientRequest = ActivateClientRequest;\nexports.ActivateClientResponse = ActivateClientResponse;\nexports.DeactivateClientRequest = DeactivateClientRequest;\nexports.DeactivateClientResponse = DeactivateClientResponse;\nexports.AttachDocumentRequest = AttachDocumentRequest;\nexports.AttachDocumentResponse = AttachDocumentResponse;\nexports.DetachDocumentRequest = DetachDocumentRequest;\nexports.DetachDocumentResponse = DetachDocumentResponse;\nexports.WatchDocumentRequest = WatchDocumentRequest;\nexports.WatchDocumentResponse = WatchDocumentResponse;\nexports.WatchDocumentResponse_Initialization = WatchDocumentResponse_Initialization;\nexports.RemoveDocumentRequest = RemoveDocumentRequest;\nexports.RemoveDocumentResponse = RemoveDocumentResponse;\nexports.PushPullChangesRequest = PushPullChangesRequest;\nexports.PushPullChangesResponse = PushPullChangesResponse;\nexports.BroadcastRequest = BroadcastRequest;\nexports.BroadcastResponse = BroadcastResponse;\n\n\n/***/ }),\n\n/***/ 79:\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_38657__) => {\n\n/* harmony export */ __nested_webpack_require_38657__.d(__nested_webpack_exports__, {\n/* harmony export */   Lt: () => (/* binding */ BinaryWriter),\n/* harmony export */   TD: () => (/* binding */ WireType),\n/* harmony export */   oP: () => (/* binding */ BinaryReader)\n/* harmony export */ });\n/* harmony import */ var _google_varint_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_38657__(818);\n/* harmony import */ var _private_assert_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_38657__(120);\n/* harmony import */ var _proto_int64_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_38657__(210);\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n/* eslint-disable prefer-const,no-case-declarations,@typescript-eslint/restrict-plus-operands */\n/**\n * Protobuf binary format wire types.\n *\n * A wire type provides just enough information to find the length of the\n * following value.\n *\n * See https://developers.google.com/protocol-buffers/docs/encoding#structure\n */\nvar WireType;\n(function (WireType) {\n    /**\n     * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum\n     */\n    WireType[WireType[\"Varint\"] = 0] = \"Varint\";\n    /**\n     * Used for fixed64, sfixed64, double.\n     * Always 8 bytes with little-endian byte order.\n     */\n    WireType[WireType[\"Bit64\"] = 1] = \"Bit64\";\n    /**\n     * Used for string, bytes, embedded messages, packed repeated fields\n     *\n     * Only repeated numeric types (types which use the varint, 32-bit,\n     * or 64-bit wire types) can be packed. In proto3, such fields are\n     * packed by default.\n     */\n    WireType[WireType[\"LengthDelimited\"] = 2] = \"LengthDelimited\";\n    /**\n     * Start of a tag-delimited aggregate, such as a proto2 group, or a message\n     * in editions with message_encoding = DELIMITED.\n     */\n    WireType[WireType[\"StartGroup\"] = 3] = \"StartGroup\";\n    /**\n     * End of a tag-delimited aggregate.\n     */\n    WireType[WireType[\"EndGroup\"] = 4] = \"EndGroup\";\n    /**\n     * Used for fixed32, sfixed32, float.\n     * Always 4 bytes with little-endian byte order.\n     */\n    WireType[WireType[\"Bit32\"] = 5] = \"Bit32\";\n})(WireType || (WireType = {}));\nclass BinaryWriter {\n    constructor(textEncoder) {\n        /**\n         * Previous fork states.\n         */\n        this.stack = [];\n        this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();\n        this.chunks = [];\n        this.buf = [];\n    }\n    /**\n     * Return all bytes written and reset this writer.\n     */\n    finish() {\n        this.chunks.push(new Uint8Array(this.buf)); // flush the buffer\n        let len = 0;\n        for (let i = 0; i < this.chunks.length; i++)\n            len += this.chunks[i].length;\n        let bytes = new Uint8Array(len);\n        let offset = 0;\n        for (let i = 0; i < this.chunks.length; i++) {\n            bytes.set(this.chunks[i], offset);\n            offset += this.chunks[i].length;\n        }\n        this.chunks = [];\n        return bytes;\n    }\n    /**\n     * Start a new fork for length-delimited data like a message\n     * or a packed repeated field.\n     *\n     * Must be joined later with `join()`.\n     */\n    fork() {\n        this.stack.push({ chunks: this.chunks, buf: this.buf });\n        this.chunks = [];\n        this.buf = [];\n        return this;\n    }\n    /**\n     * Join the last fork. Write its length and bytes, then\n     * return to the previous state.\n     */\n    join() {\n        // get chunk of fork\n        let chunk = this.finish();\n        // restore previous state\n        let prev = this.stack.pop();\n        if (!prev)\n            throw new Error(\"invalid state, fork stack empty\");\n        this.chunks = prev.chunks;\n        this.buf = prev.buf;\n        // write length of chunk as varint\n        this.uint32(chunk.byteLength);\n        return this.raw(chunk);\n    }\n    /**\n     * Writes a tag (field number and wire type).\n     *\n     * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.\n     *\n     * Generated code should compute the tag ahead of time and call `uint32()`.\n     */\n    tag(fieldNo, type) {\n        return this.uint32(((fieldNo << 3) | type) >>> 0);\n    }\n    /**\n     * Write a chunk of raw bytes.\n     */\n    raw(chunk) {\n        if (this.buf.length) {\n            this.chunks.push(new Uint8Array(this.buf));\n            this.buf = [];\n        }\n        this.chunks.push(chunk);\n        return this;\n    }\n    /**\n     * Write a `uint32` value, an unsigned 32 bit varint.\n     */\n    uint32(value) {\n        (0,_private_assert_js__WEBPACK_IMPORTED_MODULE_0__/* .assertUInt32 */ .fp)(value);\n        // write value as varint 32, inlined for speed\n        while (value > 0x7f) {\n            this.buf.push((value & 0x7f) | 0x80);\n            value = value >>> 7;\n        }\n        this.buf.push(value);\n        return this;\n    }\n    /**\n     * Write a `int32` value, a signed 32 bit varint.\n     */\n    int32(value) {\n        (0,_private_assert_js__WEBPACK_IMPORTED_MODULE_0__/* .assertInt32 */ .ug)(value);\n        (0,_google_varint_js__WEBPACK_IMPORTED_MODULE_1__/* .varint32write */ .fC)(value, this.buf);\n        return this;\n    }\n    /**\n     * Write a `bool` value, a variant.\n     */\n    bool(value) {\n        this.buf.push(value ? 1 : 0);\n        return this;\n    }\n    /**\n     * Write a `bytes` value, length-delimited arbitrary data.\n     */\n    bytes(value) {\n        this.uint32(value.byteLength); // write length of chunk as varint\n        return this.raw(value);\n    }\n    /**\n     * Write a `string` value, length-delimited data converted to UTF-8 text.\n     */\n    string(value) {\n        let chunk = this.textEncoder.encode(value);\n        this.uint32(chunk.byteLength); // write length of chunk as varint\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `float` value, 32-bit floating point number.\n     */\n    float(value) {\n        (0,_private_assert_js__WEBPACK_IMPORTED_MODULE_0__/* .assertFloat32 */ .E_)(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setFloat32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `double` value, a 64-bit floating point number.\n     */\n    double(value) {\n        let chunk = new Uint8Array(8);\n        new DataView(chunk.buffer).setFloat64(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.\n     */\n    fixed32(value) {\n        (0,_private_assert_js__WEBPACK_IMPORTED_MODULE_0__/* .assertUInt32 */ .fp)(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setUint32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.\n     */\n    sfixed32(value) {\n        (0,_private_assert_js__WEBPACK_IMPORTED_MODULE_0__/* .assertInt32 */ .ug)(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setInt32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.\n     */\n    sint32(value) {\n        (0,_private_assert_js__WEBPACK_IMPORTED_MODULE_0__/* .assertInt32 */ .ug)(value);\n        // zigzag encode\n        value = ((value << 1) ^ (value >> 31)) >>> 0;\n        (0,_google_varint_js__WEBPACK_IMPORTED_MODULE_1__/* .varint32write */ .fC)(value, this.buf);\n        return this;\n    }\n    /**\n     * Write a `fixed64` value, a signed, fixed-length 64-bit integer.\n     */\n    sfixed64(value) {\n        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = _proto_int64_js__WEBPACK_IMPORTED_MODULE_2__/* .protoInt64 */ .q.enc(value);\n        view.setInt32(0, tc.lo, true);\n        view.setInt32(4, tc.hi, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.\n     */\n    fixed64(value) {\n        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = _proto_int64_js__WEBPACK_IMPORTED_MODULE_2__/* .protoInt64 */ .q.uEnc(value);\n        view.setInt32(0, tc.lo, true);\n        view.setInt32(4, tc.hi, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `int64` value, a signed 64-bit varint.\n     */\n    int64(value) {\n        let tc = _proto_int64_js__WEBPACK_IMPORTED_MODULE_2__/* .protoInt64 */ .q.enc(value);\n        (0,_google_varint_js__WEBPACK_IMPORTED_MODULE_1__/* .varint64write */ ._y)(tc.lo, tc.hi, this.buf);\n        return this;\n    }\n    /**\n     * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.\n     */\n    sint64(value) {\n        let tc = _proto_int64_js__WEBPACK_IMPORTED_MODULE_2__/* .protoInt64 */ .q.enc(value), \n        // zigzag encode\n        sign = tc.hi >> 31, lo = (tc.lo << 1) ^ sign, hi = ((tc.hi << 1) | (tc.lo >>> 31)) ^ sign;\n        (0,_google_varint_js__WEBPACK_IMPORTED_MODULE_1__/* .varint64write */ ._y)(lo, hi, this.buf);\n        return this;\n    }\n    /**\n     * Write a `uint64` value, an unsigned 64-bit varint.\n     */\n    uint64(value) {\n        let tc = _proto_int64_js__WEBPACK_IMPORTED_MODULE_2__/* .protoInt64 */ .q.uEnc(value);\n        (0,_google_varint_js__WEBPACK_IMPORTED_MODULE_1__/* .varint64write */ ._y)(tc.lo, tc.hi, this.buf);\n        return this;\n    }\n}\nclass BinaryReader {\n    constructor(buf, textDecoder) {\n        this.varint64 = _google_varint_js__WEBPACK_IMPORTED_MODULE_1__/* .varint64read */ .sg; // dirty cast for `this`\n        /**\n         * Read a `uint32` field, an unsigned 32 bit varint.\n         */\n        this.uint32 = _google_varint_js__WEBPACK_IMPORTED_MODULE_1__/* .varint32read */ .jI; // dirty cast for `this` and access to protected `buf`\n        this.buf = buf;\n        this.len = buf.length;\n        this.pos = 0;\n        this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();\n    }\n    /**\n     * Reads a tag - field number and wire type.\n     */\n    tag() {\n        let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;\n        if (fieldNo <= 0 || wireType < 0 || wireType > 5)\n            throw new Error(\"illegal tag: field no \" + fieldNo + \" wire type \" + wireType);\n        return [fieldNo, wireType];\n    }\n    /**\n     * Skip one element on the wire and return the skipped data.\n     * Supports WireType.StartGroup since v2.0.0-alpha.23.\n     */\n    skip(wireType) {\n        let start = this.pos;\n        switch (wireType) {\n            case WireType.Varint:\n                while (this.buf[this.pos++] & 0x80) {\n                    // ignore\n                }\n                break;\n            // eslint-disable-next-line\n            // @ts-ignore TS7029: Fallthrough case in switch\n            case WireType.Bit64:\n                this.pos += 4;\n            // eslint-disable-next-line\n            // @ts-ignore TS7029: Fallthrough case in switch\n            case WireType.Bit32:\n                this.pos += 4;\n                break;\n            case WireType.LengthDelimited:\n                let len = this.uint32();\n                this.pos += len;\n                break;\n            case WireType.StartGroup:\n                // From descriptor.proto: Group type is deprecated, not supported in proto3.\n                // But we must still be able to parse and treat as unknown.\n                let t;\n                while ((t = this.tag()[1]) !== WireType.EndGroup) {\n                    this.skip(t);\n                }\n                break;\n            default:\n                throw new Error(\"cant skip wire type \" + wireType);\n        }\n        this.assertBounds();\n        return this.buf.subarray(start, this.pos);\n    }\n    /**\n     * Throws error if position in byte array is out of range.\n     */\n    assertBounds() {\n        if (this.pos > this.len)\n            throw new RangeError(\"premature EOF\");\n    }\n    /**\n     * Read a `int32` field, a signed 32 bit varint.\n     */\n    int32() {\n        return this.uint32() | 0;\n    }\n    /**\n     * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.\n     */\n    sint32() {\n        let zze = this.uint32();\n        // decode zigzag\n        return (zze >>> 1) ^ -(zze & 1);\n    }\n    /**\n     * Read a `int64` field, a signed 64-bit varint.\n     */\n    int64() {\n        return _proto_int64_js__WEBPACK_IMPORTED_MODULE_2__/* .protoInt64 */ .q.dec(...this.varint64());\n    }\n    /**\n     * Read a `uint64` field, an unsigned 64-bit varint.\n     */\n    uint64() {\n        return _proto_int64_js__WEBPACK_IMPORTED_MODULE_2__/* .protoInt64 */ .q.uDec(...this.varint64());\n    }\n    /**\n     * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.\n     */\n    sint64() {\n        let [lo, hi] = this.varint64();\n        // decode zig zag\n        let s = -(lo & 1);\n        lo = ((lo >>> 1) | ((hi & 1) << 31)) ^ s;\n        hi = (hi >>> 1) ^ s;\n        return _proto_int64_js__WEBPACK_IMPORTED_MODULE_2__/* .protoInt64 */ .q.dec(lo, hi);\n    }\n    /**\n     * Read a `bool` field, a variant.\n     */\n    bool() {\n        let [lo, hi] = this.varint64();\n        return lo !== 0 || hi !== 0;\n    }\n    /**\n     * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.\n     */\n    fixed32() {\n        return this.view.getUint32((this.pos += 4) - 4, true);\n    }\n    /**\n     * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.\n     */\n    sfixed32() {\n        return this.view.getInt32((this.pos += 4) - 4, true);\n    }\n    /**\n     * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.\n     */\n    fixed64() {\n        return _proto_int64_js__WEBPACK_IMPORTED_MODULE_2__/* .protoInt64 */ .q.uDec(this.sfixed32(), this.sfixed32());\n    }\n    /**\n     * Read a `fixed64` field, a signed, fixed-length 64-bit integer.\n     */\n    sfixed64() {\n        return _proto_int64_js__WEBPACK_IMPORTED_MODULE_2__/* .protoInt64 */ .q.dec(this.sfixed32(), this.sfixed32());\n    }\n    /**\n     * Read a `float` field, 32-bit floating point number.\n     */\n    float() {\n        return this.view.getFloat32((this.pos += 4) - 4, true);\n    }\n    /**\n     * Read a `double` field, a 64-bit floating point number.\n     */\n    double() {\n        return this.view.getFloat64((this.pos += 8) - 8, true);\n    }\n    /**\n     * Read a `bytes` field, length-delimited arbitrary data.\n     */\n    bytes() {\n        let len = this.uint32(), start = this.pos;\n        this.pos += len;\n        this.assertBounds();\n        return this.buf.subarray(start, start + len);\n    }\n    /**\n     * Read a `string` field, length-delimited data converted to UTF-8 text.\n     */\n    string() {\n        return this.textDecoder.decode(this.bytes());\n    }\n}\n\n\n/***/ }),\n\n/***/ 465:\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_54023__) => {\n\n/* harmony export */ __nested_webpack_require_54023__.d(__nested_webpack_exports__, {\n/* harmony export */   p: () => (/* binding */ LongType),\n/* harmony export */   w: () => (/* binding */ ScalarType)\n/* harmony export */ });\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Scalar value types. This is a subset of field types declared by protobuf\n * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE\n * are omitted, but the numerical values are identical.\n */\nvar ScalarType;\n(function (ScalarType) {\n    // 0 is reserved for errors.\n    // Order is weird for historical reasons.\n    ScalarType[ScalarType[\"DOUBLE\"] = 1] = \"DOUBLE\";\n    ScalarType[ScalarType[\"FLOAT\"] = 2] = \"FLOAT\";\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if\n    // negative values are likely.\n    ScalarType[ScalarType[\"INT64\"] = 3] = \"INT64\";\n    ScalarType[ScalarType[\"UINT64\"] = 4] = \"UINT64\";\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if\n    // negative values are likely.\n    ScalarType[ScalarType[\"INT32\"] = 5] = \"INT32\";\n    ScalarType[ScalarType[\"FIXED64\"] = 6] = \"FIXED64\";\n    ScalarType[ScalarType[\"FIXED32\"] = 7] = \"FIXED32\";\n    ScalarType[ScalarType[\"BOOL\"] = 8] = \"BOOL\";\n    ScalarType[ScalarType[\"STRING\"] = 9] = \"STRING\";\n    // Tag-delimited aggregate.\n    // Group type is deprecated and not supported in proto3. However, Proto3\n    // implementations should still be able to parse the group wire format and\n    // treat group fields as unknown fields.\n    // TYPE_GROUP = 10,\n    // TYPE_MESSAGE = 11,  // Length-delimited aggregate.\n    // New in version 2.\n    ScalarType[ScalarType[\"BYTES\"] = 12] = \"BYTES\";\n    ScalarType[ScalarType[\"UINT32\"] = 13] = \"UINT32\";\n    // TYPE_ENUM = 14,\n    ScalarType[ScalarType[\"SFIXED32\"] = 15] = \"SFIXED32\";\n    ScalarType[ScalarType[\"SFIXED64\"] = 16] = \"SFIXED64\";\n    ScalarType[ScalarType[\"SINT32\"] = 17] = \"SINT32\";\n    ScalarType[ScalarType[\"SINT64\"] = 18] = \"SINT64\";\n})(ScalarType || (ScalarType = {}));\n/**\n * JavaScript representation of fields with 64 bit integral types (int64, uint64,\n * sint64, fixed64, sfixed64).\n *\n * This is a subset of google.protobuf.FieldOptions.JSType, which defines JS_NORMAL,\n * JS_STRING, and JS_NUMBER. Protobuf-ES uses BigInt by default, but will use\n * String if `[jstype = JS_STRING]` is specified.\n *\n * ```protobuf\n * uint64 field_a = 1; // BigInt\n * uint64 field_b = 2 [jstype = JS_NORMAL]; // BigInt\n * uint64 field_b = 2 [jstype = JS_NUMBER]; // BigInt\n * uint64 field_b = 2 [jstype = JS_STRING]; // String\n * ```\n */\nvar LongType;\n(function (LongType) {\n    /**\n     * Use JavaScript BigInt.\n     */\n    LongType[LongType[\"BIGINT\"] = 0] = \"BIGINT\";\n    /**\n     * Use JavaScript String.\n     *\n     * Field option `[jstype = JS_STRING]`.\n     */\n    LongType[LongType[\"STRING\"] = 1] = \"STRING\";\n})(LongType || (LongType = {}));\n\n\n/***/ }),\n\n/***/ 733:\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_57590__) => {\n\n/* harmony export */ __nested_webpack_require_57590__.d(__nested_webpack_exports__, {\n/* harmony export */   I: () => (/* binding */ Any)\n/* harmony export */ });\n/* harmony import */ var _message_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_57590__(561);\n/* harmony import */ var _proto3_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_57590__(850);\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n/**\n * `Any` contains an arbitrary serialized protocol buffer message along with a\n * URL that describes the type of the serialized message.\n *\n * Protobuf library provides support to pack/unpack Any values in the form\n * of utility functions or additional generated methods of the Any type.\n *\n * Example 1: Pack and unpack a message in C++.\n *\n *     Foo foo = ...;\n *     Any any;\n *     any.PackFrom(foo);\n *     ...\n *     if (any.UnpackTo(&foo)) {\n *       ...\n *     }\n *\n * Example 2: Pack and unpack a message in Java.\n *\n *     Foo foo = ...;\n *     Any any = Any.pack(foo);\n *     ...\n *     if (any.is(Foo.class)) {\n *       foo = any.unpack(Foo.class);\n *     }\n *     // or ...\n *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n *       foo = any.unpack(Foo.getDefaultInstance());\n *     }\n *\n *  Example 3: Pack and unpack a message in Python.\n *\n *     foo = Foo(...)\n *     any = Any()\n *     any.Pack(foo)\n *     ...\n *     if any.Is(Foo.DESCRIPTOR):\n *       any.Unpack(foo)\n *       ...\n *\n *  Example 4: Pack and unpack a message in Go\n *\n *      foo := &pb.Foo{...}\n *      any, err := anypb.New(foo)\n *      if err != nil {\n *        ...\n *      }\n *      ...\n *      foo := &pb.Foo{}\n *      if err := any.UnmarshalTo(foo); err != nil {\n *        ...\n *      }\n *\n * The pack methods provided by protobuf library will by default use\n * 'type.googleapis.com/full.type.name' as the type URL and the unpack\n * methods only use the fully qualified type name after the last '/'\n * in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n * name \"y.z\".\n *\n * JSON\n * ====\n * The JSON representation of an `Any` value uses the regular\n * representation of the deserialized, embedded message, with an\n * additional field `@type` which contains the type URL. Example:\n *\n *     package google.profile;\n *     message Person {\n *       string first_name = 1;\n *       string last_name = 2;\n *     }\n *\n *     {\n *       \"@type\": \"type.googleapis.com/google.profile.Person\",\n *       \"firstName\": <string>,\n *       \"lastName\": <string>\n *     }\n *\n * If the embedded message type is well-known and has a custom JSON\n * representation, that representation will be embedded adding a field\n * `value` which holds the custom JSON in addition to the `@type`\n * field. Example (for message [google.protobuf.Duration][]):\n *\n *     {\n *       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n *       \"value\": \"1.212s\"\n *     }\n *\n *\n * @generated from message google.protobuf.Any\n */\nclass Any extends _message_js__WEBPACK_IMPORTED_MODULE_0__/* .Message */ .v {\n    constructor(data) {\n        super();\n        /**\n         * A URL/resource name that uniquely identifies the type of the serialized\n         * protocol buffer message. This string must contain at least\n         * one \"/\" character. The last segment of the URL's path must represent\n         * the fully qualified name of the type (as in\n         * `path/google.protobuf.Duration`). The name should be in a canonical form\n         * (e.g., leading \".\" is not accepted).\n         *\n         * In practice, teams usually precompile into the binary all types that they\n         * expect it to use in the context of Any. However, for URLs which use the\n         * scheme `http`, `https`, or no scheme, one can optionally set up a type\n         * server that maps type URLs to message definitions as follows:\n         *\n         * * If no scheme is provided, `https` is assumed.\n         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n         *   value in binary format, or produce an error.\n         * * Applications are allowed to cache lookup results based on the\n         *   URL, or have them precompiled into a binary to avoid any\n         *   lookup. Therefore, binary compatibility needs to be preserved\n         *   on changes to types. (Use versioned type names to manage\n         *   breaking changes.)\n         *\n         * Note: this functionality is not currently available in the official\n         * protobuf release, and it is not used for type URLs beginning with\n         * type.googleapis.com. As of May 2023, there are no widely used type server\n         * implementations and no plans to implement one.\n         *\n         * Schemes other than `http`, `https` (or the empty scheme) might be\n         * used with implementation specific semantics.\n         *\n         *\n         * @generated from field: string type_url = 1;\n         */\n        this.typeUrl = \"\";\n        /**\n         * Must be a valid serialized protocol buffer of the above specified type.\n         *\n         * @generated from field: bytes value = 2;\n         */\n        this.value = new Uint8Array(0);\n        _proto3_js__WEBPACK_IMPORTED_MODULE_1__/* .proto3 */ .w.util.initPartial(data, this);\n    }\n    toJson(options) {\n        var _a;\n        if (this.typeUrl === \"\") {\n            return {};\n        }\n        const typeName = this.typeUrlToName(this.typeUrl);\n        const messageType = (_a = options === null || options === void 0 ? void 0 : options.typeRegistry) === null || _a === void 0 ? void 0 : _a.findMessage(typeName);\n        if (!messageType) {\n            throw new Error(`cannot encode message google.protobuf.Any to JSON: \"${this.typeUrl}\" is not in the type registry`);\n        }\n        const message = messageType.fromBinary(this.value);\n        let json = message.toJson(options);\n        if (typeName.startsWith(\"google.protobuf.\") || (json === null || Array.isArray(json) || typeof json !== \"object\")) {\n            json = { value: json };\n        }\n        json[\"@type\"] = this.typeUrl;\n        return json;\n    }\n    fromJson(json, options) {\n        var _a;\n        if (json === null || Array.isArray(json) || typeof json != \"object\") {\n            throw new Error(`cannot decode message google.protobuf.Any from JSON: expected object but got ${json === null ? \"null\" : Array.isArray(json) ? \"array\" : typeof json}`);\n        }\n        if (Object.keys(json).length == 0) {\n            return this;\n        }\n        const typeUrl = json[\"@type\"];\n        if (typeof typeUrl != \"string\" || typeUrl == \"\") {\n            throw new Error(`cannot decode message google.protobuf.Any from JSON: \"@type\" is empty`);\n        }\n        const typeName = this.typeUrlToName(typeUrl), messageType = (_a = options === null || options === void 0 ? void 0 : options.typeRegistry) === null || _a === void 0 ? void 0 : _a.findMessage(typeName);\n        if (!messageType) {\n            throw new Error(`cannot decode message google.protobuf.Any from JSON: ${typeUrl} is not in the type registry`);\n        }\n        let message;\n        if (typeName.startsWith(\"google.protobuf.\") && Object.prototype.hasOwnProperty.call(json, \"value\")) {\n            message = messageType.fromJson(json[\"value\"], options);\n        }\n        else {\n            const copy = Object.assign({}, json);\n            delete copy[\"@type\"];\n            message = messageType.fromJson(copy, options);\n        }\n        this.packFrom(message);\n        return this;\n    }\n    packFrom(message) {\n        this.value = message.toBinary();\n        this.typeUrl = this.typeNameToUrl(message.getType().typeName);\n    }\n    unpackTo(target) {\n        if (!this.is(target.getType())) {\n            return false;\n        }\n        target.fromBinary(this.value);\n        return true;\n    }\n    unpack(registry) {\n        if (this.typeUrl === \"\") {\n            return undefined;\n        }\n        const messageType = registry.findMessage(this.typeUrlToName(this.typeUrl));\n        if (!messageType) {\n            return undefined;\n        }\n        return messageType.fromBinary(this.value);\n    }\n    is(type) {\n        if (this.typeUrl === '') {\n            return false;\n        }\n        const name = this.typeUrlToName(this.typeUrl);\n        let typeName = '';\n        if (typeof type === 'string') {\n            typeName = type;\n        }\n        else {\n            typeName = type.typeName;\n        }\n        return name === typeName;\n    }\n    typeNameToUrl(name) {\n        return `type.googleapis.com/${name}`;\n    }\n    typeUrlToName(url) {\n        if (!url.length) {\n            throw new Error(`invalid type url: ${url}`);\n        }\n        const slash = url.lastIndexOf(\"/\");\n        const name = slash >= 0 ? url.substring(slash + 1) : url;\n        if (!name.length) {\n            throw new Error(`invalid type url: ${url}`);\n        }\n        return name;\n    }\n    static pack(message) {\n        const any = new Any();\n        any.packFrom(message);\n        return any;\n    }\n    static fromBinary(bytes, options) {\n        return new Any().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Any().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Any().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return _proto3_js__WEBPACK_IMPORTED_MODULE_1__/* .proto3 */ .w.util.equals(Any, a, b);\n    }\n}\nAny.runtime = _proto3_js__WEBPACK_IMPORTED_MODULE_1__/* .proto3 */ .w;\nAny.typeName = \"google.protobuf.Any\";\nAny.fields = _proto3_js__WEBPACK_IMPORTED_MODULE_1__/* .proto3 */ .w.util.newFieldList(() => [\n    { no: 1, name: \"type_url\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 2, name: \"value\", kind: \"scalar\", T: 12 /* ScalarType.BYTES */ },\n]);\n\n\n/***/ }),\n\n/***/ 818:\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_68023__) => {\n\n/* harmony export */ __nested_webpack_require_68023__.d(__nested_webpack_exports__, {\n/* harmony export */   Ak: () => (/* binding */ int64ToString),\n/* harmony export */   CZ: () => (/* binding */ int64FromString),\n/* harmony export */   Fd: () => (/* binding */ uInt64ToString),\n/* harmony export */   _y: () => (/* binding */ varint64write),\n/* harmony export */   fC: () => (/* binding */ varint32write),\n/* harmony export */   jI: () => (/* binding */ varint32read),\n/* harmony export */   sg: () => (/* binding */ varint64read)\n/* harmony export */ });\n// Copyright 2008 Google Inc.  All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Code generated by the Protocol Buffer compiler is owned by the owner\n// of the input file used when generating it.  This code is not\n// standalone and requires a support library to be linked with it.  This\n// support library is itself covered by the above license.\n/* eslint-disable prefer-const,@typescript-eslint/restrict-plus-operands */\n/**\n * Read a 64 bit varint as two JS numbers.\n *\n * Returns tuple:\n * [0]: low bits\n * [1]: high bits\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175\n */\nfunction varint64read() {\n    let lowBits = 0;\n    let highBits = 0;\n    for (let shift = 0; shift < 28; shift += 7) {\n        let b = this.buf[this.pos++];\n        lowBits |= (b & 0x7f) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [lowBits, highBits];\n        }\n    }\n    let middleByte = this.buf[this.pos++];\n    // last four bits of the first 32 bit number\n    lowBits |= (middleByte & 0x0f) << 28;\n    // 3 upper bits are part of the next 32 bit number\n    highBits = (middleByte & 0x70) >> 4;\n    if ((middleByte & 0x80) == 0) {\n        this.assertBounds();\n        return [lowBits, highBits];\n    }\n    for (let shift = 3; shift <= 31; shift += 7) {\n        let b = this.buf[this.pos++];\n        highBits |= (b & 0x7f) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [lowBits, highBits];\n        }\n    }\n    throw new Error(\"invalid varint\");\n}\n/**\n * Write a 64 bit varint, given as two JS numbers, to the given bytes array.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344\n */\nfunction varint64write(lo, hi, bytes) {\n    for (let i = 0; i < 28; i = i + 7) {\n        const shift = lo >>> i;\n        const hasNext = !(shift >>> 7 == 0 && hi == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    const splitBits = ((lo >>> 28) & 0x0f) | ((hi & 0x07) << 4);\n    const hasMoreBits = !(hi >> 3 == 0);\n    bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xff);\n    if (!hasMoreBits) {\n        return;\n    }\n    for (let i = 3; i < 31; i = i + 7) {\n        const shift = hi >>> i;\n        const hasNext = !(shift >>> 7 == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    bytes.push((hi >>> 31) & 0x01);\n}\n// constants for binary math\nconst TWO_PWR_32_DBL = 0x100000000;\n/**\n * Parse decimal string of 64 bit integer value as two JS numbers.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */\nfunction int64FromString(dec) {\n    // Check for minus sign.\n    const minus = dec[0] === \"-\";\n    if (minus) {\n        dec = dec.slice(1);\n    }\n    // Work 6 decimal digits at a time, acting like we're converting base 1e6\n    // digits to binary. This is safe to do with floating point math because\n    // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.\n    const base = 1e6;\n    let lowBits = 0;\n    let highBits = 0;\n    function add1e6digit(begin, end) {\n        // Note: Number('') is 0.\n        const digit1e6 = Number(dec.slice(begin, end));\n        highBits *= base;\n        lowBits = lowBits * base + digit1e6;\n        // Carry bits from lowBits to\n        if (lowBits >= TWO_PWR_32_DBL) {\n            highBits = highBits + ((lowBits / TWO_PWR_32_DBL) | 0);\n            lowBits = lowBits % TWO_PWR_32_DBL;\n        }\n    }\n    add1e6digit(-24, -18);\n    add1e6digit(-18, -12);\n    add1e6digit(-12, -6);\n    add1e6digit(-6);\n    return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);\n}\n/**\n * Losslessly converts a 64-bit signed integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */\nfunction int64ToString(lo, hi) {\n    let bits = newBits(lo, hi);\n    // If we're treating the input as a signed value and the high bit is set, do\n    // a manual two's complement conversion before the decimal conversion.\n    const negative = (bits.hi & 0x80000000);\n    if (negative) {\n        bits = negate(bits.lo, bits.hi);\n    }\n    const result = uInt64ToString(bits.lo, bits.hi);\n    return negative ? \"-\" + result : result;\n}\n/**\n * Losslessly converts a 64-bit unsigned integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */\nfunction uInt64ToString(lo, hi) {\n    ({ lo, hi } = toUnsigned(lo, hi));\n    // Skip the expensive conversion if the number is small enough to use the\n    // built-in conversions.\n    // Number.MAX_SAFE_INTEGER = 0x001FFFFF FFFFFFFF, thus any number with\n    // highBits <= 0x1FFFFF can be safely expressed with a double and retain\n    // integer precision.\n    // Proven by: Number.isSafeInteger(0x1FFFFF * 2**32 + 0xFFFFFFFF) == true.\n    if (hi <= 0x1FFFFF) {\n        return String(TWO_PWR_32_DBL * hi + lo);\n    }\n    // What this code is doing is essentially converting the input number from\n    // base-2 to base-1e7, which allows us to represent the 64-bit range with\n    // only 3 (very large) digits. Those digits are then trivial to convert to\n    // a base-10 string.\n    // The magic numbers used here are -\n    // 2^24 = 16777216 = (1,6777216) in base-1e7.\n    // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.\n    // Split 32:32 representation into 16:24:24 representation so our\n    // intermediate digits don't overflow.\n    const low = lo & 0xFFFFFF;\n    const mid = ((lo >>> 24) | (hi << 8)) & 0xFFFFFF;\n    const high = (hi >> 16) & 0xFFFF;\n    // Assemble our three base-1e7 digits, ignoring carries. The maximum\n    // value in a digit at this step is representable as a 48-bit integer, which\n    // can be stored in a 64-bit floating point number.\n    let digitA = low + (mid * 6777216) + (high * 6710656);\n    let digitB = mid + (high * 8147497);\n    let digitC = (high * 2);\n    // Apply carries from A to B and from B to C.\n    const base = 10000000;\n    if (digitA >= base) {\n        digitB += Math.floor(digitA / base);\n        digitA %= base;\n    }\n    if (digitB >= base) {\n        digitC += Math.floor(digitB / base);\n        digitB %= base;\n    }\n    // If digitC is 0, then we should have returned in the trivial code path\n    // at the top for non-safe integers. Given this, we can assume both digitB\n    // and digitA need leading zeros.\n    return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) +\n        decimalFrom1e7WithLeadingZeros(digitA);\n}\nfunction toUnsigned(lo, hi) {\n    return { lo: lo >>> 0, hi: hi >>> 0 };\n}\nfunction newBits(lo, hi) {\n    return { lo: lo | 0, hi: hi | 0 };\n}\n/**\n * Returns two's compliment negation of input.\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Signed_32-bit_integers\n */\nfunction negate(lowBits, highBits) {\n    highBits = ~highBits;\n    if (lowBits) {\n        lowBits = ~lowBits + 1;\n    }\n    else {\n        // If lowBits is 0, then bitwise-not is 0xFFFFFFFF,\n        // adding 1 to that, results in 0x100000000, which leaves\n        // the low bits 0x0 and simply adds one to the high bits.\n        highBits += 1;\n    }\n    return newBits(lowBits, highBits);\n}\n/**\n * Returns decimal representation of digit1e7 with leading zeros.\n */\nconst decimalFrom1e7WithLeadingZeros = (digit1e7) => {\n    const partial = String(digit1e7);\n    return \"0000000\".slice(partial.length) + partial;\n};\n/**\n * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144\n */\nfunction varint32write(value, bytes) {\n    if (value >= 0) {\n        // write value as varint 32\n        while (value > 0x7f) {\n            bytes.push((value & 0x7f) | 0x80);\n            value = value >>> 7;\n        }\n        bytes.push(value);\n    }\n    else {\n        for (let i = 0; i < 9; i++) {\n            bytes.push((value & 127) | 128);\n            value = value >> 7;\n        }\n        bytes.push(1);\n    }\n}\n/**\n * Read an unsigned 32 bit varint.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220\n */\nfunction varint32read() {\n    let b = this.buf[this.pos++];\n    let result = b & 0x7f;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 7;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 14;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 21;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    // Extract only last 4 bits\n    b = this.buf[this.pos++];\n    result |= (b & 0x0f) << 28;\n    for (let readBytes = 5; (b & 0x80) !== 0 && readBytes < 10; readBytes++)\n        b = this.buf[this.pos++];\n    if ((b & 0x80) != 0)\n        throw new Error(\"invalid varint\");\n    this.assertBounds();\n    // Result can have 32 bits, convert it to unsigned\n    return result >>> 0;\n}\n\n\n/***/ }),\n\n/***/ 532:\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_80292__) => {\n\n// ESM COMPAT FLAG\n__nested_webpack_require_80292__.r(__nested_webpack_exports__);\n\n// EXPORTS\n__nested_webpack_require_80292__.d(__nested_webpack_exports__, {\n  Any: () => (/* reexport */ any_pb/* Any */.I),\n  Api: () => (/* reexport */ Api),\n  BinaryReader: () => (/* reexport */ binary_encoding/* BinaryReader */.oP),\n  BinaryWriter: () => (/* reexport */ binary_encoding/* BinaryWriter */.Lt),\n  BoolValue: () => (/* reexport */ BoolValue),\n  BytesValue: () => (/* reexport */ BytesValue),\n  CodeGeneratorRequest: () => (/* reexport */ CodeGeneratorRequest),\n  CodeGeneratorResponse: () => (/* reexport */ CodeGeneratorResponse),\n  CodeGeneratorResponse_Feature: () => (/* reexport */ CodeGeneratorResponse_Feature),\n  CodeGeneratorResponse_File: () => (/* reexport */ CodeGeneratorResponse_File),\n  DescriptorProto: () => (/* reexport */ DescriptorProto),\n  DescriptorProto_ExtensionRange: () => (/* reexport */ DescriptorProto_ExtensionRange),\n  DescriptorProto_ReservedRange: () => (/* reexport */ DescriptorProto_ReservedRange),\n  DoubleValue: () => (/* reexport */ DoubleValue),\n  Duration: () => (/* reexport */ Duration),\n  Edition: () => (/* reexport */ Edition),\n  Empty: () => (/* reexport */ Empty),\n  Enum: () => (/* reexport */ Enum),\n  EnumDescriptorProto: () => (/* reexport */ EnumDescriptorProto),\n  EnumDescriptorProto_EnumReservedRange: () => (/* reexport */ EnumDescriptorProto_EnumReservedRange),\n  EnumOptions: () => (/* reexport */ EnumOptions),\n  EnumValue: () => (/* reexport */ EnumValue),\n  EnumValueDescriptorProto: () => (/* reexport */ EnumValueDescriptorProto),\n  EnumValueOptions: () => (/* reexport */ EnumValueOptions),\n  ExtensionRangeOptions: () => (/* reexport */ ExtensionRangeOptions),\n  ExtensionRangeOptions_Declaration: () => (/* reexport */ ExtensionRangeOptions_Declaration),\n  ExtensionRangeOptions_VerificationState: () => (/* reexport */ ExtensionRangeOptions_VerificationState),\n  FeatureSet: () => (/* reexport */ FeatureSet),\n  FeatureSetDefaults: () => (/* reexport */ FeatureSetDefaults),\n  FeatureSetDefaults_FeatureSetEditionDefault: () => (/* reexport */ FeatureSetDefaults_FeatureSetEditionDefault),\n  FeatureSet_EnumType: () => (/* reexport */ FeatureSet_EnumType),\n  FeatureSet_FieldPresence: () => (/* reexport */ FeatureSet_FieldPresence),\n  FeatureSet_JsonFormat: () => (/* reexport */ FeatureSet_JsonFormat),\n  FeatureSet_MessageEncoding: () => (/* reexport */ FeatureSet_MessageEncoding),\n  FeatureSet_RepeatedFieldEncoding: () => (/* reexport */ FeatureSet_RepeatedFieldEncoding),\n  FeatureSet_Utf8Validation: () => (/* reexport */ FeatureSet_Utf8Validation),\n  Field: () => (/* reexport */ Field),\n  FieldDescriptorProto: () => (/* reexport */ FieldDescriptorProto),\n  FieldDescriptorProto_Label: () => (/* reexport */ FieldDescriptorProto_Label),\n  FieldDescriptorProto_Type: () => (/* reexport */ FieldDescriptorProto_Type),\n  FieldMask: () => (/* reexport */ FieldMask),\n  FieldOptions: () => (/* reexport */ FieldOptions),\n  FieldOptions_CType: () => (/* reexport */ FieldOptions_CType),\n  FieldOptions_EditionDefault: () => (/* reexport */ FieldOptions_EditionDefault),\n  FieldOptions_JSType: () => (/* reexport */ FieldOptions_JSType),\n  FieldOptions_OptionRetention: () => (/* reexport */ FieldOptions_OptionRetention),\n  FieldOptions_OptionTargetType: () => (/* reexport */ FieldOptions_OptionTargetType),\n  Field_Cardinality: () => (/* reexport */ Field_Cardinality),\n  Field_Kind: () => (/* reexport */ Field_Kind),\n  FileDescriptorProto: () => (/* reexport */ FileDescriptorProto),\n  FileDescriptorSet: () => (/* reexport */ FileDescriptorSet),\n  FileOptions: () => (/* reexport */ FileOptions),\n  FileOptions_OptimizeMode: () => (/* reexport */ FileOptions_OptimizeMode),\n  FloatValue: () => (/* reexport */ FloatValue),\n  GeneratedCodeInfo: () => (/* reexport */ GeneratedCodeInfo),\n  GeneratedCodeInfo_Annotation: () => (/* reexport */ GeneratedCodeInfo_Annotation),\n  GeneratedCodeInfo_Annotation_Semantic: () => (/* reexport */ GeneratedCodeInfo_Annotation_Semantic),\n  Int32Value: () => (/* reexport */ Int32Value),\n  Int64Value: () => (/* reexport */ Int64Value),\n  ListValue: () => (/* reexport */ ListValue),\n  LongType: () => (/* reexport */ esm_field/* LongType */.p),\n  Message: () => (/* reexport */ esm_message/* Message */.v),\n  MessageOptions: () => (/* reexport */ MessageOptions),\n  Method: () => (/* reexport */ Method),\n  MethodDescriptorProto: () => (/* reexport */ MethodDescriptorProto),\n  MethodIdempotency: () => (/* reexport */ service_type/* MethodIdempotency */.w),\n  MethodKind: () => (/* reexport */ service_type/* MethodKind */.t),\n  MethodOptions: () => (/* reexport */ MethodOptions),\n  MethodOptions_IdempotencyLevel: () => (/* reexport */ MethodOptions_IdempotencyLevel),\n  Mixin: () => (/* reexport */ Mixin),\n  NullValue: () => (/* reexport */ NullValue),\n  OneofDescriptorProto: () => (/* reexport */ OneofDescriptorProto),\n  OneofOptions: () => (/* reexport */ OneofOptions),\n  Option: () => (/* reexport */ Option),\n  ScalarType: () => (/* reexport */ esm_field/* ScalarType */.w),\n  ServiceDescriptorProto: () => (/* reexport */ ServiceDescriptorProto),\n  ServiceOptions: () => (/* reexport */ ServiceOptions),\n  SourceCodeInfo: () => (/* reexport */ SourceCodeInfo),\n  SourceCodeInfo_Location: () => (/* reexport */ SourceCodeInfo_Location),\n  SourceContext: () => (/* reexport */ SourceContext),\n  StringValue: () => (/* reexport */ StringValue),\n  Struct: () => (/* reexport */ Struct),\n  Syntax: () => (/* reexport */ Syntax),\n  Timestamp: () => (/* reexport */ Timestamp),\n  Type: () => (/* reexport */ Type),\n  UInt32Value: () => (/* reexport */ UInt32Value),\n  UInt64Value: () => (/* reexport */ UInt64Value),\n  UninterpretedOption: () => (/* reexport */ UninterpretedOption),\n  UninterpretedOption_NamePart: () => (/* reexport */ UninterpretedOption_NamePart),\n  Value: () => (/* reexport */ Value),\n  Version: () => (/* reexport */ Version),\n  WireType: () => (/* reexport */ binary_encoding/* WireType */.TD),\n  codegenInfo: () => (/* reexport */ codegenInfo),\n  createDescriptorSet: () => (/* reexport */ createDescriptorSet),\n  createRegistry: () => (/* reexport */ createRegistry),\n  createRegistryFromDescriptors: () => (/* reexport */ createRegistryFromDescriptors),\n  proto2: () => (/* reexport */ proto2),\n  proto3: () => (/* reexport */ proto3/* proto3 */.w),\n  protoBase64: () => (/* reexport */ proto_base64/* protoBase64 */.W),\n  protoDelimited: () => (/* reexport */ protoDelimited),\n  protoDouble: () => (/* reexport */ protoDouble),\n  protoInt64: () => (/* reexport */ proto_int64/* protoInt64 */.q),\n  toPlainMessage: () => (/* reexport */ toPlainMessage)\n});\n\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/proto3.js + 2 modules\nvar proto3 = __nested_webpack_require_80292__(850);\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/proto-runtime.js + 1 modules\nvar proto_runtime = __nested_webpack_require_80292__(493);\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/field.js\nvar esm_field = __nested_webpack_require_80292__(465);\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/binary-format-common.js\nvar binary_format_common = __nested_webpack_require_80292__(744);\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/binary-format-proto2.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n/* eslint-disable @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unnecessary-condition, @typescript-eslint/strict-boolean-expressions, no-case-declarations, prefer-const */\nfunction makeBinaryFormatProto2() {\n    return Object.assign(Object.assign({}, (0,binary_format_common/* makeBinaryFormatCommon */.gY)()), { writeMessage(message, writer, options) {\n            const type = message.getType();\n            let field;\n            try {\n                for (field of type.fields.byNumber()) {\n                    let value, // this will be our field value, whether it is member of a oneof or not\n                    repeated = field.repeated, localName = field.localName;\n                    if (field.oneof) {\n                        const oneof = message[field.oneof.localName];\n                        if (oneof.case !== localName) {\n                            continue; // field is not selected, skip\n                        }\n                        value = oneof.value;\n                    }\n                    else {\n                        value = message[localName];\n                        // In contrast to proto3, we raise an error if a non-optional (proto2 required)\n                        // field is missing a value.\n                        if (value === undefined && !field.oneof && !field.opt) {\n                            throw new Error(`cannot encode field ${type.typeName}.${field.name} to binary: required field not set`);\n                        }\n                    }\n                    switch (field.kind) {\n                        case \"scalar\":\n                        case \"enum\":\n                            let scalarType = field.kind == \"enum\" ? esm_field/* ScalarType */.w.INT32 : field.T;\n                            if (repeated) {\n                                if (field.packed) {\n                                    (0,binary_format_common/* writePacked */.Jj)(writer, scalarType, field.no, value);\n                                }\n                                else {\n                                    for (const item of value) {\n                                        (0,binary_format_common/* writeScalar */.NN)(writer, scalarType, field.no, item, true);\n                                    }\n                                }\n                            }\n                            else {\n                                if (value !== undefined) {\n                                    // In contrast to proto3, we do not skip intrinsic default values.\n                                    // Explicit default values are not special cased either.\n                                    (0,binary_format_common/* writeScalar */.NN)(writer, scalarType, field.no, value, true);\n                                }\n                            }\n                            break;\n                        case \"message\":\n                            if (repeated) {\n                                for (const item of value) {\n                                    (0,binary_format_common/* writeMessageField */.oQ)(writer, options, field, item);\n                                }\n                            }\n                            else {\n                                (0,binary_format_common/* writeMessageField */.oQ)(writer, options, field, value);\n                            }\n                            break;\n                        case \"map\":\n                            for (const [key, val] of Object.entries(value)) {\n                                (0,binary_format_common/* writeMapEntry */.gQ)(writer, options, field, key, val);\n                            }\n                            break;\n                    }\n                }\n            }\n            catch (e) {\n                let m = field\n                    ? `cannot encode field ${type.typeName}.${field === null || field === void 0 ? void 0 : field.name} to binary`\n                    : `cannot encode message ${type.typeName} to binary`;\n                let r = e instanceof Error ? e.message : String(e);\n                throw new Error(m + (r.length > 0 ? `: ${r}` : \"\"));\n            }\n            if (options.writeUnknownFields) {\n                this.writeUnknownFields(message, writer);\n            }\n            return writer;\n        } });\n}\n\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/util-common.js\nvar util_common = __nested_webpack_require_80292__(433);\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/field-list.js\nvar field_list = __nested_webpack_require_80292__(501);\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/field.js\nvar private_field = __nested_webpack_require_80292__(215);\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/names.js\nvar names = __nested_webpack_require_80292__(504);\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/field-wrapper.js\nvar field_wrapper = __nested_webpack_require_80292__(432);\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/assert.js\nvar assert = __nested_webpack_require_80292__(120);\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/json-format-common.js\nvar json_format_common = __nested_webpack_require_80292__(814);\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/json-format-proto2.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n/* eslint-disable no-case-declarations, @typescript-eslint/restrict-plus-operands,@typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-argument */\nfunction makeJsonFormatProto2() {\n    return (0,json_format_common/* makeJsonFormatCommon */.b)((writeEnum, writeScalar) => {\n        return function writeField(field, value, options) {\n            if (field.kind == \"map\") {\n                const jsonObj = {};\n                switch (field.V.kind) {\n                    case \"scalar\":\n                        for (const [entryKey, entryValue] of Object.entries(value)) {\n                            const val = writeScalar(field.V.T, entryValue, true);\n                            (0,assert/* assert */.hu)(val !== undefined);\n                            jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key\n                        }\n                        break;\n                    case \"message\":\n                        for (const [entryKey, entryValue] of Object.entries(value)) {\n                            // JSON standard allows only (double quoted) string as property key\n                            jsonObj[entryKey.toString()] = entryValue.toJson(options);\n                        }\n                        break;\n                    case \"enum\":\n                        const enumType = field.V.T;\n                        for (const [entryKey, entryValue] of Object.entries(value)) {\n                            (0,assert/* assert */.hu)(entryValue === undefined || typeof entryValue == \"number\");\n                            const val = writeEnum(enumType, entryValue, true, options.enumAsInteger);\n                            (0,assert/* assert */.hu)(val !== undefined);\n                            jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key\n                        }\n                        break;\n                }\n                return options.emitDefaultValues || Object.keys(jsonObj).length > 0\n                    ? jsonObj\n                    : undefined;\n            }\n            else if (field.repeated) {\n                const jsonArr = [];\n                switch (field.kind) {\n                    case \"scalar\":\n                        for (let i = 0; i < value.length; i++) {\n                            jsonArr.push(writeScalar(field.T, value[i], true));\n                        }\n                        break;\n                    case \"enum\":\n                        for (let i = 0; i < value.length; i++) {\n                            jsonArr.push(writeEnum(field.T, value[i], true, options.enumAsInteger));\n                        }\n                        break;\n                    case \"message\":\n                        for (let i = 0; i < value.length; i++) {\n                            jsonArr.push(value[i].toJson(options));\n                        }\n                        break;\n                }\n                return options.emitDefaultValues || jsonArr.length > 0\n                    ? jsonArr\n                    : undefined;\n            }\n            else {\n                // In contrast to proto3, we raise an error if a non-optional (proto2 required)\n                // field is missing a value.\n                if (value === undefined) {\n                    if (!field.oneof && !field.opt) {\n                        throw `required field not set`;\n                    }\n                    return undefined;\n                }\n                switch (field.kind) {\n                    case \"scalar\":\n                        // In contrast to proto3, we do not skip intrinsic default values.\n                        // Explicit default values are not special cased either.\n                        return writeScalar(field.T, value, true);\n                    case \"enum\":\n                        // In contrast to proto3, we do not skip intrinsic default values.\n                        // Explicit default values are not special cased either.\n                        return writeEnum(field.T, value, true, options.enumAsInteger);\n                    case \"message\":\n                        return (0,field_wrapper/* wrapField */.E)(field.T, value).toJson(options);\n                }\n            }\n        };\n    });\n}\n\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/proto2.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n\n\n\n\n\n/**\n * Provides functionality for messages defined with the proto2 syntax.\n */\nconst proto2 = (0,proto_runtime/* makeProtoRuntime */.F)(\"proto2\", makeJsonFormatProto2(), makeBinaryFormatProto2(), Object.assign(Object.assign({}, (0,util_common/* makeUtilCommon */.f)()), { newFieldList(fields) {\n        return new field_list/* InternalFieldList */.i(fields, normalizeFieldInfosProto2);\n    },\n    initFields(target) {\n        for (const member of target.getType().fields.byMember()) {\n            const name = member.localName, t = target;\n            if (member.repeated) {\n                t[name] = [];\n                continue;\n            }\n            switch (member.kind) {\n                case \"oneof\":\n                    t[name] = { case: undefined };\n                    break;\n                case \"map\":\n                    t[name] = {};\n                    break;\n                case \"scalar\":\n                case \"enum\":\n                case \"message\":\n                    // In contrast to proto3, enum and scalar fields have no intrinsic default value,\n                    // only an optional explicit default value.\n                    // Unlike proto3 intrinsic default values, proto2 explicit default values are not\n                    // set on construction, because they are not omitted on the wire. If we did set\n                    // default values on construction, a deserialize-serialize round-trip would add\n                    // fields to a message.\n                    break;\n            }\n        }\n    } }));\n/* eslint-disable @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-argument */\nfunction normalizeFieldInfosProto2(fieldInfos) {\n    var _a, _b, _c, _d, _e;\n    const r = [];\n    let o;\n    for (const field of typeof fieldInfos == \"function\"\n        ? fieldInfos()\n        : fieldInfos) {\n        const f = field;\n        f.localName = (0,names/* localFieldName */.Rz)(field.name, field.oneof !== undefined);\n        f.jsonName = (_a = field.jsonName) !== null && _a !== void 0 ? _a : (0,names/* fieldJsonName */.x1)(field.name);\n        f.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;\n        if (field.kind == \"scalar\") {\n            f.L = (_c = field.L) !== null && _c !== void 0 ? _c : esm_field/* LongType */.p.BIGINT;\n        }\n        // We do not surface options at this time\n        // f.options = field.options ?? emptyReadonlyObject;\n        if (field.oneof !== undefined) {\n            const ooname = typeof field.oneof == \"string\" ? field.oneof : field.oneof.name;\n            if (!o || o.name != ooname) {\n                o = new private_field/* InternalOneofInfo */.o(ooname);\n            }\n            f.oneof = o;\n            o.addField(f);\n        }\n        // proto2 specific:\n        if (field.kind == \"message\") {\n            f.delimited = (_d = field.delimited) !== null && _d !== void 0 ? _d : false;\n        }\n        // In contrast to proto3, repeated fields are unpacked except when explicitly specified.\n        f.packed = (_e = field.packed) !== null && _e !== void 0 ? _e : false;\n        r.push(f);\n    }\n    return r;\n}\n\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/proto-double.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// Export global Number constants. This is done so that we can safely use\n// these global constants when generating code and be assured we're using\n// the correct values. We cannot rely on globalThis since we support ES2017\n// and globalThis was introduced in ES2020. We also don't want to explicitly\n// generate code using, for example, Number.NaN, since this could clash with\n// a message name of Number. Instead we can export them here since this will\n// be in a different scope as the generated code and we are guaranteed to use\n// the intended global values.\nconst protoDouble = {\n    NaN: Number.NaN,\n    POSITIVE_INFINITY: Number.POSITIVE_INFINITY,\n    NEGATIVE_INFINITY: Number.NEGATIVE_INFINITY,\n};\n\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/proto-int64.js\nvar proto_int64 = __nested_webpack_require_80292__(210);\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/proto-base64.js\nvar proto_base64 = __nested_webpack_require_80292__(236);\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/binary-encoding.js\nvar binary_encoding = __nested_webpack_require_80292__(79);\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/proto-delimited.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __asyncValues = ( false) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __await = ( false) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = ( false) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\n\n\n/**\n * protoDelimited provides functions to serialize and parse size-delimited\n * messages.\n *\n * A size-delimited message is a varint size in bytes, followed by exactly\n * that many bytes of a message serialized with the binary format.\n *\n * This size-delimited format is compatible with other implementations.\n * For details, see https://github.com/protocolbuffers/protobuf/issues/10229\n */\nconst protoDelimited = {\n    /**\n     * Serialize a message, prefixing it with its size.\n     */\n    enc(message, options) {\n        const opt = (0,binary_format_common/* makeBinaryFormatCommon */.gY)().makeWriteOptions(options);\n        return opt.writerFactory().bytes(message.toBinary(opt)).finish();\n    },\n    /**\n     * Parse a size-delimited message, ignoring extra bytes.\n     */\n    dec(type, bytes, options) {\n        const opt = (0,binary_format_common/* makeBinaryFormatCommon */.gY)().makeReadOptions(options);\n        return type.fromBinary(opt.readerFactory(bytes).bytes(), opt);\n    },\n    /**\n     * Parse a stream of size-delimited messages.\n     */\n    decStream(type, iterable) {\n        return __asyncGenerator(this, arguments, function* decStream_1() {\n            var _a, e_1, _b, _c;\n            // append chunk to buffer, returning updated buffer\n            function append(buffer, chunk) {\n                const n = new Uint8Array(buffer.byteLength + chunk.byteLength);\n                n.set(buffer);\n                n.set(chunk, buffer.length);\n                return n;\n            }\n            let buffer = new Uint8Array(0);\n            try {\n                for (var _d = true, iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield __await(iterable_1.next()), _a = iterable_1_1.done, !_a; _d = true) {\n                    _c = iterable_1_1.value;\n                    _d = false;\n                    const chunk = _c;\n                    buffer = append(buffer, chunk);\n                    for (;;) {\n                        const size = protoDelimited.peekSize(buffer);\n                        if (size.eof) {\n                            // size is incomplete, buffer more data\n                            break;\n                        }\n                        if (size.offset + size.size > buffer.byteLength) {\n                            // message is incomplete, buffer more data\n                            break;\n                        }\n                        yield yield __await(protoDelimited.dec(type, buffer));\n                        buffer = buffer.subarray(size.offset + size.size);\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_1.return)) yield __await(_b.call(iterable_1));\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            if (buffer.byteLength > 0) {\n                throw new Error(\"incomplete data\");\n            }\n        });\n    },\n    /**\n     * Decodes the size from the given size-delimited message, which may be\n     * incomplete.\n     *\n     * Returns an object with the following properties:\n     * - size: The size of the delimited message in bytes\n     * - offset: The offset in the given byte array where the message starts\n     * - eof: true\n     *\n     * If the size-delimited data does not include all bytes of the varint size,\n     * the following object is returned:\n     * - size: null\n     * - offset: null\n     * - eof: false\n     *\n     * This function can be used to implement parsing of size-delimited messages\n     * from a stream.\n     */\n    peekSize(data) {\n        const sizeEof = { eof: true, size: null, offset: null };\n        for (let i = 0; i < 10; i++) {\n            if (i > data.byteLength) {\n                return sizeEof;\n            }\n            if ((data[i] & 0x80) == 0) {\n                const reader = new binary_encoding/* BinaryReader */.oP(data);\n                let size;\n                try {\n                    size = reader.uint32();\n                }\n                catch (e) {\n                    if (e instanceof RangeError) {\n                        return sizeEof;\n                    }\n                    throw e;\n                }\n                return {\n                    eof: false,\n                    size,\n                    offset: reader.pos,\n                };\n            }\n        }\n        throw new Error(\"invalid varint\");\n    },\n};\n\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/scalars.js\nvar scalars = __nested_webpack_require_80292__(781);\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/reify-wkt.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @deprecated please use reifyWkt from @bufbuild/protoplugin/ecmascript instead\n *\n * Reifies a given DescMessage into a more concrete object representing its\n * respective well-known type.  The returned object will contain properties\n * representing the WKT's defined fields.\n *\n * Useful during code generation when immediate access to a particular field\n * is needed without having to search the object's typename and DescField list.\n *\n * Returns undefined if the WKT cannot be completely constructed via the\n * DescMessage.\n */\nfunction reifyWkt(message) {\n    switch (message.typeName) {\n        case \"google.protobuf.Any\": {\n            const typeUrl = message.fields.find((f) => f.number == 1 &&\n                f.fieldKind == \"scalar\" &&\n                f.scalar === esm_field/* ScalarType */.w.STRING);\n            const value = message.fields.find((f) => f.number == 2 &&\n                f.fieldKind == \"scalar\" &&\n                f.scalar === esm_field/* ScalarType */.w.BYTES);\n            if (typeUrl && value) {\n                return {\n                    typeName: message.typeName,\n                    typeUrl,\n                    value,\n                };\n            }\n            break;\n        }\n        case \"google.protobuf.Timestamp\": {\n            const seconds = message.fields.find((f) => f.number == 1 &&\n                f.fieldKind == \"scalar\" &&\n                f.scalar === esm_field/* ScalarType */.w.INT64);\n            const nanos = message.fields.find((f) => f.number == 2 &&\n                f.fieldKind == \"scalar\" &&\n                f.scalar === esm_field/* ScalarType */.w.INT32);\n            if (seconds && nanos) {\n                return {\n                    typeName: message.typeName,\n                    seconds,\n                    nanos,\n                };\n            }\n            break;\n        }\n        case \"google.protobuf.Duration\": {\n            const seconds = message.fields.find((f) => f.number == 1 &&\n                f.fieldKind == \"scalar\" &&\n                f.scalar === esm_field/* ScalarType */.w.INT64);\n            const nanos = message.fields.find((f) => f.number == 2 &&\n                f.fieldKind == \"scalar\" &&\n                f.scalar === esm_field/* ScalarType */.w.INT32);\n            if (seconds && nanos) {\n                return {\n                    typeName: message.typeName,\n                    seconds,\n                    nanos,\n                };\n            }\n            break;\n        }\n        case \"google.protobuf.Struct\": {\n            const fields = message.fields.find((f) => f.number == 1 && !f.repeated);\n            if ((fields === null || fields === void 0 ? void 0 : fields.fieldKind) !== \"map\" ||\n                fields.mapValue.kind !== \"message\" ||\n                fields.mapValue.message.typeName !== \"google.protobuf.Value\") {\n                break;\n            }\n            return { typeName: message.typeName, fields };\n        }\n        case \"google.protobuf.Value\": {\n            const kind = message.oneofs.find((o) => o.name === \"kind\");\n            const nullValue = message.fields.find((f) => f.number == 1 && f.oneof === kind);\n            if ((nullValue === null || nullValue === void 0 ? void 0 : nullValue.fieldKind) !== \"enum\" ||\n                nullValue.enum.typeName !== \"google.protobuf.NullValue\") {\n                return undefined;\n            }\n            const numberValue = message.fields.find((f) => f.number == 2 &&\n                f.fieldKind == \"scalar\" &&\n                f.scalar === esm_field/* ScalarType */.w.DOUBLE &&\n                f.oneof === kind);\n            const stringValue = message.fields.find((f) => f.number == 3 &&\n                f.fieldKind == \"scalar\" &&\n                f.scalar === esm_field/* ScalarType */.w.STRING &&\n                f.oneof === kind);\n            const boolValue = message.fields.find((f) => f.number == 4 &&\n                f.fieldKind == \"scalar\" &&\n                f.scalar === esm_field/* ScalarType */.w.BOOL &&\n                f.oneof === kind);\n            const structValue = message.fields.find((f) => f.number == 5 && f.oneof === kind);\n            if ((structValue === null || structValue === void 0 ? void 0 : structValue.fieldKind) !== \"message\" ||\n                structValue.message.typeName !== \"google.protobuf.Struct\") {\n                return undefined;\n            }\n            const listValue = message.fields.find((f) => f.number == 6 && f.oneof === kind);\n            if ((listValue === null || listValue === void 0 ? void 0 : listValue.fieldKind) !== \"message\" ||\n                listValue.message.typeName !== \"google.protobuf.ListValue\") {\n                return undefined;\n            }\n            if (kind && numberValue && stringValue && boolValue) {\n                return {\n                    typeName: message.typeName,\n                    kind,\n                    nullValue,\n                    numberValue,\n                    stringValue,\n                    boolValue,\n                    structValue,\n                    listValue,\n                };\n            }\n            break;\n        }\n        case \"google.protobuf.ListValue\": {\n            const values = message.fields.find((f) => f.number == 1 && f.repeated);\n            if ((values === null || values === void 0 ? void 0 : values.fieldKind) != \"message\" ||\n                values.message.typeName !== \"google.protobuf.Value\") {\n                break;\n            }\n            return { typeName: message.typeName, values };\n        }\n        case \"google.protobuf.FieldMask\": {\n            const paths = message.fields.find((f) => f.number == 1 &&\n                f.fieldKind == \"scalar\" &&\n                f.scalar === esm_field/* ScalarType */.w.STRING &&\n                f.repeated);\n            if (paths) {\n                return { typeName: message.typeName, paths };\n            }\n            break;\n        }\n        case \"google.protobuf.DoubleValue\":\n        case \"google.protobuf.FloatValue\":\n        case \"google.protobuf.Int64Value\":\n        case \"google.protobuf.UInt64Value\":\n        case \"google.protobuf.Int32Value\":\n        case \"google.protobuf.UInt32Value\":\n        case \"google.protobuf.BoolValue\":\n        case \"google.protobuf.StringValue\":\n        case \"google.protobuf.BytesValue\": {\n            const value = message.fields.find((f) => f.number == 1 && f.name == \"value\");\n            if (!value) {\n                break;\n            }\n            if (value.fieldKind !== \"scalar\") {\n                break;\n            }\n            return { typeName: message.typeName, value };\n        }\n    }\n    return undefined;\n}\n\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/codegen-info.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n\n\nconst packageName = \"@bufbuild/protobuf\";\nconst codegenInfo = {\n    packageName: \"@bufbuild/protobuf\",\n    localName: names/* localName */.r1,\n    reifyWkt: reifyWkt,\n    getUnwrappedFieldType: field_wrapper/* getUnwrappedFieldType */.w,\n    scalarDefaultValue: scalars/* scalarDefaultValue */.kY,\n    safeIdentifier: names/* safeIdentifier */.GD,\n    safeObjectProperty: names/* safeObjectProperty */.ll,\n    // prettier-ignore\n    symbols: {\n        proto2: { typeOnly: false, privateImportPath: \"./proto2.js\", publicImportPath: packageName },\n        proto3: { typeOnly: false, privateImportPath: \"./proto3.js\", publicImportPath: packageName },\n        Message: { typeOnly: false, privateImportPath: \"./message.js\", publicImportPath: packageName },\n        PartialMessage: { typeOnly: true, privateImportPath: \"./message.js\", publicImportPath: packageName },\n        PlainMessage: { typeOnly: true, privateImportPath: \"./message.js\", publicImportPath: packageName },\n        FieldList: { typeOnly: true, privateImportPath: \"./field-list.js\", publicImportPath: packageName },\n        MessageType: { typeOnly: true, privateImportPath: \"./message-type.js\", publicImportPath: packageName },\n        BinaryReadOptions: { typeOnly: true, privateImportPath: \"./binary-format.js\", publicImportPath: packageName },\n        BinaryWriteOptions: { typeOnly: true, privateImportPath: \"./binary-format.js\", publicImportPath: packageName },\n        JsonReadOptions: { typeOnly: true, privateImportPath: \"./json-format.js\", publicImportPath: packageName },\n        JsonWriteOptions: { typeOnly: true, privateImportPath: \"./json-format.js\", publicImportPath: packageName },\n        JsonValue: { typeOnly: true, privateImportPath: \"./json-format.js\", publicImportPath: packageName },\n        JsonObject: { typeOnly: true, privateImportPath: \"./json-format.js\", publicImportPath: packageName },\n        protoDouble: { typeOnly: false, privateImportPath: \"./proto-double.js\", publicImportPath: packageName },\n        protoInt64: { typeOnly: false, privateImportPath: \"./proto-int64.js\", publicImportPath: packageName },\n        ScalarType: { typeOnly: false, privateImportPath: \"./field.js\", publicImportPath: packageName },\n        LongType: { typeOnly: false, privateImportPath: \"./field.js\", publicImportPath: packageName },\n        MethodKind: { typeOnly: false, privateImportPath: \"./service-type.js\", publicImportPath: packageName },\n        MethodIdempotency: { typeOnly: false, privateImportPath: \"./service-type.js\", publicImportPath: packageName },\n        IMessageTypeRegistry: { typeOnly: true, privateImportPath: \"./type-registry.js\", publicImportPath: packageName },\n    },\n    wktSourceFiles: [\n        \"google/protobuf/compiler/plugin.proto\",\n        \"google/protobuf/any.proto\",\n        \"google/protobuf/api.proto\",\n        \"google/protobuf/descriptor.proto\",\n        \"google/protobuf/duration.proto\",\n        \"google/protobuf/empty.proto\",\n        \"google/protobuf/field_mask.proto\",\n        \"google/protobuf/source_context.proto\",\n        \"google/protobuf/struct.proto\",\n        \"google/protobuf/timestamp.proto\",\n        \"google/protobuf/type.proto\",\n        \"google/protobuf/wrappers.proto\",\n    ],\n};\n\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/message.js\nvar esm_message = __nested_webpack_require_80292__(561);\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/service-type.js\nvar service_type = __nested_webpack_require_80292__(328);\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/descriptor_pb.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// Author: kenton@google.com (Kenton Varda)\n//  Based on original Protocol Buffers design by\n//  Sanjay Ghemawat, Jeff Dean, and others.\n//\n// The messages in this file describe the definitions found in .proto files.\n// A valid .proto file can be translated directly to a FileDescriptorProto\n// without any other information (e.g. without reading its imports).\n// @generated by protoc-gen-es v1.6.0 with parameter \"bootstrap_wkt=true,ts_nocheck=false,target=ts\"\n// @generated from file google/protobuf/descriptor.proto (package google.protobuf, syntax proto2)\n/* eslint-disable */\n\n\n/**\n * The full set of known editions.\n *\n * @generated from enum google.protobuf.Edition\n */\nvar Edition;\n(function (Edition) {\n    /**\n     * A placeholder for an unknown edition value.\n     *\n     * @generated from enum value: EDITION_UNKNOWN = 0;\n     */\n    Edition[Edition[\"EDITION_UNKNOWN\"] = 0] = \"EDITION_UNKNOWN\";\n    /**\n     * Legacy syntax \"editions\".  These pre-date editions, but behave much like\n     * distinct editions.  These can't be used to specify the edition of proto\n     * files, but feature definitions must supply proto2/proto3 defaults for\n     * backwards compatibility.\n     *\n     * @generated from enum value: EDITION_PROTO2 = 998;\n     */\n    Edition[Edition[\"EDITION_PROTO2\"] = 998] = \"EDITION_PROTO2\";\n    /**\n     * @generated from enum value: EDITION_PROTO3 = 999;\n     */\n    Edition[Edition[\"EDITION_PROTO3\"] = 999] = \"EDITION_PROTO3\";\n    /**\n     * Editions that have been released.  The specific values are arbitrary and\n     * should not be depended on, but they will always be time-ordered for easy\n     * comparison.\n     *\n     * @generated from enum value: EDITION_2023 = 1000;\n     */\n    Edition[Edition[\"EDITION_2023\"] = 1000] = \"EDITION_2023\";\n    /**\n     * Placeholder editions for testing feature resolution.  These should not be\n     * used or relyed on outside of tests.\n     *\n     * @generated from enum value: EDITION_1_TEST_ONLY = 1;\n     */\n    Edition[Edition[\"EDITION_1_TEST_ONLY\"] = 1] = \"EDITION_1_TEST_ONLY\";\n    /**\n     * @generated from enum value: EDITION_2_TEST_ONLY = 2;\n     */\n    Edition[Edition[\"EDITION_2_TEST_ONLY\"] = 2] = \"EDITION_2_TEST_ONLY\";\n    /**\n     * @generated from enum value: EDITION_99997_TEST_ONLY = 99997;\n     */\n    Edition[Edition[\"EDITION_99997_TEST_ONLY\"] = 99997] = \"EDITION_99997_TEST_ONLY\";\n    /**\n     * @generated from enum value: EDITION_99998_TEST_ONLY = 99998;\n     */\n    Edition[Edition[\"EDITION_99998_TEST_ONLY\"] = 99998] = \"EDITION_99998_TEST_ONLY\";\n    /**\n     * @generated from enum value: EDITION_99999_TEST_ONLY = 99999;\n     */\n    Edition[Edition[\"EDITION_99999_TEST_ONLY\"] = 99999] = \"EDITION_99999_TEST_ONLY\";\n})(Edition || (Edition = {}));\n// Retrieve enum metadata with: proto2.getEnumType(Edition)\nproto2.util.setEnumType(Edition, \"google.protobuf.Edition\", [\n    { no: 0, name: \"EDITION_UNKNOWN\" },\n    { no: 998, name: \"EDITION_PROTO2\" },\n    { no: 999, name: \"EDITION_PROTO3\" },\n    { no: 1000, name: \"EDITION_2023\" },\n    { no: 1, name: \"EDITION_1_TEST_ONLY\" },\n    { no: 2, name: \"EDITION_2_TEST_ONLY\" },\n    { no: 99997, name: \"EDITION_99997_TEST_ONLY\" },\n    { no: 99998, name: \"EDITION_99998_TEST_ONLY\" },\n    { no: 99999, name: \"EDITION_99999_TEST_ONLY\" },\n]);\n/**\n * The protocol compiler can output a FileDescriptorSet containing the .proto\n * files it parses.\n *\n * @generated from message google.protobuf.FileDescriptorSet\n */\nclass FileDescriptorSet extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * @generated from field: repeated google.protobuf.FileDescriptorProto file = 1;\n         */\n        this.file = [];\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new FileDescriptorSet().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new FileDescriptorSet().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new FileDescriptorSet().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(FileDescriptorSet, a, b);\n    }\n}\nFileDescriptorSet.runtime = proto2;\nFileDescriptorSet.typeName = \"google.protobuf.FileDescriptorSet\";\nFileDescriptorSet.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"file\", kind: \"message\", T: FileDescriptorProto, repeated: true },\n]);\n/**\n * Describes a complete .proto file.\n *\n * @generated from message google.protobuf.FileDescriptorProto\n */\nclass FileDescriptorProto extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * Names of files imported by this file.\n         *\n         * @generated from field: repeated string dependency = 3;\n         */\n        this.dependency = [];\n        /**\n         * Indexes of the public imported files in the dependency list above.\n         *\n         * @generated from field: repeated int32 public_dependency = 10;\n         */\n        this.publicDependency = [];\n        /**\n         * Indexes of the weak imported files in the dependency list.\n         * For Google-internal migration only. Do not use.\n         *\n         * @generated from field: repeated int32 weak_dependency = 11;\n         */\n        this.weakDependency = [];\n        /**\n         * All top-level definitions in this file.\n         *\n         * @generated from field: repeated google.protobuf.DescriptorProto message_type = 4;\n         */\n        this.messageType = [];\n        /**\n         * @generated from field: repeated google.protobuf.EnumDescriptorProto enum_type = 5;\n         */\n        this.enumType = [];\n        /**\n         * @generated from field: repeated google.protobuf.ServiceDescriptorProto service = 6;\n         */\n        this.service = [];\n        /**\n         * @generated from field: repeated google.protobuf.FieldDescriptorProto extension = 7;\n         */\n        this.extension = [];\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new FileDescriptorProto().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new FileDescriptorProto().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new FileDescriptorProto().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(FileDescriptorProto, a, b);\n    }\n}\nFileDescriptorProto.runtime = proto2;\nFileDescriptorProto.typeName = \"google.protobuf.FileDescriptorProto\";\nFileDescriptorProto.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"name\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 2, name: \"package\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 3, name: \"dependency\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, repeated: true },\n    { no: 10, name: \"public_dependency\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, repeated: true },\n    { no: 11, name: \"weak_dependency\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, repeated: true },\n    { no: 4, name: \"message_type\", kind: \"message\", T: DescriptorProto, repeated: true },\n    { no: 5, name: \"enum_type\", kind: \"message\", T: EnumDescriptorProto, repeated: true },\n    { no: 6, name: \"service\", kind: \"message\", T: ServiceDescriptorProto, repeated: true },\n    { no: 7, name: \"extension\", kind: \"message\", T: FieldDescriptorProto, repeated: true },\n    { no: 8, name: \"options\", kind: \"message\", T: FileOptions, opt: true },\n    { no: 9, name: \"source_code_info\", kind: \"message\", T: SourceCodeInfo, opt: true },\n    { no: 12, name: \"syntax\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 14, name: \"edition\", kind: \"enum\", T: proto2.getEnumType(Edition), opt: true },\n]);\n/**\n * Describes a message type.\n *\n * @generated from message google.protobuf.DescriptorProto\n */\nclass DescriptorProto extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * @generated from field: repeated google.protobuf.FieldDescriptorProto field = 2;\n         */\n        this.field = [];\n        /**\n         * @generated from field: repeated google.protobuf.FieldDescriptorProto extension = 6;\n         */\n        this.extension = [];\n        /**\n         * @generated from field: repeated google.protobuf.DescriptorProto nested_type = 3;\n         */\n        this.nestedType = [];\n        /**\n         * @generated from field: repeated google.protobuf.EnumDescriptorProto enum_type = 4;\n         */\n        this.enumType = [];\n        /**\n         * @generated from field: repeated google.protobuf.DescriptorProto.ExtensionRange extension_range = 5;\n         */\n        this.extensionRange = [];\n        /**\n         * @generated from field: repeated google.protobuf.OneofDescriptorProto oneof_decl = 8;\n         */\n        this.oneofDecl = [];\n        /**\n         * @generated from field: repeated google.protobuf.DescriptorProto.ReservedRange reserved_range = 9;\n         */\n        this.reservedRange = [];\n        /**\n         * Reserved field names, which may not be used by fields in the same message.\n         * A given name may only be reserved once.\n         *\n         * @generated from field: repeated string reserved_name = 10;\n         */\n        this.reservedName = [];\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new DescriptorProto().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new DescriptorProto().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new DescriptorProto().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(DescriptorProto, a, b);\n    }\n}\nDescriptorProto.runtime = proto2;\nDescriptorProto.typeName = \"google.protobuf.DescriptorProto\";\nDescriptorProto.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"name\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 2, name: \"field\", kind: \"message\", T: FieldDescriptorProto, repeated: true },\n    { no: 6, name: \"extension\", kind: \"message\", T: FieldDescriptorProto, repeated: true },\n    { no: 3, name: \"nested_type\", kind: \"message\", T: DescriptorProto, repeated: true },\n    { no: 4, name: \"enum_type\", kind: \"message\", T: EnumDescriptorProto, repeated: true },\n    { no: 5, name: \"extension_range\", kind: \"message\", T: DescriptorProto_ExtensionRange, repeated: true },\n    { no: 8, name: \"oneof_decl\", kind: \"message\", T: OneofDescriptorProto, repeated: true },\n    { no: 7, name: \"options\", kind: \"message\", T: MessageOptions, opt: true },\n    { no: 9, name: \"reserved_range\", kind: \"message\", T: DescriptorProto_ReservedRange, repeated: true },\n    { no: 10, name: \"reserved_name\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, repeated: true },\n]);\n/**\n * @generated from message google.protobuf.DescriptorProto.ExtensionRange\n */\nclass DescriptorProto_ExtensionRange extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new DescriptorProto_ExtensionRange().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new DescriptorProto_ExtensionRange().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new DescriptorProto_ExtensionRange().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(DescriptorProto_ExtensionRange, a, b);\n    }\n}\nDescriptorProto_ExtensionRange.runtime = proto2;\nDescriptorProto_ExtensionRange.typeName = \"google.protobuf.DescriptorProto.ExtensionRange\";\nDescriptorProto_ExtensionRange.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"start\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, opt: true },\n    { no: 2, name: \"end\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, opt: true },\n    { no: 3, name: \"options\", kind: \"message\", T: ExtensionRangeOptions, opt: true },\n]);\n/**\n * Range of reserved tag numbers. Reserved tag numbers may not be used by\n * fields or extension ranges in the same message. Reserved ranges may\n * not overlap.\n *\n * @generated from message google.protobuf.DescriptorProto.ReservedRange\n */\nclass DescriptorProto_ReservedRange extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new DescriptorProto_ReservedRange().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new DescriptorProto_ReservedRange().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new DescriptorProto_ReservedRange().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(DescriptorProto_ReservedRange, a, b);\n    }\n}\nDescriptorProto_ReservedRange.runtime = proto2;\nDescriptorProto_ReservedRange.typeName = \"google.protobuf.DescriptorProto.ReservedRange\";\nDescriptorProto_ReservedRange.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"start\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, opt: true },\n    { no: 2, name: \"end\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, opt: true },\n]);\n/**\n * @generated from message google.protobuf.ExtensionRangeOptions\n */\nclass ExtensionRangeOptions extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The parser stores options it doesn't recognize here. See above.\n         *\n         * @generated from field: repeated google.protobuf.UninterpretedOption uninterpreted_option = 999;\n         */\n        this.uninterpretedOption = [];\n        /**\n         * For external users: DO NOT USE. We are in the process of open sourcing\n         * extension declaration and executing internal cleanups before it can be\n         * used externally.\n         *\n         * @generated from field: repeated google.protobuf.ExtensionRangeOptions.Declaration declaration = 2;\n         */\n        this.declaration = [];\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ExtensionRangeOptions().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ExtensionRangeOptions().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ExtensionRangeOptions().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(ExtensionRangeOptions, a, b);\n    }\n}\nExtensionRangeOptions.runtime = proto2;\nExtensionRangeOptions.typeName = \"google.protobuf.ExtensionRangeOptions\";\nExtensionRangeOptions.fields = proto2.util.newFieldList(() => [\n    { no: 999, name: \"uninterpreted_option\", kind: \"message\", T: UninterpretedOption, repeated: true },\n    { no: 2, name: \"declaration\", kind: \"message\", T: ExtensionRangeOptions_Declaration, repeated: true },\n    { no: 50, name: \"features\", kind: \"message\", T: FeatureSet, opt: true },\n    { no: 3, name: \"verification\", kind: \"enum\", T: proto2.getEnumType(ExtensionRangeOptions_VerificationState), opt: true, default: ExtensionRangeOptions_VerificationState.UNVERIFIED },\n]);\n/**\n * The verification state of the extension range.\n *\n * @generated from enum google.protobuf.ExtensionRangeOptions.VerificationState\n */\nvar ExtensionRangeOptions_VerificationState;\n(function (ExtensionRangeOptions_VerificationState) {\n    /**\n     * All the extensions of the range must be declared.\n     *\n     * @generated from enum value: DECLARATION = 0;\n     */\n    ExtensionRangeOptions_VerificationState[ExtensionRangeOptions_VerificationState[\"DECLARATION\"] = 0] = \"DECLARATION\";\n    /**\n     * @generated from enum value: UNVERIFIED = 1;\n     */\n    ExtensionRangeOptions_VerificationState[ExtensionRangeOptions_VerificationState[\"UNVERIFIED\"] = 1] = \"UNVERIFIED\";\n})(ExtensionRangeOptions_VerificationState || (ExtensionRangeOptions_VerificationState = {}));\n// Retrieve enum metadata with: proto2.getEnumType(ExtensionRangeOptions_VerificationState)\nproto2.util.setEnumType(ExtensionRangeOptions_VerificationState, \"google.protobuf.ExtensionRangeOptions.VerificationState\", [\n    { no: 0, name: \"DECLARATION\" },\n    { no: 1, name: \"UNVERIFIED\" },\n]);\n/**\n * @generated from message google.protobuf.ExtensionRangeOptions.Declaration\n */\nclass ExtensionRangeOptions_Declaration extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ExtensionRangeOptions_Declaration().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ExtensionRangeOptions_Declaration().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ExtensionRangeOptions_Declaration().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(ExtensionRangeOptions_Declaration, a, b);\n    }\n}\nExtensionRangeOptions_Declaration.runtime = proto2;\nExtensionRangeOptions_Declaration.typeName = \"google.protobuf.ExtensionRangeOptions.Declaration\";\nExtensionRangeOptions_Declaration.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"number\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, opt: true },\n    { no: 2, name: \"full_name\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 3, name: \"type\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 5, name: \"reserved\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true },\n    { no: 6, name: \"repeated\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true },\n]);\n/**\n * Describes a field within a message.\n *\n * @generated from message google.protobuf.FieldDescriptorProto\n */\nclass FieldDescriptorProto extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new FieldDescriptorProto().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new FieldDescriptorProto().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new FieldDescriptorProto().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(FieldDescriptorProto, a, b);\n    }\n}\nFieldDescriptorProto.runtime = proto2;\nFieldDescriptorProto.typeName = \"google.protobuf.FieldDescriptorProto\";\nFieldDescriptorProto.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"name\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 3, name: \"number\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, opt: true },\n    { no: 4, name: \"label\", kind: \"enum\", T: proto2.getEnumType(FieldDescriptorProto_Label), opt: true },\n    { no: 5, name: \"type\", kind: \"enum\", T: proto2.getEnumType(FieldDescriptorProto_Type), opt: true },\n    { no: 6, name: \"type_name\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 2, name: \"extendee\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 7, name: \"default_value\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 9, name: \"oneof_index\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, opt: true },\n    { no: 10, name: \"json_name\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 8, name: \"options\", kind: \"message\", T: FieldOptions, opt: true },\n    { no: 17, name: \"proto3_optional\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true },\n]);\n/**\n * @generated from enum google.protobuf.FieldDescriptorProto.Type\n */\nvar FieldDescriptorProto_Type;\n(function (FieldDescriptorProto_Type) {\n    /**\n     * 0 is reserved for errors.\n     * Order is weird for historical reasons.\n     *\n     * @generated from enum value: TYPE_DOUBLE = 1;\n     */\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"DOUBLE\"] = 1] = \"DOUBLE\";\n    /**\n     * @generated from enum value: TYPE_FLOAT = 2;\n     */\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"FLOAT\"] = 2] = \"FLOAT\";\n    /**\n     * Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if\n     * negative values are likely.\n     *\n     * @generated from enum value: TYPE_INT64 = 3;\n     */\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"INT64\"] = 3] = \"INT64\";\n    /**\n     * @generated from enum value: TYPE_UINT64 = 4;\n     */\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"UINT64\"] = 4] = \"UINT64\";\n    /**\n     * Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if\n     * negative values are likely.\n     *\n     * @generated from enum value: TYPE_INT32 = 5;\n     */\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"INT32\"] = 5] = \"INT32\";\n    /**\n     * @generated from enum value: TYPE_FIXED64 = 6;\n     */\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"FIXED64\"] = 6] = \"FIXED64\";\n    /**\n     * @generated from enum value: TYPE_FIXED32 = 7;\n     */\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"FIXED32\"] = 7] = \"FIXED32\";\n    /**\n     * @generated from enum value: TYPE_BOOL = 8;\n     */\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"BOOL\"] = 8] = \"BOOL\";\n    /**\n     * @generated from enum value: TYPE_STRING = 9;\n     */\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"STRING\"] = 9] = \"STRING\";\n    /**\n     * Tag-delimited aggregate.\n     * Group type is deprecated and not supported after google.protobuf. However, Proto3\n     * implementations should still be able to parse the group wire format and\n     * treat group fields as unknown fields.  In Editions, the group wire format\n     * can be enabled via the `message_encoding` feature.\n     *\n     * @generated from enum value: TYPE_GROUP = 10;\n     */\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"GROUP\"] = 10] = \"GROUP\";\n    /**\n     * Length-delimited aggregate.\n     *\n     * @generated from enum value: TYPE_MESSAGE = 11;\n     */\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"MESSAGE\"] = 11] = \"MESSAGE\";\n    /**\n     * New in version 2.\n     *\n     * @generated from enum value: TYPE_BYTES = 12;\n     */\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"BYTES\"] = 12] = \"BYTES\";\n    /**\n     * @generated from enum value: TYPE_UINT32 = 13;\n     */\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"UINT32\"] = 13] = \"UINT32\";\n    /**\n     * @generated from enum value: TYPE_ENUM = 14;\n     */\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"ENUM\"] = 14] = \"ENUM\";\n    /**\n     * @generated from enum value: TYPE_SFIXED32 = 15;\n     */\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"SFIXED32\"] = 15] = \"SFIXED32\";\n    /**\n     * @generated from enum value: TYPE_SFIXED64 = 16;\n     */\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"SFIXED64\"] = 16] = \"SFIXED64\";\n    /**\n     * Uses ZigZag encoding.\n     *\n     * @generated from enum value: TYPE_SINT32 = 17;\n     */\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"SINT32\"] = 17] = \"SINT32\";\n    /**\n     * Uses ZigZag encoding.\n     *\n     * @generated from enum value: TYPE_SINT64 = 18;\n     */\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"SINT64\"] = 18] = \"SINT64\";\n})(FieldDescriptorProto_Type || (FieldDescriptorProto_Type = {}));\n// Retrieve enum metadata with: proto2.getEnumType(FieldDescriptorProto_Type)\nproto2.util.setEnumType(FieldDescriptorProto_Type, \"google.protobuf.FieldDescriptorProto.Type\", [\n    { no: 1, name: \"TYPE_DOUBLE\" },\n    { no: 2, name: \"TYPE_FLOAT\" },\n    { no: 3, name: \"TYPE_INT64\" },\n    { no: 4, name: \"TYPE_UINT64\" },\n    { no: 5, name: \"TYPE_INT32\" },\n    { no: 6, name: \"TYPE_FIXED64\" },\n    { no: 7, name: \"TYPE_FIXED32\" },\n    { no: 8, name: \"TYPE_BOOL\" },\n    { no: 9, name: \"TYPE_STRING\" },\n    { no: 10, name: \"TYPE_GROUP\" },\n    { no: 11, name: \"TYPE_MESSAGE\" },\n    { no: 12, name: \"TYPE_BYTES\" },\n    { no: 13, name: \"TYPE_UINT32\" },\n    { no: 14, name: \"TYPE_ENUM\" },\n    { no: 15, name: \"TYPE_SFIXED32\" },\n    { no: 16, name: \"TYPE_SFIXED64\" },\n    { no: 17, name: \"TYPE_SINT32\" },\n    { no: 18, name: \"TYPE_SINT64\" },\n]);\n/**\n * @generated from enum google.protobuf.FieldDescriptorProto.Label\n */\nvar FieldDescriptorProto_Label;\n(function (FieldDescriptorProto_Label) {\n    /**\n     * 0 is reserved for errors\n     *\n     * @generated from enum value: LABEL_OPTIONAL = 1;\n     */\n    FieldDescriptorProto_Label[FieldDescriptorProto_Label[\"OPTIONAL\"] = 1] = \"OPTIONAL\";\n    /**\n     * @generated from enum value: LABEL_REPEATED = 3;\n     */\n    FieldDescriptorProto_Label[FieldDescriptorProto_Label[\"REPEATED\"] = 3] = \"REPEATED\";\n    /**\n     * The required label is only allowed in google.protobuf.  In proto3 and Editions\n     * it's explicitly prohibited.  In Editions, the `field_presence` feature\n     * can be used to get this behavior.\n     *\n     * @generated from enum value: LABEL_REQUIRED = 2;\n     */\n    FieldDescriptorProto_Label[FieldDescriptorProto_Label[\"REQUIRED\"] = 2] = \"REQUIRED\";\n})(FieldDescriptorProto_Label || (FieldDescriptorProto_Label = {}));\n// Retrieve enum metadata with: proto2.getEnumType(FieldDescriptorProto_Label)\nproto2.util.setEnumType(FieldDescriptorProto_Label, \"google.protobuf.FieldDescriptorProto.Label\", [\n    { no: 1, name: \"LABEL_OPTIONAL\" },\n    { no: 3, name: \"LABEL_REPEATED\" },\n    { no: 2, name: \"LABEL_REQUIRED\" },\n]);\n/**\n * Describes a oneof.\n *\n * @generated from message google.protobuf.OneofDescriptorProto\n */\nclass OneofDescriptorProto extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new OneofDescriptorProto().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new OneofDescriptorProto().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new OneofDescriptorProto().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(OneofDescriptorProto, a, b);\n    }\n}\nOneofDescriptorProto.runtime = proto2;\nOneofDescriptorProto.typeName = \"google.protobuf.OneofDescriptorProto\";\nOneofDescriptorProto.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"name\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 2, name: \"options\", kind: \"message\", T: OneofOptions, opt: true },\n]);\n/**\n * Describes an enum type.\n *\n * @generated from message google.protobuf.EnumDescriptorProto\n */\nclass EnumDescriptorProto extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * @generated from field: repeated google.protobuf.EnumValueDescriptorProto value = 2;\n         */\n        this.value = [];\n        /**\n         * Range of reserved numeric values. Reserved numeric values may not be used\n         * by enum values in the same enum declaration. Reserved ranges may not\n         * overlap.\n         *\n         * @generated from field: repeated google.protobuf.EnumDescriptorProto.EnumReservedRange reserved_range = 4;\n         */\n        this.reservedRange = [];\n        /**\n         * Reserved enum value names, which may not be reused. A given name may only\n         * be reserved once.\n         *\n         * @generated from field: repeated string reserved_name = 5;\n         */\n        this.reservedName = [];\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new EnumDescriptorProto().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new EnumDescriptorProto().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new EnumDescriptorProto().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(EnumDescriptorProto, a, b);\n    }\n}\nEnumDescriptorProto.runtime = proto2;\nEnumDescriptorProto.typeName = \"google.protobuf.EnumDescriptorProto\";\nEnumDescriptorProto.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"name\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 2, name: \"value\", kind: \"message\", T: EnumValueDescriptorProto, repeated: true },\n    { no: 3, name: \"options\", kind: \"message\", T: EnumOptions, opt: true },\n    { no: 4, name: \"reserved_range\", kind: \"message\", T: EnumDescriptorProto_EnumReservedRange, repeated: true },\n    { no: 5, name: \"reserved_name\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, repeated: true },\n]);\n/**\n * Range of reserved numeric values. Reserved values may not be used by\n * entries in the same enum. Reserved ranges may not overlap.\n *\n * Note that this is distinct from DescriptorProto.ReservedRange in that it\n * is inclusive such that it can appropriately represent the entire int32\n * domain.\n *\n * @generated from message google.protobuf.EnumDescriptorProto.EnumReservedRange\n */\nclass EnumDescriptorProto_EnumReservedRange extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new EnumDescriptorProto_EnumReservedRange().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new EnumDescriptorProto_EnumReservedRange().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new EnumDescriptorProto_EnumReservedRange().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(EnumDescriptorProto_EnumReservedRange, a, b);\n    }\n}\nEnumDescriptorProto_EnumReservedRange.runtime = proto2;\nEnumDescriptorProto_EnumReservedRange.typeName = \"google.protobuf.EnumDescriptorProto.EnumReservedRange\";\nEnumDescriptorProto_EnumReservedRange.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"start\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, opt: true },\n    { no: 2, name: \"end\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, opt: true },\n]);\n/**\n * Describes a value within an enum.\n *\n * @generated from message google.protobuf.EnumValueDescriptorProto\n */\nclass EnumValueDescriptorProto extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new EnumValueDescriptorProto().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new EnumValueDescriptorProto().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new EnumValueDescriptorProto().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(EnumValueDescriptorProto, a, b);\n    }\n}\nEnumValueDescriptorProto.runtime = proto2;\nEnumValueDescriptorProto.typeName = \"google.protobuf.EnumValueDescriptorProto\";\nEnumValueDescriptorProto.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"name\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 2, name: \"number\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, opt: true },\n    { no: 3, name: \"options\", kind: \"message\", T: EnumValueOptions, opt: true },\n]);\n/**\n * Describes a service.\n *\n * @generated from message google.protobuf.ServiceDescriptorProto\n */\nclass ServiceDescriptorProto extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * @generated from field: repeated google.protobuf.MethodDescriptorProto method = 2;\n         */\n        this.method = [];\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ServiceDescriptorProto().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ServiceDescriptorProto().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ServiceDescriptorProto().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(ServiceDescriptorProto, a, b);\n    }\n}\nServiceDescriptorProto.runtime = proto2;\nServiceDescriptorProto.typeName = \"google.protobuf.ServiceDescriptorProto\";\nServiceDescriptorProto.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"name\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 2, name: \"method\", kind: \"message\", T: MethodDescriptorProto, repeated: true },\n    { no: 3, name: \"options\", kind: \"message\", T: ServiceOptions, opt: true },\n]);\n/**\n * Describes a method of a service.\n *\n * @generated from message google.protobuf.MethodDescriptorProto\n */\nclass MethodDescriptorProto extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new MethodDescriptorProto().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new MethodDescriptorProto().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new MethodDescriptorProto().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(MethodDescriptorProto, a, b);\n    }\n}\nMethodDescriptorProto.runtime = proto2;\nMethodDescriptorProto.typeName = \"google.protobuf.MethodDescriptorProto\";\nMethodDescriptorProto.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"name\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 2, name: \"input_type\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 3, name: \"output_type\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 4, name: \"options\", kind: \"message\", T: MethodOptions, opt: true },\n    { no: 5, name: \"client_streaming\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true, default: false },\n    { no: 6, name: \"server_streaming\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true, default: false },\n]);\n/**\n * @generated from message google.protobuf.FileOptions\n */\nclass FileOptions extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The parser stores options it doesn't recognize here.\n         * See the documentation for the \"Options\" section above.\n         *\n         * @generated from field: repeated google.protobuf.UninterpretedOption uninterpreted_option = 999;\n         */\n        this.uninterpretedOption = [];\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new FileOptions().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new FileOptions().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new FileOptions().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(FileOptions, a, b);\n    }\n}\nFileOptions.runtime = proto2;\nFileOptions.typeName = \"google.protobuf.FileOptions\";\nFileOptions.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"java_package\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 8, name: \"java_outer_classname\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 10, name: \"java_multiple_files\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true, default: false },\n    { no: 20, name: \"java_generate_equals_and_hash\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true },\n    { no: 27, name: \"java_string_check_utf8\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true, default: false },\n    { no: 9, name: \"optimize_for\", kind: \"enum\", T: proto2.getEnumType(FileOptions_OptimizeMode), opt: true, default: FileOptions_OptimizeMode.SPEED },\n    { no: 11, name: \"go_package\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 16, name: \"cc_generic_services\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true, default: false },\n    { no: 17, name: \"java_generic_services\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true, default: false },\n    { no: 18, name: \"py_generic_services\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true, default: false },\n    { no: 42, name: \"php_generic_services\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true, default: false },\n    { no: 23, name: \"deprecated\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true, default: false },\n    { no: 31, name: \"cc_enable_arenas\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true, default: true },\n    { no: 36, name: \"objc_class_prefix\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 37, name: \"csharp_namespace\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 39, name: \"swift_prefix\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 40, name: \"php_class_prefix\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 41, name: \"php_namespace\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 44, name: \"php_metadata_namespace\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 45, name: \"ruby_package\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 50, name: \"features\", kind: \"message\", T: FeatureSet, opt: true },\n    { no: 999, name: \"uninterpreted_option\", kind: \"message\", T: UninterpretedOption, repeated: true },\n]);\n/**\n * Generated classes can be optimized for speed or code size.\n *\n * @generated from enum google.protobuf.FileOptions.OptimizeMode\n */\nvar FileOptions_OptimizeMode;\n(function (FileOptions_OptimizeMode) {\n    /**\n     * Generate complete code for parsing, serialization,\n     *\n     * @generated from enum value: SPEED = 1;\n     */\n    FileOptions_OptimizeMode[FileOptions_OptimizeMode[\"SPEED\"] = 1] = \"SPEED\";\n    /**\n     * etc.\n     *\n     * Use ReflectionOps to implement these methods.\n     *\n     * @generated from enum value: CODE_SIZE = 2;\n     */\n    FileOptions_OptimizeMode[FileOptions_OptimizeMode[\"CODE_SIZE\"] = 2] = \"CODE_SIZE\";\n    /**\n     * Generate code using MessageLite and the lite runtime.\n     *\n     * @generated from enum value: LITE_RUNTIME = 3;\n     */\n    FileOptions_OptimizeMode[FileOptions_OptimizeMode[\"LITE_RUNTIME\"] = 3] = \"LITE_RUNTIME\";\n})(FileOptions_OptimizeMode || (FileOptions_OptimizeMode = {}));\n// Retrieve enum metadata with: proto2.getEnumType(FileOptions_OptimizeMode)\nproto2.util.setEnumType(FileOptions_OptimizeMode, \"google.protobuf.FileOptions.OptimizeMode\", [\n    { no: 1, name: \"SPEED\" },\n    { no: 2, name: \"CODE_SIZE\" },\n    { no: 3, name: \"LITE_RUNTIME\" },\n]);\n/**\n * @generated from message google.protobuf.MessageOptions\n */\nclass MessageOptions extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The parser stores options it doesn't recognize here. See above.\n         *\n         * @generated from field: repeated google.protobuf.UninterpretedOption uninterpreted_option = 999;\n         */\n        this.uninterpretedOption = [];\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new MessageOptions().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new MessageOptions().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new MessageOptions().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(MessageOptions, a, b);\n    }\n}\nMessageOptions.runtime = proto2;\nMessageOptions.typeName = \"google.protobuf.MessageOptions\";\nMessageOptions.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"message_set_wire_format\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true, default: false },\n    { no: 2, name: \"no_standard_descriptor_accessor\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true, default: false },\n    { no: 3, name: \"deprecated\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true, default: false },\n    { no: 7, name: \"map_entry\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true },\n    { no: 11, name: \"deprecated_legacy_json_field_conflicts\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true },\n    { no: 12, name: \"features\", kind: \"message\", T: FeatureSet, opt: true },\n    { no: 999, name: \"uninterpreted_option\", kind: \"message\", T: UninterpretedOption, repeated: true },\n]);\n/**\n * @generated from message google.protobuf.FieldOptions\n */\nclass FieldOptions extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * @generated from field: repeated google.protobuf.FieldOptions.OptionTargetType targets = 19;\n         */\n        this.targets = [];\n        /**\n         * @generated from field: repeated google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;\n         */\n        this.editionDefaults = [];\n        /**\n         * The parser stores options it doesn't recognize here. See above.\n         *\n         * @generated from field: repeated google.protobuf.UninterpretedOption uninterpreted_option = 999;\n         */\n        this.uninterpretedOption = [];\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new FieldOptions().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new FieldOptions().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new FieldOptions().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(FieldOptions, a, b);\n    }\n}\nFieldOptions.runtime = proto2;\nFieldOptions.typeName = \"google.protobuf.FieldOptions\";\nFieldOptions.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"ctype\", kind: \"enum\", T: proto2.getEnumType(FieldOptions_CType), opt: true, default: FieldOptions_CType.STRING },\n    { no: 2, name: \"packed\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true },\n    { no: 6, name: \"jstype\", kind: \"enum\", T: proto2.getEnumType(FieldOptions_JSType), opt: true, default: FieldOptions_JSType.JS_NORMAL },\n    { no: 5, name: \"lazy\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true, default: false },\n    { no: 15, name: \"unverified_lazy\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true, default: false },\n    { no: 3, name: \"deprecated\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true, default: false },\n    { no: 10, name: \"weak\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true, default: false },\n    { no: 16, name: \"debug_redact\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true, default: false },\n    { no: 17, name: \"retention\", kind: \"enum\", T: proto2.getEnumType(FieldOptions_OptionRetention), opt: true },\n    { no: 19, name: \"targets\", kind: \"enum\", T: proto2.getEnumType(FieldOptions_OptionTargetType), repeated: true },\n    { no: 20, name: \"edition_defaults\", kind: \"message\", T: FieldOptions_EditionDefault, repeated: true },\n    { no: 21, name: \"features\", kind: \"message\", T: FeatureSet, opt: true },\n    { no: 999, name: \"uninterpreted_option\", kind: \"message\", T: UninterpretedOption, repeated: true },\n]);\n/**\n * @generated from enum google.protobuf.FieldOptions.CType\n */\nvar FieldOptions_CType;\n(function (FieldOptions_CType) {\n    /**\n     * Default mode.\n     *\n     * @generated from enum value: STRING = 0;\n     */\n    FieldOptions_CType[FieldOptions_CType[\"STRING\"] = 0] = \"STRING\";\n    /**\n     * The option [ctype=CORD] may be applied to a non-repeated field of type\n     * \"bytes\". It indicates that in C++, the data should be stored in a Cord\n     * instead of a string.  For very large strings, this may reduce memory\n     * fragmentation. It may also allow better performance when parsing from a\n     * Cord, or when parsing with aliasing enabled, as the parsed Cord may then\n     * alias the original buffer.\n     *\n     * @generated from enum value: CORD = 1;\n     */\n    FieldOptions_CType[FieldOptions_CType[\"CORD\"] = 1] = \"CORD\";\n    /**\n     * @generated from enum value: STRING_PIECE = 2;\n     */\n    FieldOptions_CType[FieldOptions_CType[\"STRING_PIECE\"] = 2] = \"STRING_PIECE\";\n})(FieldOptions_CType || (FieldOptions_CType = {}));\n// Retrieve enum metadata with: proto2.getEnumType(FieldOptions_CType)\nproto2.util.setEnumType(FieldOptions_CType, \"google.protobuf.FieldOptions.CType\", [\n    { no: 0, name: \"STRING\" },\n    { no: 1, name: \"CORD\" },\n    { no: 2, name: \"STRING_PIECE\" },\n]);\n/**\n * @generated from enum google.protobuf.FieldOptions.JSType\n */\nvar FieldOptions_JSType;\n(function (FieldOptions_JSType) {\n    /**\n     * Use the default type.\n     *\n     * @generated from enum value: JS_NORMAL = 0;\n     */\n    FieldOptions_JSType[FieldOptions_JSType[\"JS_NORMAL\"] = 0] = \"JS_NORMAL\";\n    /**\n     * Use JavaScript strings.\n     *\n     * @generated from enum value: JS_STRING = 1;\n     */\n    FieldOptions_JSType[FieldOptions_JSType[\"JS_STRING\"] = 1] = \"JS_STRING\";\n    /**\n     * Use JavaScript numbers.\n     *\n     * @generated from enum value: JS_NUMBER = 2;\n     */\n    FieldOptions_JSType[FieldOptions_JSType[\"JS_NUMBER\"] = 2] = \"JS_NUMBER\";\n})(FieldOptions_JSType || (FieldOptions_JSType = {}));\n// Retrieve enum metadata with: proto2.getEnumType(FieldOptions_JSType)\nproto2.util.setEnumType(FieldOptions_JSType, \"google.protobuf.FieldOptions.JSType\", [\n    { no: 0, name: \"JS_NORMAL\" },\n    { no: 1, name: \"JS_STRING\" },\n    { no: 2, name: \"JS_NUMBER\" },\n]);\n/**\n * If set to RETENTION_SOURCE, the option will be omitted from the binary.\n * Note: as of January 2023, support for this is in progress and does not yet\n * have an effect (b/264593489).\n *\n * @generated from enum google.protobuf.FieldOptions.OptionRetention\n */\nvar FieldOptions_OptionRetention;\n(function (FieldOptions_OptionRetention) {\n    /**\n     * @generated from enum value: RETENTION_UNKNOWN = 0;\n     */\n    FieldOptions_OptionRetention[FieldOptions_OptionRetention[\"RETENTION_UNKNOWN\"] = 0] = \"RETENTION_UNKNOWN\";\n    /**\n     * @generated from enum value: RETENTION_RUNTIME = 1;\n     */\n    FieldOptions_OptionRetention[FieldOptions_OptionRetention[\"RETENTION_RUNTIME\"] = 1] = \"RETENTION_RUNTIME\";\n    /**\n     * @generated from enum value: RETENTION_SOURCE = 2;\n     */\n    FieldOptions_OptionRetention[FieldOptions_OptionRetention[\"RETENTION_SOURCE\"] = 2] = \"RETENTION_SOURCE\";\n})(FieldOptions_OptionRetention || (FieldOptions_OptionRetention = {}));\n// Retrieve enum metadata with: proto2.getEnumType(FieldOptions_OptionRetention)\nproto2.util.setEnumType(FieldOptions_OptionRetention, \"google.protobuf.FieldOptions.OptionRetention\", [\n    { no: 0, name: \"RETENTION_UNKNOWN\" },\n    { no: 1, name: \"RETENTION_RUNTIME\" },\n    { no: 2, name: \"RETENTION_SOURCE\" },\n]);\n/**\n * This indicates the types of entities that the field may apply to when used\n * as an option. If it is unset, then the field may be freely used as an\n * option on any kind of entity. Note: as of January 2023, support for this is\n * in progress and does not yet have an effect (b/264593489).\n *\n * @generated from enum google.protobuf.FieldOptions.OptionTargetType\n */\nvar FieldOptions_OptionTargetType;\n(function (FieldOptions_OptionTargetType) {\n    /**\n     * @generated from enum value: TARGET_TYPE_UNKNOWN = 0;\n     */\n    FieldOptions_OptionTargetType[FieldOptions_OptionTargetType[\"TARGET_TYPE_UNKNOWN\"] = 0] = \"TARGET_TYPE_UNKNOWN\";\n    /**\n     * @generated from enum value: TARGET_TYPE_FILE = 1;\n     */\n    FieldOptions_OptionTargetType[FieldOptions_OptionTargetType[\"TARGET_TYPE_FILE\"] = 1] = \"TARGET_TYPE_FILE\";\n    /**\n     * @generated from enum value: TARGET_TYPE_EXTENSION_RANGE = 2;\n     */\n    FieldOptions_OptionTargetType[FieldOptions_OptionTargetType[\"TARGET_TYPE_EXTENSION_RANGE\"] = 2] = \"TARGET_TYPE_EXTENSION_RANGE\";\n    /**\n     * @generated from enum value: TARGET_TYPE_MESSAGE = 3;\n     */\n    FieldOptions_OptionTargetType[FieldOptions_OptionTargetType[\"TARGET_TYPE_MESSAGE\"] = 3] = \"TARGET_TYPE_MESSAGE\";\n    /**\n     * @generated from enum value: TARGET_TYPE_FIELD = 4;\n     */\n    FieldOptions_OptionTargetType[FieldOptions_OptionTargetType[\"TARGET_TYPE_FIELD\"] = 4] = \"TARGET_TYPE_FIELD\";\n    /**\n     * @generated from enum value: TARGET_TYPE_ONEOF = 5;\n     */\n    FieldOptions_OptionTargetType[FieldOptions_OptionTargetType[\"TARGET_TYPE_ONEOF\"] = 5] = \"TARGET_TYPE_ONEOF\";\n    /**\n     * @generated from enum value: TARGET_TYPE_ENUM = 6;\n     */\n    FieldOptions_OptionTargetType[FieldOptions_OptionTargetType[\"TARGET_TYPE_ENUM\"] = 6] = \"TARGET_TYPE_ENUM\";\n    /**\n     * @generated from enum value: TARGET_TYPE_ENUM_ENTRY = 7;\n     */\n    FieldOptions_OptionTargetType[FieldOptions_OptionTargetType[\"TARGET_TYPE_ENUM_ENTRY\"] = 7] = \"TARGET_TYPE_ENUM_ENTRY\";\n    /**\n     * @generated from enum value: TARGET_TYPE_SERVICE = 8;\n     */\n    FieldOptions_OptionTargetType[FieldOptions_OptionTargetType[\"TARGET_TYPE_SERVICE\"] = 8] = \"TARGET_TYPE_SERVICE\";\n    /**\n     * @generated from enum value: TARGET_TYPE_METHOD = 9;\n     */\n    FieldOptions_OptionTargetType[FieldOptions_OptionTargetType[\"TARGET_TYPE_METHOD\"] = 9] = \"TARGET_TYPE_METHOD\";\n})(FieldOptions_OptionTargetType || (FieldOptions_OptionTargetType = {}));\n// Retrieve enum metadata with: proto2.getEnumType(FieldOptions_OptionTargetType)\nproto2.util.setEnumType(FieldOptions_OptionTargetType, \"google.protobuf.FieldOptions.OptionTargetType\", [\n    { no: 0, name: \"TARGET_TYPE_UNKNOWN\" },\n    { no: 1, name: \"TARGET_TYPE_FILE\" },\n    { no: 2, name: \"TARGET_TYPE_EXTENSION_RANGE\" },\n    { no: 3, name: \"TARGET_TYPE_MESSAGE\" },\n    { no: 4, name: \"TARGET_TYPE_FIELD\" },\n    { no: 5, name: \"TARGET_TYPE_ONEOF\" },\n    { no: 6, name: \"TARGET_TYPE_ENUM\" },\n    { no: 7, name: \"TARGET_TYPE_ENUM_ENTRY\" },\n    { no: 8, name: \"TARGET_TYPE_SERVICE\" },\n    { no: 9, name: \"TARGET_TYPE_METHOD\" },\n]);\n/**\n * @generated from message google.protobuf.FieldOptions.EditionDefault\n */\nclass FieldOptions_EditionDefault extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new FieldOptions_EditionDefault().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new FieldOptions_EditionDefault().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new FieldOptions_EditionDefault().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(FieldOptions_EditionDefault, a, b);\n    }\n}\nFieldOptions_EditionDefault.runtime = proto2;\nFieldOptions_EditionDefault.typeName = \"google.protobuf.FieldOptions.EditionDefault\";\nFieldOptions_EditionDefault.fields = proto2.util.newFieldList(() => [\n    { no: 3, name: \"edition\", kind: \"enum\", T: proto2.getEnumType(Edition), opt: true },\n    { no: 2, name: \"value\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n]);\n/**\n * @generated from message google.protobuf.OneofOptions\n */\nclass OneofOptions extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The parser stores options it doesn't recognize here. See above.\n         *\n         * @generated from field: repeated google.protobuf.UninterpretedOption uninterpreted_option = 999;\n         */\n        this.uninterpretedOption = [];\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new OneofOptions().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new OneofOptions().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new OneofOptions().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(OneofOptions, a, b);\n    }\n}\nOneofOptions.runtime = proto2;\nOneofOptions.typeName = \"google.protobuf.OneofOptions\";\nOneofOptions.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"features\", kind: \"message\", T: FeatureSet, opt: true },\n    { no: 999, name: \"uninterpreted_option\", kind: \"message\", T: UninterpretedOption, repeated: true },\n]);\n/**\n * @generated from message google.protobuf.EnumOptions\n */\nclass EnumOptions extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The parser stores options it doesn't recognize here. See above.\n         *\n         * @generated from field: repeated google.protobuf.UninterpretedOption uninterpreted_option = 999;\n         */\n        this.uninterpretedOption = [];\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new EnumOptions().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new EnumOptions().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new EnumOptions().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(EnumOptions, a, b);\n    }\n}\nEnumOptions.runtime = proto2;\nEnumOptions.typeName = \"google.protobuf.EnumOptions\";\nEnumOptions.fields = proto2.util.newFieldList(() => [\n    { no: 2, name: \"allow_alias\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true },\n    { no: 3, name: \"deprecated\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true, default: false },\n    { no: 6, name: \"deprecated_legacy_json_field_conflicts\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true },\n    { no: 7, name: \"features\", kind: \"message\", T: FeatureSet, opt: true },\n    { no: 999, name: \"uninterpreted_option\", kind: \"message\", T: UninterpretedOption, repeated: true },\n]);\n/**\n * @generated from message google.protobuf.EnumValueOptions\n */\nclass EnumValueOptions extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The parser stores options it doesn't recognize here. See above.\n         *\n         * @generated from field: repeated google.protobuf.UninterpretedOption uninterpreted_option = 999;\n         */\n        this.uninterpretedOption = [];\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new EnumValueOptions().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new EnumValueOptions().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new EnumValueOptions().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(EnumValueOptions, a, b);\n    }\n}\nEnumValueOptions.runtime = proto2;\nEnumValueOptions.typeName = \"google.protobuf.EnumValueOptions\";\nEnumValueOptions.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"deprecated\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true, default: false },\n    { no: 2, name: \"features\", kind: \"message\", T: FeatureSet, opt: true },\n    { no: 3, name: \"debug_redact\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true, default: false },\n    { no: 999, name: \"uninterpreted_option\", kind: \"message\", T: UninterpretedOption, repeated: true },\n]);\n/**\n * @generated from message google.protobuf.ServiceOptions\n */\nclass ServiceOptions extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The parser stores options it doesn't recognize here. See above.\n         *\n         * @generated from field: repeated google.protobuf.UninterpretedOption uninterpreted_option = 999;\n         */\n        this.uninterpretedOption = [];\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ServiceOptions().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ServiceOptions().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ServiceOptions().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(ServiceOptions, a, b);\n    }\n}\nServiceOptions.runtime = proto2;\nServiceOptions.typeName = \"google.protobuf.ServiceOptions\";\nServiceOptions.fields = proto2.util.newFieldList(() => [\n    { no: 34, name: \"features\", kind: \"message\", T: FeatureSet, opt: true },\n    { no: 33, name: \"deprecated\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true, default: false },\n    { no: 999, name: \"uninterpreted_option\", kind: \"message\", T: UninterpretedOption, repeated: true },\n]);\n/**\n * @generated from message google.protobuf.MethodOptions\n */\nclass MethodOptions extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The parser stores options it doesn't recognize here. See above.\n         *\n         * @generated from field: repeated google.protobuf.UninterpretedOption uninterpreted_option = 999;\n         */\n        this.uninterpretedOption = [];\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new MethodOptions().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new MethodOptions().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new MethodOptions().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(MethodOptions, a, b);\n    }\n}\nMethodOptions.runtime = proto2;\nMethodOptions.typeName = \"google.protobuf.MethodOptions\";\nMethodOptions.fields = proto2.util.newFieldList(() => [\n    { no: 33, name: \"deprecated\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true, default: false },\n    { no: 34, name: \"idempotency_level\", kind: \"enum\", T: proto2.getEnumType(MethodOptions_IdempotencyLevel), opt: true, default: MethodOptions_IdempotencyLevel.IDEMPOTENCY_UNKNOWN },\n    { no: 35, name: \"features\", kind: \"message\", T: FeatureSet, opt: true },\n    { no: 999, name: \"uninterpreted_option\", kind: \"message\", T: UninterpretedOption, repeated: true },\n]);\n/**\n * Is this method side-effect-free (or safe in HTTP parlance), or idempotent,\n * or neither? HTTP based RPC implementation may choose GET verb for safe\n * methods, and PUT verb for idempotent methods instead of the default POST.\n *\n * @generated from enum google.protobuf.MethodOptions.IdempotencyLevel\n */\nvar MethodOptions_IdempotencyLevel;\n(function (MethodOptions_IdempotencyLevel) {\n    /**\n     * @generated from enum value: IDEMPOTENCY_UNKNOWN = 0;\n     */\n    MethodOptions_IdempotencyLevel[MethodOptions_IdempotencyLevel[\"IDEMPOTENCY_UNKNOWN\"] = 0] = \"IDEMPOTENCY_UNKNOWN\";\n    /**\n     * implies idempotent\n     *\n     * @generated from enum value: NO_SIDE_EFFECTS = 1;\n     */\n    MethodOptions_IdempotencyLevel[MethodOptions_IdempotencyLevel[\"NO_SIDE_EFFECTS\"] = 1] = \"NO_SIDE_EFFECTS\";\n    /**\n     * idempotent, but may have side effects\n     *\n     * @generated from enum value: IDEMPOTENT = 2;\n     */\n    MethodOptions_IdempotencyLevel[MethodOptions_IdempotencyLevel[\"IDEMPOTENT\"] = 2] = \"IDEMPOTENT\";\n})(MethodOptions_IdempotencyLevel || (MethodOptions_IdempotencyLevel = {}));\n// Retrieve enum metadata with: proto2.getEnumType(MethodOptions_IdempotencyLevel)\nproto2.util.setEnumType(MethodOptions_IdempotencyLevel, \"google.protobuf.MethodOptions.IdempotencyLevel\", [\n    { no: 0, name: \"IDEMPOTENCY_UNKNOWN\" },\n    { no: 1, name: \"NO_SIDE_EFFECTS\" },\n    { no: 2, name: \"IDEMPOTENT\" },\n]);\n/**\n * A message representing a option the parser does not recognize. This only\n * appears in options protos created by the compiler::Parser class.\n * DescriptorPool resolves these when building Descriptor objects. Therefore,\n * options protos in descriptor objects (e.g. returned by Descriptor::options(),\n * or produced by Descriptor::CopyTo()) will never have UninterpretedOptions\n * in them.\n *\n * @generated from message google.protobuf.UninterpretedOption\n */\nclass UninterpretedOption extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * @generated from field: repeated google.protobuf.UninterpretedOption.NamePart name = 2;\n         */\n        this.name = [];\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new UninterpretedOption().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UninterpretedOption().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UninterpretedOption().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(UninterpretedOption, a, b);\n    }\n}\nUninterpretedOption.runtime = proto2;\nUninterpretedOption.typeName = \"google.protobuf.UninterpretedOption\";\nUninterpretedOption.fields = proto2.util.newFieldList(() => [\n    { no: 2, name: \"name\", kind: \"message\", T: UninterpretedOption_NamePart, repeated: true },\n    { no: 3, name: \"identifier_value\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 4, name: \"positive_int_value\", kind: \"scalar\", T: 4 /* ScalarType.UINT64 */, opt: true },\n    { no: 5, name: \"negative_int_value\", kind: \"scalar\", T: 3 /* ScalarType.INT64 */, opt: true },\n    { no: 6, name: \"double_value\", kind: \"scalar\", T: 1 /* ScalarType.DOUBLE */, opt: true },\n    { no: 7, name: \"string_value\", kind: \"scalar\", T: 12 /* ScalarType.BYTES */, opt: true },\n    { no: 8, name: \"aggregate_value\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n]);\n/**\n * The name of the uninterpreted option.  Each string represents a segment in\n * a dot-separated name.  is_extension is true iff a segment represents an\n * extension (denoted with parentheses in options specs in .proto files).\n * E.g.,{ [\"foo\", false], [\"bar.baz\", true], [\"moo\", false] } represents\n * \"foo.(bar.baz).moo\".\n *\n * @generated from message google.protobuf.UninterpretedOption.NamePart\n */\nclass UninterpretedOption_NamePart extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new UninterpretedOption_NamePart().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UninterpretedOption_NamePart().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UninterpretedOption_NamePart().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(UninterpretedOption_NamePart, a, b);\n    }\n}\nUninterpretedOption_NamePart.runtime = proto2;\nUninterpretedOption_NamePart.typeName = \"google.protobuf.UninterpretedOption.NamePart\";\nUninterpretedOption_NamePart.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"name_part\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 2, name: \"is_extension\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */ },\n]);\n/**\n * TODO Enums in C++ gencode (and potentially other languages) are\n * not well scoped.  This means that each of the feature enums below can clash\n * with each other.  The short names we've chosen maximize call-site\n * readability, but leave us very open to this scenario.  A future feature will\n * be designed and implemented to handle this, hopefully before we ever hit a\n * conflict here.\n *\n * @generated from message google.protobuf.FeatureSet\n */\nclass FeatureSet extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new FeatureSet().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new FeatureSet().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new FeatureSet().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(FeatureSet, a, b);\n    }\n}\nFeatureSet.runtime = proto2;\nFeatureSet.typeName = \"google.protobuf.FeatureSet\";\nFeatureSet.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"field_presence\", kind: \"enum\", T: proto2.getEnumType(FeatureSet_FieldPresence), opt: true },\n    { no: 2, name: \"enum_type\", kind: \"enum\", T: proto2.getEnumType(FeatureSet_EnumType), opt: true },\n    { no: 3, name: \"repeated_field_encoding\", kind: \"enum\", T: proto2.getEnumType(FeatureSet_RepeatedFieldEncoding), opt: true },\n    { no: 4, name: \"utf8_validation\", kind: \"enum\", T: proto2.getEnumType(FeatureSet_Utf8Validation), opt: true },\n    { no: 5, name: \"message_encoding\", kind: \"enum\", T: proto2.getEnumType(FeatureSet_MessageEncoding), opt: true },\n    { no: 6, name: \"json_format\", kind: \"enum\", T: proto2.getEnumType(FeatureSet_JsonFormat), opt: true },\n]);\n/**\n * @generated from enum google.protobuf.FeatureSet.FieldPresence\n */\nvar FeatureSet_FieldPresence;\n(function (FeatureSet_FieldPresence) {\n    /**\n     * @generated from enum value: FIELD_PRESENCE_UNKNOWN = 0;\n     */\n    FeatureSet_FieldPresence[FeatureSet_FieldPresence[\"FIELD_PRESENCE_UNKNOWN\"] = 0] = \"FIELD_PRESENCE_UNKNOWN\";\n    /**\n     * @generated from enum value: EXPLICIT = 1;\n     */\n    FeatureSet_FieldPresence[FeatureSet_FieldPresence[\"EXPLICIT\"] = 1] = \"EXPLICIT\";\n    /**\n     * @generated from enum value: IMPLICIT = 2;\n     */\n    FeatureSet_FieldPresence[FeatureSet_FieldPresence[\"IMPLICIT\"] = 2] = \"IMPLICIT\";\n    /**\n     * @generated from enum value: LEGACY_REQUIRED = 3;\n     */\n    FeatureSet_FieldPresence[FeatureSet_FieldPresence[\"LEGACY_REQUIRED\"] = 3] = \"LEGACY_REQUIRED\";\n})(FeatureSet_FieldPresence || (FeatureSet_FieldPresence = {}));\n// Retrieve enum metadata with: proto2.getEnumType(FeatureSet_FieldPresence)\nproto2.util.setEnumType(FeatureSet_FieldPresence, \"google.protobuf.FeatureSet.FieldPresence\", [\n    { no: 0, name: \"FIELD_PRESENCE_UNKNOWN\" },\n    { no: 1, name: \"EXPLICIT\" },\n    { no: 2, name: \"IMPLICIT\" },\n    { no: 3, name: \"LEGACY_REQUIRED\" },\n]);\n/**\n * @generated from enum google.protobuf.FeatureSet.EnumType\n */\nvar FeatureSet_EnumType;\n(function (FeatureSet_EnumType) {\n    /**\n     * @generated from enum value: ENUM_TYPE_UNKNOWN = 0;\n     */\n    FeatureSet_EnumType[FeatureSet_EnumType[\"ENUM_TYPE_UNKNOWN\"] = 0] = \"ENUM_TYPE_UNKNOWN\";\n    /**\n     * @generated from enum value: OPEN = 1;\n     */\n    FeatureSet_EnumType[FeatureSet_EnumType[\"OPEN\"] = 1] = \"OPEN\";\n    /**\n     * @generated from enum value: CLOSED = 2;\n     */\n    FeatureSet_EnumType[FeatureSet_EnumType[\"CLOSED\"] = 2] = \"CLOSED\";\n})(FeatureSet_EnumType || (FeatureSet_EnumType = {}));\n// Retrieve enum metadata with: proto2.getEnumType(FeatureSet_EnumType)\nproto2.util.setEnumType(FeatureSet_EnumType, \"google.protobuf.FeatureSet.EnumType\", [\n    { no: 0, name: \"ENUM_TYPE_UNKNOWN\" },\n    { no: 1, name: \"OPEN\" },\n    { no: 2, name: \"CLOSED\" },\n]);\n/**\n * @generated from enum google.protobuf.FeatureSet.RepeatedFieldEncoding\n */\nvar FeatureSet_RepeatedFieldEncoding;\n(function (FeatureSet_RepeatedFieldEncoding) {\n    /**\n     * @generated from enum value: REPEATED_FIELD_ENCODING_UNKNOWN = 0;\n     */\n    FeatureSet_RepeatedFieldEncoding[FeatureSet_RepeatedFieldEncoding[\"REPEATED_FIELD_ENCODING_UNKNOWN\"] = 0] = \"REPEATED_FIELD_ENCODING_UNKNOWN\";\n    /**\n     * @generated from enum value: PACKED = 1;\n     */\n    FeatureSet_RepeatedFieldEncoding[FeatureSet_RepeatedFieldEncoding[\"PACKED\"] = 1] = \"PACKED\";\n    /**\n     * @generated from enum value: EXPANDED = 2;\n     */\n    FeatureSet_RepeatedFieldEncoding[FeatureSet_RepeatedFieldEncoding[\"EXPANDED\"] = 2] = \"EXPANDED\";\n})(FeatureSet_RepeatedFieldEncoding || (FeatureSet_RepeatedFieldEncoding = {}));\n// Retrieve enum metadata with: proto2.getEnumType(FeatureSet_RepeatedFieldEncoding)\nproto2.util.setEnumType(FeatureSet_RepeatedFieldEncoding, \"google.protobuf.FeatureSet.RepeatedFieldEncoding\", [\n    { no: 0, name: \"REPEATED_FIELD_ENCODING_UNKNOWN\" },\n    { no: 1, name: \"PACKED\" },\n    { no: 2, name: \"EXPANDED\" },\n]);\n/**\n * @generated from enum google.protobuf.FeatureSet.Utf8Validation\n */\nvar FeatureSet_Utf8Validation;\n(function (FeatureSet_Utf8Validation) {\n    /**\n     * @generated from enum value: UTF8_VALIDATION_UNKNOWN = 0;\n     */\n    FeatureSet_Utf8Validation[FeatureSet_Utf8Validation[\"UTF8_VALIDATION_UNKNOWN\"] = 0] = \"UTF8_VALIDATION_UNKNOWN\";\n    /**\n     * @generated from enum value: NONE = 1;\n     */\n    FeatureSet_Utf8Validation[FeatureSet_Utf8Validation[\"NONE\"] = 1] = \"NONE\";\n    /**\n     * @generated from enum value: VERIFY = 2;\n     */\n    FeatureSet_Utf8Validation[FeatureSet_Utf8Validation[\"VERIFY\"] = 2] = \"VERIFY\";\n})(FeatureSet_Utf8Validation || (FeatureSet_Utf8Validation = {}));\n// Retrieve enum metadata with: proto2.getEnumType(FeatureSet_Utf8Validation)\nproto2.util.setEnumType(FeatureSet_Utf8Validation, \"google.protobuf.FeatureSet.Utf8Validation\", [\n    { no: 0, name: \"UTF8_VALIDATION_UNKNOWN\" },\n    { no: 1, name: \"NONE\" },\n    { no: 2, name: \"VERIFY\" },\n]);\n/**\n * @generated from enum google.protobuf.FeatureSet.MessageEncoding\n */\nvar FeatureSet_MessageEncoding;\n(function (FeatureSet_MessageEncoding) {\n    /**\n     * @generated from enum value: MESSAGE_ENCODING_UNKNOWN = 0;\n     */\n    FeatureSet_MessageEncoding[FeatureSet_MessageEncoding[\"MESSAGE_ENCODING_UNKNOWN\"] = 0] = \"MESSAGE_ENCODING_UNKNOWN\";\n    /**\n     * @generated from enum value: LENGTH_PREFIXED = 1;\n     */\n    FeatureSet_MessageEncoding[FeatureSet_MessageEncoding[\"LENGTH_PREFIXED\"] = 1] = \"LENGTH_PREFIXED\";\n    /**\n     * @generated from enum value: DELIMITED = 2;\n     */\n    FeatureSet_MessageEncoding[FeatureSet_MessageEncoding[\"DELIMITED\"] = 2] = \"DELIMITED\";\n})(FeatureSet_MessageEncoding || (FeatureSet_MessageEncoding = {}));\n// Retrieve enum metadata with: proto2.getEnumType(FeatureSet_MessageEncoding)\nproto2.util.setEnumType(FeatureSet_MessageEncoding, \"google.protobuf.FeatureSet.MessageEncoding\", [\n    { no: 0, name: \"MESSAGE_ENCODING_UNKNOWN\" },\n    { no: 1, name: \"LENGTH_PREFIXED\" },\n    { no: 2, name: \"DELIMITED\" },\n]);\n/**\n * @generated from enum google.protobuf.FeatureSet.JsonFormat\n */\nvar FeatureSet_JsonFormat;\n(function (FeatureSet_JsonFormat) {\n    /**\n     * @generated from enum value: JSON_FORMAT_UNKNOWN = 0;\n     */\n    FeatureSet_JsonFormat[FeatureSet_JsonFormat[\"JSON_FORMAT_UNKNOWN\"] = 0] = \"JSON_FORMAT_UNKNOWN\";\n    /**\n     * @generated from enum value: ALLOW = 1;\n     */\n    FeatureSet_JsonFormat[FeatureSet_JsonFormat[\"ALLOW\"] = 1] = \"ALLOW\";\n    /**\n     * @generated from enum value: LEGACY_BEST_EFFORT = 2;\n     */\n    FeatureSet_JsonFormat[FeatureSet_JsonFormat[\"LEGACY_BEST_EFFORT\"] = 2] = \"LEGACY_BEST_EFFORT\";\n})(FeatureSet_JsonFormat || (FeatureSet_JsonFormat = {}));\n// Retrieve enum metadata with: proto2.getEnumType(FeatureSet_JsonFormat)\nproto2.util.setEnumType(FeatureSet_JsonFormat, \"google.protobuf.FeatureSet.JsonFormat\", [\n    { no: 0, name: \"JSON_FORMAT_UNKNOWN\" },\n    { no: 1, name: \"ALLOW\" },\n    { no: 2, name: \"LEGACY_BEST_EFFORT\" },\n]);\n/**\n * A compiled specification for the defaults of a set of features.  These\n * messages are generated from FeatureSet extensions and can be used to seed\n * feature resolution. The resolution with this object becomes a simple search\n * for the closest matching edition, followed by proto merges.\n *\n * @generated from message google.protobuf.FeatureSetDefaults\n */\nclass FeatureSetDefaults extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * @generated from field: repeated google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault defaults = 1;\n         */\n        this.defaults = [];\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new FeatureSetDefaults().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new FeatureSetDefaults().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new FeatureSetDefaults().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(FeatureSetDefaults, a, b);\n    }\n}\nFeatureSetDefaults.runtime = proto2;\nFeatureSetDefaults.typeName = \"google.protobuf.FeatureSetDefaults\";\nFeatureSetDefaults.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"defaults\", kind: \"message\", T: FeatureSetDefaults_FeatureSetEditionDefault, repeated: true },\n    { no: 4, name: \"minimum_edition\", kind: \"enum\", T: proto2.getEnumType(Edition), opt: true },\n    { no: 5, name: \"maximum_edition\", kind: \"enum\", T: proto2.getEnumType(Edition), opt: true },\n]);\n/**\n * A map from every known edition with a unique set of defaults to its\n * defaults. Not all editions may be contained here.  For a given edition,\n * the defaults at the closest matching edition ordered at or before it should\n * be used.  This field must be in strict ascending order by edition.\n *\n * @generated from message google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault\n */\nclass FeatureSetDefaults_FeatureSetEditionDefault extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new FeatureSetDefaults_FeatureSetEditionDefault().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new FeatureSetDefaults_FeatureSetEditionDefault().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new FeatureSetDefaults_FeatureSetEditionDefault().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(FeatureSetDefaults_FeatureSetEditionDefault, a, b);\n    }\n}\nFeatureSetDefaults_FeatureSetEditionDefault.runtime = proto2;\nFeatureSetDefaults_FeatureSetEditionDefault.typeName = \"google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault\";\nFeatureSetDefaults_FeatureSetEditionDefault.fields = proto2.util.newFieldList(() => [\n    { no: 3, name: \"edition\", kind: \"enum\", T: proto2.getEnumType(Edition), opt: true },\n    { no: 2, name: \"features\", kind: \"message\", T: FeatureSet, opt: true },\n]);\n/**\n * Encapsulates information about the original source file from which a\n * FileDescriptorProto was generated.\n *\n * @generated from message google.protobuf.SourceCodeInfo\n */\nclass SourceCodeInfo extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * A Location identifies a piece of source code in a .proto file which\n         * corresponds to a particular definition.  This information is intended\n         * to be useful to IDEs, code indexers, documentation generators, and similar\n         * tools.\n         *\n         * For example, say we have a file like:\n         *   message Foo {\n         *     optional string foo = 1;\n         *   }\n         * Let's look at just the field definition:\n         *   optional string foo = 1;\n         *   ^       ^^     ^^  ^  ^^^\n         *   a       bc     de  f  ghi\n         * We have the following locations:\n         *   span   path               represents\n         *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.\n         *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).\n         *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).\n         *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).\n         *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).\n         *\n         * Notes:\n         * - A location may refer to a repeated field itself (i.e. not to any\n         *   particular index within it).  This is used whenever a set of elements are\n         *   logically enclosed in a single code segment.  For example, an entire\n         *   extend block (possibly containing multiple extension definitions) will\n         *   have an outer location whose path refers to the \"extensions\" repeated\n         *   field without an index.\n         * - Multiple locations may have the same path.  This happens when a single\n         *   logical declaration is spread out across multiple places.  The most\n         *   obvious example is the \"extend\" block again -- there may be multiple\n         *   extend blocks in the same scope, each of which will have the same path.\n         * - A location's span is not always a subset of its parent's span.  For\n         *   example, the \"extendee\" of an extension declaration appears at the\n         *   beginning of the \"extend\" block and is shared by all extensions within\n         *   the block.\n         * - Just because a location's span is a subset of some other location's span\n         *   does not mean that it is a descendant.  For example, a \"group\" defines\n         *   both a type and a field in a single declaration.  Thus, the locations\n         *   corresponding to the type and field and their components will overlap.\n         * - Code which tries to interpret locations should probably be designed to\n         *   ignore those that it doesn't understand, as more types of locations could\n         *   be recorded in the future.\n         *\n         * @generated from field: repeated google.protobuf.SourceCodeInfo.Location location = 1;\n         */\n        this.location = [];\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SourceCodeInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SourceCodeInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SourceCodeInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(SourceCodeInfo, a, b);\n    }\n}\nSourceCodeInfo.runtime = proto2;\nSourceCodeInfo.typeName = \"google.protobuf.SourceCodeInfo\";\nSourceCodeInfo.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"location\", kind: \"message\", T: SourceCodeInfo_Location, repeated: true },\n]);\n/**\n * @generated from message google.protobuf.SourceCodeInfo.Location\n */\nclass SourceCodeInfo_Location extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * Identifies which part of the FileDescriptorProto was defined at this\n         * location.\n         *\n         * Each element is a field number or an index.  They form a path from\n         * the root FileDescriptorProto to the place where the definition occurs.\n         * For example, this path:\n         *   [ 4, 3, 2, 7, 1 ]\n         * refers to:\n         *   file.message_type(3)  // 4, 3\n         *       .field(7)         // 2, 7\n         *       .name()           // 1\n         * This is because FileDescriptorProto.message_type has field number 4:\n         *   repeated DescriptorProto message_type = 4;\n         * and DescriptorProto.field has field number 2:\n         *   repeated FieldDescriptorProto field = 2;\n         * and FieldDescriptorProto.name has field number 1:\n         *   optional string name = 1;\n         *\n         * Thus, the above path gives the location of a field name.  If we removed\n         * the last element:\n         *   [ 4, 3, 2, 7 ]\n         * this path refers to the whole field declaration (from the beginning\n         * of the label to the terminating semicolon).\n         *\n         * @generated from field: repeated int32 path = 1 [packed = true];\n         */\n        this.path = [];\n        /**\n         * Always has exactly three or four elements: start line, start column,\n         * end line (optional, otherwise assumed same as start line), end column.\n         * These are packed into a single field for efficiency.  Note that line\n         * and column numbers are zero-based -- typically you will want to add\n         * 1 to each before displaying to a user.\n         *\n         * @generated from field: repeated int32 span = 2 [packed = true];\n         */\n        this.span = [];\n        /**\n         * @generated from field: repeated string leading_detached_comments = 6;\n         */\n        this.leadingDetachedComments = [];\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SourceCodeInfo_Location().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SourceCodeInfo_Location().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SourceCodeInfo_Location().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(SourceCodeInfo_Location, a, b);\n    }\n}\nSourceCodeInfo_Location.runtime = proto2;\nSourceCodeInfo_Location.typeName = \"google.protobuf.SourceCodeInfo.Location\";\nSourceCodeInfo_Location.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"path\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, repeated: true, packed: true },\n    { no: 2, name: \"span\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, repeated: true, packed: true },\n    { no: 3, name: \"leading_comments\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 4, name: \"trailing_comments\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 6, name: \"leading_detached_comments\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, repeated: true },\n]);\n/**\n * Describes the relationship between generated code and its original source\n * file. A GeneratedCodeInfo message is associated with only one generated\n * source file, but may contain references to different source .proto files.\n *\n * @generated from message google.protobuf.GeneratedCodeInfo\n */\nclass GeneratedCodeInfo extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * An Annotation connects some span of text in generated code to an element\n         * of its generating .proto file.\n         *\n         * @generated from field: repeated google.protobuf.GeneratedCodeInfo.Annotation annotation = 1;\n         */\n        this.annotation = [];\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new GeneratedCodeInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new GeneratedCodeInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new GeneratedCodeInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(GeneratedCodeInfo, a, b);\n    }\n}\nGeneratedCodeInfo.runtime = proto2;\nGeneratedCodeInfo.typeName = \"google.protobuf.GeneratedCodeInfo\";\nGeneratedCodeInfo.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"annotation\", kind: \"message\", T: GeneratedCodeInfo_Annotation, repeated: true },\n]);\n/**\n * @generated from message google.protobuf.GeneratedCodeInfo.Annotation\n */\nclass GeneratedCodeInfo_Annotation extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * Identifies the element in the original source .proto file. This field\n         * is formatted the same as SourceCodeInfo.Location.path.\n         *\n         * @generated from field: repeated int32 path = 1 [packed = true];\n         */\n        this.path = [];\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new GeneratedCodeInfo_Annotation().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new GeneratedCodeInfo_Annotation().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new GeneratedCodeInfo_Annotation().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(GeneratedCodeInfo_Annotation, a, b);\n    }\n}\nGeneratedCodeInfo_Annotation.runtime = proto2;\nGeneratedCodeInfo_Annotation.typeName = \"google.protobuf.GeneratedCodeInfo.Annotation\";\nGeneratedCodeInfo_Annotation.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"path\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, repeated: true, packed: true },\n    { no: 2, name: \"source_file\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 3, name: \"begin\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, opt: true },\n    { no: 4, name: \"end\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, opt: true },\n    { no: 5, name: \"semantic\", kind: \"enum\", T: proto2.getEnumType(GeneratedCodeInfo_Annotation_Semantic), opt: true },\n]);\n/**\n * Represents the identified object's effect on the element in the original\n * .proto file.\n *\n * @generated from enum google.protobuf.GeneratedCodeInfo.Annotation.Semantic\n */\nvar GeneratedCodeInfo_Annotation_Semantic;\n(function (GeneratedCodeInfo_Annotation_Semantic) {\n    /**\n     * There is no effect or the effect is indescribable.\n     *\n     * @generated from enum value: NONE = 0;\n     */\n    GeneratedCodeInfo_Annotation_Semantic[GeneratedCodeInfo_Annotation_Semantic[\"NONE\"] = 0] = \"NONE\";\n    /**\n     * The element is set or otherwise mutated.\n     *\n     * @generated from enum value: SET = 1;\n     */\n    GeneratedCodeInfo_Annotation_Semantic[GeneratedCodeInfo_Annotation_Semantic[\"SET\"] = 1] = \"SET\";\n    /**\n     * An alias to the element is returned.\n     *\n     * @generated from enum value: ALIAS = 2;\n     */\n    GeneratedCodeInfo_Annotation_Semantic[GeneratedCodeInfo_Annotation_Semantic[\"ALIAS\"] = 2] = \"ALIAS\";\n})(GeneratedCodeInfo_Annotation_Semantic || (GeneratedCodeInfo_Annotation_Semantic = {}));\n// Retrieve enum metadata with: proto2.getEnumType(GeneratedCodeInfo_Annotation_Semantic)\nproto2.util.setEnumType(GeneratedCodeInfo_Annotation_Semantic, \"google.protobuf.GeneratedCodeInfo.Annotation.Semantic\", [\n    { no: 0, name: \"NONE\" },\n    { no: 1, name: \"SET\" },\n    { no: 2, name: \"ALIAS\" },\n]);\n\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/text-format.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\nfunction parseTextFormatEnumValue(descEnum, value) {\n    const enumValue = descEnum.values.find((v) => v.name === value);\n    (0,assert/* assert */.hu)(enumValue, `cannot parse ${descEnum.name} default value: ${value}`);\n    return enumValue.number;\n}\nfunction parseTextFormatScalarValue(type, value) {\n    switch (type) {\n        case esm_field/* ScalarType */.w.STRING:\n            return value;\n        case esm_field/* ScalarType */.w.BYTES: {\n            const u = unescapeBytesDefaultValue(value);\n            if (u === false) {\n                throw new Error(`cannot parse ${esm_field/* ScalarType */.w[type]} default value: ${value}`);\n            }\n            return u;\n        }\n        case esm_field/* ScalarType */.w.INT64:\n        case esm_field/* ScalarType */.w.SFIXED64:\n        case esm_field/* ScalarType */.w.SINT64:\n            return proto_int64/* protoInt64 */.q.parse(value);\n        case esm_field/* ScalarType */.w.UINT64:\n        case esm_field/* ScalarType */.w.FIXED64:\n            return proto_int64/* protoInt64 */.q.uParse(value);\n        case esm_field/* ScalarType */.w.DOUBLE:\n        case esm_field/* ScalarType */.w.FLOAT:\n            switch (value) {\n                case \"inf\":\n                    return Number.POSITIVE_INFINITY;\n                case \"-inf\":\n                    return Number.NEGATIVE_INFINITY;\n                case \"nan\":\n                    return Number.NaN;\n                default:\n                    return parseFloat(value);\n            }\n        case esm_field/* ScalarType */.w.BOOL:\n            return value === \"true\";\n        case esm_field/* ScalarType */.w.INT32:\n        case esm_field/* ScalarType */.w.UINT32:\n        case esm_field/* ScalarType */.w.SINT32:\n        case esm_field/* ScalarType */.w.FIXED32:\n        case esm_field/* ScalarType */.w.SFIXED32:\n            return parseInt(value, 10);\n    }\n}\n/**\n * Parses a text-encoded default value (proto2) of a BYTES field.\n */\nfunction unescapeBytesDefaultValue(str) {\n    const b = [];\n    const input = {\n        tail: str,\n        c: \"\",\n        next() {\n            if (this.tail.length == 0) {\n                return false;\n            }\n            this.c = this.tail[0];\n            this.tail = this.tail.substring(1);\n            return true;\n        },\n        take(n) {\n            if (this.tail.length >= n) {\n                const r = this.tail.substring(0, n);\n                this.tail = this.tail.substring(n);\n                return r;\n            }\n            return false;\n        },\n    };\n    while (input.next()) {\n        switch (input.c) {\n            case \"\\\\\":\n                if (input.next()) {\n                    switch (input.c) {\n                        case \"\\\\\":\n                            b.push(input.c.charCodeAt(0));\n                            break;\n                        case \"b\":\n                            b.push(0x08);\n                            break;\n                        case \"f\":\n                            b.push(0x0c);\n                            break;\n                        case \"n\":\n                            b.push(0x0a);\n                            break;\n                        case \"r\":\n                            b.push(0x0d);\n                            break;\n                        case \"t\":\n                            b.push(0x09);\n                            break;\n                        case \"v\":\n                            b.push(0x0b);\n                            break;\n                        case \"0\":\n                        case \"1\":\n                        case \"2\":\n                        case \"3\":\n                        case \"4\":\n                        case \"5\":\n                        case \"6\":\n                        case \"7\": {\n                            const s = input.c;\n                            const t = input.take(2);\n                            if (t === false) {\n                                return false;\n                            }\n                            const n = parseInt(s + t, 8);\n                            if (isNaN(n)) {\n                                return false;\n                            }\n                            b.push(n);\n                            break;\n                        }\n                        case \"x\": {\n                            const s = input.c;\n                            const t = input.take(2);\n                            if (t === false) {\n                                return false;\n                            }\n                            const n = parseInt(s + t, 16);\n                            if (isNaN(n)) {\n                                return false;\n                            }\n                            b.push(n);\n                            break;\n                        }\n                        case \"u\": {\n                            const s = input.c;\n                            const t = input.take(4);\n                            if (t === false) {\n                                return false;\n                            }\n                            const n = parseInt(s + t, 16);\n                            if (isNaN(n)) {\n                                return false;\n                            }\n                            const chunk = new Uint8Array(4);\n                            const view = new DataView(chunk.buffer);\n                            view.setInt32(0, n, true);\n                            b.push(chunk[0], chunk[1], chunk[2], chunk[3]);\n                            break;\n                        }\n                        case \"U\": {\n                            const s = input.c;\n                            const t = input.take(8);\n                            if (t === false) {\n                                return false;\n                            }\n                            const tc = proto_int64/* protoInt64 */.q.uEnc(s + t);\n                            const chunk = new Uint8Array(8);\n                            const view = new DataView(chunk.buffer);\n                            view.setInt32(0, tc.lo, true);\n                            view.setInt32(4, tc.hi, true);\n                            b.push(chunk[0], chunk[1], chunk[2], chunk[3], chunk[4], chunk[5], chunk[6], chunk[7]);\n                            break;\n                        }\n                    }\n                }\n                break;\n            default:\n                b.push(input.c.charCodeAt(0));\n        }\n    }\n    return new Uint8Array(b);\n}\n\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/feature-set.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n/**\n * Static edition feature defaults supported by @bufbuild/protobuf.\n */\nconst featureSetDefaults = FeatureSetDefaults.fromBinary(proto_base64/* protoBase64 */.W.dec(\n/*upstream-inject-feature-defaults-start*/ \"ChESDAgBEAIYAiABKAEwAhjmBwoREgwIAhABGAEgAigBMAEY5wcKERIMCAEQARgBIAIoATABGOgHIOYHKOgH\" /*upstream-inject-feature-defaults-end*/));\n/**\n * Create an edition feature resolver with the given feature set defaults.\n */\nfunction createFeatureResolver(compiledFeatureSetDefaults) {\n    const min = compiledFeatureSetDefaults.minimumEdition;\n    const max = compiledFeatureSetDefaults.maximumEdition;\n    if (min === undefined ||\n        max === undefined ||\n        compiledFeatureSetDefaults.defaults.some((d) => d.edition === undefined)) {\n        throw new Error(\"Invalid FeatureSetDefaults\");\n    }\n    const defaultsBinByEdition = new Map();\n    return (edition, ...rest) => {\n        var _a, _b;\n        let defaultsBin = defaultsBinByEdition.get(edition);\n        if (defaultsBin === undefined) {\n            if (edition < min) {\n                throw new Error(`Edition ${Edition[edition]} is earlier than the minimum supported edition ${Edition[min]}`);\n            }\n            if (max < edition) {\n                throw new Error(`Edition ${Edition[edition]} is later than the maximum supported edition ${Edition[max]}`);\n            }\n            let highestMatch = undefined;\n            for (const c of compiledFeatureSetDefaults.defaults) {\n                const e = (_a = c.edition) !== null && _a !== void 0 ? _a : 0;\n                if (e > edition) {\n                    continue;\n                }\n                if (highestMatch !== undefined && highestMatch.e > e) {\n                    continue;\n                }\n                highestMatch = {\n                    e,\n                    f: (_b = c.features) !== null && _b !== void 0 ? _b : new FeatureSet(),\n                };\n            }\n            if (highestMatch === undefined) {\n                throw new Error(`No valid default found for edition ${Edition[edition]}`);\n            }\n            defaultsBin = highestMatch.f.toBinary();\n            defaultsBinByEdition.set(edition, defaultsBin);\n        }\n        const f = FeatureSet.fromBinary(defaultsBin);\n        for (const c of rest) {\n            if (c !== undefined) {\n                f.fromBinary(c.toBinary());\n            }\n        }\n        if (!validateMergedFeatures(f)) {\n            throw new Error(`Invalid FeatureSet for edition ${Edition[edition]}`);\n        }\n        return f;\n    };\n}\n// When protoc generates google.protobuf.FeatureSetDefaults, it ensures that\n// fields are not repeated or required, do not use oneof, and have a default\n// value.\n//\n// When features for an element are resolved, features of the element and its\n// parents are merged into the default FeatureSet for the edition. Because unset\n// fields in the FeatureSet of an element do not unset the default FeatureSet\n// values, a resolved FeatureSet is guaranteed to have all fields set. This is\n// also the case for extensions to FeatureSet that a user might provide, and for\n// features from the future.\n//\n// We cannot exhaustively validate correctness of FeatureSetDefaults at runtime\n// without knowing the schema: If no value for a feature is provided, we do not\n// know that it exists at all.\n//\n// As a sanity check, we validate that all fields known to our version of\n// FeatureSet are set.\nfunction validateMergedFeatures(featureSet) {\n    for (const fi of FeatureSet.fields.list()) {\n        const v = featureSet[fi.localName];\n        if (v === undefined) {\n            return false;\n        }\n        if (fi.kind == \"enum\" && v === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/create-descriptor-set.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n\n\n\n\n/**\n * Create a DescriptorSet, a convenient interface for working with a set of\n * google.protobuf.FileDescriptorProto.\n *\n * Note that files must be given in topological order, so each file appears\n * before any file that imports it. Protocol buffer compilers always produce\n * files in topological order.\n */\nfunction createDescriptorSet(input, options) {\n    var _a;\n    const cart = {\n        enums: new Map(),\n        messages: new Map(),\n        services: new Map(),\n        extensions: new Map(),\n        mapEntries: new Map(),\n        resolveFeatures: createFeatureResolver((_a = options === null || options === void 0 ? void 0 : options.featureSetDefaults) !== null && _a !== void 0 ? _a : featureSetDefaults),\n    };\n    const fileDescriptors = input instanceof FileDescriptorSet\n        ? input.file\n        : input instanceof Uint8Array\n            ? FileDescriptorSet.fromBinary(input).file\n            : input;\n    const files = fileDescriptors.map((proto) => newFile(proto, cart));\n    return Object.assign({ files }, cart);\n}\n/**\n * Create a descriptor for a file.\n */\nfunction newFile(proto, cart) {\n    var _a, _b;\n    (0,assert/* assert */.hu)(proto.name, `invalid FileDescriptorProto: missing name`);\n    const file = Object.assign(Object.assign({ kind: \"file\", proto, deprecated: (_b = (_a = proto.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false }, parseFileSyntax(proto.syntax, proto.edition)), { name: proto.name.replace(/\\.proto/, \"\"), enums: [], messages: [], extensions: [], services: [], toString() {\n            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions -- we asserted above\n            return `file ${this.proto.name}`;\n        },\n        getSyntaxComments() {\n            return findComments(this.proto.sourceCodeInfo, [\n                FieldNumber.FileDescriptorProto_Syntax,\n            ]);\n        },\n        getPackageComments() {\n            return findComments(this.proto.sourceCodeInfo, [\n                FieldNumber.FileDescriptorProto_Package,\n            ]);\n        },\n        getFeatures() {\n            var _a;\n            return cart.resolveFeatures(this.edition, (_a = this.proto.options) === null || _a === void 0 ? void 0 : _a.features);\n        } });\n    cart.mapEntries.clear(); // map entries are local to the file, we can safely discard\n    for (const enumProto of proto.enumType) {\n        addEnum(enumProto, file, undefined, cart);\n    }\n    for (const messageProto of proto.messageType) {\n        addMessage(messageProto, file, undefined, cart);\n    }\n    for (const serviceProto of proto.service) {\n        addService(serviceProto, file, cart);\n    }\n    addExtensions(file, cart);\n    for (const mapEntry of cart.mapEntries.values()) {\n        addFields(mapEntry, cart);\n    }\n    for (const message of file.messages) {\n        addFields(message, cart);\n        addExtensions(message, cart);\n    }\n    cart.mapEntries.clear(); // map entries are local to the file, we can safely discard\n    return file;\n}\n/**\n * Create descriptors for extensions, and add them to the message / file,\n * and to our cart.\n * Recurses into nested types.\n */\nfunction addExtensions(desc, cart) {\n    switch (desc.kind) {\n        case \"file\":\n            for (const proto of desc.proto.extension) {\n                const ext = newExtension(proto, desc, undefined, cart);\n                desc.extensions.push(ext);\n                cart.extensions.set(ext.typeName, ext);\n            }\n            break;\n        case \"message\":\n            for (const proto of desc.proto.extension) {\n                const ext = newExtension(proto, desc.file, desc, cart);\n                desc.nestedExtensions.push(ext);\n                cart.extensions.set(ext.typeName, ext);\n            }\n            for (const message of desc.nestedMessages) {\n                addExtensions(message, cart);\n            }\n            break;\n    }\n}\n/**\n * Create descriptors for fields and oneof groups, and add them to the message.\n * Recurses into nested types.\n */\nfunction addFields(message, cart) {\n    const allOneofs = message.proto.oneofDecl.map((proto) => newOneof(proto, message, cart));\n    const oneofsSeen = new Set();\n    for (const proto of message.proto.field) {\n        const oneof = findOneof(proto, allOneofs);\n        const field = newField(proto, message.file, message, oneof, cart);\n        message.fields.push(field);\n        if (oneof === undefined) {\n            message.members.push(field);\n        }\n        else {\n            oneof.fields.push(field);\n            if (!oneofsSeen.has(oneof)) {\n                oneofsSeen.add(oneof);\n                message.members.push(oneof);\n            }\n        }\n    }\n    for (const oneof of allOneofs.filter((o) => oneofsSeen.has(o))) {\n        message.oneofs.push(oneof);\n    }\n    for (const child of message.nestedMessages) {\n        addFields(child, cart);\n    }\n}\n/**\n * Create a descriptor for an enumeration, and add it our cart and to the\n * parent type, if any.\n */\nfunction addEnum(proto, file, parent, cart) {\n    var _a, _b, _c;\n    (0,assert/* assert */.hu)(proto.name, `invalid EnumDescriptorProto: missing name`);\n    const desc = {\n        kind: \"enum\",\n        proto,\n        deprecated: (_b = (_a = proto.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,\n        file,\n        parent,\n        name: proto.name,\n        typeName: makeTypeName(proto, parent, file),\n        values: [],\n        sharedPrefix: (0,names/* findEnumSharedPrefix */.Sm)(proto.name, proto.value.map((v) => { var _a; return (_a = v.name) !== null && _a !== void 0 ? _a : \"\"; })),\n        toString() {\n            return `enum ${this.typeName}`;\n        },\n        getComments() {\n            const path = this.parent\n                ? [\n                    ...this.parent.getComments().sourcePath,\n                    FieldNumber.DescriptorProto_EnumType,\n                    this.parent.proto.enumType.indexOf(this.proto),\n                ]\n                : [\n                    FieldNumber.FileDescriptorProto_EnumType,\n                    this.file.proto.enumType.indexOf(this.proto),\n                ];\n            return findComments(file.proto.sourceCodeInfo, path);\n        },\n        getFeatures() {\n            var _a, _b, _c;\n            const parentFeatures = (_b = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.getFeatures()) !== null && _b !== void 0 ? _b : this.file.getFeatures();\n            return cart.resolveFeatures(this.file.edition, parentFeatures, (_c = this.proto.options) === null || _c === void 0 ? void 0 : _c.features);\n        },\n    };\n    cart.enums.set(desc.typeName, desc);\n    proto.value.forEach((proto) => {\n        var _a, _b;\n        (0,assert/* assert */.hu)(proto.name, `invalid EnumValueDescriptorProto: missing name`);\n        (0,assert/* assert */.hu)(proto.number !== undefined, `invalid EnumValueDescriptorProto: missing number`);\n        desc.values.push({\n            kind: \"enum_value\",\n            proto,\n            deprecated: (_b = (_a = proto.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,\n            parent: desc,\n            name: proto.name,\n            number: proto.number,\n            toString() {\n                return `enum value ${desc.typeName}.${this.name}`;\n            },\n            declarationString() {\n                var _a;\n                let str = `${this.name} = ${this.number}`;\n                if (((_a = this.proto.options) === null || _a === void 0 ? void 0 : _a.deprecated) === true) {\n                    str += \" [deprecated = true]\";\n                }\n                return str;\n            },\n            getComments() {\n                const path = [\n                    ...this.parent.getComments().sourcePath,\n                    FieldNumber.EnumDescriptorProto_Value,\n                    this.parent.proto.value.indexOf(this.proto),\n                ];\n                return findComments(file.proto.sourceCodeInfo, path);\n            },\n            getFeatures() {\n                var _a;\n                return cart.resolveFeatures(this.parent.file.edition, this.parent.getFeatures(), (_a = this.proto.options) === null || _a === void 0 ? void 0 : _a.features);\n            },\n        });\n    });\n    ((_c = parent === null || parent === void 0 ? void 0 : parent.nestedEnums) !== null && _c !== void 0 ? _c : file.enums).push(desc);\n}\n/**\n * Create a descriptor for a message, including nested types, and add it to our\n * cart. Note that this does not create descriptors fields.\n */\nfunction addMessage(proto, file, parent, cart) {\n    var _a, _b, _c, _d;\n    (0,assert/* assert */.hu)(proto.name, `invalid DescriptorProto: missing name`);\n    const desc = {\n        kind: \"message\",\n        proto,\n        deprecated: (_b = (_a = proto.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,\n        file,\n        parent,\n        name: proto.name,\n        typeName: makeTypeName(proto, parent, file),\n        fields: [],\n        oneofs: [],\n        members: [],\n        nestedEnums: [],\n        nestedMessages: [],\n        nestedExtensions: [],\n        toString() {\n            return `message ${this.typeName}`;\n        },\n        getComments() {\n            const path = this.parent\n                ? [\n                    ...this.parent.getComments().sourcePath,\n                    FieldNumber.DescriptorProto_NestedType,\n                    this.parent.proto.nestedType.indexOf(this.proto),\n                ]\n                : [\n                    FieldNumber.FileDescriptorProto_MessageType,\n                    this.file.proto.messageType.indexOf(this.proto),\n                ];\n            return findComments(file.proto.sourceCodeInfo, path);\n        },\n        getFeatures() {\n            var _a, _b, _c;\n            const parentFeatures = (_b = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.getFeatures()) !== null && _b !== void 0 ? _b : this.file.getFeatures();\n            return cart.resolveFeatures(this.file.edition, parentFeatures, (_c = this.proto.options) === null || _c === void 0 ? void 0 : _c.features);\n        },\n    };\n    if (((_c = proto.options) === null || _c === void 0 ? void 0 : _c.mapEntry) === true) {\n        cart.mapEntries.set(desc.typeName, desc);\n    }\n    else {\n        ((_d = parent === null || parent === void 0 ? void 0 : parent.nestedMessages) !== null && _d !== void 0 ? _d : file.messages).push(desc);\n        cart.messages.set(desc.typeName, desc);\n    }\n    for (const enumProto of proto.enumType) {\n        addEnum(enumProto, file, desc, cart);\n    }\n    for (const messageProto of proto.nestedType) {\n        addMessage(messageProto, file, desc, cart);\n    }\n}\n/**\n * Create a descriptor for a service, including methods, and add it to our\n * cart.\n */\nfunction addService(proto, file, cart) {\n    var _a, _b;\n    (0,assert/* assert */.hu)(proto.name, `invalid ServiceDescriptorProto: missing name`);\n    const desc = {\n        kind: \"service\",\n        proto,\n        deprecated: (_b = (_a = proto.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,\n        file,\n        name: proto.name,\n        typeName: makeTypeName(proto, undefined, file),\n        methods: [],\n        toString() {\n            return `service ${this.typeName}`;\n        },\n        getComments() {\n            const path = [\n                FieldNumber.FileDescriptorProto_Service,\n                this.file.proto.service.indexOf(this.proto),\n            ];\n            return findComments(file.proto.sourceCodeInfo, path);\n        },\n        getFeatures() {\n            var _a;\n            return cart.resolveFeatures(this.file.edition, this.file.getFeatures(), (_a = this.proto.options) === null || _a === void 0 ? void 0 : _a.features);\n        },\n    };\n    file.services.push(desc);\n    cart.services.set(desc.typeName, desc);\n    for (const methodProto of proto.method) {\n        desc.methods.push(newMethod(methodProto, desc, cart));\n    }\n}\n/**\n * Create a descriptor for a method.\n */\nfunction newMethod(proto, parent, cart) {\n    var _a, _b, _c;\n    (0,assert/* assert */.hu)(proto.name, `invalid MethodDescriptorProto: missing name`);\n    (0,assert/* assert */.hu)(proto.inputType, `invalid MethodDescriptorProto: missing input_type`);\n    (0,assert/* assert */.hu)(proto.outputType, `invalid MethodDescriptorProto: missing output_type`);\n    let methodKind;\n    if (proto.clientStreaming === true && proto.serverStreaming === true) {\n        methodKind = service_type/* MethodKind */.t.BiDiStreaming;\n    }\n    else if (proto.clientStreaming === true) {\n        methodKind = service_type/* MethodKind */.t.ClientStreaming;\n    }\n    else if (proto.serverStreaming === true) {\n        methodKind = service_type/* MethodKind */.t.ServerStreaming;\n    }\n    else {\n        methodKind = service_type/* MethodKind */.t.Unary;\n    }\n    let idempotency;\n    switch ((_a = proto.options) === null || _a === void 0 ? void 0 : _a.idempotencyLevel) {\n        case MethodOptions_IdempotencyLevel.IDEMPOTENT:\n            idempotency = service_type/* MethodIdempotency */.w.Idempotent;\n            break;\n        case MethodOptions_IdempotencyLevel.NO_SIDE_EFFECTS:\n            idempotency = service_type/* MethodIdempotency */.w.NoSideEffects;\n            break;\n        case MethodOptions_IdempotencyLevel.IDEMPOTENCY_UNKNOWN:\n        case undefined:\n            idempotency = undefined;\n            break;\n    }\n    const input = cart.messages.get(trimLeadingDot(proto.inputType));\n    const output = cart.messages.get(trimLeadingDot(proto.outputType));\n    (0,assert/* assert */.hu)(input, `invalid MethodDescriptorProto: input_type ${proto.inputType} not found`);\n    (0,assert/* assert */.hu)(output, `invalid MethodDescriptorProto: output_type ${proto.inputType} not found`);\n    const name = proto.name;\n    return {\n        kind: \"rpc\",\n        proto,\n        deprecated: (_c = (_b = proto.options) === null || _b === void 0 ? void 0 : _b.deprecated) !== null && _c !== void 0 ? _c : false,\n        parent,\n        name,\n        methodKind,\n        input,\n        output,\n        idempotency,\n        toString() {\n            return `rpc ${parent.typeName}.${name}`;\n        },\n        getComments() {\n            const path = [\n                ...this.parent.getComments().sourcePath,\n                FieldNumber.ServiceDescriptorProto_Method,\n                this.parent.proto.method.indexOf(this.proto),\n            ];\n            return findComments(parent.file.proto.sourceCodeInfo, path);\n        },\n        getFeatures() {\n            var _a;\n            return cart.resolveFeatures(this.parent.file.edition, this.parent.getFeatures(), (_a = this.proto.options) === null || _a === void 0 ? void 0 : _a.features);\n        },\n    };\n}\n/**\n * Create a descriptor for a oneof group.\n */\nfunction newOneof(proto, parent, cart) {\n    (0,assert/* assert */.hu)(proto.name, `invalid OneofDescriptorProto: missing name`);\n    return {\n        kind: \"oneof\",\n        proto,\n        deprecated: false,\n        parent,\n        fields: [],\n        name: proto.name,\n        toString() {\n            return `oneof ${parent.typeName}.${this.name}`;\n        },\n        getComments() {\n            const path = [\n                ...this.parent.getComments().sourcePath,\n                FieldNumber.DescriptorProto_OneofDecl,\n                this.parent.proto.oneofDecl.indexOf(this.proto),\n            ];\n            return findComments(parent.file.proto.sourceCodeInfo, path);\n        },\n        getFeatures() {\n            var _a;\n            return cart.resolveFeatures(this.parent.file.edition, this.parent.getFeatures(), (_a = this.proto.options) === null || _a === void 0 ? void 0 : _a.features);\n        },\n    };\n}\n/**\n * Create a descriptor for a field.\n */\nfunction newField(proto, file, parent, oneof, cart) {\n    var _a, _b, _c;\n    (0,assert/* assert */.hu)(proto.name, `invalid FieldDescriptorProto: missing name`);\n    (0,assert/* assert */.hu)(proto.number, `invalid FieldDescriptorProto: missing number`);\n    (0,assert/* assert */.hu)(proto.type, `invalid FieldDescriptorProto: missing type`);\n    const common = {\n        proto,\n        deprecated: (_b = (_a = proto.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,\n        name: proto.name,\n        number: proto.number,\n        parent,\n        oneof,\n        optional: isOptionalField(proto, file.syntax),\n        packedByDefault: isPackedFieldByDefault(file, proto, cart.resolveFeatures),\n        packed: isPackedField(file, parent, proto, cart.resolveFeatures),\n        jsonName: proto.jsonName === (0,names/* fieldJsonName */.x1)(proto.name) ? undefined : proto.jsonName,\n        scalar: undefined,\n        longType: undefined,\n        message: undefined,\n        enum: undefined,\n        mapKey: undefined,\n        mapValue: undefined,\n        declarationString,\n        // toString, getComments, getFeatures are overridden in newExtension\n        toString() {\n            return `field ${this.parent.typeName}.${this.name}`;\n        },\n        getComments() {\n            const path = [\n                ...this.parent.getComments().sourcePath,\n                FieldNumber.DescriptorProto_Field,\n                this.parent.proto.field.indexOf(this.proto),\n            ];\n            return findComments(file.proto.sourceCodeInfo, path);\n        },\n        getFeatures() {\n            var _a;\n            return cart.resolveFeatures(file.edition, this.parent.getFeatures(), (_a = this.proto.options) === null || _a === void 0 ? void 0 : _a.features);\n        },\n    };\n    const repeated = proto.label === FieldDescriptorProto_Label.REPEATED;\n    switch (proto.type) {\n        case FieldDescriptorProto_Type.MESSAGE:\n        case FieldDescriptorProto_Type.GROUP: {\n            (0,assert/* assert */.hu)(proto.typeName, `invalid FieldDescriptorProto: missing type_name`);\n            const mapEntry = cart.mapEntries.get(trimLeadingDot(proto.typeName));\n            if (mapEntry !== undefined) {\n                (0,assert/* assert */.hu)(repeated, `invalid FieldDescriptorProto: expected map entry to be repeated`);\n                return Object.assign(Object.assign(Object.assign({}, common), { kind: \"field\", fieldKind: \"map\", repeated: false }), getMapFieldTypes(mapEntry));\n            }\n            const message = cart.messages.get(trimLeadingDot(proto.typeName));\n            (0,assert/* assert */.hu)(message !== undefined, `invalid FieldDescriptorProto: type_name ${proto.typeName} not found`);\n            return Object.assign(Object.assign({}, common), { kind: \"field\", fieldKind: \"message\", repeated,\n                message });\n        }\n        case FieldDescriptorProto_Type.ENUM: {\n            (0,assert/* assert */.hu)(proto.typeName, `invalid FieldDescriptorProto: missing type_name`);\n            const e = cart.enums.get(trimLeadingDot(proto.typeName));\n            (0,assert/* assert */.hu)(e !== undefined, `invalid FieldDescriptorProto: type_name ${proto.typeName} not found`);\n            return Object.assign(Object.assign({}, common), { kind: \"field\", fieldKind: \"enum\", getDefaultValue,\n                repeated, enum: e });\n        }\n        default: {\n            const scalar = fieldTypeToScalarType[proto.type];\n            (0,assert/* assert */.hu)(scalar, `invalid FieldDescriptorProto: unknown type ${proto.type}`);\n            return Object.assign(Object.assign({}, common), { kind: \"field\", fieldKind: \"scalar\", getDefaultValue,\n                repeated,\n                scalar, longType: ((_c = proto.options) === null || _c === void 0 ? void 0 : _c.jstype) == FieldOptions_JSType.JS_STRING\n                    ? esm_field/* LongType */.p.STRING\n                    : esm_field/* LongType */.p.BIGINT });\n        }\n    }\n}\n/**\n * Create a descriptor for an extension field.\n */\nfunction newExtension(proto, file, parent, cart) {\n    (0,assert/* assert */.hu)(proto.extendee, `invalid FieldDescriptorProto: missing extendee`);\n    const field = newField(proto, file, null, // to safe us many lines of duplicated code, we trick the type system\n    undefined, cart);\n    const extendee = cart.messages.get(trimLeadingDot(proto.extendee));\n    (0,assert/* assert */.hu)(extendee, `invalid FieldDescriptorProto: extendee ${proto.extendee} not found`);\n    return Object.assign(Object.assign({}, field), { kind: \"extension\", typeName: makeTypeName(proto, parent, file), parent,\n        file,\n        extendee,\n        // Must override toString, getComments, getFeatures from newField, because we\n        // call newField with parent undefined.\n        toString() {\n            return `extension ${this.typeName}`;\n        },\n        getComments() {\n            const path = this.parent\n                ? [\n                    ...this.parent.getComments().sourcePath,\n                    FieldNumber.DescriptorProto_Extension,\n                    this.parent.proto.extension.indexOf(proto),\n                ]\n                : [\n                    FieldNumber.FileDescriptorProto_Extension,\n                    this.file.proto.extension.indexOf(proto),\n                ];\n            return findComments(file.proto.sourceCodeInfo, path);\n        },\n        getFeatures() {\n            var _a, _b;\n            return cart.resolveFeatures(this.file.edition, ((_a = this.parent) !== null && _a !== void 0 ? _a : this.file).getFeatures(), (_b = this.proto.options) === null || _b === void 0 ? void 0 : _b.features);\n        } });\n}\n/**\n * Parse the \"syntax\" and \"edition\" fields, stripping test editions.\n */\nfunction parseFileSyntax(syntax, edition) {\n    let e;\n    let s;\n    switch (syntax) {\n        case undefined:\n        case \"proto2\":\n            s = \"proto2\";\n            e = Edition.EDITION_PROTO2;\n            break;\n        case \"proto3\":\n            s = \"proto3\";\n            e = Edition.EDITION_PROTO3;\n            break;\n        case \"editions\":\n            s = \"editions\";\n            switch (edition) {\n                case undefined:\n                case Edition.EDITION_1_TEST_ONLY:\n                case Edition.EDITION_2_TEST_ONLY:\n                case Edition.EDITION_99997_TEST_ONLY:\n                case Edition.EDITION_99998_TEST_ONLY:\n                case Edition.EDITION_99999_TEST_ONLY:\n                case Edition.EDITION_UNKNOWN:\n                    e = Edition.EDITION_UNKNOWN;\n                    break;\n                default:\n                    e = edition;\n                    break;\n            }\n            break;\n        default:\n            throw new Error(`invalid FileDescriptorProto: unsupported syntax: ${syntax}`);\n    }\n    if (syntax === \"editions\" && edition === Edition.EDITION_UNKNOWN) {\n        throw new Error(`invalid FileDescriptorProto: syntax ${syntax} cannot have edition ${String(edition)}`);\n    }\n    return {\n        syntax: s,\n        edition: e,\n    };\n}\n/**\n * Create a fully qualified name for a protobuf type or extension field.\n *\n * The fully qualified name for messages, enumerations, and services is\n * constructed by concatenating the package name (if present), parent\n * message names (for nested types), and the type name. We omit the leading\n * dot added by protobuf compilers. Examples:\n * - mypackage.MyMessage\n * - mypackage.MyMessage.NestedMessage\n *\n * The fully qualified name for extension fields is constructed by\n * concatenating the package name (if present), parent message names (for\n * extensions declared within a message), and the field name. Examples:\n * - mypackage.extfield\n * - mypackage.MyMessage.extfield\n */\nfunction makeTypeName(proto, parent, file) {\n    (0,assert/* assert */.hu)(proto.name, `invalid ${proto.getType().typeName}: missing name`);\n    let typeName;\n    if (parent) {\n        typeName = `${parent.typeName}.${proto.name}`;\n    }\n    else if (file.proto.package !== undefined) {\n        typeName = `${file.proto.package}.${proto.name}`;\n    }\n    else {\n        typeName = `${proto.name}`;\n    }\n    return typeName;\n}\n/**\n * Remove the leading dot from a fully qualified type name.\n */\nfunction trimLeadingDot(typeName) {\n    return typeName.startsWith(\".\") ? typeName.substring(1) : typeName;\n}\nfunction getMapFieldTypes(mapEntry) {\n    var _a, _b;\n    (0,assert/* assert */.hu)((_a = mapEntry.proto.options) === null || _a === void 0 ? void 0 : _a.mapEntry, `invalid DescriptorProto: expected ${mapEntry.toString()} to be a map entry`);\n    (0,assert/* assert */.hu)(mapEntry.fields.length === 2, `invalid DescriptorProto: map entry ${mapEntry.toString()} has ${mapEntry.fields.length} fields`);\n    const keyField = mapEntry.fields.find((f) => f.proto.number === 1);\n    (0,assert/* assert */.hu)(keyField, `invalid DescriptorProto: map entry ${mapEntry.toString()} is missing key field`);\n    const mapKey = keyField.scalar;\n    (0,assert/* assert */.hu)(mapKey !== undefined &&\n        mapKey !== esm_field/* ScalarType */.w.BYTES &&\n        mapKey !== esm_field/* ScalarType */.w.FLOAT &&\n        mapKey !== esm_field/* ScalarType */.w.DOUBLE, `invalid DescriptorProto: map entry ${mapEntry.toString()} has unexpected key type ${(_b = keyField.proto.type) !== null && _b !== void 0 ? _b : -1}`);\n    const valueField = mapEntry.fields.find((f) => f.proto.number === 2);\n    (0,assert/* assert */.hu)(valueField, `invalid DescriptorProto: map entry ${mapEntry.toString()} is missing value field`);\n    switch (valueField.fieldKind) {\n        case \"scalar\":\n            return {\n                mapKey,\n                mapValue: Object.assign(Object.assign({}, valueField), { kind: \"scalar\" }),\n            };\n        case \"message\":\n            return {\n                mapKey,\n                mapValue: Object.assign(Object.assign({}, valueField), { kind: \"message\" }),\n            };\n        case \"enum\":\n            return {\n                mapKey,\n                mapValue: Object.assign(Object.assign({}, valueField), { kind: \"enum\" }),\n            };\n        default:\n            throw new Error(\"invalid DescriptorProto: unsupported map entry value field\");\n    }\n}\n/**\n * Did the user put the field in a oneof group?\n * This handles proto3 optionals.\n */\nfunction findOneof(proto, allOneofs) {\n    var _a;\n    const oneofIndex = proto.oneofIndex;\n    if (oneofIndex === undefined) {\n        return undefined;\n    }\n    let oneof;\n    if (proto.proto3Optional !== true) {\n        oneof = allOneofs[oneofIndex];\n        (0,assert/* assert */.hu)(oneof, `invalid FieldDescriptorProto: oneof #${oneofIndex} for field #${(_a = proto.number) !== null && _a !== void 0 ? _a : -1} not found`);\n    }\n    return oneof;\n}\n/**\n * Did the user use the `optional` keyword?\n * This handles proto3 optionals.\n */\nfunction isOptionalField(proto, syntax) {\n    switch (syntax) {\n        case \"proto2\":\n            return (proto.oneofIndex === undefined &&\n                proto.label === FieldDescriptorProto_Label.OPTIONAL);\n        case \"proto3\":\n            return proto.proto3Optional === true;\n        case \"editions\":\n            return false;\n    }\n}\n/**\n * Is this field packed by default? Only valid for repeated enum fields, and\n * for repeated scalar fields except BYTES and STRING.\n *\n * In proto3 syntax, fields are packed by default. In proto2 syntax, fields\n * are unpacked by default. With editions, the default is whatever the edition\n * specifies as a default. In edition 2023, fields are packed by default.\n */\nfunction isPackedFieldByDefault(file, proto, resolveFeatures) {\n    const { repeatedFieldEncoding } = resolveFeatures(file.edition);\n    if (repeatedFieldEncoding != FeatureSet_RepeatedFieldEncoding.PACKED) {\n        return false;\n    }\n    // From the proto3 language guide:\n    // > In proto3, repeated fields of scalar numeric types are packed by default.\n    // This information is incomplete - according to the conformance tests, BOOL\n    // and ENUM are packed by default as well. This means only STRING and BYTES\n    // are not packed by default, which makes sense because they are length-delimited.\n    switch (proto.type) {\n        case FieldDescriptorProto_Type.STRING:\n        case FieldDescriptorProto_Type.BYTES:\n        case FieldDescriptorProto_Type.GROUP:\n        case FieldDescriptorProto_Type.MESSAGE:\n            return false;\n        default:\n            return true;\n    }\n}\n/**\n * Pack this repeated field?\n *\n * Respects field type, proto2/proto3 defaults and the `packed` option, or\n * edition defaults and the edition features.repeated_field_encoding options.\n */\nfunction isPackedField(file, parent, proto, resolveFeatures) {\n    var _a, _b, _c, _d, _e, _f;\n    switch (proto.type) {\n        case FieldDescriptorProto_Type.STRING:\n        case FieldDescriptorProto_Type.BYTES:\n        case FieldDescriptorProto_Type.GROUP:\n        case FieldDescriptorProto_Type.MESSAGE:\n            // length-delimited types cannot be packed\n            return false;\n        default:\n            switch (file.edition) {\n                case Edition.EDITION_PROTO2:\n                    return (_b = (_a = proto.options) === null || _a === void 0 ? void 0 : _a.packed) !== null && _b !== void 0 ? _b : false;\n                case Edition.EDITION_PROTO3:\n                    return (_d = (_c = proto.options) === null || _c === void 0 ? void 0 : _c.packed) !== null && _d !== void 0 ? _d : true;\n                default: {\n                    const { repeatedFieldEncoding } = resolveFeatures(file.edition, (_e = parent === null || parent === void 0 ? void 0 : parent.getFeatures()) !== null && _e !== void 0 ? _e : file.getFeatures(), (_f = proto.options) === null || _f === void 0 ? void 0 : _f.features);\n                    return (repeatedFieldEncoding == FeatureSet_RepeatedFieldEncoding.PACKED);\n                }\n            }\n    }\n}\n/**\n * Map from a compiler-generated field type to our ScalarType, which is a\n * subset of field types declared by protobuf enum google.protobuf.FieldDescriptorProto.\n */\nconst fieldTypeToScalarType = {\n    [FieldDescriptorProto_Type.DOUBLE]: esm_field/* ScalarType */.w.DOUBLE,\n    [FieldDescriptorProto_Type.FLOAT]: esm_field/* ScalarType */.w.FLOAT,\n    [FieldDescriptorProto_Type.INT64]: esm_field/* ScalarType */.w.INT64,\n    [FieldDescriptorProto_Type.UINT64]: esm_field/* ScalarType */.w.UINT64,\n    [FieldDescriptorProto_Type.INT32]: esm_field/* ScalarType */.w.INT32,\n    [FieldDescriptorProto_Type.FIXED64]: esm_field/* ScalarType */.w.FIXED64,\n    [FieldDescriptorProto_Type.FIXED32]: esm_field/* ScalarType */.w.FIXED32,\n    [FieldDescriptorProto_Type.BOOL]: esm_field/* ScalarType */.w.BOOL,\n    [FieldDescriptorProto_Type.STRING]: esm_field/* ScalarType */.w.STRING,\n    [FieldDescriptorProto_Type.GROUP]: undefined,\n    [FieldDescriptorProto_Type.MESSAGE]: undefined,\n    [FieldDescriptorProto_Type.BYTES]: esm_field/* ScalarType */.w.BYTES,\n    [FieldDescriptorProto_Type.UINT32]: esm_field/* ScalarType */.w.UINT32,\n    [FieldDescriptorProto_Type.ENUM]: undefined,\n    [FieldDescriptorProto_Type.SFIXED32]: esm_field/* ScalarType */.w.SFIXED32,\n    [FieldDescriptorProto_Type.SFIXED64]: esm_field/* ScalarType */.w.SFIXED64,\n    [FieldDescriptorProto_Type.SINT32]: esm_field/* ScalarType */.w.SINT32,\n    [FieldDescriptorProto_Type.SINT64]: esm_field/* ScalarType */.w.SINT64,\n};\n/**\n * Find comments.\n */\nfunction findComments(sourceCodeInfo, sourcePath) {\n    if (!sourceCodeInfo) {\n        return {\n            leadingDetached: [],\n            sourcePath,\n        };\n    }\n    for (const location of sourceCodeInfo.location) {\n        if (location.path.length !== sourcePath.length) {\n            continue;\n        }\n        if (location.path.some((value, index) => sourcePath[index] !== value)) {\n            continue;\n        }\n        return {\n            leadingDetached: location.leadingDetachedComments,\n            leading: location.leadingComments,\n            trailing: location.trailingComments,\n            sourcePath,\n        };\n    }\n    return {\n        leadingDetached: [],\n        sourcePath,\n    };\n}\n/**\n * The following field numbers are used to find comments in\n * google.protobuf.SourceCodeInfo.\n */\nvar FieldNumber;\n(function (FieldNumber) {\n    FieldNumber[FieldNumber[\"FileDescriptorProto_Package\"] = 2] = \"FileDescriptorProto_Package\";\n    FieldNumber[FieldNumber[\"FileDescriptorProto_MessageType\"] = 4] = \"FileDescriptorProto_MessageType\";\n    FieldNumber[FieldNumber[\"FileDescriptorProto_EnumType\"] = 5] = \"FileDescriptorProto_EnumType\";\n    FieldNumber[FieldNumber[\"FileDescriptorProto_Service\"] = 6] = \"FileDescriptorProto_Service\";\n    FieldNumber[FieldNumber[\"FileDescriptorProto_Extension\"] = 7] = \"FileDescriptorProto_Extension\";\n    FieldNumber[FieldNumber[\"FileDescriptorProto_Syntax\"] = 12] = \"FileDescriptorProto_Syntax\";\n    FieldNumber[FieldNumber[\"DescriptorProto_Field\"] = 2] = \"DescriptorProto_Field\";\n    FieldNumber[FieldNumber[\"DescriptorProto_NestedType\"] = 3] = \"DescriptorProto_NestedType\";\n    FieldNumber[FieldNumber[\"DescriptorProto_EnumType\"] = 4] = \"DescriptorProto_EnumType\";\n    FieldNumber[FieldNumber[\"DescriptorProto_Extension\"] = 6] = \"DescriptorProto_Extension\";\n    FieldNumber[FieldNumber[\"DescriptorProto_OneofDecl\"] = 8] = \"DescriptorProto_OneofDecl\";\n    FieldNumber[FieldNumber[\"EnumDescriptorProto_Value\"] = 2] = \"EnumDescriptorProto_Value\";\n    FieldNumber[FieldNumber[\"ServiceDescriptorProto_Method\"] = 2] = \"ServiceDescriptorProto_Method\";\n})(FieldNumber || (FieldNumber = {}));\n/**\n * Return a string that matches the definition of a field in the protobuf\n * source. Does not take custom options into account.\n */\nfunction declarationString() {\n    var _a, _b, _c;\n    const parts = [];\n    if (this.repeated) {\n        parts.push(\"repeated\");\n    }\n    if (this.optional) {\n        parts.push(\"optional\");\n    }\n    const file = this.kind === \"extension\" ? this.file : this.parent.file;\n    if (file.syntax == \"proto2\" &&\n        this.proto.label === FieldDescriptorProto_Label.REQUIRED) {\n        parts.push(\"required\");\n    }\n    let type;\n    switch (this.fieldKind) {\n        case \"scalar\":\n            type = esm_field/* ScalarType */.w[this.scalar].toLowerCase();\n            break;\n        case \"enum\":\n            type = this.enum.typeName;\n            break;\n        case \"message\":\n            type = this.message.typeName;\n            break;\n        case \"map\": {\n            const k = esm_field/* ScalarType */.w[this.mapKey].toLowerCase();\n            let v;\n            switch (this.mapValue.kind) {\n                case \"scalar\":\n                    v = esm_field/* ScalarType */.w[this.mapValue.scalar].toLowerCase();\n                    break;\n                case \"enum\":\n                    v = this.mapValue.enum.typeName;\n                    break;\n                case \"message\":\n                    v = this.mapValue.message.typeName;\n                    break;\n            }\n            type = `map<${k}, ${v}>`;\n            break;\n        }\n    }\n    parts.push(`${type} ${this.name} = ${this.number}`);\n    const options = [];\n    if (((_a = this.proto.options) === null || _a === void 0 ? void 0 : _a.packed) !== undefined) {\n        options.push(`packed = ${this.proto.options.packed.toString()}`);\n    }\n    let defaultValue = this.proto.defaultValue;\n    if (defaultValue !== undefined) {\n        if (this.proto.type == FieldDescriptorProto_Type.BYTES ||\n            this.proto.type == FieldDescriptorProto_Type.STRING) {\n            defaultValue = '\"' + defaultValue.replace('\"', '\\\\\"') + '\"';\n        }\n        options.push(`default = ${defaultValue}`);\n    }\n    if (this.jsonName !== undefined) {\n        options.push(`json_name = \"${this.jsonName}\"`);\n    }\n    if (((_b = this.proto.options) === null || _b === void 0 ? void 0 : _b.jstype) !== undefined) {\n        options.push(`jstype = ${FieldOptions_JSType[this.proto.options.jstype]}`);\n    }\n    if (((_c = this.proto.options) === null || _c === void 0 ? void 0 : _c.deprecated) === true) {\n        options.push(`deprecated = true`);\n    }\n    if (options.length > 0) {\n        parts.push(\"[\" + options.join(\", \") + \"]\");\n    }\n    return parts.join(\" \");\n}\n/**\n * Parses a text-encoded default value (proto2) of a scalar or enum field.\n */\nfunction getDefaultValue() {\n    const d = this.proto.defaultValue;\n    if (d === undefined) {\n        return undefined;\n    }\n    switch (this.fieldKind) {\n        case \"enum\":\n            return parseTextFormatEnumValue(this.enum, d);\n        case \"scalar\":\n            return parseTextFormatScalarValue(this.scalar, d);\n        default:\n            return undefined;\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/create-registry.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create a new registry from the given types.\n */\nfunction createRegistry(...types) {\n    const messages = {};\n    const enums = {};\n    const services = {};\n    const registry = {\n        /**\n         * Add a type to the registry. For messages, the types used in message\n         * fields are added recursively. For services, the message types used\n         * for requests and responses are added recursively.\n         */\n        add(type) {\n            if (\"fields\" in type) {\n                if (!this.findMessage(type.typeName)) {\n                    messages[type.typeName] = type;\n                    for (const field of type.fields.list()) {\n                        if (field.kind == \"message\") {\n                            this.add(field.T);\n                        }\n                        else if (field.kind == \"map\" && field.V.kind == \"message\") {\n                            this.add(field.V.T);\n                        }\n                        else if (field.kind == \"enum\") {\n                            this.add(field.T);\n                        }\n                    }\n                }\n            }\n            else if (\"methods\" in type) {\n                if (!this.findService(type.typeName)) {\n                    services[type.typeName] = type;\n                    for (const method of Object.values(type.methods)) {\n                        this.add(method.I);\n                        this.add(method.O);\n                    }\n                }\n            }\n            else {\n                enums[type.typeName] = type;\n            }\n        },\n        findMessage(typeName) {\n            return messages[typeName];\n        },\n        findEnum(typeName) {\n            return enums[typeName];\n        },\n        findService(typeName) {\n            return services[typeName];\n        },\n    };\n    for (const type of types) {\n        registry.add(type);\n    }\n    return registry;\n}\n\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/timestamp_pb.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n/**\n * A Timestamp represents a point in time independent of any time zone or local\n * calendar, encoded as a count of seconds and fractions of seconds at\n * nanosecond resolution. The count is relative to an epoch at UTC midnight on\n * January 1, 1970, in the proleptic Gregorian calendar which extends the\n * Gregorian calendar backwards to year one.\n *\n * All minutes are 60 seconds long. Leap seconds are \"smeared\" so that no leap\n * second table is needed for interpretation, using a [24-hour linear\n * smear](https://developers.google.com/time/smear).\n *\n * The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By\n * restricting to that range, we ensure that we can convert to and from [RFC\n * 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.\n *\n * # Examples\n *\n * Example 1: Compute Timestamp from POSIX `time()`.\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(time(NULL));\n *     timestamp.set_nanos(0);\n *\n * Example 2: Compute Timestamp from POSIX `gettimeofday()`.\n *\n *     struct timeval tv;\n *     gettimeofday(&tv, NULL);\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(tv.tv_sec);\n *     timestamp.set_nanos(tv.tv_usec * 1000);\n *\n * Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.\n *\n *     FILETIME ft;\n *     GetSystemTimeAsFileTime(&ft);\n *     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;\n *\n *     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z\n *     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.\n *     Timestamp timestamp;\n *     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));\n *     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));\n *\n * Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.\n *\n *     long millis = System.currentTimeMillis();\n *\n *     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)\n *         .setNanos((int) ((millis % 1000) * 1000000)).build();\n *\n * Example 5: Compute Timestamp from Java `Instant.now()`.\n *\n *     Instant now = Instant.now();\n *\n *     Timestamp timestamp =\n *         Timestamp.newBuilder().setSeconds(now.getEpochSecond())\n *             .setNanos(now.getNano()).build();\n *\n * Example 6: Compute Timestamp from current time in Python.\n *\n *     timestamp = Timestamp()\n *     timestamp.GetCurrentTime()\n *\n * # JSON Mapping\n *\n * In JSON format, the Timestamp type is encoded as a string in the\n * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the\n * format is \"{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z\"\n * where {year} is always expressed using four digits while {month}, {day},\n * {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional\n * seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),\n * are optional. The \"Z\" suffix indicates the timezone (\"UTC\"); the timezone\n * is required. A proto3 JSON serializer should always use UTC (as indicated by\n * \"Z\") when printing the Timestamp type and a proto3 JSON parser should be\n * able to accept both UTC and other timezones (as indicated by an offset).\n *\n * For example, \"2017-01-15T01:30:15.01Z\" encodes 15.01 seconds past\n * 01:30 UTC on January 15, 2017.\n *\n * In JavaScript, one can convert a Date object to this format using the\n * standard\n * [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)\n * method. In Python, a standard `datetime.datetime` object can be converted\n * to this format using\n * [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with\n * the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use\n * the Joda Time's [`ISODateTimeFormat.dateTime()`](\n * http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()\n * ) to obtain a formatter capable of generating timestamps in this format.\n *\n *\n * @generated from message google.protobuf.Timestamp\n */\nclass Timestamp extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * Represents seconds of UTC time since Unix epoch\n         * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n         * 9999-12-31T23:59:59Z inclusive.\n         *\n         * @generated from field: int64 seconds = 1;\n         */\n        this.seconds = proto_int64/* protoInt64 */.q.zero;\n        /**\n         * Non-negative fractions of a second at nanosecond resolution. Negative\n         * second values with fractions must still have non-negative nanos values\n         * that count forward in time. Must be from 0 to 999,999,999\n         * inclusive.\n         *\n         * @generated from field: int32 nanos = 2;\n         */\n        this.nanos = 0;\n        proto3/* proto3 */.w.util.initPartial(data, this);\n    }\n    fromJson(json, options) {\n        if (typeof json !== \"string\") {\n            throw new Error(`cannot decode google.protobuf.Timestamp from JSON: ${proto3/* proto3 */.w.json.debug(json)}`);\n        }\n        const matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);\n        if (!matches) {\n            throw new Error(`cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string`);\n        }\n        const ms = Date.parse(matches[1] + \"-\" + matches[2] + \"-\" + matches[3] + \"T\" + matches[4] + \":\" + matches[5] + \":\" + matches[6] + (matches[8] ? matches[8] : \"Z\"));\n        if (Number.isNaN(ms)) {\n            throw new Error(`cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string`);\n        }\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) {\n            throw new Error(`cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);\n        }\n        this.seconds = proto_int64/* protoInt64 */.q.parse(ms / 1000);\n        this.nanos = 0;\n        if (matches[7]) {\n            this.nanos = (parseInt(\"1\" + matches[7] + \"0\".repeat(9 - matches[7].length)) - 1000000000);\n        }\n        return this;\n    }\n    toJson(options) {\n        const ms = Number(this.seconds) * 1000;\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) {\n            throw new Error(`cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);\n        }\n        if (this.nanos < 0) {\n            throw new Error(`cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative`);\n        }\n        let z = \"Z\";\n        if (this.nanos > 0) {\n            const nanosStr = (this.nanos + 1000000000).toString().substring(1);\n            if (nanosStr.substring(3) === \"000000\") {\n                z = \".\" + nanosStr.substring(0, 3) + \"Z\";\n            }\n            else if (nanosStr.substring(6) === \"000\") {\n                z = \".\" + nanosStr.substring(0, 6) + \"Z\";\n            }\n            else {\n                z = \".\" + nanosStr + \"Z\";\n            }\n        }\n        return new Date(ms).toISOString().replace(\".000Z\", z);\n    }\n    toDate() {\n        return new Date(Number(this.seconds) * 1000 + Math.ceil(this.nanos / 1000000));\n    }\n    static now() {\n        return Timestamp.fromDate(new Date());\n    }\n    static fromDate(date) {\n        const ms = date.getTime();\n        return new Timestamp({\n            seconds: proto_int64/* protoInt64 */.q.parse(Math.floor(ms / 1000)),\n            nanos: (ms % 1000) * 1000000,\n        });\n    }\n    static fromBinary(bytes, options) {\n        return new Timestamp().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Timestamp().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Timestamp().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3/* proto3 */.w.util.equals(Timestamp, a, b);\n    }\n}\nTimestamp.runtime = proto3/* proto3 */.w;\nTimestamp.typeName = \"google.protobuf.Timestamp\";\nTimestamp.fields = proto3/* proto3 */.w.util.newFieldList(() => [\n    { no: 1, name: \"seconds\", kind: \"scalar\", T: 3 /* ScalarType.INT64 */ },\n    { no: 2, name: \"nanos\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */ },\n]);\n\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/duration_pb.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n/**\n * A Duration represents a signed, fixed-length span of time represented\n * as a count of seconds and fractions of seconds at nanosecond\n * resolution. It is independent of any calendar and concepts like \"day\"\n * or \"month\". It is related to Timestamp in that the difference between\n * two Timestamp values is a Duration and it can be added or subtracted\n * from a Timestamp. Range is approximately +-10,000 years.\n *\n * # Examples\n *\n * Example 1: Compute Duration from two Timestamps in pseudo code.\n *\n *     Timestamp start = ...;\n *     Timestamp end = ...;\n *     Duration duration = ...;\n *\n *     duration.seconds = end.seconds - start.seconds;\n *     duration.nanos = end.nanos - start.nanos;\n *\n *     if (duration.seconds < 0 && duration.nanos > 0) {\n *       duration.seconds += 1;\n *       duration.nanos -= 1000000000;\n *     } else if (duration.seconds > 0 && duration.nanos < 0) {\n *       duration.seconds -= 1;\n *       duration.nanos += 1000000000;\n *     }\n *\n * Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.\n *\n *     Timestamp start = ...;\n *     Duration duration = ...;\n *     Timestamp end = ...;\n *\n *     end.seconds = start.seconds + duration.seconds;\n *     end.nanos = start.nanos + duration.nanos;\n *\n *     if (end.nanos < 0) {\n *       end.seconds -= 1;\n *       end.nanos += 1000000000;\n *     } else if (end.nanos >= 1000000000) {\n *       end.seconds += 1;\n *       end.nanos -= 1000000000;\n *     }\n *\n * Example 3: Compute Duration from datetime.timedelta in Python.\n *\n *     td = datetime.timedelta(days=3, minutes=10)\n *     duration = Duration()\n *     duration.FromTimedelta(td)\n *\n * # JSON Mapping\n *\n * In JSON format, the Duration type is encoded as a string rather than an\n * object, where the string ends in the suffix \"s\" (indicating seconds) and\n * is preceded by the number of seconds, with nanoseconds expressed as\n * fractional seconds. For example, 3 seconds with 0 nanoseconds should be\n * encoded in JSON format as \"3s\", while 3 seconds and 1 nanosecond should\n * be expressed in JSON format as \"3.000000001s\", and 3 seconds and 1\n * microsecond should be expressed in JSON format as \"3.000001s\".\n *\n *\n * @generated from message google.protobuf.Duration\n */\nclass Duration extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * Signed seconds of the span of time. Must be from -315,576,000,000\n         * to +315,576,000,000 inclusive. Note: these bounds are computed from:\n         * 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years\n         *\n         * @generated from field: int64 seconds = 1;\n         */\n        this.seconds = proto_int64/* protoInt64 */.q.zero;\n        /**\n         * Signed fractions of a second at nanosecond resolution of the span\n         * of time. Durations less than one second are represented with a 0\n         * `seconds` field and a positive or negative `nanos` field. For durations\n         * of one second or more, a non-zero value for the `nanos` field must be\n         * of the same sign as the `seconds` field. Must be from -999,999,999\n         * to +999,999,999 inclusive.\n         *\n         * @generated from field: int32 nanos = 2;\n         */\n        this.nanos = 0;\n        proto3/* proto3 */.w.util.initPartial(data, this);\n    }\n    fromJson(json, options) {\n        if (typeof json !== \"string\") {\n            throw new Error(`cannot decode google.protobuf.Duration from JSON: ${proto3/* proto3 */.w.json.debug(json)}`);\n        }\n        const match = json.match(/^(-?[0-9]+)(?:\\.([0-9]+))?s/);\n        if (match === null) {\n            throw new Error(`cannot decode google.protobuf.Duration from JSON: ${proto3/* proto3 */.w.json.debug(json)}`);\n        }\n        const longSeconds = Number(match[1]);\n        if (longSeconds > 315576000000 || longSeconds < -315576000000) {\n            throw new Error(`cannot decode google.protobuf.Duration from JSON: ${proto3/* proto3 */.w.json.debug(json)}`);\n        }\n        this.seconds = proto_int64/* protoInt64 */.q.parse(longSeconds);\n        if (typeof match[2] == \"string\") {\n            const nanosStr = match[2] + \"0\".repeat(9 - match[2].length);\n            this.nanos = parseInt(nanosStr);\n            if (longSeconds < 0 || Object.is(longSeconds, -0)) {\n                this.nanos = -this.nanos;\n            }\n        }\n        return this;\n    }\n    toJson(options) {\n        if (Number(this.seconds) > 315576000000 || Number(this.seconds) < -315576000000) {\n            throw new Error(`cannot encode google.protobuf.Duration to JSON: value out of range`);\n        }\n        let text = this.seconds.toString();\n        if (this.nanos !== 0) {\n            let nanosStr = Math.abs(this.nanos).toString();\n            nanosStr = \"0\".repeat(9 - nanosStr.length) + nanosStr;\n            if (nanosStr.substring(3) === \"000000\") {\n                nanosStr = nanosStr.substring(0, 3);\n            }\n            else if (nanosStr.substring(6) === \"000\") {\n                nanosStr = nanosStr.substring(0, 6);\n            }\n            text += \".\" + nanosStr;\n            if (this.nanos < 0 && Number(this.seconds) == 0) {\n                text = \"-\" + text;\n            }\n        }\n        return text + \"s\";\n    }\n    static fromBinary(bytes, options) {\n        return new Duration().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Duration().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Duration().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3/* proto3 */.w.util.equals(Duration, a, b);\n    }\n}\nDuration.runtime = proto3/* proto3 */.w;\nDuration.typeName = \"google.protobuf.Duration\";\nDuration.fields = proto3/* proto3 */.w.util.newFieldList(() => [\n    { no: 1, name: \"seconds\", kind: \"scalar\", T: 3 /* ScalarType.INT64 */ },\n    { no: 2, name: \"nanos\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */ },\n]);\n\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/any_pb.js\nvar any_pb = __nested_webpack_require_80292__(733);\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/empty_pb.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n/**\n * A generic empty message that you can re-use to avoid defining duplicated\n * empty messages in your APIs. A typical example is to use it as the request\n * or the response type of an API method. For instance:\n *\n *     service Foo {\n *       rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);\n *     }\n *\n *\n * @generated from message google.protobuf.Empty\n */\nclass Empty extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        proto3/* proto3 */.w.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Empty().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Empty().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Empty().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3/* proto3 */.w.util.equals(Empty, a, b);\n    }\n}\nEmpty.runtime = proto3/* proto3 */.w;\nEmpty.typeName = \"google.protobuf.Empty\";\nEmpty.fields = proto3/* proto3 */.w.util.newFieldList(() => []);\n\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/field_mask_pb.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n/**\n * `FieldMask` represents a set of symbolic field paths, for example:\n *\n *     paths: \"f.a\"\n *     paths: \"f.b.d\"\n *\n * Here `f` represents a field in some root message, `a` and `b`\n * fields in the message found in `f`, and `d` a field found in the\n * message in `f.b`.\n *\n * Field masks are used to specify a subset of fields that should be\n * returned by a get operation or modified by an update operation.\n * Field masks also have a custom JSON encoding (see below).\n *\n * # Field Masks in Projections\n *\n * When used in the context of a projection, a response message or\n * sub-message is filtered by the API to only contain those fields as\n * specified in the mask. For example, if the mask in the previous\n * example is applied to a response message as follows:\n *\n *     f {\n *       a : 22\n *       b {\n *         d : 1\n *         x : 2\n *       }\n *       y : 13\n *     }\n *     z: 8\n *\n * The result will not contain specific values for fields x,y and z\n * (their value will be set to the default, and omitted in proto text\n * output):\n *\n *\n *     f {\n *       a : 22\n *       b {\n *         d : 1\n *       }\n *     }\n *\n * A repeated field is not allowed except at the last position of a\n * paths string.\n *\n * If a FieldMask object is not present in a get operation, the\n * operation applies to all fields (as if a FieldMask of all fields\n * had been specified).\n *\n * Note that a field mask does not necessarily apply to the\n * top-level response message. In case of a REST get operation, the\n * field mask applies directly to the response, but in case of a REST\n * list operation, the mask instead applies to each individual message\n * in the returned resource list. In case of a REST custom method,\n * other definitions may be used. Where the mask applies will be\n * clearly documented together with its declaration in the API.  In\n * any case, the effect on the returned resource/resources is required\n * behavior for APIs.\n *\n * # Field Masks in Update Operations\n *\n * A field mask in update operations specifies which fields of the\n * targeted resource are going to be updated. The API is required\n * to only change the values of the fields as specified in the mask\n * and leave the others untouched. If a resource is passed in to\n * describe the updated values, the API ignores the values of all\n * fields not covered by the mask.\n *\n * If a repeated field is specified for an update operation, new values will\n * be appended to the existing repeated field in the target resource. Note that\n * a repeated field is only allowed in the last position of a `paths` string.\n *\n * If a sub-message is specified in the last position of the field mask for an\n * update operation, then new value will be merged into the existing sub-message\n * in the target resource.\n *\n * For example, given the target message:\n *\n *     f {\n *       b {\n *         d: 1\n *         x: 2\n *       }\n *       c: [1]\n *     }\n *\n * And an update message:\n *\n *     f {\n *       b {\n *         d: 10\n *       }\n *       c: [2]\n *     }\n *\n * then if the field mask is:\n *\n *  paths: [\"f.b\", \"f.c\"]\n *\n * then the result will be:\n *\n *     f {\n *       b {\n *         d: 10\n *         x: 2\n *       }\n *       c: [1, 2]\n *     }\n *\n * An implementation may provide options to override this default behavior for\n * repeated and message fields.\n *\n * In order to reset a field's value to the default, the field must\n * be in the mask and set to the default value in the provided resource.\n * Hence, in order to reset all fields of a resource, provide a default\n * instance of the resource and set all fields in the mask, or do\n * not provide a mask as described below.\n *\n * If a field mask is not present on update, the operation applies to\n * all fields (as if a field mask of all fields has been specified).\n * Note that in the presence of schema evolution, this may mean that\n * fields the client does not know and has therefore not filled into\n * the request will be reset to their default. If this is unwanted\n * behavior, a specific service may require a client to always specify\n * a field mask, producing an error if not.\n *\n * As with get operations, the location of the resource which\n * describes the updated values in the request message depends on the\n * operation kind. In any case, the effect of the field mask is\n * required to be honored by the API.\n *\n * ## Considerations for HTTP REST\n *\n * The HTTP kind of an update operation which uses a field mask must\n * be set to PATCH instead of PUT in order to satisfy HTTP semantics\n * (PUT must only be used for full updates).\n *\n * # JSON Encoding of Field Masks\n *\n * In JSON, a field mask is encoded as a single string where paths are\n * separated by a comma. Fields name in each path are converted\n * to/from lower-camel naming conventions.\n *\n * As an example, consider the following message declarations:\n *\n *     message Profile {\n *       User user = 1;\n *       Photo photo = 2;\n *     }\n *     message User {\n *       string display_name = 1;\n *       string address = 2;\n *     }\n *\n * In proto a field mask for `Profile` may look as such:\n *\n *     mask {\n *       paths: \"user.display_name\"\n *       paths: \"photo\"\n *     }\n *\n * In JSON, the same mask is represented as below:\n *\n *     {\n *       mask: \"user.displayName,photo\"\n *     }\n *\n * # Field Masks and Oneof Fields\n *\n * Field masks treat fields in oneofs just as regular fields. Consider the\n * following message:\n *\n *     message SampleMessage {\n *       oneof test_oneof {\n *         string name = 4;\n *         SubMessage sub_message = 9;\n *       }\n *     }\n *\n * The field mask can be:\n *\n *     mask {\n *       paths: \"name\"\n *     }\n *\n * Or:\n *\n *     mask {\n *       paths: \"sub_message\"\n *     }\n *\n * Note that oneof type names (\"test_oneof\" in this case) cannot be used in\n * paths.\n *\n * ## Field Mask Verification\n *\n * The implementation of any API method which has a FieldMask type field in the\n * request should verify the included field paths, and return an\n * `INVALID_ARGUMENT` error if any path is unmappable.\n *\n * @generated from message google.protobuf.FieldMask\n */\nclass FieldMask extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The set of field mask paths.\n         *\n         * @generated from field: repeated string paths = 1;\n         */\n        this.paths = [];\n        proto3/* proto3 */.w.util.initPartial(data, this);\n    }\n    toJson(options) {\n        // Converts snake_case to protoCamelCase according to the convention\n        // used by protoc to convert a field name to a JSON name.\n        function protoCamelCase(snakeCase) {\n            let capNext = false;\n            const b = [];\n            for (let i = 0; i < snakeCase.length; i++) {\n                let c = snakeCase.charAt(i);\n                switch (c) {\n                    case '_':\n                        capNext = true;\n                        break;\n                    case '0':\n                    case '1':\n                    case '2':\n                    case '3':\n                    case '4':\n                    case '5':\n                    case '6':\n                    case '7':\n                    case '8':\n                    case '9':\n                        b.push(c);\n                        capNext = false;\n                        break;\n                    default:\n                        if (capNext) {\n                            capNext = false;\n                            c = c.toUpperCase();\n                        }\n                        b.push(c);\n                        break;\n                }\n            }\n            return b.join('');\n        }\n        return this.paths.map(p => {\n            if (p.match(/_[0-9]?_/g) || p.match(/[A-Z]/g)) {\n                throw new Error(\"cannot encode google.protobuf.FieldMask to JSON: lowerCamelCase of path name \\\"\" + p + \"\\\" is irreversible\");\n            }\n            return protoCamelCase(p);\n        }).join(\",\");\n    }\n    fromJson(json, options) {\n        if (typeof json !== \"string\") {\n            throw new Error(\"cannot decode google.protobuf.FieldMask from JSON: \" + proto3/* proto3 */.w.json.debug(json));\n        }\n        if (json === \"\") {\n            return this;\n        }\n        function camelToSnake(str) {\n            if (str.includes(\"_\")) {\n                throw new Error(\"cannot decode google.protobuf.FieldMask from JSON: path names must be lowerCamelCase\");\n            }\n            const sc = str.replace(/[A-Z]/g, letter => \"_\" + letter.toLowerCase());\n            return (sc[0] === \"_\") ? sc.substring(1) : sc;\n        }\n        this.paths = json.split(\",\").map(camelToSnake);\n        return this;\n    }\n    static fromBinary(bytes, options) {\n        return new FieldMask().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new FieldMask().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new FieldMask().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3/* proto3 */.w.util.equals(FieldMask, a, b);\n    }\n}\nFieldMask.runtime = proto3/* proto3 */.w;\nFieldMask.typeName = \"google.protobuf.FieldMask\";\nFieldMask.fields = proto3/* proto3 */.w.util.newFieldList(() => [\n    { no: 1, name: \"paths\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, repeated: true },\n]);\n\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/struct_pb.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// @generated by protoc-gen-es v1.6.0 with parameter \"bootstrap_wkt=true,ts_nocheck=false,target=ts\"\n// @generated from file google/protobuf/struct.proto (package google.protobuf, syntax proto3)\n/* eslint-disable */\n\n\n/**\n * `NullValue` is a singleton enumeration to represent the null value for the\n * `Value` type union.\n *\n * The JSON representation for `NullValue` is JSON `null`.\n *\n * @generated from enum google.protobuf.NullValue\n */\nvar NullValue;\n(function (NullValue) {\n    /**\n     * Null value.\n     *\n     * @generated from enum value: NULL_VALUE = 0;\n     */\n    NullValue[NullValue[\"NULL_VALUE\"] = 0] = \"NULL_VALUE\";\n})(NullValue || (NullValue = {}));\n// Retrieve enum metadata with: proto3.getEnumType(NullValue)\nproto3/* proto3 */.w.util.setEnumType(NullValue, \"google.protobuf.NullValue\", [\n    { no: 0, name: \"NULL_VALUE\" },\n]);\n/**\n * `Struct` represents a structured data value, consisting of fields\n * which map to dynamically typed values. In some languages, `Struct`\n * might be supported by a native representation. For example, in\n * scripting languages like JS a struct is represented as an\n * object. The details of that representation are described together\n * with the proto support for the language.\n *\n * The JSON representation for `Struct` is JSON object.\n *\n * @generated from message google.protobuf.Struct\n */\nclass Struct extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * Unordered map of dynamically typed values.\n         *\n         * @generated from field: map<string, google.protobuf.Value> fields = 1;\n         */\n        this.fields = {};\n        proto3/* proto3 */.w.util.initPartial(data, this);\n    }\n    toJson(options) {\n        const json = {};\n        for (const [k, v] of Object.entries(this.fields)) {\n            json[k] = v.toJson(options);\n        }\n        return json;\n    }\n    fromJson(json, options) {\n        if (typeof json != \"object\" || json == null || Array.isArray(json)) {\n            throw new Error(\"cannot decode google.protobuf.Struct from JSON \" + proto3/* proto3 */.w.json.debug(json));\n        }\n        for (const [k, v] of Object.entries(json)) {\n            this.fields[k] = Value.fromJson(v);\n        }\n        return this;\n    }\n    static fromBinary(bytes, options) {\n        return new Struct().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Struct().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Struct().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3/* proto3 */.w.util.equals(Struct, a, b);\n    }\n}\nStruct.runtime = proto3/* proto3 */.w;\nStruct.typeName = \"google.protobuf.Struct\";\nStruct.fields = proto3/* proto3 */.w.util.newFieldList(() => [\n    { no: 1, name: \"fields\", kind: \"map\", K: 9 /* ScalarType.STRING */, V: { kind: \"message\", T: Value } },\n]);\n/**\n * `Value` represents a dynamically typed value which can be either\n * null, a number, a string, a boolean, a recursive struct value, or a\n * list of values. A producer of value is expected to set one of these\n * variants. Absence of any variant indicates an error.\n *\n * The JSON representation for `Value` is JSON value.\n *\n * @generated from message google.protobuf.Value\n */\nclass Value extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The kind of value.\n         *\n         * @generated from oneof google.protobuf.Value.kind\n         */\n        this.kind = { case: undefined };\n        proto3/* proto3 */.w.util.initPartial(data, this);\n    }\n    toJson(options) {\n        switch (this.kind.case) {\n            case \"nullValue\":\n                return null;\n            case \"numberValue\":\n                if (!Number.isFinite(this.kind.value)) {\n                    throw new Error(\"google.protobuf.Value cannot be NaN or Infinity\");\n                }\n                return this.kind.value;\n            case \"boolValue\":\n                return this.kind.value;\n            case \"stringValue\":\n                return this.kind.value;\n            case \"structValue\":\n            case \"listValue\":\n                return this.kind.value.toJson(Object.assign(Object.assign({}, options), { emitDefaultValues: true }));\n        }\n        throw new Error(\"google.protobuf.Value must have a value\");\n    }\n    fromJson(json, options) {\n        switch (typeof json) {\n            case \"number\":\n                this.kind = { case: \"numberValue\", value: json };\n                break;\n            case \"string\":\n                this.kind = { case: \"stringValue\", value: json };\n                break;\n            case \"boolean\":\n                this.kind = { case: \"boolValue\", value: json };\n                break;\n            case \"object\":\n                if (json === null) {\n                    this.kind = { case: \"nullValue\", value: NullValue.NULL_VALUE };\n                }\n                else if (Array.isArray(json)) {\n                    this.kind = { case: \"listValue\", value: ListValue.fromJson(json) };\n                }\n                else {\n                    this.kind = { case: \"structValue\", value: Struct.fromJson(json) };\n                }\n                break;\n            default:\n                throw new Error(\"cannot decode google.protobuf.Value from JSON \" + proto3/* proto3 */.w.json.debug(json));\n        }\n        return this;\n    }\n    static fromBinary(bytes, options) {\n        return new Value().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Value().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Value().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3/* proto3 */.w.util.equals(Value, a, b);\n    }\n}\nValue.runtime = proto3/* proto3 */.w;\nValue.typeName = \"google.protobuf.Value\";\nValue.fields = proto3/* proto3 */.w.util.newFieldList(() => [\n    { no: 1, name: \"null_value\", kind: \"enum\", T: proto3/* proto3 */.w.getEnumType(NullValue), oneof: \"kind\" },\n    { no: 2, name: \"number_value\", kind: \"scalar\", T: 1 /* ScalarType.DOUBLE */, oneof: \"kind\" },\n    { no: 3, name: \"string_value\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, oneof: \"kind\" },\n    { no: 4, name: \"bool_value\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, oneof: \"kind\" },\n    { no: 5, name: \"struct_value\", kind: \"message\", T: Struct, oneof: \"kind\" },\n    { no: 6, name: \"list_value\", kind: \"message\", T: ListValue, oneof: \"kind\" },\n]);\n/**\n * `ListValue` is a wrapper around a repeated field of values.\n *\n * The JSON representation for `ListValue` is JSON array.\n *\n * @generated from message google.protobuf.ListValue\n */\nclass ListValue extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * Repeated field of dynamically typed values.\n         *\n         * @generated from field: repeated google.protobuf.Value values = 1;\n         */\n        this.values = [];\n        proto3/* proto3 */.w.util.initPartial(data, this);\n    }\n    toJson(options) {\n        return this.values.map(v => v.toJson());\n    }\n    fromJson(json, options) {\n        if (!Array.isArray(json)) {\n            throw new Error(\"cannot decode google.protobuf.ListValue from JSON \" + proto3/* proto3 */.w.json.debug(json));\n        }\n        for (let e of json) {\n            this.values.push(Value.fromJson(e));\n        }\n        return this;\n    }\n    static fromBinary(bytes, options) {\n        return new ListValue().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ListValue().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ListValue().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3/* proto3 */.w.util.equals(ListValue, a, b);\n    }\n}\nListValue.runtime = proto3/* proto3 */.w;\nListValue.typeName = \"google.protobuf.ListValue\";\nListValue.fields = proto3/* proto3 */.w.util.newFieldList(() => [\n    { no: 1, name: \"values\", kind: \"message\", T: Value, repeated: true },\n]);\n\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/enum.js\nvar private_enum = __nested_webpack_require_80292__(609);\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/wrappers_pb.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n\n/**\n * Wrapper message for `double`.\n *\n * The JSON representation for `DoubleValue` is JSON number.\n *\n * @generated from message google.protobuf.DoubleValue\n */\nclass DoubleValue extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The double value.\n         *\n         * @generated from field: double value = 1;\n         */\n        this.value = 0;\n        proto3/* proto3 */.w.util.initPartial(data, this);\n    }\n    toJson(options) {\n        return proto3/* proto3 */.w.json.writeScalar(esm_field/* ScalarType */.w.DOUBLE, this.value, true);\n    }\n    fromJson(json, options) {\n        try {\n            this.value = proto3/* proto3 */.w.json.readScalar(esm_field/* ScalarType */.w.DOUBLE, json);\n        }\n        catch (e) {\n            let m = `cannot decode message google.protobuf.DoubleValue from JSON\"`;\n            if (e instanceof Error && e.message.length > 0) {\n                m += `: ${e.message}`;\n            }\n            throw new Error(m);\n        }\n        return this;\n    }\n    static fromBinary(bytes, options) {\n        return new DoubleValue().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new DoubleValue().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new DoubleValue().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3/* proto3 */.w.util.equals(DoubleValue, a, b);\n    }\n}\nDoubleValue.runtime = proto3/* proto3 */.w;\nDoubleValue.typeName = \"google.protobuf.DoubleValue\";\nDoubleValue.fields = proto3/* proto3 */.w.util.newFieldList(() => [\n    { no: 1, name: \"value\", kind: \"scalar\", T: 1 /* ScalarType.DOUBLE */ },\n]);\nDoubleValue.fieldWrapper = {\n    wrapField(value) {\n        return new DoubleValue({ value });\n    },\n    unwrapField(value) {\n        return value.value;\n    }\n};\n/**\n * Wrapper message for `float`.\n *\n * The JSON representation for `FloatValue` is JSON number.\n *\n * @generated from message google.protobuf.FloatValue\n */\nclass FloatValue extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The float value.\n         *\n         * @generated from field: float value = 1;\n         */\n        this.value = 0;\n        proto3/* proto3 */.w.util.initPartial(data, this);\n    }\n    toJson(options) {\n        return proto3/* proto3 */.w.json.writeScalar(esm_field/* ScalarType */.w.FLOAT, this.value, true);\n    }\n    fromJson(json, options) {\n        try {\n            this.value = proto3/* proto3 */.w.json.readScalar(esm_field/* ScalarType */.w.FLOAT, json);\n        }\n        catch (e) {\n            let m = `cannot decode message google.protobuf.FloatValue from JSON\"`;\n            if (e instanceof Error && e.message.length > 0) {\n                m += `: ${e.message}`;\n            }\n            throw new Error(m);\n        }\n        return this;\n    }\n    static fromBinary(bytes, options) {\n        return new FloatValue().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new FloatValue().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new FloatValue().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3/* proto3 */.w.util.equals(FloatValue, a, b);\n    }\n}\nFloatValue.runtime = proto3/* proto3 */.w;\nFloatValue.typeName = \"google.protobuf.FloatValue\";\nFloatValue.fields = proto3/* proto3 */.w.util.newFieldList(() => [\n    { no: 1, name: \"value\", kind: \"scalar\", T: 2 /* ScalarType.FLOAT */ },\n]);\nFloatValue.fieldWrapper = {\n    wrapField(value) {\n        return new FloatValue({ value });\n    },\n    unwrapField(value) {\n        return value.value;\n    }\n};\n/**\n * Wrapper message for `int64`.\n *\n * The JSON representation for `Int64Value` is JSON string.\n *\n * @generated from message google.protobuf.Int64Value\n */\nclass Int64Value extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The int64 value.\n         *\n         * @generated from field: int64 value = 1;\n         */\n        this.value = proto_int64/* protoInt64 */.q.zero;\n        proto3/* proto3 */.w.util.initPartial(data, this);\n    }\n    toJson(options) {\n        return proto3/* proto3 */.w.json.writeScalar(esm_field/* ScalarType */.w.INT64, this.value, true);\n    }\n    fromJson(json, options) {\n        try {\n            this.value = proto3/* proto3 */.w.json.readScalar(esm_field/* ScalarType */.w.INT64, json);\n        }\n        catch (e) {\n            let m = `cannot decode message google.protobuf.Int64Value from JSON\"`;\n            if (e instanceof Error && e.message.length > 0) {\n                m += `: ${e.message}`;\n            }\n            throw new Error(m);\n        }\n        return this;\n    }\n    static fromBinary(bytes, options) {\n        return new Int64Value().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Int64Value().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Int64Value().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3/* proto3 */.w.util.equals(Int64Value, a, b);\n    }\n}\nInt64Value.runtime = proto3/* proto3 */.w;\nInt64Value.typeName = \"google.protobuf.Int64Value\";\nInt64Value.fields = proto3/* proto3 */.w.util.newFieldList(() => [\n    { no: 1, name: \"value\", kind: \"scalar\", T: 3 /* ScalarType.INT64 */ },\n]);\nInt64Value.fieldWrapper = {\n    wrapField(value) {\n        return new Int64Value({ value });\n    },\n    unwrapField(value) {\n        return value.value;\n    }\n};\n/**\n * Wrapper message for `uint64`.\n *\n * The JSON representation for `UInt64Value` is JSON string.\n *\n * @generated from message google.protobuf.UInt64Value\n */\nclass UInt64Value extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The uint64 value.\n         *\n         * @generated from field: uint64 value = 1;\n         */\n        this.value = proto_int64/* protoInt64 */.q.zero;\n        proto3/* proto3 */.w.util.initPartial(data, this);\n    }\n    toJson(options) {\n        return proto3/* proto3 */.w.json.writeScalar(esm_field/* ScalarType */.w.UINT64, this.value, true);\n    }\n    fromJson(json, options) {\n        try {\n            this.value = proto3/* proto3 */.w.json.readScalar(esm_field/* ScalarType */.w.UINT64, json);\n        }\n        catch (e) {\n            let m = `cannot decode message google.protobuf.UInt64Value from JSON\"`;\n            if (e instanceof Error && e.message.length > 0) {\n                m += `: ${e.message}`;\n            }\n            throw new Error(m);\n        }\n        return this;\n    }\n    static fromBinary(bytes, options) {\n        return new UInt64Value().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UInt64Value().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UInt64Value().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3/* proto3 */.w.util.equals(UInt64Value, a, b);\n    }\n}\nUInt64Value.runtime = proto3/* proto3 */.w;\nUInt64Value.typeName = \"google.protobuf.UInt64Value\";\nUInt64Value.fields = proto3/* proto3 */.w.util.newFieldList(() => [\n    { no: 1, name: \"value\", kind: \"scalar\", T: 4 /* ScalarType.UINT64 */ },\n]);\nUInt64Value.fieldWrapper = {\n    wrapField(value) {\n        return new UInt64Value({ value });\n    },\n    unwrapField(value) {\n        return value.value;\n    }\n};\n/**\n * Wrapper message for `int32`.\n *\n * The JSON representation for `Int32Value` is JSON number.\n *\n * @generated from message google.protobuf.Int32Value\n */\nclass Int32Value extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The int32 value.\n         *\n         * @generated from field: int32 value = 1;\n         */\n        this.value = 0;\n        proto3/* proto3 */.w.util.initPartial(data, this);\n    }\n    toJson(options) {\n        return proto3/* proto3 */.w.json.writeScalar(esm_field/* ScalarType */.w.INT32, this.value, true);\n    }\n    fromJson(json, options) {\n        try {\n            this.value = proto3/* proto3 */.w.json.readScalar(esm_field/* ScalarType */.w.INT32, json);\n        }\n        catch (e) {\n            let m = `cannot decode message google.protobuf.Int32Value from JSON\"`;\n            if (e instanceof Error && e.message.length > 0) {\n                m += `: ${e.message}`;\n            }\n            throw new Error(m);\n        }\n        return this;\n    }\n    static fromBinary(bytes, options) {\n        return new Int32Value().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Int32Value().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Int32Value().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3/* proto3 */.w.util.equals(Int32Value, a, b);\n    }\n}\nInt32Value.runtime = proto3/* proto3 */.w;\nInt32Value.typeName = \"google.protobuf.Int32Value\";\nInt32Value.fields = proto3/* proto3 */.w.util.newFieldList(() => [\n    { no: 1, name: \"value\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */ },\n]);\nInt32Value.fieldWrapper = {\n    wrapField(value) {\n        return new Int32Value({ value });\n    },\n    unwrapField(value) {\n        return value.value;\n    }\n};\n/**\n * Wrapper message for `uint32`.\n *\n * The JSON representation for `UInt32Value` is JSON number.\n *\n * @generated from message google.protobuf.UInt32Value\n */\nclass UInt32Value extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The uint32 value.\n         *\n         * @generated from field: uint32 value = 1;\n         */\n        this.value = 0;\n        proto3/* proto3 */.w.util.initPartial(data, this);\n    }\n    toJson(options) {\n        return proto3/* proto3 */.w.json.writeScalar(esm_field/* ScalarType */.w.UINT32, this.value, true);\n    }\n    fromJson(json, options) {\n        try {\n            this.value = proto3/* proto3 */.w.json.readScalar(esm_field/* ScalarType */.w.UINT32, json);\n        }\n        catch (e) {\n            let m = `cannot decode message google.protobuf.UInt32Value from JSON\"`;\n            if (e instanceof Error && e.message.length > 0) {\n                m += `: ${e.message}`;\n            }\n            throw new Error(m);\n        }\n        return this;\n    }\n    static fromBinary(bytes, options) {\n        return new UInt32Value().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UInt32Value().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UInt32Value().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3/* proto3 */.w.util.equals(UInt32Value, a, b);\n    }\n}\nUInt32Value.runtime = proto3/* proto3 */.w;\nUInt32Value.typeName = \"google.protobuf.UInt32Value\";\nUInt32Value.fields = proto3/* proto3 */.w.util.newFieldList(() => [\n    { no: 1, name: \"value\", kind: \"scalar\", T: 13 /* ScalarType.UINT32 */ },\n]);\nUInt32Value.fieldWrapper = {\n    wrapField(value) {\n        return new UInt32Value({ value });\n    },\n    unwrapField(value) {\n        return value.value;\n    }\n};\n/**\n * Wrapper message for `bool`.\n *\n * The JSON representation for `BoolValue` is JSON `true` and `false`.\n *\n * @generated from message google.protobuf.BoolValue\n */\nclass BoolValue extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The bool value.\n         *\n         * @generated from field: bool value = 1;\n         */\n        this.value = false;\n        proto3/* proto3 */.w.util.initPartial(data, this);\n    }\n    toJson(options) {\n        return proto3/* proto3 */.w.json.writeScalar(esm_field/* ScalarType */.w.BOOL, this.value, true);\n    }\n    fromJson(json, options) {\n        try {\n            this.value = proto3/* proto3 */.w.json.readScalar(esm_field/* ScalarType */.w.BOOL, json);\n        }\n        catch (e) {\n            let m = `cannot decode message google.protobuf.BoolValue from JSON\"`;\n            if (e instanceof Error && e.message.length > 0) {\n                m += `: ${e.message}`;\n            }\n            throw new Error(m);\n        }\n        return this;\n    }\n    static fromBinary(bytes, options) {\n        return new BoolValue().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new BoolValue().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new BoolValue().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3/* proto3 */.w.util.equals(BoolValue, a, b);\n    }\n}\nBoolValue.runtime = proto3/* proto3 */.w;\nBoolValue.typeName = \"google.protobuf.BoolValue\";\nBoolValue.fields = proto3/* proto3 */.w.util.newFieldList(() => [\n    { no: 1, name: \"value\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */ },\n]);\nBoolValue.fieldWrapper = {\n    wrapField(value) {\n        return new BoolValue({ value });\n    },\n    unwrapField(value) {\n        return value.value;\n    }\n};\n/**\n * Wrapper message for `string`.\n *\n * The JSON representation for `StringValue` is JSON string.\n *\n * @generated from message google.protobuf.StringValue\n */\nclass StringValue extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The string value.\n         *\n         * @generated from field: string value = 1;\n         */\n        this.value = \"\";\n        proto3/* proto3 */.w.util.initPartial(data, this);\n    }\n    toJson(options) {\n        return proto3/* proto3 */.w.json.writeScalar(esm_field/* ScalarType */.w.STRING, this.value, true);\n    }\n    fromJson(json, options) {\n        try {\n            this.value = proto3/* proto3 */.w.json.readScalar(esm_field/* ScalarType */.w.STRING, json);\n        }\n        catch (e) {\n            let m = `cannot decode message google.protobuf.StringValue from JSON\"`;\n            if (e instanceof Error && e.message.length > 0) {\n                m += `: ${e.message}`;\n            }\n            throw new Error(m);\n        }\n        return this;\n    }\n    static fromBinary(bytes, options) {\n        return new StringValue().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new StringValue().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new StringValue().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3/* proto3 */.w.util.equals(StringValue, a, b);\n    }\n}\nStringValue.runtime = proto3/* proto3 */.w;\nStringValue.typeName = \"google.protobuf.StringValue\";\nStringValue.fields = proto3/* proto3 */.w.util.newFieldList(() => [\n    { no: 1, name: \"value\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n]);\nStringValue.fieldWrapper = {\n    wrapField(value) {\n        return new StringValue({ value });\n    },\n    unwrapField(value) {\n        return value.value;\n    }\n};\n/**\n * Wrapper message for `bytes`.\n *\n * The JSON representation for `BytesValue` is JSON string.\n *\n * @generated from message google.protobuf.BytesValue\n */\nclass BytesValue extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The bytes value.\n         *\n         * @generated from field: bytes value = 1;\n         */\n        this.value = new Uint8Array(0);\n        proto3/* proto3 */.w.util.initPartial(data, this);\n    }\n    toJson(options) {\n        return proto3/* proto3 */.w.json.writeScalar(esm_field/* ScalarType */.w.BYTES, this.value, true);\n    }\n    fromJson(json, options) {\n        try {\n            this.value = proto3/* proto3 */.w.json.readScalar(esm_field/* ScalarType */.w.BYTES, json);\n        }\n        catch (e) {\n            let m = `cannot decode message google.protobuf.BytesValue from JSON\"`;\n            if (e instanceof Error && e.message.length > 0) {\n                m += `: ${e.message}`;\n            }\n            throw new Error(m);\n        }\n        return this;\n    }\n    static fromBinary(bytes, options) {\n        return new BytesValue().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new BytesValue().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new BytesValue().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3/* proto3 */.w.util.equals(BytesValue, a, b);\n    }\n}\nBytesValue.runtime = proto3/* proto3 */.w;\nBytesValue.typeName = \"google.protobuf.BytesValue\";\nBytesValue.fields = proto3/* proto3 */.w.util.newFieldList(() => [\n    { no: 1, name: \"value\", kind: \"scalar\", T: 12 /* ScalarType.BYTES */ },\n]);\nBytesValue.fieldWrapper = {\n    wrapField(value) {\n        return new BytesValue({ value });\n    },\n    unwrapField(value) {\n        return value.value;\n    }\n};\n\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/create-registry-from-desc.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// well-known message types with specialized JSON representation\nconst wkMessages = [\n    any_pb/* Any */.I,\n    Duration,\n    Empty,\n    FieldMask,\n    Struct,\n    Value,\n    ListValue,\n    Timestamp,\n    Duration,\n    DoubleValue,\n    FloatValue,\n    Int64Value,\n    Int32Value,\n    UInt32Value,\n    UInt64Value,\n    BoolValue,\n    StringValue,\n    BytesValue,\n];\n// well-known enum types with specialized JSON representation\nconst wkEnums = [(0,private_enum/* getEnumType */.V3)(NullValue)];\n/**\n * Create a registry from a set of descriptors. The types returned by this\n * registry behave exactly like types from generated code.\n *\n * This function accepts google.protobuf.FileDescriptorSet in serialized or\n * deserialized form. Alternatively, it also accepts a DescriptorSet (see\n * createDescriptorSet()).\n *\n * By default, all well-known types with a specialized JSON representation\n * are replaced with their generated counterpart in this package.\n */\nfunction createRegistryFromDescriptors(input, replaceWkt = true) {\n    const set = input instanceof Uint8Array || input instanceof FileDescriptorSet\n        ? createDescriptorSet(input)\n        : input;\n    const enums = {};\n    const messages = {};\n    const services = {};\n    if (replaceWkt) {\n        for (const mt of wkMessages) {\n            messages[mt.typeName] = mt;\n        }\n        for (const et of wkEnums) {\n            enums[et.typeName] = et;\n        }\n    }\n    return {\n        /**\n         * May raise an error on invalid descriptors.\n         */\n        findEnum(typeName) {\n            const existing = enums[typeName];\n            if (existing) {\n                return existing;\n            }\n            const desc = set.enums.get(typeName);\n            if (!desc) {\n                return undefined;\n            }\n            const runtime = desc.file.syntax == \"proto3\" ? proto3/* proto3 */.w : proto2;\n            const type = runtime.makeEnumType(typeName, desc.values.map((u) => ({\n                no: u.number,\n                name: u.name,\n                localName: (0,names/* localName */.r1)(u),\n            })), {});\n            enums[typeName] = type;\n            return type;\n        },\n        /**\n         * May raise an error on invalid descriptors.\n         */\n        findMessage(typeName) {\n            const existing = messages[typeName];\n            if (existing) {\n                return existing;\n            }\n            const desc = set.messages.get(typeName);\n            if (!desc) {\n                return undefined;\n            }\n            const runtime = desc.file.syntax == \"proto3\" ? proto3/* proto3 */.w : proto2;\n            const fields = [];\n            const type = runtime.makeMessageType(typeName, () => fields, {\n                localName: (0,names/* localName */.r1)(desc),\n            });\n            messages[typeName] = type;\n            for (const field of desc.fields) {\n                const fieldInfo = makeFieldInfo(field, this);\n                fields.push(fieldInfo);\n            }\n            return type;\n        },\n        /**\n         * May raise an error on invalid descriptors.\n         */\n        findService(typeName) {\n            const existing = services[typeName];\n            if (existing) {\n                return existing;\n            }\n            const desc = set.services.get(typeName);\n            if (!desc) {\n                return undefined;\n            }\n            const methods = {};\n            for (const method of desc.methods) {\n                const I = this.findMessage(method.input.typeName);\n                const O = this.findMessage(method.output.typeName);\n                (0,assert/* assert */.hu)(I, `message \"${method.input.typeName}\" for ${method.toString()} not found`);\n                (0,assert/* assert */.hu)(O, `output message \"${method.output.typeName}\" for ${method.toString()} not found`);\n                methods[(0,names/* localName */.r1)(method)] = {\n                    name: method.name,\n                    I,\n                    O,\n                    kind: method.methodKind,\n                    idempotency: method.idempotency,\n                    // We do not surface options at this time\n                    // options: {},\n                };\n            }\n            return (services[typeName] = {\n                typeName: desc.typeName,\n                methods,\n            });\n        },\n    };\n}\nfunction makeFieldInfo(desc, resolver) {\n    switch (desc.fieldKind) {\n        case \"map\":\n            return makeMapFieldInfo(desc, resolver);\n        case \"message\":\n            return makeMessageFieldInfo(desc, resolver);\n        case \"enum\": {\n            const fi = makeEnumFieldInfo(desc, resolver);\n            fi.default = desc.getDefaultValue();\n            return fi;\n        }\n        case \"scalar\": {\n            const fi = makeScalarFieldInfo(desc);\n            fi.default = desc.getDefaultValue();\n            return fi;\n        }\n    }\n}\nfunction makeMapFieldInfo(field, resolver) {\n    const base = {\n        kind: \"map\",\n        no: field.number,\n        name: field.name,\n        jsonName: field.jsonName,\n        K: field.mapKey,\n    };\n    if (field.mapValue.message) {\n        const messageType = resolver.findMessage(field.mapValue.message.typeName);\n        (0,assert/* assert */.hu)(messageType, `message \"${field.mapValue.message.typeName}\" for ${field.toString()} not found`);\n        return Object.assign(Object.assign({}, base), { V: {\n                kind: \"message\",\n                T: messageType,\n            } });\n    }\n    if (field.mapValue.enum) {\n        const enumType = resolver.findEnum(field.mapValue.enum.typeName);\n        (0,assert/* assert */.hu)(enumType, `enum \"${field.mapValue.enum.typeName}\" for ${field.toString()} not found`);\n        return Object.assign(Object.assign({}, base), { V: {\n                kind: \"enum\",\n                T: enumType,\n            } });\n    }\n    return Object.assign(Object.assign({}, base), { V: {\n            kind: \"scalar\",\n            T: field.mapValue.scalar,\n        } });\n}\nfunction makeScalarFieldInfo(field) {\n    // We are creating _partial_ field info here, so we omit long type bigint,\n    // which is the default.\n    const longType = field.longType == esm_field/* LongType */.p.STRING\n        ? { L: esm_field/* LongType */.p.STRING }\n        : {};\n    const base = Object.assign({ kind: \"scalar\", no: field.number, name: field.name, jsonName: field.jsonName, T: field.scalar }, longType);\n    if (field.repeated) {\n        return Object.assign(Object.assign({}, base), { repeated: true, packed: field.packed, oneof: undefined, T: field.scalar });\n    }\n    if (field.oneof) {\n        return Object.assign(Object.assign({}, base), { oneof: field.oneof.name });\n    }\n    if (field.optional) {\n        return Object.assign(Object.assign({}, base), { opt: true });\n    }\n    return base;\n}\nfunction makeMessageFieldInfo(field, resolver) {\n    const messageType = resolver.findMessage(field.message.typeName);\n    (0,assert/* assert */.hu)(messageType, `message \"${field.message.typeName}\" for ${field.toString()} not found`);\n    const base = {\n        kind: \"message\",\n        no: field.number,\n        name: field.name,\n        jsonName: field.jsonName,\n        T: messageType,\n        delimited: field.proto.type == FieldDescriptorProto_Type.GROUP,\n    };\n    if (field.repeated) {\n        return Object.assign(Object.assign({}, base), { repeated: true, packed: field.packed, oneof: undefined });\n    }\n    if (field.oneof) {\n        return Object.assign(Object.assign({}, base), { oneof: field.oneof.name });\n    }\n    if (field.optional) {\n        return Object.assign(Object.assign({}, base), { opt: true });\n    }\n    return base;\n}\nfunction makeEnumFieldInfo(field, resolver) {\n    const enumType = resolver.findEnum(field.enum.typeName);\n    (0,assert/* assert */.hu)(enumType, `enum \"${field.enum.typeName}\" for ${field.toString()} not found`);\n    const base = {\n        kind: \"enum\",\n        no: field.number,\n        name: field.name,\n        jsonName: field.jsonName,\n        T: enumType,\n    };\n    if (field.repeated) {\n        return Object.assign(Object.assign({}, base), { repeated: true, packed: field.packed, oneof: undefined });\n    }\n    if (field.oneof) {\n        return Object.assign(Object.assign({}, base), { oneof: field.oneof.name });\n    }\n    if (field.optional) {\n        return Object.assign(Object.assign({}, base), { opt: true });\n    }\n    return base;\n}\n\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/to-plain-message.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-argument,no-case-declarations */\n\n/**\n * toPlainMessage returns a new object by stripping\n * all methods from a message, leaving only fields and\n * oneof groups. It is recursive, meaning it applies this\n * same logic to all nested message fields as well.\n *\n * If the argument is already a plain message, it is\n * returned as-is.\n */\nfunction toPlainMessage(message) {\n    if (!(message instanceof esm_message/* Message */.v)) {\n        return message;\n    }\n    const type = message.getType();\n    const target = {};\n    for (const member of type.fields.byMember()) {\n        const source = message[member.localName];\n        let copy;\n        if (member.repeated) {\n            copy = source.map((e) => toPlainValue(e));\n        }\n        else if (member.kind == \"map\") {\n            copy = {};\n            for (const [key, v] of Object.entries(source)) {\n                copy[key] = toPlainValue(v);\n            }\n        }\n        else if (member.kind == \"oneof\") {\n            const f = member.findField(source.case);\n            copy = f\n                ? { case: source.case, value: toPlainValue(source.value) }\n                : { case: undefined };\n        }\n        else {\n            copy = toPlainValue(source);\n        }\n        target[member.localName] = copy;\n    }\n    return target;\n}\nfunction toPlainValue(value) {\n    if (value === undefined) {\n        return value;\n    }\n    if (value instanceof esm_message/* Message */.v) {\n        return toPlainMessage(value);\n    }\n    if (value instanceof Uint8Array) {\n        const c = new Uint8Array(value.byteLength);\n        c.set(value);\n        return c;\n    }\n    return value;\n}\n\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/compiler/plugin_pb.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n/**\n * The version number of protocol compiler.\n *\n * @generated from message google.protobuf.compiler.Version\n */\nclass Version extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Version().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Version().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Version().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(Version, a, b);\n    }\n}\nVersion.runtime = proto2;\nVersion.typeName = \"google.protobuf.compiler.Version\";\nVersion.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"major\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, opt: true },\n    { no: 2, name: \"minor\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, opt: true },\n    { no: 3, name: \"patch\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, opt: true },\n    { no: 4, name: \"suffix\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n]);\n/**\n * An encoded CodeGeneratorRequest is written to the plugin's stdin.\n *\n * @generated from message google.protobuf.compiler.CodeGeneratorRequest\n */\nclass CodeGeneratorRequest extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The .proto files that were explicitly listed on the command-line.  The\n         * code generator should generate code only for these files.  Each file's\n         * descriptor will be included in proto_file, below.\n         *\n         * @generated from field: repeated string file_to_generate = 1;\n         */\n        this.fileToGenerate = [];\n        /**\n         * FileDescriptorProtos for all files in files_to_generate and everything\n         * they import.  The files will appear in topological order, so each file\n         * appears before any file that imports it.\n         *\n         * Note: the files listed in files_to_generate will include runtime-retention\n         * options only, but all other files will include source-retention options.\n         * The source_file_descriptors field below is available in case you need\n         * source-retention options for files_to_generate.\n         *\n         * protoc guarantees that all proto_files will be written after\n         * the fields above, even though this is not technically guaranteed by the\n         * protobuf wire format.  This theoretically could allow a plugin to stream\n         * in the FileDescriptorProtos and handle them one by one rather than read\n         * the entire set into memory at once.  However, as of this writing, this\n         * is not similarly optimized on protoc's end -- it will store all fields in\n         * memory at once before sending them to the plugin.\n         *\n         * Type names of fields and extensions in the FileDescriptorProto are always\n         * fully qualified.\n         *\n         * @generated from field: repeated google.protobuf.FileDescriptorProto proto_file = 15;\n         */\n        this.protoFile = [];\n        /**\n         * File descriptors with all options, including source-retention options.\n         * These descriptors are only provided for the files listed in\n         * files_to_generate.\n         *\n         * @generated from field: repeated google.protobuf.FileDescriptorProto source_file_descriptors = 17;\n         */\n        this.sourceFileDescriptors = [];\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new CodeGeneratorRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new CodeGeneratorRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new CodeGeneratorRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(CodeGeneratorRequest, a, b);\n    }\n}\nCodeGeneratorRequest.runtime = proto2;\nCodeGeneratorRequest.typeName = \"google.protobuf.compiler.CodeGeneratorRequest\";\nCodeGeneratorRequest.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"file_to_generate\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, repeated: true },\n    { no: 2, name: \"parameter\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 15, name: \"proto_file\", kind: \"message\", T: FileDescriptorProto, repeated: true },\n    { no: 17, name: \"source_file_descriptors\", kind: \"message\", T: FileDescriptorProto, repeated: true },\n    { no: 3, name: \"compiler_version\", kind: \"message\", T: Version, opt: true },\n]);\n/**\n * The plugin writes an encoded CodeGeneratorResponse to stdout.\n *\n * @generated from message google.protobuf.compiler.CodeGeneratorResponse\n */\nclass CodeGeneratorResponse extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * @generated from field: repeated google.protobuf.compiler.CodeGeneratorResponse.File file = 15;\n         */\n        this.file = [];\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new CodeGeneratorResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new CodeGeneratorResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new CodeGeneratorResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(CodeGeneratorResponse, a, b);\n    }\n}\nCodeGeneratorResponse.runtime = proto2;\nCodeGeneratorResponse.typeName = \"google.protobuf.compiler.CodeGeneratorResponse\";\nCodeGeneratorResponse.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"error\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 2, name: \"supported_features\", kind: \"scalar\", T: 4 /* ScalarType.UINT64 */, opt: true },\n    { no: 15, name: \"file\", kind: \"message\", T: CodeGeneratorResponse_File, repeated: true },\n]);\n/**\n * Sync with code_generator.h.\n *\n * @generated from enum google.protobuf.compiler.CodeGeneratorResponse.Feature\n */\nvar CodeGeneratorResponse_Feature;\n(function (CodeGeneratorResponse_Feature) {\n    /**\n     * @generated from enum value: FEATURE_NONE = 0;\n     */\n    CodeGeneratorResponse_Feature[CodeGeneratorResponse_Feature[\"NONE\"] = 0] = \"NONE\";\n    /**\n     * @generated from enum value: FEATURE_PROTO3_OPTIONAL = 1;\n     */\n    CodeGeneratorResponse_Feature[CodeGeneratorResponse_Feature[\"PROTO3_OPTIONAL\"] = 1] = \"PROTO3_OPTIONAL\";\n    /**\n     * @generated from enum value: FEATURE_SUPPORTS_EDITIONS = 2;\n     */\n    CodeGeneratorResponse_Feature[CodeGeneratorResponse_Feature[\"SUPPORTS_EDITIONS\"] = 2] = \"SUPPORTS_EDITIONS\";\n})(CodeGeneratorResponse_Feature || (CodeGeneratorResponse_Feature = {}));\n// Retrieve enum metadata with: proto2.getEnumType(CodeGeneratorResponse_Feature)\nproto2.util.setEnumType(CodeGeneratorResponse_Feature, \"google.protobuf.compiler.CodeGeneratorResponse.Feature\", [\n    { no: 0, name: \"FEATURE_NONE\" },\n    { no: 1, name: \"FEATURE_PROTO3_OPTIONAL\" },\n    { no: 2, name: \"FEATURE_SUPPORTS_EDITIONS\" },\n]);\n/**\n * Represents a single generated file.\n *\n * @generated from message google.protobuf.compiler.CodeGeneratorResponse.File\n */\nclass CodeGeneratorResponse_File extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        proto2.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new CodeGeneratorResponse_File().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new CodeGeneratorResponse_File().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new CodeGeneratorResponse_File().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto2.util.equals(CodeGeneratorResponse_File, a, b);\n    }\n}\nCodeGeneratorResponse_File.runtime = proto2;\nCodeGeneratorResponse_File.typeName = \"google.protobuf.compiler.CodeGeneratorResponse.File\";\nCodeGeneratorResponse_File.fields = proto2.util.newFieldList(() => [\n    { no: 1, name: \"name\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 2, name: \"insertion_point\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 15, name: \"content\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 16, name: \"generated_code_info\", kind: \"message\", T: GeneratedCodeInfo, opt: true },\n]);\n\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/source_context_pb.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n/**\n * `SourceContext` represents information about the source of a\n * protobuf element, like the file in which it is defined.\n *\n * @generated from message google.protobuf.SourceContext\n */\nclass SourceContext extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The path-qualified name of the .proto file that contained the associated\n         * protobuf element.  For example: `\"google/protobuf/source_context.proto\"`.\n         *\n         * @generated from field: string file_name = 1;\n         */\n        this.fileName = \"\";\n        proto3/* proto3 */.w.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SourceContext().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SourceContext().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SourceContext().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3/* proto3 */.w.util.equals(SourceContext, a, b);\n    }\n}\nSourceContext.runtime = proto3/* proto3 */.w;\nSourceContext.typeName = \"google.protobuf.SourceContext\";\nSourceContext.fields = proto3/* proto3 */.w.util.newFieldList(() => [\n    { no: 1, name: \"file_name\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n]);\n\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/type_pb.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// @generated by protoc-gen-es v1.6.0 with parameter \"bootstrap_wkt=true,ts_nocheck=false,target=ts\"\n// @generated from file google/protobuf/type.proto (package google.protobuf, syntax proto3)\n/* eslint-disable */\n\n\n\n\n/**\n * The syntax in which a protocol buffer element is defined.\n *\n * @generated from enum google.protobuf.Syntax\n */\nvar Syntax;\n(function (Syntax) {\n    /**\n     * Syntax `proto2`.\n     *\n     * @generated from enum value: SYNTAX_PROTO2 = 0;\n     */\n    Syntax[Syntax[\"PROTO2\"] = 0] = \"PROTO2\";\n    /**\n     * Syntax `proto3`.\n     *\n     * @generated from enum value: SYNTAX_PROTO3 = 1;\n     */\n    Syntax[Syntax[\"PROTO3\"] = 1] = \"PROTO3\";\n    /**\n     * Syntax `editions`.\n     *\n     * @generated from enum value: SYNTAX_EDITIONS = 2;\n     */\n    Syntax[Syntax[\"EDITIONS\"] = 2] = \"EDITIONS\";\n})(Syntax || (Syntax = {}));\n// Retrieve enum metadata with: proto3.getEnumType(Syntax)\nproto3/* proto3 */.w.util.setEnumType(Syntax, \"google.protobuf.Syntax\", [\n    { no: 0, name: \"SYNTAX_PROTO2\" },\n    { no: 1, name: \"SYNTAX_PROTO3\" },\n    { no: 2, name: \"SYNTAX_EDITIONS\" },\n]);\n/**\n * A protocol buffer message type.\n *\n * @generated from message google.protobuf.Type\n */\nclass Type extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The fully qualified message name.\n         *\n         * @generated from field: string name = 1;\n         */\n        this.name = \"\";\n        /**\n         * The list of fields.\n         *\n         * @generated from field: repeated google.protobuf.Field fields = 2;\n         */\n        this.fields = [];\n        /**\n         * The list of types appearing in `oneof` definitions in this type.\n         *\n         * @generated from field: repeated string oneofs = 3;\n         */\n        this.oneofs = [];\n        /**\n         * The protocol buffer options.\n         *\n         * @generated from field: repeated google.protobuf.Option options = 4;\n         */\n        this.options = [];\n        /**\n         * The source syntax.\n         *\n         * @generated from field: google.protobuf.Syntax syntax = 6;\n         */\n        this.syntax = Syntax.PROTO2;\n        /**\n         * The source edition string, only valid when syntax is SYNTAX_EDITIONS.\n         *\n         * @generated from field: string edition = 7;\n         */\n        this.edition = \"\";\n        proto3/* proto3 */.w.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Type().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Type().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Type().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3/* proto3 */.w.util.equals(Type, a, b);\n    }\n}\nType.runtime = proto3/* proto3 */.w;\nType.typeName = \"google.protobuf.Type\";\nType.fields = proto3/* proto3 */.w.util.newFieldList(() => [\n    { no: 1, name: \"name\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 2, name: \"fields\", kind: \"message\", T: Field, repeated: true },\n    { no: 3, name: \"oneofs\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, repeated: true },\n    { no: 4, name: \"options\", kind: \"message\", T: Option, repeated: true },\n    { no: 5, name: \"source_context\", kind: \"message\", T: SourceContext },\n    { no: 6, name: \"syntax\", kind: \"enum\", T: proto3/* proto3 */.w.getEnumType(Syntax) },\n    { no: 7, name: \"edition\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n]);\n/**\n * A single field of a message type.\n *\n * @generated from message google.protobuf.Field\n */\nclass Field extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The field type.\n         *\n         * @generated from field: google.protobuf.Field.Kind kind = 1;\n         */\n        this.kind = Field_Kind.TYPE_UNKNOWN;\n        /**\n         * The field cardinality.\n         *\n         * @generated from field: google.protobuf.Field.Cardinality cardinality = 2;\n         */\n        this.cardinality = Field_Cardinality.UNKNOWN;\n        /**\n         * The field number.\n         *\n         * @generated from field: int32 number = 3;\n         */\n        this.number = 0;\n        /**\n         * The field name.\n         *\n         * @generated from field: string name = 4;\n         */\n        this.name = \"\";\n        /**\n         * The field type URL, without the scheme, for message or enumeration\n         * types. Example: `\"type.googleapis.com/google.protobuf.Timestamp\"`.\n         *\n         * @generated from field: string type_url = 6;\n         */\n        this.typeUrl = \"\";\n        /**\n         * The index of the field type in `Type.oneofs`, for message or enumeration\n         * types. The first type has index 1; zero means the type is not in the list.\n         *\n         * @generated from field: int32 oneof_index = 7;\n         */\n        this.oneofIndex = 0;\n        /**\n         * Whether to use alternative packed wire representation.\n         *\n         * @generated from field: bool packed = 8;\n         */\n        this.packed = false;\n        /**\n         * The protocol buffer options.\n         *\n         * @generated from field: repeated google.protobuf.Option options = 9;\n         */\n        this.options = [];\n        /**\n         * The field JSON name.\n         *\n         * @generated from field: string json_name = 10;\n         */\n        this.jsonName = \"\";\n        /**\n         * The string value of the default value of this field. Proto2 syntax only.\n         *\n         * @generated from field: string default_value = 11;\n         */\n        this.defaultValue = \"\";\n        proto3/* proto3 */.w.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Field().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Field().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Field().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3/* proto3 */.w.util.equals(Field, a, b);\n    }\n}\nField.runtime = proto3/* proto3 */.w;\nField.typeName = \"google.protobuf.Field\";\nField.fields = proto3/* proto3 */.w.util.newFieldList(() => [\n    { no: 1, name: \"kind\", kind: \"enum\", T: proto3/* proto3 */.w.getEnumType(Field_Kind) },\n    { no: 2, name: \"cardinality\", kind: \"enum\", T: proto3/* proto3 */.w.getEnumType(Field_Cardinality) },\n    { no: 3, name: \"number\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */ },\n    { no: 4, name: \"name\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 6, name: \"type_url\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 7, name: \"oneof_index\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */ },\n    { no: 8, name: \"packed\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */ },\n    { no: 9, name: \"options\", kind: \"message\", T: Option, repeated: true },\n    { no: 10, name: \"json_name\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 11, name: \"default_value\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n]);\n/**\n * Basic field types.\n *\n * @generated from enum google.protobuf.Field.Kind\n */\nvar Field_Kind;\n(function (Field_Kind) {\n    /**\n     * Field type unknown.\n     *\n     * @generated from enum value: TYPE_UNKNOWN = 0;\n     */\n    Field_Kind[Field_Kind[\"TYPE_UNKNOWN\"] = 0] = \"TYPE_UNKNOWN\";\n    /**\n     * Field type double.\n     *\n     * @generated from enum value: TYPE_DOUBLE = 1;\n     */\n    Field_Kind[Field_Kind[\"TYPE_DOUBLE\"] = 1] = \"TYPE_DOUBLE\";\n    /**\n     * Field type float.\n     *\n     * @generated from enum value: TYPE_FLOAT = 2;\n     */\n    Field_Kind[Field_Kind[\"TYPE_FLOAT\"] = 2] = \"TYPE_FLOAT\";\n    /**\n     * Field type int64.\n     *\n     * @generated from enum value: TYPE_INT64 = 3;\n     */\n    Field_Kind[Field_Kind[\"TYPE_INT64\"] = 3] = \"TYPE_INT64\";\n    /**\n     * Field type uint64.\n     *\n     * @generated from enum value: TYPE_UINT64 = 4;\n     */\n    Field_Kind[Field_Kind[\"TYPE_UINT64\"] = 4] = \"TYPE_UINT64\";\n    /**\n     * Field type int32.\n     *\n     * @generated from enum value: TYPE_INT32 = 5;\n     */\n    Field_Kind[Field_Kind[\"TYPE_INT32\"] = 5] = \"TYPE_INT32\";\n    /**\n     * Field type fixed64.\n     *\n     * @generated from enum value: TYPE_FIXED64 = 6;\n     */\n    Field_Kind[Field_Kind[\"TYPE_FIXED64\"] = 6] = \"TYPE_FIXED64\";\n    /**\n     * Field type fixed32.\n     *\n     * @generated from enum value: TYPE_FIXED32 = 7;\n     */\n    Field_Kind[Field_Kind[\"TYPE_FIXED32\"] = 7] = \"TYPE_FIXED32\";\n    /**\n     * Field type bool.\n     *\n     * @generated from enum value: TYPE_BOOL = 8;\n     */\n    Field_Kind[Field_Kind[\"TYPE_BOOL\"] = 8] = \"TYPE_BOOL\";\n    /**\n     * Field type string.\n     *\n     * @generated from enum value: TYPE_STRING = 9;\n     */\n    Field_Kind[Field_Kind[\"TYPE_STRING\"] = 9] = \"TYPE_STRING\";\n    /**\n     * Field type group. Proto2 syntax only, and deprecated.\n     *\n     * @generated from enum value: TYPE_GROUP = 10;\n     */\n    Field_Kind[Field_Kind[\"TYPE_GROUP\"] = 10] = \"TYPE_GROUP\";\n    /**\n     * Field type message.\n     *\n     * @generated from enum value: TYPE_MESSAGE = 11;\n     */\n    Field_Kind[Field_Kind[\"TYPE_MESSAGE\"] = 11] = \"TYPE_MESSAGE\";\n    /**\n     * Field type bytes.\n     *\n     * @generated from enum value: TYPE_BYTES = 12;\n     */\n    Field_Kind[Field_Kind[\"TYPE_BYTES\"] = 12] = \"TYPE_BYTES\";\n    /**\n     * Field type uint32.\n     *\n     * @generated from enum value: TYPE_UINT32 = 13;\n     */\n    Field_Kind[Field_Kind[\"TYPE_UINT32\"] = 13] = \"TYPE_UINT32\";\n    /**\n     * Field type enum.\n     *\n     * @generated from enum value: TYPE_ENUM = 14;\n     */\n    Field_Kind[Field_Kind[\"TYPE_ENUM\"] = 14] = \"TYPE_ENUM\";\n    /**\n     * Field type sfixed32.\n     *\n     * @generated from enum value: TYPE_SFIXED32 = 15;\n     */\n    Field_Kind[Field_Kind[\"TYPE_SFIXED32\"] = 15] = \"TYPE_SFIXED32\";\n    /**\n     * Field type sfixed64.\n     *\n     * @generated from enum value: TYPE_SFIXED64 = 16;\n     */\n    Field_Kind[Field_Kind[\"TYPE_SFIXED64\"] = 16] = \"TYPE_SFIXED64\";\n    /**\n     * Field type sint32.\n     *\n     * @generated from enum value: TYPE_SINT32 = 17;\n     */\n    Field_Kind[Field_Kind[\"TYPE_SINT32\"] = 17] = \"TYPE_SINT32\";\n    /**\n     * Field type sint64.\n     *\n     * @generated from enum value: TYPE_SINT64 = 18;\n     */\n    Field_Kind[Field_Kind[\"TYPE_SINT64\"] = 18] = \"TYPE_SINT64\";\n})(Field_Kind || (Field_Kind = {}));\n// Retrieve enum metadata with: proto3.getEnumType(Field_Kind)\nproto3/* proto3 */.w.util.setEnumType(Field_Kind, \"google.protobuf.Field.Kind\", [\n    { no: 0, name: \"TYPE_UNKNOWN\" },\n    { no: 1, name: \"TYPE_DOUBLE\" },\n    { no: 2, name: \"TYPE_FLOAT\" },\n    { no: 3, name: \"TYPE_INT64\" },\n    { no: 4, name: \"TYPE_UINT64\" },\n    { no: 5, name: \"TYPE_INT32\" },\n    { no: 6, name: \"TYPE_FIXED64\" },\n    { no: 7, name: \"TYPE_FIXED32\" },\n    { no: 8, name: \"TYPE_BOOL\" },\n    { no: 9, name: \"TYPE_STRING\" },\n    { no: 10, name: \"TYPE_GROUP\" },\n    { no: 11, name: \"TYPE_MESSAGE\" },\n    { no: 12, name: \"TYPE_BYTES\" },\n    { no: 13, name: \"TYPE_UINT32\" },\n    { no: 14, name: \"TYPE_ENUM\" },\n    { no: 15, name: \"TYPE_SFIXED32\" },\n    { no: 16, name: \"TYPE_SFIXED64\" },\n    { no: 17, name: \"TYPE_SINT32\" },\n    { no: 18, name: \"TYPE_SINT64\" },\n]);\n/**\n * Whether a field is optional, required, or repeated.\n *\n * @generated from enum google.protobuf.Field.Cardinality\n */\nvar Field_Cardinality;\n(function (Field_Cardinality) {\n    /**\n     * For fields with unknown cardinality.\n     *\n     * @generated from enum value: CARDINALITY_UNKNOWN = 0;\n     */\n    Field_Cardinality[Field_Cardinality[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    /**\n     * For optional fields.\n     *\n     * @generated from enum value: CARDINALITY_OPTIONAL = 1;\n     */\n    Field_Cardinality[Field_Cardinality[\"OPTIONAL\"] = 1] = \"OPTIONAL\";\n    /**\n     * For required fields. Proto2 syntax only.\n     *\n     * @generated from enum value: CARDINALITY_REQUIRED = 2;\n     */\n    Field_Cardinality[Field_Cardinality[\"REQUIRED\"] = 2] = \"REQUIRED\";\n    /**\n     * For repeated fields.\n     *\n     * @generated from enum value: CARDINALITY_REPEATED = 3;\n     */\n    Field_Cardinality[Field_Cardinality[\"REPEATED\"] = 3] = \"REPEATED\";\n})(Field_Cardinality || (Field_Cardinality = {}));\n// Retrieve enum metadata with: proto3.getEnumType(Field_Cardinality)\nproto3/* proto3 */.w.util.setEnumType(Field_Cardinality, \"google.protobuf.Field.Cardinality\", [\n    { no: 0, name: \"CARDINALITY_UNKNOWN\" },\n    { no: 1, name: \"CARDINALITY_OPTIONAL\" },\n    { no: 2, name: \"CARDINALITY_REQUIRED\" },\n    { no: 3, name: \"CARDINALITY_REPEATED\" },\n]);\n/**\n * Enum type definition.\n *\n * @generated from message google.protobuf.Enum\n */\nclass Enum extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * Enum type name.\n         *\n         * @generated from field: string name = 1;\n         */\n        this.name = \"\";\n        /**\n         * Enum value definitions.\n         *\n         * @generated from field: repeated google.protobuf.EnumValue enumvalue = 2;\n         */\n        this.enumvalue = [];\n        /**\n         * Protocol buffer options.\n         *\n         * @generated from field: repeated google.protobuf.Option options = 3;\n         */\n        this.options = [];\n        /**\n         * The source syntax.\n         *\n         * @generated from field: google.protobuf.Syntax syntax = 5;\n         */\n        this.syntax = Syntax.PROTO2;\n        /**\n         * The source edition string, only valid when syntax is SYNTAX_EDITIONS.\n         *\n         * @generated from field: string edition = 6;\n         */\n        this.edition = \"\";\n        proto3/* proto3 */.w.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Enum().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Enum().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Enum().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3/* proto3 */.w.util.equals(Enum, a, b);\n    }\n}\nEnum.runtime = proto3/* proto3 */.w;\nEnum.typeName = \"google.protobuf.Enum\";\nEnum.fields = proto3/* proto3 */.w.util.newFieldList(() => [\n    { no: 1, name: \"name\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 2, name: \"enumvalue\", kind: \"message\", T: EnumValue, repeated: true },\n    { no: 3, name: \"options\", kind: \"message\", T: Option, repeated: true },\n    { no: 4, name: \"source_context\", kind: \"message\", T: SourceContext },\n    { no: 5, name: \"syntax\", kind: \"enum\", T: proto3/* proto3 */.w.getEnumType(Syntax) },\n    { no: 6, name: \"edition\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n]);\n/**\n * Enum value definition.\n *\n * @generated from message google.protobuf.EnumValue\n */\nclass EnumValue extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * Enum value name.\n         *\n         * @generated from field: string name = 1;\n         */\n        this.name = \"\";\n        /**\n         * Enum value number.\n         *\n         * @generated from field: int32 number = 2;\n         */\n        this.number = 0;\n        /**\n         * Protocol buffer options.\n         *\n         * @generated from field: repeated google.protobuf.Option options = 3;\n         */\n        this.options = [];\n        proto3/* proto3 */.w.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new EnumValue().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new EnumValue().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new EnumValue().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3/* proto3 */.w.util.equals(EnumValue, a, b);\n    }\n}\nEnumValue.runtime = proto3/* proto3 */.w;\nEnumValue.typeName = \"google.protobuf.EnumValue\";\nEnumValue.fields = proto3/* proto3 */.w.util.newFieldList(() => [\n    { no: 1, name: \"name\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 2, name: \"number\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */ },\n    { no: 3, name: \"options\", kind: \"message\", T: Option, repeated: true },\n]);\n/**\n * A protocol buffer option, which can be attached to a message, field,\n * enumeration, etc.\n *\n * @generated from message google.protobuf.Option\n */\nclass Option extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The option's name. For protobuf built-in options (options defined in\n         * descriptor.proto), this is the short name. For example, `\"map_entry\"`.\n         * For custom options, it should be the fully-qualified name. For example,\n         * `\"google.api.http\"`.\n         *\n         * @generated from field: string name = 1;\n         */\n        this.name = \"\";\n        proto3/* proto3 */.w.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Option().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Option().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Option().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3/* proto3 */.w.util.equals(Option, a, b);\n    }\n}\nOption.runtime = proto3/* proto3 */.w;\nOption.typeName = \"google.protobuf.Option\";\nOption.fields = proto3/* proto3 */.w.util.newFieldList(() => [\n    { no: 1, name: \"name\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 2, name: \"value\", kind: \"message\", T: any_pb/* Any */.I },\n]);\n\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/api_pb.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n\n/**\n * Api is a light-weight descriptor for an API Interface.\n *\n * Interfaces are also described as \"protocol buffer services\" in some contexts,\n * such as by the \"service\" keyword in a .proto file, but they are different\n * from API Services, which represent a concrete implementation of an interface\n * as opposed to simply a description of methods and bindings. They are also\n * sometimes simply referred to as \"APIs\" in other contexts, such as the name of\n * this message itself. See https://cloud.google.com/apis/design/glossary for\n * detailed terminology.\n *\n * @generated from message google.protobuf.Api\n */\nclass Api extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The fully qualified name of this interface, including package name\n         * followed by the interface's simple name.\n         *\n         * @generated from field: string name = 1;\n         */\n        this.name = \"\";\n        /**\n         * The methods of this interface, in unspecified order.\n         *\n         * @generated from field: repeated google.protobuf.Method methods = 2;\n         */\n        this.methods = [];\n        /**\n         * Any metadata attached to the interface.\n         *\n         * @generated from field: repeated google.protobuf.Option options = 3;\n         */\n        this.options = [];\n        /**\n         * A version string for this interface. If specified, must have the form\n         * `major-version.minor-version`, as in `1.10`. If the minor version is\n         * omitted, it defaults to zero. If the entire version field is empty, the\n         * major version is derived from the package name, as outlined below. If the\n         * field is not empty, the version in the package name will be verified to be\n         * consistent with what is provided here.\n         *\n         * The versioning schema uses [semantic\n         * versioning](http://semver.org) where the major version number\n         * indicates a breaking change and the minor version an additive,\n         * non-breaking change. Both version numbers are signals to users\n         * what to expect from different versions, and should be carefully\n         * chosen based on the product plan.\n         *\n         * The major version is also reflected in the package name of the\n         * interface, which must end in `v<major-version>`, as in\n         * `google.feature.v1`. For major versions 0 and 1, the suffix can\n         * be omitted. Zero major versions must only be used for\n         * experimental, non-GA interfaces.\n         *\n         *\n         * @generated from field: string version = 4;\n         */\n        this.version = \"\";\n        /**\n         * Included interfaces. See [Mixin][].\n         *\n         * @generated from field: repeated google.protobuf.Mixin mixins = 6;\n         */\n        this.mixins = [];\n        /**\n         * The source syntax of the service.\n         *\n         * @generated from field: google.protobuf.Syntax syntax = 7;\n         */\n        this.syntax = Syntax.PROTO2;\n        proto3/* proto3 */.w.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Api().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Api().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Api().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3/* proto3 */.w.util.equals(Api, a, b);\n    }\n}\nApi.runtime = proto3/* proto3 */.w;\nApi.typeName = \"google.protobuf.Api\";\nApi.fields = proto3/* proto3 */.w.util.newFieldList(() => [\n    { no: 1, name: \"name\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 2, name: \"methods\", kind: \"message\", T: Method, repeated: true },\n    { no: 3, name: \"options\", kind: \"message\", T: Option, repeated: true },\n    { no: 4, name: \"version\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 5, name: \"source_context\", kind: \"message\", T: SourceContext },\n    { no: 6, name: \"mixins\", kind: \"message\", T: Mixin, repeated: true },\n    { no: 7, name: \"syntax\", kind: \"enum\", T: proto3/* proto3 */.w.getEnumType(Syntax) },\n]);\n/**\n * Method represents a method of an API interface.\n *\n * @generated from message google.protobuf.Method\n */\nclass Method extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The simple name of this method.\n         *\n         * @generated from field: string name = 1;\n         */\n        this.name = \"\";\n        /**\n         * A URL of the input message type.\n         *\n         * @generated from field: string request_type_url = 2;\n         */\n        this.requestTypeUrl = \"\";\n        /**\n         * If true, the request is streamed.\n         *\n         * @generated from field: bool request_streaming = 3;\n         */\n        this.requestStreaming = false;\n        /**\n         * The URL of the output message type.\n         *\n         * @generated from field: string response_type_url = 4;\n         */\n        this.responseTypeUrl = \"\";\n        /**\n         * If true, the response is streamed.\n         *\n         * @generated from field: bool response_streaming = 5;\n         */\n        this.responseStreaming = false;\n        /**\n         * Any metadata attached to the method.\n         *\n         * @generated from field: repeated google.protobuf.Option options = 6;\n         */\n        this.options = [];\n        /**\n         * The source syntax of this method.\n         *\n         * @generated from field: google.protobuf.Syntax syntax = 7;\n         */\n        this.syntax = Syntax.PROTO2;\n        proto3/* proto3 */.w.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Method().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Method().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Method().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3/* proto3 */.w.util.equals(Method, a, b);\n    }\n}\nMethod.runtime = proto3/* proto3 */.w;\nMethod.typeName = \"google.protobuf.Method\";\nMethod.fields = proto3/* proto3 */.w.util.newFieldList(() => [\n    { no: 1, name: \"name\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 2, name: \"request_type_url\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 3, name: \"request_streaming\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */ },\n    { no: 4, name: \"response_type_url\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 5, name: \"response_streaming\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */ },\n    { no: 6, name: \"options\", kind: \"message\", T: Option, repeated: true },\n    { no: 7, name: \"syntax\", kind: \"enum\", T: proto3/* proto3 */.w.getEnumType(Syntax) },\n]);\n/**\n * Declares an API Interface to be included in this interface. The including\n * interface must redeclare all the methods from the included interface, but\n * documentation and options are inherited as follows:\n *\n * - If after comment and whitespace stripping, the documentation\n *   string of the redeclared method is empty, it will be inherited\n *   from the original method.\n *\n * - Each annotation belonging to the service config (http,\n *   visibility) which is not set in the redeclared method will be\n *   inherited.\n *\n * - If an http annotation is inherited, the path pattern will be\n *   modified as follows. Any version prefix will be replaced by the\n *   version of the including interface plus the [root][] path if\n *   specified.\n *\n * Example of a simple mixin:\n *\n *     package google.acl.v1;\n *     service AccessControl {\n *       // Get the underlying ACL object.\n *       rpc GetAcl(GetAclRequest) returns (Acl) {\n *         option (google.api.http).get = \"/v1/{resource=**}:getAcl\";\n *       }\n *     }\n *\n *     package google.storage.v2;\n *     service Storage {\n *       rpc GetAcl(GetAclRequest) returns (Acl);\n *\n *       // Get a data record.\n *       rpc GetData(GetDataRequest) returns (Data) {\n *         option (google.api.http).get = \"/v2/{resource=**}\";\n *       }\n *     }\n *\n * Example of a mixin configuration:\n *\n *     apis:\n *     - name: google.storage.v2.Storage\n *       mixins:\n *       - name: google.acl.v1.AccessControl\n *\n * The mixin construct implies that all methods in `AccessControl` are\n * also declared with same name and request/response types in\n * `Storage`. A documentation generator or annotation processor will\n * see the effective `Storage.GetAcl` method after inherting\n * documentation and annotations as follows:\n *\n *     service Storage {\n *       // Get the underlying ACL object.\n *       rpc GetAcl(GetAclRequest) returns (Acl) {\n *         option (google.api.http).get = \"/v2/{resource=**}:getAcl\";\n *       }\n *       ...\n *     }\n *\n * Note how the version in the path pattern changed from `v1` to `v2`.\n *\n * If the `root` field in the mixin is specified, it should be a\n * relative path under which inherited HTTP paths are placed. Example:\n *\n *     apis:\n *     - name: google.storage.v2.Storage\n *       mixins:\n *       - name: google.acl.v1.AccessControl\n *         root: acls\n *\n * This implies the following inherited HTTP annotation:\n *\n *     service Storage {\n *       // Get the underlying ACL object.\n *       rpc GetAcl(GetAclRequest) returns (Acl) {\n *         option (google.api.http).get = \"/v2/acls/{resource=**}:getAcl\";\n *       }\n *       ...\n *     }\n *\n * @generated from message google.protobuf.Mixin\n */\nclass Mixin extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The fully qualified name of the interface which is included.\n         *\n         * @generated from field: string name = 1;\n         */\n        this.name = \"\";\n        /**\n         * If non-empty specifies a path under which inherited HTTP paths\n         * are rooted.\n         *\n         * @generated from field: string root = 2;\n         */\n        this.root = \"\";\n        proto3/* proto3 */.w.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Mixin().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Mixin().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Mixin().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3/* proto3 */.w.util.equals(Mixin, a, b);\n    }\n}\nMixin.runtime = proto3/* proto3 */.w;\nMixin.typeName = \"google.protobuf.Mixin\";\nMixin.fields = proto3/* proto3 */.w.util.newFieldList(() => [\n    { no: 1, name: \"name\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 2, name: \"root\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n]);\n\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/index.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// ideally, we would export these types with sub-path exports:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/***/ }),\n\n/***/ 561:\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_370664__) => {\n\n/* harmony export */ __nested_webpack_require_370664__.d(__nested_webpack_exports__, {\n/* harmony export */   v: () => (/* binding */ Message)\n/* harmony export */ });\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Message is the base class of every message, generated, or created at\n * runtime.\n *\n * It is _not_ safe to extend this class. If you want to create a message at\n * run time, use proto3.makeMessageType().\n */\nclass Message {\n    /**\n     * Compare with a message of the same type.\n     */\n    equals(other) {\n        return this.getType().runtime.util.equals(this.getType(), this, other);\n    }\n    /**\n     * Create a deep copy.\n     */\n    clone() {\n        return this.getType().runtime.util.clone(this);\n    }\n    /**\n     * Parse from binary data, merging fields.\n     *\n     * Repeated fields are appended. Map entries are added, overwriting\n     * existing keys.\n     *\n     * If a message field is already present, it will be merged with the\n     * new data.\n     */\n    fromBinary(bytes, options) {\n        const type = this.getType(), format = type.runtime.bin, opt = format.makeReadOptions(options);\n        format.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);\n        return this;\n    }\n    /**\n     * Parse a message from a JSON value.\n     */\n    fromJson(jsonValue, options) {\n        const type = this.getType(), format = type.runtime.json, opt = format.makeReadOptions(options);\n        format.readMessage(type, jsonValue, opt, this);\n        return this;\n    }\n    /**\n     * Parse a message from a JSON string.\n     */\n    fromJsonString(jsonString, options) {\n        let json;\n        try {\n            json = JSON.parse(jsonString);\n        }\n        catch (e) {\n            throw new Error(`cannot decode ${this.getType().typeName} from JSON: ${e instanceof Error ? e.message : String(e)}`);\n        }\n        return this.fromJson(json, options);\n    }\n    /**\n     * Serialize the message to binary data.\n     */\n    toBinary(options) {\n        const type = this.getType(), bin = type.runtime.bin, opt = bin.makeWriteOptions(options), writer = opt.writerFactory();\n        bin.writeMessage(this, writer, opt);\n        return writer.finish();\n    }\n    /**\n     * Serialize the message to a JSON value, a JavaScript value that can be\n     * passed to JSON.stringify().\n     */\n    toJson(options) {\n        const type = this.getType(), json = type.runtime.json, opt = json.makeWriteOptions(options);\n        return json.writeMessage(this, opt);\n    }\n    /**\n     * Serialize the message to a JSON string.\n     */\n    toJsonString(options) {\n        var _a;\n        const value = this.toJson(options);\n        return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);\n    }\n    /**\n     * Override for serialization behavior. This will be invoked when calling\n     * JSON.stringify on this message (i.e. JSON.stringify(msg)).\n     *\n     * Note that this will not serialize google.protobuf.Any with a packed\n     * message because the protobuf JSON format specifies that it needs to be\n     * unpacked, and this is only possible with a type registry to look up the\n     * message type.  As a result, attempting to serialize a message with this\n     * type will throw an Error.\n     *\n     * This method is protected because you should not need to invoke it\n     * directly -- instead use JSON.stringify or toJsonString for\n     * stringified JSON.  Alternatively, if actual JSON is desired, you should\n     * use toJson.\n     */\n    toJSON() {\n        return this.toJson({\n            emitDefaultValues: true,\n        });\n    }\n    /**\n     * Retrieve the MessageType of this message - a singleton that represents\n     * the protobuf message declaration and provides metadata for reflection-\n     * based operations.\n     */\n    getType() {\n        // Any class that extends Message _must_ provide a complete static\n        // implementation of MessageType.\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return\n        return Object.getPrototypeOf(this).constructor;\n    }\n}\n\n\n/***/ }),\n\n/***/ 120:\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_375513__) => {\n\n/* harmony export */ __nested_webpack_require_375513__.d(__nested_webpack_exports__, {\n/* harmony export */   E_: () => (/* binding */ assertFloat32),\n/* harmony export */   fp: () => (/* binding */ assertUInt32),\n/* harmony export */   hu: () => (/* binding */ assert),\n/* harmony export */   ug: () => (/* binding */ assertInt32)\n/* harmony export */ });\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Assert that condition is truthy or throw error (with message)\n */\nfunction assert(condition, msg) {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions -- we want the implicit conversion to boolean\n    if (!condition) {\n        throw new Error(msg);\n    }\n}\nconst FLOAT32_MAX = 3.4028234663852886e38, FLOAT32_MIN = -3.4028234663852886e38, UINT32_MAX = 0xffffffff, INT32_MAX = 0x7fffffff, INT32_MIN = -0x80000000;\n/**\n * Assert a valid signed protobuf 32-bit integer.\n */\nfunction assertInt32(arg) {\n    if (typeof arg !== \"number\")\n        throw new Error(\"invalid int 32: \" + typeof arg);\n    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)\n        throw new Error(\"invalid int 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n/**\n * Assert a valid unsigned protobuf 32-bit integer.\n */\nfunction assertUInt32(arg) {\n    if (typeof arg !== \"number\")\n        throw new Error(\"invalid uint 32: \" + typeof arg);\n    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)\n        throw new Error(\"invalid uint 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n/**\n * Assert a valid protobuf float value.\n */\nfunction assertFloat32(arg) {\n    if (typeof arg !== \"number\")\n        throw new Error(\"invalid float 32: \" + typeof arg);\n    if (!Number.isFinite(arg))\n        return;\n    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)\n        throw new Error(\"invalid float 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n\n\n/***/ }),\n\n/***/ 744:\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_378266__) => {\n\n/* harmony export */ __nested_webpack_require_378266__.d(__nested_webpack_exports__, {\n/* harmony export */   Jj: () => (/* binding */ writePacked),\n/* harmony export */   NN: () => (/* binding */ writeScalar),\n/* harmony export */   gQ: () => (/* binding */ writeMapEntry),\n/* harmony export */   gY: () => (/* binding */ makeBinaryFormatCommon),\n/* harmony export */   oQ: () => (/* binding */ writeMessageField)\n/* harmony export */ });\n/* unused harmony export readScalarLTString */\n/* harmony import */ var _binary_encoding_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_378266__(79);\n/* harmony import */ var _message_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_378266__(561);\n/* harmony import */ var _field_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_378266__(465);\n/* harmony import */ var _field_wrapper_js__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_378266__(432);\n/* harmony import */ var _scalars_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_378266__(781);\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_378266__(120);\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n\n\n\n/* eslint-disable @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unnecessary-condition, no-case-declarations, prefer-const */\nconst unknownFieldsSymbol = Symbol(\"@bufbuild/protobuf/unknown-fields\");\n// Default options for parsing binary data.\nconst readDefaults = {\n    readUnknownFields: true,\n    readerFactory: (bytes) => new _binary_encoding_js__WEBPACK_IMPORTED_MODULE_0__/* .BinaryReader */ .oP(bytes),\n};\n// Default options for serializing binary data.\nconst writeDefaults = {\n    writeUnknownFields: true,\n    writerFactory: () => new _binary_encoding_js__WEBPACK_IMPORTED_MODULE_0__/* .BinaryWriter */ .Lt(),\n};\nfunction makeReadOptions(options) {\n    return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;\n}\nfunction makeWriteOptions(options) {\n    return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;\n}\nfunction makeBinaryFormatCommon() {\n    return {\n        makeReadOptions,\n        makeWriteOptions,\n        listUnknownFields(message) {\n            var _a;\n            return (_a = message[unknownFieldsSymbol]) !== null && _a !== void 0 ? _a : [];\n        },\n        discardUnknownFields(message) {\n            delete message[unknownFieldsSymbol];\n        },\n        writeUnknownFields(message, writer) {\n            const m = message;\n            const c = m[unknownFieldsSymbol];\n            if (c) {\n                for (const f of c) {\n                    writer.tag(f.no, f.wireType).raw(f.data);\n                }\n            }\n        },\n        onUnknownField(message, no, wireType, data) {\n            const m = message;\n            if (!Array.isArray(m[unknownFieldsSymbol])) {\n                m[unknownFieldsSymbol] = [];\n            }\n            m[unknownFieldsSymbol].push({ no, wireType, data });\n        },\n        readMessage(message, reader, lengthOrEndTagFieldNo, options, delimitedMessageEncoding) {\n            const type = message.getType();\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            const end = delimitedMessageEncoding\n                ? reader.len\n                : reader.pos + lengthOrEndTagFieldNo;\n            let fieldNo, wireType;\n            while (reader.pos < end) {\n                [fieldNo, wireType] = reader.tag();\n                if (wireType == _binary_encoding_js__WEBPACK_IMPORTED_MODULE_0__/* .WireType */ .TD.EndGroup) {\n                    break;\n                }\n                const field = type.fields.find(fieldNo);\n                if (!field) {\n                    const data = reader.skip(wireType);\n                    if (options.readUnknownFields) {\n                        this.onUnknownField(message, fieldNo, wireType, data);\n                    }\n                    continue;\n                }\n                let target = message, repeated = field.repeated, localName = field.localName;\n                if (field.oneof) {\n                    target = target[field.oneof.localName];\n                    if (target.case != localName) {\n                        delete target.value;\n                    }\n                    target.case = localName;\n                    localName = \"value\";\n                }\n                switch (field.kind) {\n                    case \"scalar\":\n                    case \"enum\":\n                        const scalarType = field.kind == \"enum\" ? _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.INT32 : field.T;\n                        let read = readScalar;\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\n                        if (field.kind == \"scalar\" && field.L > 0) {\n                            read = readScalarLTString;\n                        }\n                        if (repeated) {\n                            let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values\n                            if (wireType == _binary_encoding_js__WEBPACK_IMPORTED_MODULE_0__/* .WireType */ .TD.LengthDelimited &&\n                                scalarType != _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.STRING &&\n                                scalarType != _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.BYTES) {\n                                let e = reader.uint32() + reader.pos;\n                                while (reader.pos < e) {\n                                    arr.push(read(reader, scalarType));\n                                }\n                            }\n                            else {\n                                arr.push(read(reader, scalarType));\n                            }\n                        }\n                        else {\n                            target[localName] = read(reader, scalarType);\n                        }\n                        break;\n                    case \"message\":\n                        const messageType = field.T;\n                        if (repeated) {\n                            // safe to assume presence of array, oneof cannot contain repeated values\n                            target[localName].push(readMessageField(reader, new messageType(), options, field));\n                        }\n                        else {\n                            if (target[localName] instanceof _message_js__WEBPACK_IMPORTED_MODULE_2__/* .Message */ .v) {\n                                readMessageField(reader, target[localName], options, field);\n                            }\n                            else {\n                                target[localName] = readMessageField(reader, new messageType(), options, field);\n                                if (messageType.fieldWrapper &&\n                                    !field.oneof &&\n                                    !field.repeated) {\n                                    target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);\n                                }\n                            }\n                        }\n                        break;\n                    case \"map\":\n                        let [mapKey, mapVal] = readMapEntry(field, reader, options);\n                        // safe to assume presence of map object, oneof cannot contain repeated values\n                        target[localName][mapKey] = mapVal;\n                        break;\n                }\n            }\n            if (delimitedMessageEncoding && // eslint-disable-line @typescript-eslint/strict-boolean-expressions\n                (wireType != _binary_encoding_js__WEBPACK_IMPORTED_MODULE_0__/* .WireType */ .TD.EndGroup || fieldNo !== lengthOrEndTagFieldNo)) {\n                throw new Error(`invalid end group tag`);\n            }\n        },\n    };\n}\n// Read a message, avoiding MessageType.fromBinary() to re-use the\n// BinaryReadOptions and the IBinaryReader.\nfunction readMessageField(reader, message, options, field) {\n    const format = message.getType().runtime.bin;\n    const delimited = field === null || field === void 0 ? void 0 : field.delimited;\n    format.readMessage(message, reader, delimited ? field === null || field === void 0 ? void 0 : field.no : reader.uint32(), // eslint-disable-line @typescript-eslint/strict-boolean-expressions\n    options, delimited);\n    return message;\n}\n// Read a map field, expecting key field = 1, value field = 2\nfunction readMapEntry(field, reader, options) {\n    const length = reader.uint32(), end = reader.pos + length;\n    let key, val;\n    while (reader.pos < end) {\n        let [fieldNo] = reader.tag();\n        switch (fieldNo) {\n            case 1:\n                key = readScalar(reader, field.K);\n                break;\n            case 2:\n                switch (field.V.kind) {\n                    case \"scalar\":\n                        val = readScalar(reader, field.V.T);\n                        break;\n                    case \"enum\":\n                        val = reader.int32();\n                        break;\n                    case \"message\":\n                        val = readMessageField(reader, new field.V.T(), options, undefined);\n                        break;\n                }\n                break;\n        }\n    }\n    if (key === undefined) {\n        let keyRaw = (0,_scalars_js__WEBPACK_IMPORTED_MODULE_3__/* .scalarDefaultValue */ .kY)(field.K, _field_js__WEBPACK_IMPORTED_MODULE_1__/* .LongType */ .p.BIGINT);\n        key =\n            field.K == _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.BOOL\n                ? keyRaw.toString()\n                : keyRaw;\n    }\n    if (typeof key != \"string\" && typeof key != \"number\") {\n        key = key.toString();\n    }\n    if (val === undefined) {\n        switch (field.V.kind) {\n            case \"scalar\":\n                val = (0,_scalars_js__WEBPACK_IMPORTED_MODULE_3__/* .scalarDefaultValue */ .kY)(field.V.T, _field_js__WEBPACK_IMPORTED_MODULE_1__/* .LongType */ .p.BIGINT);\n                break;\n            case \"enum\":\n                val = 0;\n                break;\n            case \"message\":\n                val = new field.V.T();\n                break;\n        }\n    }\n    return [key, val];\n}\n// Read a scalar value, but return 64 bit integral types (int64, uint64,\n// sint64, fixed64, sfixed64) as string instead of bigint.\nfunction readScalarLTString(reader, type) {\n    const v = readScalar(reader, type);\n    return typeof v == \"bigint\" ? v.toString() : v;\n}\n// Does not use scalarTypeInfo() for better performance.\nfunction readScalar(reader, type) {\n    switch (type) {\n        case _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.STRING:\n            return reader.string();\n        case _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.BOOL:\n            return reader.bool();\n        case _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.DOUBLE:\n            return reader.double();\n        case _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.FLOAT:\n            return reader.float();\n        case _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.INT32:\n            return reader.int32();\n        case _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.INT64:\n            return reader.int64();\n        case _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.UINT64:\n            return reader.uint64();\n        case _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.FIXED64:\n            return reader.fixed64();\n        case _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.BYTES:\n            return reader.bytes();\n        case _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.FIXED32:\n            return reader.fixed32();\n        case _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.SFIXED32:\n            return reader.sfixed32();\n        case _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.SFIXED64:\n            return reader.sfixed64();\n        case _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.SINT64:\n            return reader.sint64();\n        case _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.UINT32:\n            return reader.uint32();\n        case _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.SINT32:\n            return reader.sint32();\n    }\n}\nfunction writeMapEntry(writer, options, field, key, value) {\n    writer.tag(field.no, _binary_encoding_js__WEBPACK_IMPORTED_MODULE_0__/* .WireType */ .TD.LengthDelimited);\n    writer.fork();\n    // javascript only allows number or string for object properties\n    // we convert from our representation to the protobuf type\n    let keyValue = key;\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- we deliberately handle just the special cases for map keys\n    switch (field.K) {\n        case _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.INT32:\n        case _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.FIXED32:\n        case _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.UINT32:\n        case _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.SFIXED32:\n        case _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.SINT32:\n            keyValue = Number.parseInt(key);\n            break;\n        case _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.BOOL:\n            (0,_assert_js__WEBPACK_IMPORTED_MODULE_4__/* .assert */ .hu)(key == \"true\" || key == \"false\");\n            keyValue = key == \"true\";\n            break;\n    }\n    // write key, expecting key field number = 1\n    writeScalar(writer, field.K, 1, keyValue, true);\n    // write value, expecting value field number = 2\n    switch (field.V.kind) {\n        case \"scalar\":\n            writeScalar(writer, field.V.T, 2, value, true);\n            break;\n        case \"enum\":\n            writeScalar(writer, _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.INT32, 2, value, true);\n            break;\n        case \"message\":\n            writer.tag(2, _binary_encoding_js__WEBPACK_IMPORTED_MODULE_0__/* .WireType */ .TD.LengthDelimited).bytes(value.toBinary(options));\n            break;\n    }\n    writer.join();\n}\nfunction writeMessageField(writer, options, field, value) {\n    if (value !== undefined) {\n        const message = (0,_field_wrapper_js__WEBPACK_IMPORTED_MODULE_5__/* .wrapField */ .E)(field.T, value);\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        if (field === null || field === void 0 ? void 0 : field.delimited)\n            writer\n                .tag(field.no, _binary_encoding_js__WEBPACK_IMPORTED_MODULE_0__/* .WireType */ .TD.StartGroup)\n                .raw(message.toBinary(options))\n                .tag(field.no, _binary_encoding_js__WEBPACK_IMPORTED_MODULE_0__/* .WireType */ .TD.EndGroup);\n        else\n            writer\n                .tag(field.no, _binary_encoding_js__WEBPACK_IMPORTED_MODULE_0__/* .WireType */ .TD.LengthDelimited)\n                .bytes(message.toBinary(options));\n    }\n}\nfunction writeScalar(writer, type, fieldNo, value, emitIntrinsicDefault) {\n    let [wireType, method, isIntrinsicDefault] = (0,_scalars_js__WEBPACK_IMPORTED_MODULE_3__/* .scalarTypeInfo */ .T1)(type, value);\n    if (!isIntrinsicDefault || emitIntrinsicDefault) {\n        writer.tag(fieldNo, wireType)[method](value);\n    }\n}\nfunction writePacked(writer, type, fieldNo, value) {\n    if (!value.length) {\n        return;\n    }\n    writer.tag(fieldNo, _binary_encoding_js__WEBPACK_IMPORTED_MODULE_0__/* .WireType */ .TD.LengthDelimited).fork();\n    let [, method] = (0,_scalars_js__WEBPACK_IMPORTED_MODULE_3__/* .scalarTypeInfo */ .T1)(type);\n    for (let i = 0; i < value.length; i++) {\n        writer[method](value[i]);\n    }\n    writer.join();\n}\n\n\n/***/ }),\n\n/***/ 609:\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_395048__) => {\n\n/* harmony export */ __nested_webpack_require_395048__.d(__nested_webpack_exports__, {\n/* harmony export */   V3: () => (/* binding */ getEnumType),\n/* harmony export */   be: () => (/* binding */ makeEnumType),\n/* harmony export */   ut: () => (/* binding */ makeEnum),\n/* harmony export */   zg: () => (/* binding */ setEnumType)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_395048__(120);\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nconst enumTypeSymbol = Symbol(\"@bufbuild/protobuf/enum-type\");\n/**\n * Get reflection information from a generated enum.\n * If this function is called on something other than a generated\n * enum, it raises an error.\n */\nfunction getEnumType(enumObject) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-explicit-any\n    const t = enumObject[enumTypeSymbol];\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__/* .assert */ .hu)(t, \"missing enum type on enum object\");\n    return t; // eslint-disable-line @typescript-eslint/no-unsafe-return\n}\n/**\n * Sets reflection information on a generated enum.\n */\nfunction setEnumType(enumObject, typeName, values, opt) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n    enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map((v) => ({\n        no: v.no,\n        name: v.name,\n        localName: enumObject[v.no],\n    })), opt);\n}\n/**\n * Create a new EnumType with the given values.\n */\nfunction makeEnumType(typeName, values, \n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n_opt) {\n    const names = Object.create(null);\n    const numbers = Object.create(null);\n    const normalValues = [];\n    for (const value of values) {\n        // We do not surface options at this time\n        // const value: EnumValueInfo = {...v, options: v.options ?? emptyReadonlyObject};\n        const n = normalizeEnumValue(value);\n        normalValues.push(n);\n        names[value.name] = n;\n        numbers[value.no] = n;\n    }\n    return {\n        typeName,\n        values: normalValues,\n        // We do not surface options at this time\n        // options: opt?.options ?? Object.create(null),\n        findName(name) {\n            return names[name];\n        },\n        findNumber(no) {\n            return numbers[no];\n        },\n    };\n}\n/**\n * Create a new enum object with the given values.\n * Sets reflection information.\n */\nfunction makeEnum(typeName, values, opt) {\n    const enumObject = {};\n    for (const value of values) {\n        const n = normalizeEnumValue(value);\n        enumObject[n.localName] = n.no;\n        enumObject[n.no] = n.localName;\n    }\n    setEnumType(enumObject, typeName, values, opt);\n    return enumObject;\n}\nfunction normalizeEnumValue(value) {\n    if (\"localName\" in value) {\n        return value;\n    }\n    return Object.assign(Object.assign({}, value), { localName: value.name });\n}\n\n\n/***/ }),\n\n/***/ 501:\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_398714__) => {\n\n/* harmony export */ __nested_webpack_require_398714__.d(__nested_webpack_exports__, {\n/* harmony export */   i: () => (/* binding */ InternalFieldList)\n/* harmony export */ });\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass InternalFieldList {\n    constructor(fields, normalizer) {\n        this._fields = fields;\n        this._normalizer = normalizer;\n    }\n    findJsonName(jsonName) {\n        if (!this.jsonNames) {\n            const t = {};\n            for (const f of this.list()) {\n                t[f.jsonName] = t[f.name] = f;\n            }\n            this.jsonNames = t;\n        }\n        return this.jsonNames[jsonName];\n    }\n    find(fieldNo) {\n        if (!this.numbers) {\n            const t = {};\n            for (const f of this.list()) {\n                t[f.no] = f;\n            }\n            this.numbers = t;\n        }\n        return this.numbers[fieldNo];\n    }\n    list() {\n        if (!this.all) {\n            this.all = this._normalizer(this._fields);\n        }\n        return this.all;\n    }\n    byNumber() {\n        if (!this.numbersAsc) {\n            this.numbersAsc = this.list()\n                .concat()\n                .sort((a, b) => a.no - b.no);\n        }\n        return this.numbersAsc;\n    }\n    byMember() {\n        if (!this.members) {\n            this.members = [];\n            const a = this.members;\n            let o;\n            for (const f of this.list()) {\n                if (f.oneof) {\n                    if (f.oneof !== o) {\n                        o = f.oneof;\n                        a.push(o);\n                    }\n                }\n                else {\n                    a.push(f);\n                }\n            }\n        }\n        return this.members;\n    }\n}\n\n\n/***/ }),\n\n/***/ 432:\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_401094__) => {\n\n/* harmony export */ __nested_webpack_require_401094__.d(__nested_webpack_exports__, {\n/* harmony export */   E: () => (/* binding */ wrapField),\n/* harmony export */   w: () => (/* binding */ getUnwrappedFieldType)\n/* harmony export */ });\n/* harmony import */ var _message_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_401094__(561);\n/* harmony import */ var _field_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_401094__(465);\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n/**\n * Wrap a primitive message field value in its corresponding wrapper\n * message. This function is idempotent.\n */\nfunction wrapField(type, value) {\n    if (value instanceof _message_js__WEBPACK_IMPORTED_MODULE_0__/* .Message */ .v || !type.fieldWrapper) {\n        return value;\n    }\n    return type.fieldWrapper.wrapField(value);\n}\n/**\n * If the given field uses one of the well-known wrapper types, return\n * the primitive type it wraps.\n */\nfunction getUnwrappedFieldType(field) {\n    if (field.fieldKind !== \"message\") {\n        return undefined;\n    }\n    if (field.repeated) {\n        return undefined;\n    }\n    if (field.oneof != undefined) {\n        return undefined;\n    }\n    return wktWrapperToScalarType[field.message.typeName];\n}\nconst wktWrapperToScalarType = {\n    \"google.protobuf.DoubleValue\": _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.DOUBLE,\n    \"google.protobuf.FloatValue\": _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.FLOAT,\n    \"google.protobuf.Int64Value\": _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.INT64,\n    \"google.protobuf.UInt64Value\": _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.UINT64,\n    \"google.protobuf.Int32Value\": _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.INT32,\n    \"google.protobuf.UInt32Value\": _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.UINT32,\n    \"google.protobuf.BoolValue\": _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.BOOL,\n    \"google.protobuf.StringValue\": _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.STRING,\n    \"google.protobuf.BytesValue\": _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.BYTES,\n};\n\n\n/***/ }),\n\n/***/ 215:\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_403914__) => {\n\n/* harmony export */ __nested_webpack_require_403914__.d(__nested_webpack_exports__, {\n/* harmony export */   o: () => (/* binding */ InternalOneofInfo)\n/* harmony export */ });\n/* harmony import */ var _names_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_403914__(504);\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_403914__(120);\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\nclass InternalOneofInfo {\n    constructor(name) {\n        this.kind = \"oneof\";\n        this.repeated = false;\n        this.packed = false;\n        this.opt = false;\n        this.default = undefined;\n        this.fields = [];\n        this.name = name;\n        this.localName = (0,_names_js__WEBPACK_IMPORTED_MODULE_0__/* .localOneofName */ .uA)(name);\n    }\n    addField(field) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__/* .assert */ .hu)(field.oneof === this, `field ${field.name} not one of ${this.name}`);\n        this.fields.push(field);\n    }\n    findField(localName) {\n        if (!this._lookup) {\n            this._lookup = Object.create(null);\n            for (let i = 0; i < this.fields.length; i++) {\n                this._lookup[this.fields[i].localName] = this.fields[i];\n            }\n        }\n        return this._lookup[localName];\n    }\n}\n\n\n/***/ }),\n\n/***/ 814:\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_405845__) => {\n\n/* harmony export */ __nested_webpack_require_405845__.d(__nested_webpack_exports__, {\n/* harmony export */   b: () => (/* binding */ makeJsonFormatCommon)\n/* harmony export */ });\n/* harmony import */ var _message_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_405845__(561);\n/* harmony import */ var _field_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_405845__(465);\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_405845__(120);\n/* harmony import */ var _proto_int64_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_405845__(210);\n/* harmony import */ var _proto_base64_js__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_405845__(236);\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n\n\n/* eslint-disable no-case-declarations, @typescript-eslint/restrict-plus-operands,@typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-argument */\n// Default options for parsing JSON.\nconst jsonReadDefaults = {\n    ignoreUnknownFields: false,\n};\n// Default options for serializing to JSON.\nconst jsonWriteDefaults = {\n    emitDefaultValues: false,\n    enumAsInteger: false,\n    useProtoFieldName: false,\n    prettySpaces: 0,\n};\nfunction makeReadOptions(options) {\n    return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;\n}\nfunction makeWriteOptions(options) {\n    return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;\n}\nfunction makeJsonFormatCommon(makeWriteField) {\n    const writeField = makeWriteField(writeEnum, writeScalar);\n    return {\n        makeReadOptions,\n        makeWriteOptions,\n        readMessage(type, json, options, message) {\n            if (json == null || Array.isArray(json) || typeof json != \"object\") {\n                throw new Error(`cannot decode message ${type.typeName} from JSON: ${this.debug(json)}`);\n            }\n            message = message !== null && message !== void 0 ? message : new type();\n            const oneofSeen = {};\n            for (const [jsonKey, jsonValue] of Object.entries(json)) {\n                const field = type.fields.findJsonName(jsonKey);\n                if (!field) {\n                    if (!options.ignoreUnknownFields) {\n                        throw new Error(`cannot decode message ${type.typeName} from JSON: key \"${jsonKey}\" is unknown`);\n                    }\n                    continue;\n                }\n                let localName = field.localName;\n                let target = message;\n                if (field.oneof) {\n                    if (jsonValue === null && field.kind == \"scalar\") {\n                        // see conformance test Required.Proto3.JsonInput.OneofFieldNull{First,Second}\n                        continue;\n                    }\n                    const seen = oneofSeen[field.oneof.localName];\n                    if (seen) {\n                        throw new Error(`cannot decode message ${type.typeName} from JSON: multiple keys for oneof \"${field.oneof.name}\" present: \"${seen}\", \"${jsonKey}\"`);\n                    }\n                    oneofSeen[field.oneof.localName] = jsonKey;\n                    target = target[field.oneof.localName] = { case: localName };\n                    localName = \"value\";\n                }\n                if (field.repeated) {\n                    if (jsonValue === null) {\n                        continue;\n                    }\n                    if (!Array.isArray(jsonValue)) {\n                        throw new Error(`cannot decode field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonValue)}`);\n                    }\n                    const targetArray = target[localName];\n                    for (const jsonItem of jsonValue) {\n                        if (jsonItem === null) {\n                            throw new Error(`cannot decode field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonItem)}`);\n                        }\n                        let val;\n                        // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- \"map\" is invalid for repeated fields\n                        switch (field.kind) {\n                            case \"message\":\n                                val = field.T.fromJson(jsonItem, options);\n                                break;\n                            case \"enum\":\n                                val = readEnum(field.T, jsonItem, options.ignoreUnknownFields);\n                                if (val === undefined)\n                                    continue;\n                                break;\n                            case \"scalar\":\n                                try {\n                                    val = readScalar(field.T, jsonItem, field.L);\n                                }\n                                catch (e) {\n                                    let m = `cannot decode field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonItem)}`;\n                                    if (e instanceof Error && e.message.length > 0) {\n                                        m += `: ${e.message}`;\n                                    }\n                                    throw new Error(m);\n                                }\n                                break;\n                        }\n                        targetArray.push(val);\n                    }\n                }\n                else if (field.kind == \"map\") {\n                    if (jsonValue === null) {\n                        continue;\n                    }\n                    if (Array.isArray(jsonValue) || typeof jsonValue != \"object\") {\n                        throw new Error(`cannot decode field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonValue)}`);\n                    }\n                    const targetMap = target[localName];\n                    for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)) {\n                        if (jsonMapValue === null) {\n                            throw new Error(`cannot decode field ${type.typeName}.${field.name} from JSON: map value null`);\n                        }\n                        let val;\n                        switch (field.V.kind) {\n                            case \"message\":\n                                val = field.V.T.fromJson(jsonMapValue, options);\n                                break;\n                            case \"enum\":\n                                val = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields);\n                                if (val === undefined)\n                                    continue;\n                                break;\n                            case \"scalar\":\n                                try {\n                                    val = readScalar(field.V.T, jsonMapValue, _field_js__WEBPACK_IMPORTED_MODULE_0__/* .LongType */ .p.BIGINT);\n                                }\n                                catch (e) {\n                                    let m = `cannot decode map value for field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonValue)}`;\n                                    if (e instanceof Error && e.message.length > 0) {\n                                        m += `: ${e.message}`;\n                                    }\n                                    throw new Error(m);\n                                }\n                                break;\n                        }\n                        try {\n                            targetMap[readScalar(field.K, field.K == _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.BOOL\n                                ? jsonMapKey == \"true\"\n                                    ? true\n                                    : jsonMapKey == \"false\"\n                                        ? false\n                                        : jsonMapKey\n                                : jsonMapKey, _field_js__WEBPACK_IMPORTED_MODULE_0__/* .LongType */ .p.BIGINT).toString()] = val;\n                        }\n                        catch (e) {\n                            let m = `cannot decode map key for field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonValue)}`;\n                            if (e instanceof Error && e.message.length > 0) {\n                                m += `: ${e.message}`;\n                            }\n                            throw new Error(m);\n                        }\n                    }\n                }\n                else {\n                    switch (field.kind) {\n                        case \"message\":\n                            const messageType = field.T;\n                            if (jsonValue === null &&\n                                messageType.typeName != \"google.protobuf.Value\") {\n                                if (field.oneof) {\n                                    throw new Error(`cannot decode field ${type.typeName}.${field.name} from JSON: null is invalid for oneof field \"${jsonKey}\"`);\n                                }\n                                continue;\n                            }\n                            if (target[localName] instanceof _message_js__WEBPACK_IMPORTED_MODULE_1__/* .Message */ .v) {\n                                target[localName].fromJson(jsonValue, options);\n                            }\n                            else {\n                                target[localName] = messageType.fromJson(jsonValue, options);\n                                if (messageType.fieldWrapper && !field.oneof) {\n                                    target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);\n                                }\n                            }\n                            break;\n                        case \"enum\":\n                            const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields);\n                            if (enumValue !== undefined) {\n                                target[localName] = enumValue;\n                            }\n                            break;\n                        case \"scalar\":\n                            try {\n                                target[localName] = readScalar(field.T, jsonValue, field.L);\n                            }\n                            catch (e) {\n                                let m = `cannot decode field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonValue)}`;\n                                if (e instanceof Error && e.message.length > 0) {\n                                    m += `: ${e.message}`;\n                                }\n                                throw new Error(m);\n                            }\n                            break;\n                    }\n                }\n            }\n            return message;\n        },\n        writeMessage(message, options) {\n            const type = message.getType();\n            const json = {};\n            let field;\n            try {\n                for (const member of type.fields.byMember()) {\n                    let jsonValue;\n                    if (member.kind == \"oneof\") {\n                        const oneof = message[member.localName];\n                        if (oneof.value === undefined) {\n                            continue;\n                        }\n                        field = member.findField(oneof.case);\n                        if (!field) {\n                            throw \"oneof case not found: \" + oneof.case;\n                        }\n                        jsonValue = writeField(field, oneof.value, options);\n                    }\n                    else {\n                        field = member;\n                        jsonValue = writeField(field, message[field.localName], options);\n                    }\n                    if (jsonValue !== undefined) {\n                        json[options.useProtoFieldName ? field.name : field.jsonName] =\n                            jsonValue;\n                    }\n                }\n            }\n            catch (e) {\n                const m = field\n                    ? `cannot encode field ${type.typeName}.${field.name} to JSON`\n                    : `cannot encode message ${type.typeName} to JSON`;\n                const r = e instanceof Error ? e.message : String(e);\n                throw new Error(m + (r.length > 0 ? `: ${r}` : \"\"));\n            }\n            return json;\n        },\n        readScalar,\n        writeScalar,\n        debug: debugJsonValue,\n    };\n}\nfunction debugJsonValue(json) {\n    if (json === null) {\n        return \"null\";\n    }\n    switch (typeof json) {\n        case \"object\":\n            return Array.isArray(json) ? \"array\" : \"object\";\n        case \"string\":\n            return json.length > 100 ? \"string\" : `\"${json.split('\"').join('\\\\\"')}\"`;\n        default:\n            return String(json);\n    }\n}\n// May throw an error. If the error message is non-blank, it should be shown.\n// It is up to the caller to provide context.\nfunction readScalar(type, json, longType) {\n    // every valid case in the switch below returns, and every fall\n    // through is regarded as a failure.\n    switch (type) {\n        // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n        // Either numbers or strings are accepted. Exponent notation is also accepted.\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.DOUBLE:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.FLOAT:\n            if (json === null)\n                return 0.0;\n            if (json === \"NaN\")\n                return Number.NaN;\n            if (json === \"Infinity\")\n                return Number.POSITIVE_INFINITY;\n            if (json === \"-Infinity\")\n                return Number.NEGATIVE_INFINITY;\n            if (json === \"\") {\n                // empty string is not a number\n                break;\n            }\n            if (typeof json == \"string\" && json.trim().length !== json.length) {\n                // extra whitespace\n                break;\n            }\n            if (typeof json != \"string\" && typeof json != \"number\") {\n                break;\n            }\n            const float = Number(json);\n            if (Number.isNaN(float)) {\n                // not a number\n                break;\n            }\n            if (!Number.isFinite(float)) {\n                // infinity and -infinity are handled by string representation above, so this is an error\n                break;\n            }\n            if (type == _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.FLOAT)\n                (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__/* .assertFloat32 */ .E_)(float);\n            return float;\n        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.INT32:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.FIXED32:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.SFIXED32:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.SINT32:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.UINT32:\n            if (json === null)\n                return 0;\n            let int32;\n            if (typeof json == \"number\")\n                int32 = json;\n            else if (typeof json == \"string\" && json.length > 0) {\n                if (json.trim().length === json.length)\n                    int32 = Number(json);\n            }\n            if (int32 === undefined)\n                break;\n            if (type == _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.UINT32)\n                (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__/* .assertUInt32 */ .fp)(int32);\n            else\n                (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__/* .assertInt32 */ .ug)(int32);\n            return int32;\n        // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.INT64:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.SFIXED64:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.SINT64:\n            if (json === null)\n                return _proto_int64_js__WEBPACK_IMPORTED_MODULE_3__/* .protoInt64 */ .q.zero;\n            if (typeof json != \"number\" && typeof json != \"string\")\n                break;\n            const long = _proto_int64_js__WEBPACK_IMPORTED_MODULE_3__/* .protoInt64 */ .q.parse(json);\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            return longType ? long.toString() : long;\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.FIXED64:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.UINT64:\n            if (json === null)\n                return _proto_int64_js__WEBPACK_IMPORTED_MODULE_3__/* .protoInt64 */ .q.zero;\n            if (typeof json != \"number\" && typeof json != \"string\")\n                break;\n            const uLong = _proto_int64_js__WEBPACK_IMPORTED_MODULE_3__/* .protoInt64 */ .q.uParse(json);\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            return longType ? uLong.toString() : uLong;\n        // bool:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.BOOL:\n            if (json === null)\n                return false;\n            if (typeof json !== \"boolean\")\n                break;\n            return json;\n        // string:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.STRING:\n            if (json === null)\n                return \"\";\n            if (typeof json !== \"string\") {\n                break;\n            }\n            // A string must always contain UTF-8 encoded or 7-bit ASCII.\n            // We validate with encodeURIComponent, which appears to be the fastest widely available option.\n            try {\n                encodeURIComponent(json);\n            }\n            catch (e) {\n                throw new Error(\"invalid UTF8\");\n            }\n            return json;\n        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n        // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.BYTES:\n            if (json === null || json === \"\")\n                return new Uint8Array(0);\n            if (typeof json !== \"string\")\n                break;\n            return _proto_base64_js__WEBPACK_IMPORTED_MODULE_4__/* .protoBase64 */ .W.dec(json);\n    }\n    throw new Error();\n}\nfunction readEnum(type, json, ignoreUnknownFields) {\n    if (json === null) {\n        // proto3 requires 0 to be default value for all enums\n        return 0;\n    }\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n    switch (typeof json) {\n        case \"number\":\n            if (Number.isInteger(json)) {\n                return json;\n            }\n            break;\n        case \"string\":\n            const value = type.findName(json);\n            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n            if (value || ignoreUnknownFields) {\n                return value === null || value === void 0 ? void 0 : value.no;\n            }\n            break;\n    }\n    throw new Error(`cannot decode enum ${type.typeName} from JSON: ${debugJsonValue(json)}`);\n}\nfunction writeEnum(type, value, emitIntrinsicDefault, enumAsInteger) {\n    var _a;\n    if (value === undefined) {\n        return value;\n    }\n    if (value === 0 && !emitIntrinsicDefault) {\n        // proto3 requires 0 to be default value for all enums\n        return undefined;\n    }\n    if (enumAsInteger) {\n        return value;\n    }\n    if (type.typeName == \"google.protobuf.NullValue\") {\n        return null;\n    }\n    const val = type.findNumber(value);\n    return (_a = val === null || val === void 0 ? void 0 : val.name) !== null && _a !== void 0 ? _a : value; // if we don't know the enum value, just return the number\n}\nfunction writeScalar(type, value, emitIntrinsicDefault) {\n    if (value === undefined) {\n        return undefined;\n    }\n    switch (type) {\n        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.INT32:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.SFIXED32:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.SINT32:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.FIXED32:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.UINT32:\n            (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__/* .assert */ .hu)(typeof value == \"number\");\n            return value != 0 || emitIntrinsicDefault ? value : undefined;\n        // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n        // Either numbers or strings are accepted. Exponent notation is also accepted.\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.FLOAT:\n        // assertFloat32(value);\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.DOUBLE: // eslint-disable-line no-fallthrough\n            (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__/* .assert */ .hu)(typeof value == \"number\");\n            if (Number.isNaN(value))\n                return \"NaN\";\n            if (value === Number.POSITIVE_INFINITY)\n                return \"Infinity\";\n            if (value === Number.NEGATIVE_INFINITY)\n                return \"-Infinity\";\n            return value !== 0 || emitIntrinsicDefault ? value : undefined;\n        // string:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.STRING:\n            (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__/* .assert */ .hu)(typeof value == \"string\");\n            return value.length > 0 || emitIntrinsicDefault ? value : undefined;\n        // bool:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.BOOL:\n            (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__/* .assert */ .hu)(typeof value == \"boolean\");\n            return value || emitIntrinsicDefault ? value : undefined;\n        // JSON value will be a decimal string. Either numbers or strings are accepted.\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.UINT64:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.FIXED64:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.INT64:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.SFIXED64:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.SINT64:\n            (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__/* .assert */ .hu)(typeof value == \"bigint\" ||\n                typeof value == \"string\" ||\n                typeof value == \"number\");\n            // We use implicit conversion with `value != 0` to catch both 0n and \"0\"\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            return emitIntrinsicDefault || value != 0\n                ? value.toString(10)\n                : undefined;\n        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n        // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.BYTES:\n            (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__/* .assert */ .hu)(value instanceof Uint8Array);\n            return emitIntrinsicDefault || value.byteLength > 0\n                ? _proto_base64_js__WEBPACK_IMPORTED_MODULE_4__/* .protoBase64 */ .W.enc(value)\n                : undefined;\n    }\n}\n\n\n/***/ }),\n\n/***/ 504:\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_430676__) => {\n\n/* harmony export */ __nested_webpack_require_430676__.d(__nested_webpack_exports__, {\n/* harmony export */   GD: () => (/* binding */ safeIdentifier),\n/* harmony export */   Rz: () => (/* binding */ localFieldName),\n/* harmony export */   Sm: () => (/* binding */ findEnumSharedPrefix),\n/* harmony export */   ll: () => (/* binding */ safeObjectProperty),\n/* harmony export */   r1: () => (/* binding */ localName),\n/* harmony export */   uA: () => (/* binding */ localOneofName),\n/* harmony export */   x1: () => (/* binding */ fieldJsonName)\n/* harmony export */ });\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Returns the name of a protobuf element in generated code.\n *\n * Field names - including oneofs - are converted to lowerCamelCase. For\n * messages, enumerations and services, the package name is stripped from\n * the type name. For nested messages and enumerations, the names are joined\n * with an underscore. For methods, the first character is made lowercase.\n */\nfunction localName(desc) {\n    switch (desc.kind) {\n        case \"field\":\n            return localFieldName(desc.name, desc.oneof !== undefined);\n        case \"oneof\":\n            return localOneofName(desc.name);\n        case \"enum\":\n        case \"message\":\n        case \"service\": {\n            const pkg = desc.file.proto.package;\n            const offset = pkg === undefined ? 0 : pkg.length + 1;\n            const name = desc.typeName.substring(offset).replace(/\\./g, \"_\");\n            // For services, we only care about safe identifiers, not safe object properties,\n            // but we have shipped v1 with a bug that respected object properties, and we\n            // do not want to introduce a breaking change, so we continue to escape for\n            // safe object properties.\n            // See https://github.com/bufbuild/protobuf-es/pull/391\n            return safeObjectProperty(safeIdentifier(name));\n        }\n        case \"enum_value\": {\n            const sharedPrefix = desc.parent.sharedPrefix;\n            if (sharedPrefix === undefined) {\n                return desc.name;\n            }\n            const name = desc.name.substring(sharedPrefix.length);\n            return safeObjectProperty(name);\n        }\n        case \"rpc\": {\n            let name = desc.name;\n            if (name.length == 0) {\n                return name;\n            }\n            name = name[0].toLowerCase() + name.substring(1);\n            return safeObjectProperty(name);\n        }\n    }\n}\n/**\n * Returns the name of a field in generated code.\n */\nfunction localFieldName(protoName, inOneof) {\n    const name = protoCamelCase(protoName);\n    if (inOneof) {\n        // oneof member names are not properties, but values of the `case` property.\n        return name;\n    }\n    return safeObjectProperty(safeMessageProperty(name));\n}\n/**\n * Returns the name of a oneof group in generated code.\n */\nfunction localOneofName(protoName) {\n    return localFieldName(protoName, false);\n}\n/**\n * Returns the JSON name for a protobuf field, exactly like protoc does.\n */\nconst fieldJsonName = protoCamelCase;\n/**\n * Finds a prefix shared by enum values, for example `MY_ENUM_` for\n * `enum MyEnum {MY_ENUM_A=0; MY_ENUM_B=1;}`.\n */\nfunction findEnumSharedPrefix(enumName, valueNames) {\n    const prefix = camelToSnakeCase(enumName) + \"_\";\n    for (const name of valueNames) {\n        if (!name.toLowerCase().startsWith(prefix)) {\n            return undefined;\n        }\n        const shortName = name.substring(prefix.length);\n        if (shortName.length == 0) {\n            return undefined;\n        }\n        if (/^\\d/.test(shortName)) {\n            // identifiers must not start with numbers\n            return undefined;\n        }\n    }\n    return prefix;\n}\n/**\n * Converts lowerCamelCase or UpperCamelCase into lower_snake_case.\n * This is used to find shared prefixes in an enum.\n */\nfunction camelToSnakeCase(camel) {\n    return (camel.substring(0, 1) + camel.substring(1).replace(/[A-Z]/g, (c) => \"_\" + c)).toLowerCase();\n}\n/**\n * Converts snake_case to protoCamelCase according to the convention\n * used by protoc to convert a field name to a JSON name.\n */\nfunction protoCamelCase(snakeCase) {\n    let capNext = false;\n    const b = [];\n    for (let i = 0; i < snakeCase.length; i++) {\n        let c = snakeCase.charAt(i);\n        switch (c) {\n            case \"_\":\n                capNext = true;\n                break;\n            case \"0\":\n            case \"1\":\n            case \"2\":\n            case \"3\":\n            case \"4\":\n            case \"5\":\n            case \"6\":\n            case \"7\":\n            case \"8\":\n            case \"9\":\n                b.push(c);\n                capNext = false;\n                break;\n            default:\n                if (capNext) {\n                    capNext = false;\n                    c = c.toUpperCase();\n                }\n                b.push(c);\n                break;\n        }\n    }\n    return b.join(\"\");\n}\n/**\n * Names that cannot be used for identifiers, such as class names,\n * but _can_ be used for object properties.\n */\nconst reservedIdentifiers = new Set([\n    // ECMAScript 2015 keywords\n    \"break\",\n    \"case\",\n    \"catch\",\n    \"class\",\n    \"const\",\n    \"continue\",\n    \"debugger\",\n    \"default\",\n    \"delete\",\n    \"do\",\n    \"else\",\n    \"export\",\n    \"extends\",\n    \"false\",\n    \"finally\",\n    \"for\",\n    \"function\",\n    \"if\",\n    \"import\",\n    \"in\",\n    \"instanceof\",\n    \"new\",\n    \"null\",\n    \"return\",\n    \"super\",\n    \"switch\",\n    \"this\",\n    \"throw\",\n    \"true\",\n    \"try\",\n    \"typeof\",\n    \"var\",\n    \"void\",\n    \"while\",\n    \"with\",\n    \"yield\",\n    // ECMAScript 2015 future reserved keywords\n    \"enum\",\n    \"implements\",\n    \"interface\",\n    \"let\",\n    \"package\",\n    \"private\",\n    \"protected\",\n    \"public\",\n    \"static\",\n    // Class name cannot be 'Object' when targeting ES5 with module CommonJS\n    \"Object\",\n    // TypeScript keywords that cannot be used for types (as opposed to variables)\n    \"bigint\",\n    \"number\",\n    \"boolean\",\n    \"string\",\n    \"object\",\n    // Identifiers reserved for the runtime, so we can generate legible code\n    \"globalThis\",\n    \"Uint8Array\",\n    \"Partial\",\n]);\n/**\n * Names that cannot be used for object properties because they are reserved\n * by built-in JavaScript properties.\n */\nconst reservedObjectProperties = new Set([\n    // names reserved by JavaScript\n    \"constructor\",\n    \"toString\",\n    \"toJSON\",\n    \"valueOf\",\n]);\n/**\n * Names that cannot be used for object properties because they are reserved\n * by the runtime.\n */\nconst reservedMessageProperties = new Set([\n    // names reserved by the runtime\n    \"getType\",\n    \"clone\",\n    \"equals\",\n    \"fromBinary\",\n    \"fromJson\",\n    \"fromJsonString\",\n    \"toBinary\",\n    \"toJson\",\n    \"toJsonString\",\n    // names reserved by the runtime for the future\n    \"toObject\",\n]);\nconst fallback = (name) => `${name}$`;\n/**\n * Will wrap names that are Object prototype properties or names reserved\n * for `Message`s.\n */\nconst safeMessageProperty = (name) => {\n    if (reservedMessageProperties.has(name)) {\n        return fallback(name);\n    }\n    return name;\n};\n/**\n * Names that cannot be used for object properties because they are reserved\n * by built-in JavaScript properties.\n */\nconst safeObjectProperty = (name) => {\n    if (reservedObjectProperties.has(name)) {\n        return fallback(name);\n    }\n    return name;\n};\n/**\n * Names that can be used for identifiers or class properties\n */\nconst safeIdentifier = (name) => {\n    if (reservedIdentifiers.has(name)) {\n        return fallback(name);\n    }\n    return name;\n};\n\n\n/***/ }),\n\n/***/ 493:\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_438925__) => {\n\n\n// EXPORTS\n__nested_webpack_require_438925__.d(__nested_webpack_exports__, {\n  F: () => (/* binding */ makeProtoRuntime)\n});\n\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/enum.js\nvar private_enum = __nested_webpack_require_438925__(609);\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/message.js\nvar message = __nested_webpack_require_438925__(561);\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/message-type.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * Create a new message type using the given runtime.\n */\nfunction makeMessageType(runtime, typeName, fields, opt) {\n    var _a;\n    const localName = (_a = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a !== void 0 ? _a : typeName.substring(typeName.lastIndexOf(\".\") + 1);\n    const type = {\n        [localName]: function (data) {\n            runtime.util.initFields(this);\n            runtime.util.initPartial(data, this);\n        },\n    }[localName];\n    Object.setPrototypeOf(type.prototype, new message/* Message */.v());\n    Object.assign(type, {\n        runtime,\n        typeName,\n        fields: runtime.util.newFieldList(fields),\n        fromBinary(bytes, options) {\n            return new type().fromBinary(bytes, options);\n        },\n        fromJson(jsonValue, options) {\n            return new type().fromJson(jsonValue, options);\n        },\n        fromJsonString(jsonString, options) {\n            return new type().fromJsonString(jsonString, options);\n        },\n        equals(a, b) {\n            return runtime.util.equals(type, a, b);\n        },\n    });\n    return type;\n}\n\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/proto-runtime.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\nfunction makeProtoRuntime(syntax, json, bin, util) {\n    return {\n        syntax,\n        json,\n        bin,\n        util,\n        makeMessageType(typeName, fields, opt) {\n            return makeMessageType(this, typeName, fields, opt);\n        },\n        makeEnum: private_enum/* makeEnum */.ut,\n        makeEnumType: private_enum/* makeEnumType */.be,\n        getEnumType: private_enum/* getEnumType */.V3,\n    };\n}\n\n\n/***/ }),\n\n/***/ 781:\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_442323__) => {\n\n/* harmony export */ __nested_webpack_require_442323__.d(__nested_webpack_exports__, {\n/* harmony export */   AA: () => (/* binding */ scalarEquals),\n/* harmony export */   T1: () => (/* binding */ scalarTypeInfo),\n/* harmony export */   kY: () => (/* binding */ scalarDefaultValue)\n/* harmony export */ });\n/* harmony import */ var _field_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_442323__(465);\n/* harmony import */ var _binary_encoding_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_442323__(79);\n/* harmony import */ var _proto_int64_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_442323__(210);\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Returns true if both scalar values are equal.\n */\nfunction scalarEquals(type, a, b) {\n    if (a === b) {\n        // This correctly matches equal values except BYTES and (possibly) 64-bit integers.\n        return true;\n    }\n    // Special case BYTES - we need to compare each byte individually\n    if (type == _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.BYTES) {\n        if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {\n            return false;\n        }\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0; i < a.length; i++) {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // Special case 64-bit integers - we support number, string and bigint representation.\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n    switch (type) {\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.UINT64:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.FIXED64:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.INT64:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.SFIXED64:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.SINT64:\n            // Loose comparison will match between 0n, 0 and \"0\".\n            return a == b;\n    }\n    // Anything that hasn't been caught by strict comparison or special cased\n    // BYTES and 64-bit integers is not equal.\n    return false;\n}\n/**\n * Returns the default value for the given scalar type, following\n * proto3 semantics.\n */\nfunction scalarDefaultValue(type, longType) {\n    switch (type) {\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.BOOL:\n            return false;\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.UINT64:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.FIXED64:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.INT64:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.SFIXED64:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.SINT64:\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\n            return longType == 0 ? _proto_int64_js__WEBPACK_IMPORTED_MODULE_1__/* .protoInt64 */ .q.zero : \"0\";\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.DOUBLE:\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.FLOAT:\n            return 0.0;\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.BYTES:\n            return new Uint8Array(0);\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.STRING:\n            return \"\";\n        default:\n            // Handles INT32, UINT32, SINT32, FIXED32, SFIXED32.\n            // We do not use individual cases to save a few bytes code size.\n            return 0;\n    }\n}\n/**\n * Get information for writing a scalar value.\n *\n * Returns tuple:\n * [0]: appropriate WireType\n * [1]: name of the appropriate method of IBinaryWriter\n * [2]: whether the given value is a default value for proto3 semantics\n *\n * If argument `value` is omitted, [2] is always false.\n */\nfunction scalarTypeInfo(type, value) {\n    const isUndefined = value === undefined;\n    let wireType = _binary_encoding_js__WEBPACK_IMPORTED_MODULE_2__/* .WireType */ .TD.Varint;\n    let isIntrinsicDefault = value === 0;\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- INT32, UINT32, SINT32 are covered by the defaults\n    switch (type) {\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.STRING:\n            isIntrinsicDefault = isUndefined || !value.length;\n            wireType = _binary_encoding_js__WEBPACK_IMPORTED_MODULE_2__/* .WireType */ .TD.LengthDelimited;\n            break;\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.BOOL:\n            isIntrinsicDefault = value === false;\n            break;\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.DOUBLE:\n            wireType = _binary_encoding_js__WEBPACK_IMPORTED_MODULE_2__/* .WireType */ .TD.Bit64;\n            break;\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.FLOAT:\n            wireType = _binary_encoding_js__WEBPACK_IMPORTED_MODULE_2__/* .WireType */ .TD.Bit32;\n            break;\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.INT64:\n            isIntrinsicDefault = isUndefined || value == 0; // Loose comparison matches 0n, 0 and \"0\"\n            break;\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.UINT64:\n            isIntrinsicDefault = isUndefined || value == 0; // Loose comparison matches 0n, 0 and \"0\"\n            break;\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.FIXED64:\n            isIntrinsicDefault = isUndefined || value == 0; // Loose comparison matches 0n, 0 and \"0\"\n            wireType = _binary_encoding_js__WEBPACK_IMPORTED_MODULE_2__/* .WireType */ .TD.Bit64;\n            break;\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.BYTES:\n            isIntrinsicDefault = isUndefined || !value.byteLength;\n            wireType = _binary_encoding_js__WEBPACK_IMPORTED_MODULE_2__/* .WireType */ .TD.LengthDelimited;\n            break;\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.FIXED32:\n            wireType = _binary_encoding_js__WEBPACK_IMPORTED_MODULE_2__/* .WireType */ .TD.Bit32;\n            break;\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.SFIXED32:\n            wireType = _binary_encoding_js__WEBPACK_IMPORTED_MODULE_2__/* .WireType */ .TD.Bit32;\n            break;\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.SFIXED64:\n            isIntrinsicDefault = isUndefined || value == 0;\n            wireType = _binary_encoding_js__WEBPACK_IMPORTED_MODULE_2__/* .WireType */ .TD.Bit64;\n            break;\n        case _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w.SINT64:\n            isIntrinsicDefault = isUndefined || value == 0;\n            break;\n    }\n    const method = _field_js__WEBPACK_IMPORTED_MODULE_0__/* .ScalarType */ .w[type].toLowerCase();\n    return [wireType, method, isUndefined || isIntrinsicDefault];\n}\n\n\n/***/ }),\n\n/***/ 433:\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_450178__) => {\n\n/* harmony export */ __nested_webpack_require_450178__.d(__nested_webpack_exports__, {\n/* harmony export */   f: () => (/* binding */ makeUtilCommon)\n/* harmony export */ });\n/* harmony import */ var _enum_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_450178__(609);\n/* harmony import */ var _message_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_450178__(561);\n/* harmony import */ var _field_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_450178__(465);\n/* harmony import */ var _scalars_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_450178__(781);\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n\n/* eslint-disable @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-argument,no-case-declarations */\nfunction makeUtilCommon() {\n    return {\n        setEnumType: _enum_js__WEBPACK_IMPORTED_MODULE_0__/* .setEnumType */ .zg,\n        initPartial(source, target) {\n            if (source === undefined) {\n                return;\n            }\n            const type = target.getType();\n            for (const member of type.fields.byMember()) {\n                const localName = member.localName, t = target, s = source;\n                if (s[localName] === undefined) {\n                    continue;\n                }\n                switch (member.kind) {\n                    case \"oneof\":\n                        const sk = s[localName].case;\n                        if (sk === undefined) {\n                            continue;\n                        }\n                        const sourceField = member.findField(sk);\n                        let val = s[localName].value;\n                        if (sourceField &&\n                            sourceField.kind == \"message\" &&\n                            !(val instanceof sourceField.T)) {\n                            val = new sourceField.T(val);\n                        }\n                        else if (sourceField &&\n                            sourceField.kind === \"scalar\" &&\n                            sourceField.T === _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.BYTES) {\n                            val = toU8Arr(val);\n                        }\n                        t[localName] = { case: sk, value: val };\n                        break;\n                    case \"scalar\":\n                    case \"enum\":\n                        let copy = s[localName];\n                        if (member.T === _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.BYTES) {\n                            copy = member.repeated\n                                ? copy.map(toU8Arr)\n                                : toU8Arr(copy);\n                        }\n                        t[localName] = copy;\n                        break;\n                    case \"map\":\n                        switch (member.V.kind) {\n                            case \"scalar\":\n                            case \"enum\":\n                                if (member.V.T === _field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.BYTES) {\n                                    for (const [k, v] of Object.entries(s[localName])) {\n                                        t[localName][k] = toU8Arr(v);\n                                    }\n                                }\n                                else {\n                                    Object.assign(t[localName], s[localName]);\n                                }\n                                break;\n                            case \"message\":\n                                const messageType = member.V.T;\n                                for (const k of Object.keys(s[localName])) {\n                                    let val = s[localName][k];\n                                    if (!messageType.fieldWrapper) {\n                                        // We only take partial input for messages that are not a wrapper type.\n                                        // For those messages, we recursively normalize the partial input.\n                                        val = new messageType(val);\n                                    }\n                                    t[localName][k] = val;\n                                }\n                                break;\n                        }\n                        break;\n                    case \"message\":\n                        const mt = member.T;\n                        if (member.repeated) {\n                            t[localName] = s[localName].map((val) => val instanceof mt ? val : new mt(val));\n                        }\n                        else if (s[localName] !== undefined) {\n                            const val = s[localName];\n                            if (mt.fieldWrapper) {\n                                if (\n                                // We can't use BytesValue.typeName as that will create a circular import\n                                mt.typeName === \"google.protobuf.BytesValue\") {\n                                    t[localName] = toU8Arr(val);\n                                }\n                                else {\n                                    t[localName] = val;\n                                }\n                            }\n                            else {\n                                t[localName] = val instanceof mt ? val : new mt(val);\n                            }\n                        }\n                        break;\n                }\n            }\n        },\n        equals(type, a, b) {\n            if (a === b) {\n                return true;\n            }\n            if (!a || !b) {\n                return false;\n            }\n            return type.fields.byMember().every((m) => {\n                const va = a[m.localName];\n                const vb = b[m.localName];\n                if (m.repeated) {\n                    if (va.length !== vb.length) {\n                        return false;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- repeated fields are never \"map\"\n                    switch (m.kind) {\n                        case \"message\":\n                            return va.every((a, i) => m.T.equals(a, vb[i]));\n                        case \"scalar\":\n                            return va.every((a, i) => (0,_scalars_js__WEBPACK_IMPORTED_MODULE_2__/* .scalarEquals */ .AA)(m.T, a, vb[i]));\n                        case \"enum\":\n                            return va.every((a, i) => (0,_scalars_js__WEBPACK_IMPORTED_MODULE_2__/* .scalarEquals */ .AA)(_field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.INT32, a, vb[i]));\n                    }\n                    throw new Error(`repeated cannot contain ${m.kind}`);\n                }\n                switch (m.kind) {\n                    case \"message\":\n                        return m.T.equals(va, vb);\n                    case \"enum\":\n                        return (0,_scalars_js__WEBPACK_IMPORTED_MODULE_2__/* .scalarEquals */ .AA)(_field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.INT32, va, vb);\n                    case \"scalar\":\n                        return (0,_scalars_js__WEBPACK_IMPORTED_MODULE_2__/* .scalarEquals */ .AA)(m.T, va, vb);\n                    case \"oneof\":\n                        if (va.case !== vb.case) {\n                            return false;\n                        }\n                        const s = m.findField(va.case);\n                        if (s === undefined) {\n                            return true;\n                        }\n                        // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- oneof fields are never \"map\"\n                        switch (s.kind) {\n                            case \"message\":\n                                return s.T.equals(va.value, vb.value);\n                            case \"enum\":\n                                return (0,_scalars_js__WEBPACK_IMPORTED_MODULE_2__/* .scalarEquals */ .AA)(_field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.INT32, va.value, vb.value);\n                            case \"scalar\":\n                                return (0,_scalars_js__WEBPACK_IMPORTED_MODULE_2__/* .scalarEquals */ .AA)(s.T, va.value, vb.value);\n                        }\n                        throw new Error(`oneof cannot contain ${s.kind}`);\n                    case \"map\":\n                        const keys = Object.keys(va).concat(Object.keys(vb));\n                        switch (m.V.kind) {\n                            case \"message\":\n                                const messageType = m.V.T;\n                                return keys.every((k) => messageType.equals(va[k], vb[k]));\n                            case \"enum\":\n                                return keys.every((k) => (0,_scalars_js__WEBPACK_IMPORTED_MODULE_2__/* .scalarEquals */ .AA)(_field_js__WEBPACK_IMPORTED_MODULE_1__/* .ScalarType */ .w.INT32, va[k], vb[k]));\n                            case \"scalar\":\n                                const scalarType = m.V.T;\n                                return keys.every((k) => (0,_scalars_js__WEBPACK_IMPORTED_MODULE_2__/* .scalarEquals */ .AA)(scalarType, va[k], vb[k]));\n                        }\n                        break;\n                }\n            });\n        },\n        clone(message) {\n            const type = message.getType(), target = new type(), any = target;\n            for (const member of type.fields.byMember()) {\n                const source = message[member.localName];\n                let copy;\n                if (member.repeated) {\n                    copy = source.map(cloneSingularField);\n                }\n                else if (member.kind == \"map\") {\n                    copy = any[member.localName];\n                    for (const [key, v] of Object.entries(source)) {\n                        copy[key] = cloneSingularField(v);\n                    }\n                }\n                else if (member.kind == \"oneof\") {\n                    const f = member.findField(source.case);\n                    copy = f\n                        ? { case: source.case, value: cloneSingularField(source.value) }\n                        : { case: undefined };\n                }\n                else {\n                    copy = cloneSingularField(source);\n                }\n                any[member.localName] = copy;\n            }\n            return target;\n        },\n    };\n}\n// clone a single field value - i.e. the element type of repeated fields, the value type of maps\nfunction cloneSingularField(value) {\n    if (value === undefined) {\n        return value;\n    }\n    if (value instanceof _message_js__WEBPACK_IMPORTED_MODULE_3__/* .Message */ .v) {\n        return value.clone();\n    }\n    if (value instanceof Uint8Array) {\n        const c = new Uint8Array(value.byteLength);\n        c.set(value);\n        return c;\n    }\n    return value;\n}\n// converts any ArrayLike<number> to Uint8Array if necessary.\nfunction toU8Arr(input) {\n    return input instanceof Uint8Array ? input : new Uint8Array(input);\n}\n\n\n/***/ }),\n\n/***/ 236:\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_461948__) => {\n\n/* harmony export */ __nested_webpack_require_461948__.d(__nested_webpack_exports__, {\n/* harmony export */   W: () => (/* binding */ protoBase64)\n/* harmony export */ });\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/ban-ts-comment, @typescript-eslint/no-unnecessary-condition, prefer-const */\n// lookup table from base64 character to byte\nlet encTable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\");\n// lookup table from base64 character *code* to byte because lookup by number is fast\nlet decTable = [];\nfor (let i = 0; i < encTable.length; i++)\n    decTable[encTable[i].charCodeAt(0)] = i;\n// support base64url variants\ndecTable[\"-\".charCodeAt(0)] = encTable.indexOf(\"+\");\ndecTable[\"_\".charCodeAt(0)] = encTable.indexOf(\"/\");\nconst protoBase64 = {\n    /**\n     * Decodes a base64 string to a byte array.\n     *\n     * - ignores white-space, including line breaks and tabs\n     * - allows inner padding (can decode concatenated base64 strings)\n     * - does not require padding\n     * - understands base64url encoding:\n     *   \"-\" instead of \"+\",\n     *   \"_\" instead of \"/\",\n     *   no padding\n     */\n    dec(base64Str) {\n        // estimate byte size, not accounting for inner padding and whitespace\n        let es = (base64Str.length * 3) / 4;\n        if (base64Str[base64Str.length - 2] == \"=\")\n            es -= 2;\n        else if (base64Str[base64Str.length - 1] == \"=\")\n            es -= 1;\n        let bytes = new Uint8Array(es), bytePos = 0, // position in byte array\n        groupPos = 0, // position in base64 group\n        b, // current byte\n        p = 0; // previous byte\n        for (let i = 0; i < base64Str.length; i++) {\n            b = decTable[base64Str.charCodeAt(i)];\n            if (b === undefined) {\n                switch (base64Str[i]) {\n                    // @ts-ignore TS7029: Fallthrough case in switch\n                    case \"=\":\n                        groupPos = 0; // reset state when padding found\n                    // @ts-ignore TS7029: Fallthrough case in switch\n                    case \"\\n\":\n                    case \"\\r\":\n                    case \"\\t\":\n                    case \" \":\n                        continue; // skip white-space, and padding\n                    default:\n                        throw Error(\"invalid base64 string.\");\n                }\n            }\n            switch (groupPos) {\n                case 0:\n                    p = b;\n                    groupPos = 1;\n                    break;\n                case 1:\n                    bytes[bytePos++] = (p << 2) | ((b & 48) >> 4);\n                    p = b;\n                    groupPos = 2;\n                    break;\n                case 2:\n                    bytes[bytePos++] = ((p & 15) << 4) | ((b & 60) >> 2);\n                    p = b;\n                    groupPos = 3;\n                    break;\n                case 3:\n                    bytes[bytePos++] = ((p & 3) << 6) | b;\n                    groupPos = 0;\n                    break;\n            }\n        }\n        if (groupPos == 1)\n            throw Error(\"invalid base64 string.\");\n        return bytes.subarray(0, bytePos);\n    },\n    /**\n     * Encode a byte array to a base64 string.\n     */\n    enc(bytes) {\n        let base64 = \"\", groupPos = 0, // position in base64 group\n        b, // current byte\n        p = 0; // carry over from previous byte\n        for (let i = 0; i < bytes.length; i++) {\n            b = bytes[i];\n            switch (groupPos) {\n                case 0:\n                    base64 += encTable[b >> 2];\n                    p = (b & 3) << 4;\n                    groupPos = 1;\n                    break;\n                case 1:\n                    base64 += encTable[p | (b >> 4)];\n                    p = (b & 15) << 2;\n                    groupPos = 2;\n                    break;\n                case 2:\n                    base64 += encTable[p | (b >> 6)];\n                    base64 += encTable[b & 63];\n                    groupPos = 0;\n                    break;\n            }\n        }\n        // add output padding\n        if (groupPos) {\n            base64 += encTable[p];\n            base64 += \"=\";\n            if (groupPos == 1)\n                base64 += \"=\";\n        }\n        return base64;\n    },\n};\n\n\n/***/ }),\n\n/***/ 210:\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_466912__) => {\n\n/* harmony export */ __nested_webpack_require_466912__.d(__nested_webpack_exports__, {\n/* harmony export */   q: () => (/* binding */ protoInt64)\n/* harmony export */ });\n/* harmony import */ var _private_assert_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_466912__(120);\n/* harmony import */ var _google_varint_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_466912__(818);\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\nfunction makeInt64Support() {\n    const dv = new DataView(new ArrayBuffer(8));\n    // note that Safari 14 implements BigInt, but not the DataView methods\n    const ok = typeof BigInt === \"function\" &&\n        typeof dv.getBigInt64 === \"function\" &&\n        typeof dv.getBigUint64 === \"function\" &&\n        typeof dv.setBigInt64 === \"function\" &&\n        typeof dv.setBigUint64 === \"function\" &&\n        (typeof process != \"object\" ||\n            typeof process.env != \"object\" ||\n            process.env.BUF_BIGINT_DISABLE !== \"1\");\n    if (ok) {\n        const MIN = BigInt(\"-9223372036854775808\"), MAX = BigInt(\"9223372036854775807\"), UMIN = BigInt(\"0\"), UMAX = BigInt(\"18446744073709551615\");\n        return {\n            zero: BigInt(0),\n            supported: true,\n            parse(value) {\n                const bi = typeof value == \"bigint\" ? value : BigInt(value);\n                if (bi > MAX || bi < MIN) {\n                    throw new Error(`int64 invalid: ${value}`);\n                }\n                return bi;\n            },\n            uParse(value) {\n                const bi = typeof value == \"bigint\" ? value : BigInt(value);\n                if (bi > UMAX || bi < UMIN) {\n                    throw new Error(`uint64 invalid: ${value}`);\n                }\n                return bi;\n            },\n            enc(value) {\n                dv.setBigInt64(0, this.parse(value), true);\n                return {\n                    lo: dv.getInt32(0, true),\n                    hi: dv.getInt32(4, true),\n                };\n            },\n            uEnc(value) {\n                dv.setBigInt64(0, this.uParse(value), true);\n                return {\n                    lo: dv.getInt32(0, true),\n                    hi: dv.getInt32(4, true),\n                };\n            },\n            dec(lo, hi) {\n                dv.setInt32(0, lo, true);\n                dv.setInt32(4, hi, true);\n                return dv.getBigInt64(0, true);\n            },\n            uDec(lo, hi) {\n                dv.setInt32(0, lo, true);\n                dv.setInt32(4, hi, true);\n                return dv.getBigUint64(0, true);\n            },\n        };\n    }\n    const assertInt64String = (value) => (0,_private_assert_js__WEBPACK_IMPORTED_MODULE_0__/* .assert */ .hu)(/^-?[0-9]+$/.test(value), `int64 invalid: ${value}`);\n    const assertUInt64String = (value) => (0,_private_assert_js__WEBPACK_IMPORTED_MODULE_0__/* .assert */ .hu)(/^[0-9]+$/.test(value), `uint64 invalid: ${value}`);\n    return {\n        zero: \"0\",\n        supported: false,\n        parse(value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertInt64String(value);\n            return value;\n        },\n        uParse(value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertUInt64String(value);\n            return value;\n        },\n        enc(value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertInt64String(value);\n            return (0,_google_varint_js__WEBPACK_IMPORTED_MODULE_1__/* .int64FromString */ .CZ)(value);\n        },\n        uEnc(value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertUInt64String(value);\n            return (0,_google_varint_js__WEBPACK_IMPORTED_MODULE_1__/* .int64FromString */ .CZ)(value);\n        },\n        dec(lo, hi) {\n            return (0,_google_varint_js__WEBPACK_IMPORTED_MODULE_1__/* .int64ToString */ .Ak)(lo, hi);\n        },\n        uDec(lo, hi) {\n            return (0,_google_varint_js__WEBPACK_IMPORTED_MODULE_1__/* .uInt64ToString */ .Fd)(lo, hi);\n        },\n    };\n}\nconst protoInt64 = makeInt64Support();\n\n\n/***/ }),\n\n/***/ 850:\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_471800__) => {\n\n\n// EXPORTS\n__nested_webpack_require_471800__.d(__nested_webpack_exports__, {\n  w: () => (/* binding */ proto3)\n});\n\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/proto-runtime.js + 1 modules\nvar proto_runtime = __nested_webpack_require_471800__(493);\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/field.js\nvar esm_field = __nested_webpack_require_471800__(465);\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/binary-format-common.js\nvar binary_format_common = __nested_webpack_require_471800__(744);\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/binary-format-proto3.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n/* eslint-disable @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unnecessary-condition, @typescript-eslint/strict-boolean-expressions, prefer-const, no-case-declarations */\nfunction makeBinaryFormatProto3() {\n    return Object.assign(Object.assign({}, (0,binary_format_common/* makeBinaryFormatCommon */.gY)()), { writeMessage(message, writer, options) {\n            const type = message.getType();\n            for (const field of type.fields.byNumber()) {\n                let value, // this will be our field value, whether it is member of a oneof or regular field\n                repeated = field.repeated, localName = field.localName;\n                if (field.oneof) {\n                    const oneof = message[field.oneof.localName];\n                    if (oneof.case !== localName) {\n                        continue; // field is not selected, skip\n                    }\n                    value = oneof.value;\n                }\n                else {\n                    value = message[localName];\n                }\n                switch (field.kind) {\n                    case \"scalar\":\n                    case \"enum\":\n                        let scalarType = field.kind == \"enum\" ? esm_field/* ScalarType */.w.INT32 : field.T;\n                        if (repeated) {\n                            if (field.packed) {\n                                (0,binary_format_common/* writePacked */.Jj)(writer, scalarType, field.no, value);\n                            }\n                            else {\n                                for (const item of value) {\n                                    (0,binary_format_common/* writeScalar */.NN)(writer, scalarType, field.no, item, true);\n                                }\n                            }\n                        }\n                        else {\n                            if (value !== undefined) {\n                                (0,binary_format_common/* writeScalar */.NN)(writer, scalarType, field.no, value, !!field.oneof || field.opt);\n                            }\n                        }\n                        break;\n                    case \"message\":\n                        if (repeated) {\n                            for (const item of value) {\n                                (0,binary_format_common/* writeMessageField */.oQ)(writer, options, field, item);\n                            }\n                        }\n                        else {\n                            (0,binary_format_common/* writeMessageField */.oQ)(writer, options, field, value);\n                        }\n                        break;\n                    case \"map\":\n                        for (const [key, val] of Object.entries(value)) {\n                            (0,binary_format_common/* writeMapEntry */.gQ)(writer, options, field, key, val);\n                        }\n                        break;\n                }\n            }\n            if (options.writeUnknownFields) {\n                this.writeUnknownFields(message, writer);\n            }\n            return writer;\n        } });\n}\n\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/field-wrapper.js\nvar field_wrapper = __nested_webpack_require_471800__(432);\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/assert.js\nvar assert = __nested_webpack_require_471800__(120);\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/json-format-common.js\nvar json_format_common = __nested_webpack_require_471800__(814);\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/json-format-proto3.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n/* eslint-disable no-case-declarations, @typescript-eslint/restrict-plus-operands,@typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-argument */\nfunction makeJsonFormatProto3() {\n    return (0,json_format_common/* makeJsonFormatCommon */.b)((writeEnum, writeScalar) => {\n        return function writeField(field, value, options) {\n            if (field.kind == \"map\") {\n                const jsonObj = {};\n                switch (field.V.kind) {\n                    case \"scalar\":\n                        for (const [entryKey, entryValue] of Object.entries(value)) {\n                            const val = writeScalar(field.V.T, entryValue, true);\n                            (0,assert/* assert */.hu)(val !== undefined);\n                            jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key\n                        }\n                        break;\n                    case \"message\":\n                        for (const [entryKey, entryValue] of Object.entries(value)) {\n                            // JSON standard allows only (double quoted) string as property key\n                            jsonObj[entryKey.toString()] = entryValue.toJson(options);\n                        }\n                        break;\n                    case \"enum\":\n                        const enumType = field.V.T;\n                        for (const [entryKey, entryValue] of Object.entries(value)) {\n                            (0,assert/* assert */.hu)(entryValue === undefined || typeof entryValue == \"number\");\n                            const val = writeEnum(enumType, entryValue, true, options.enumAsInteger);\n                            (0,assert/* assert */.hu)(val !== undefined);\n                            jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key\n                        }\n                        break;\n                }\n                return options.emitDefaultValues || Object.keys(jsonObj).length > 0\n                    ? jsonObj\n                    : undefined;\n            }\n            else if (field.repeated) {\n                const jsonArr = [];\n                switch (field.kind) {\n                    case \"scalar\":\n                        for (let i = 0; i < value.length; i++) {\n                            jsonArr.push(writeScalar(field.T, value[i], true));\n                        }\n                        break;\n                    case \"enum\":\n                        for (let i = 0; i < value.length; i++) {\n                            jsonArr.push(writeEnum(field.T, value[i], true, options.enumAsInteger));\n                        }\n                        break;\n                    case \"message\":\n                        for (let i = 0; i < value.length; i++) {\n                            jsonArr.push((0,field_wrapper/* wrapField */.E)(field.T, value[i]).toJson(options));\n                        }\n                        break;\n                }\n                return options.emitDefaultValues || jsonArr.length > 0\n                    ? jsonArr\n                    : undefined;\n            }\n            else {\n                switch (field.kind) {\n                    case \"scalar\":\n                        return writeScalar(field.T, value, !!field.oneof || field.opt || options.emitDefaultValues);\n                    case \"enum\":\n                        return writeEnum(field.T, value, !!field.oneof || field.opt || options.emitDefaultValues, options.enumAsInteger);\n                    case \"message\":\n                        return value !== undefined\n                            ? (0,field_wrapper/* wrapField */.E)(field.T, value).toJson(options)\n                            : undefined;\n                }\n            }\n        };\n    });\n}\n\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/util-common.js\nvar util_common = __nested_webpack_require_471800__(433);\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/field-list.js\nvar field_list = __nested_webpack_require_471800__(501);\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/scalars.js\nvar scalars = __nested_webpack_require_471800__(781);\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/field.js\nvar private_field = __nested_webpack_require_471800__(215);\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/private/names.js\nvar names = __nested_webpack_require_471800__(504);\n;// CONCATENATED MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/proto3.js\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n\n\n\n\n\n\n/**\n * Provides functionality for messages defined with the proto3 syntax.\n */\nconst proto3 = (0,proto_runtime/* makeProtoRuntime */.F)(\"proto3\", makeJsonFormatProto3(), makeBinaryFormatProto3(), Object.assign(Object.assign({}, (0,util_common/* makeUtilCommon */.f)()), { newFieldList(fields) {\n        return new field_list/* InternalFieldList */.i(fields, normalizeFieldInfosProto3);\n    },\n    initFields(target) {\n        for (const member of target.getType().fields.byMember()) {\n            if (member.opt) {\n                continue;\n            }\n            const name = member.localName, t = target;\n            if (member.repeated) {\n                t[name] = [];\n                continue;\n            }\n            switch (member.kind) {\n                case \"oneof\":\n                    t[name] = { case: undefined };\n                    break;\n                case \"enum\":\n                    t[name] = 0;\n                    break;\n                case \"map\":\n                    t[name] = {};\n                    break;\n                case \"scalar\":\n                    t[name] = (0,scalars/* scalarDefaultValue */.kY)(member.T, member.L); // eslint-disable-line @typescript-eslint/no-unsafe-assignment\n                    break;\n                case \"message\":\n                    // message fields are always optional in proto3\n                    break;\n            }\n        }\n    } }));\n/* eslint-disable @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-argument */\nfunction normalizeFieldInfosProto3(fieldInfos) {\n    var _a, _b, _c, _d;\n    const r = [];\n    let o;\n    for (const field of typeof fieldInfos == \"function\"\n        ? fieldInfos()\n        : fieldInfos) {\n        const f = field;\n        f.localName = (0,names/* localFieldName */.Rz)(field.name, field.oneof !== undefined);\n        f.jsonName = (_a = field.jsonName) !== null && _a !== void 0 ? _a : (0,names/* fieldJsonName */.x1)(field.name);\n        f.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;\n        if (field.kind == \"scalar\") {\n            f.L = (_c = field.L) !== null && _c !== void 0 ? _c : esm_field/* LongType */.p.BIGINT;\n        }\n        // We do not surface options at this time\n        // f.options = field.options ?? emptyReadonlyObject;\n        if (field.oneof !== undefined) {\n            const ooname = typeof field.oneof == \"string\" ? field.oneof : field.oneof.name;\n            if (!o || o.name != ooname) {\n                o = new private_field/* InternalOneofInfo */.o(ooname);\n            }\n            f.oneof = o;\n            o.addField(f);\n        }\n        // proto3 specific:\n        if (field.kind == \"message\") {\n            f.delimited = false;\n        }\n        // From the proto3 language guide:\n        // > In proto3, repeated fields of scalar numeric types are packed by default.\n        // This information is incomplete - according to the conformance tests, BOOL\n        // and ENUM are packed by default as well. This means only STRING and BYTES\n        // are not packed by default, which makes sense because they are length-delimited.\n        f.packed =\n            (_d = field.packed) !== null && _d !== void 0 ? _d : (field.kind == \"enum\" ||\n                (field.kind == \"scalar\" &&\n                    field.T != esm_field/* ScalarType */.w.BYTES &&\n                    field.T != esm_field/* ScalarType */.w.STRING));\n        r.push(f);\n    }\n    return r;\n}\n\n\n/***/ }),\n\n/***/ 328:\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_486212__) => {\n\n/* harmony export */ __nested_webpack_require_486212__.d(__nested_webpack_exports__, {\n/* harmony export */   t: () => (/* binding */ MethodKind),\n/* harmony export */   w: () => (/* binding */ MethodIdempotency)\n/* harmony export */ });\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * MethodKind represents the four method types that can be declared in\n * protobuf with the `stream` keyword:\n *\n * 1. Unary:           rpc (Input) returns (Output)\n * 2. ServerStreaming: rpc (Input) returns (stream Output)\n * 3. ClientStreaming: rpc (stream Input) returns (Output)\n * 4. BiDiStreaming:   rpc (stream Input) returns (stream Output)\n */\nvar MethodKind;\n(function (MethodKind) {\n    MethodKind[MethodKind[\"Unary\"] = 0] = \"Unary\";\n    MethodKind[MethodKind[\"ServerStreaming\"] = 1] = \"ServerStreaming\";\n    MethodKind[MethodKind[\"ClientStreaming\"] = 2] = \"ClientStreaming\";\n    MethodKind[MethodKind[\"BiDiStreaming\"] = 3] = \"BiDiStreaming\";\n})(MethodKind || (MethodKind = {}));\n/**\n * Is this method side-effect-free (or safe in HTTP parlance), or just\n * idempotent, or neither? HTTP based RPC implementation may choose GET verb\n * for safe methods, and PUT verb for idempotent methods instead of the\n * default POST.\n *\n * This enum matches the protobuf enum google.protobuf.MethodOptions.IdempotencyLevel,\n * defined in the well-known type google/protobuf/descriptor.proto, but\n * drops UNKNOWN.\n */\nvar MethodIdempotency;\n(function (MethodIdempotency) {\n    /**\n     * Idempotent, no side effects.\n     */\n    MethodIdempotency[MethodIdempotency[\"NoSideEffects\"] = 1] = \"NoSideEffects\";\n    /**\n     * Idempotent, but may have side effects.\n     */\n    MethodIdempotency[MethodIdempotency[\"Idempotent\"] = 2] = \"Idempotent\";\n})(MethodIdempotency || (MethodIdempotency = {}));\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_488788__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_488788__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__nested_webpack_require_488788__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__nested_webpack_require_488788__.o(definition, key) && !__nested_webpack_require_488788__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__nested_webpack_require_488788__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__nested_webpack_require_488788__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __nested_webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n(() => {\n// ESM COMPAT FLAG\n__nested_webpack_require_488788__.r(__nested_webpack_exports__);\n\n// EXPORTS\n__nested_webpack_require_488788__.d(__nested_webpack_exports__, {\n  Change: () => (/* reexport */ Change),\n  Client: () => (/* reexport */ Client),\n  ClientEventType: () => (/* reexport */ ClientEventType),\n  ClientStatus: () => (/* reexport */ ClientStatus),\n  Counter: () => (/* reexport */ Counter),\n  DocEventType: () => (/* reexport */ DocEventType),\n  Document: () => (/* reexport */ Document),\n  DocumentSyncResultType: () => (/* reexport */ DocumentSyncResultType),\n  Primitive: () => (/* reexport */ Primitive),\n  StreamConnectionStatus: () => (/* reexport */ StreamConnectionStatus),\n  SyncMode: () => (/* reexport */ SyncMode),\n  Text: () => (/* reexport */ Text),\n  TimeTicket: () => (/* reexport */ TimeTicket),\n  Tree: () => (/* reexport */ Tree),\n  converter: () => (/* reexport */ converter),\n  \"default\": () => (/* binding */ src_yorkie)\n});\n\n;// CONCATENATED MODULE: ./src/util/logger.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"Trivial\"] = 0] = \"Trivial\";\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\n    LogLevel[LogLevel[\"Info\"] = 2] = \"Info\";\n    LogLevel[LogLevel[\"Warn\"] = 3] = \"Warn\";\n    LogLevel[LogLevel[\"Error\"] = 4] = \"Error\";\n    LogLevel[LogLevel[\"Fatal\"] = 5] = \"Fatal\";\n})(LogLevel || (LogLevel = {}));\nlet level = LogLevel.Info;\n/**\n * `setLogLevel` sets log level.\n */\nfunction setLogLevel(l) {\n    level = l;\n}\nconst logger = {\n    trivial: (...messages) => {\n        if (level > LogLevel.Trivial) {\n            return;\n        }\n        if (typeof console != 'undefined') {\n            console.log('YORKIE T:', ...messages);\n        }\n    },\n    debug: (...messages) => {\n        if (level > LogLevel.Debug) {\n            return;\n        }\n        if (typeof console != 'undefined') {\n            console.log('YORKIE D:', ...messages);\n        }\n    },\n    info: (...messages) => {\n        if (level > LogLevel.Info) {\n            return;\n        }\n        if (typeof console != 'undefined') {\n            console.log('YORKIE I:', ...messages);\n        }\n    },\n    warn: (...messages) => {\n        if (level > LogLevel.Warn) {\n            return;\n        }\n        if (typeof console != 'undefined') {\n            if (typeof console.warn !== 'undefined') {\n                console.warn('YORKIE W:', ...messages);\n            }\n            else {\n                console.log('YORKIE W:', ...messages);\n            }\n        }\n    },\n    error: (...messages) => {\n        if (level > LogLevel.Error) {\n            return;\n        }\n        if (typeof console != 'undefined') {\n            if (typeof console.error !== 'undefined') {\n                console.error('YORKIE E:', ...messages);\n            }\n            else {\n                console.log('YORKIE E:', ...messages);\n            }\n        }\n    },\n    fatal: (message, ...messages) => {\n        if (typeof console != 'undefined') {\n            if (typeof console.error !== 'undefined') {\n                console.error('YORKIE F:', ...messages);\n            }\n            else {\n                console.log('YORKIE F:', ...messages);\n            }\n        }\n        throw new Error(`YORKIE F: ${message}`);\n    },\n    isEnabled: (l) => {\n        return level <= l;\n    },\n};\n\n;// CONCATENATED MODULE: ./src/util/uuid.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * `uuid` generates uuid string\n * @see http://www.ietf.org/rfc/rfc4122.txt\n */\nfunction uuid() {\n    return 'xxxxxxxx-xxxx-4xxxy-xxxx-xxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n        const r = (Math.random() * 16) | 0;\n        const v = c === 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n}\n\n;// CONCATENATED MODULE: ./src/util/observable.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nconst Noop = () => {\n    // Do nothing\n};\n/**\n * `ObserverProxy` is proxy of `Observer`.\n */\nclass ObserverProxy {\n    constructor(executor) {\n        this.finalized = false;\n        this.observers = [];\n        try {\n            executor(this);\n        }\n        catch (error) {\n            this.error(error);\n        }\n    }\n    /**\n     * `next` iterates next observer synchronously.\n     */\n    next(value) {\n        this.forEachObserver((observer) => {\n            observer.next(value);\n        });\n    }\n    /**\n     * `error` invoke error.\n     */\n    error(error) {\n        this.forEachObserver((observer) => {\n            observer.error(error);\n        });\n        this.close(error);\n    }\n    /**\n     * `complete` completes observer.\n     */\n    complete() {\n        this.forEachObserver((observer) => {\n            observer.complete();\n        });\n        this.close();\n    }\n    /**\n     * `subscribe` is a function for subscribing observer.\n     */\n    subscribe(nextOrObserver, error, complete) {\n        let observer;\n        if (!nextOrObserver) {\n            logger.fatal('missing observer');\n        }\n        if (this.finalized) {\n            logger.fatal('observable is finalized due to previous error');\n        }\n        if (typeof nextOrObserver === 'object') {\n            observer = nextOrObserver;\n        }\n        else {\n            observer = {\n                next: nextOrObserver,\n                error,\n                complete,\n            };\n        }\n        if (observer.next === undefined) {\n            observer.next = Noop;\n        }\n        if (observer.error === undefined) {\n            observer.error = Noop;\n        }\n        if (observer.complete === undefined) {\n            observer.complete = Noop;\n        }\n        const id = uuid();\n        const unsub = this.unsubscribeOne.bind(this, id);\n        this.observers.push({\n            subscriptionID: id,\n            observer: observer,\n        });\n        if (this.finalized) {\n            try {\n                if (this.finalError) {\n                    observer.error(this.finalError);\n                }\n                else {\n                    observer.complete();\n                }\n            }\n            catch (err) {\n                // nothing\n                logger.warn(err);\n            }\n        }\n        return unsub;\n    }\n    unsubscribeOne(id) {\n        var _a;\n        this.observers = (_a = this.observers) === null || _a === void 0 ? void 0 : _a.filter((it) => it.subscriptionID !== id);\n    }\n    forEachObserver(fn) {\n        if (this.finalized) {\n            return;\n        }\n        for (let i = 0; i < this.observers.length; i++) {\n            this.sendOne(i, fn);\n        }\n    }\n    sendOne(i, fn) {\n        if (this.observers !== undefined && this.observers[i] !== undefined) {\n            try {\n                fn(this.observers[i].observer);\n            }\n            catch (err) {\n                logger.error(err);\n            }\n        }\n    }\n    close(err) {\n        if (this.finalized) {\n            return;\n        }\n        this.finalized = true;\n        if (err !== undefined) {\n            this.finalError = err;\n        }\n        this.observers = undefined;\n    }\n}\n/**\n * `createObservable` creates a new instance of ObserverProxy\n * and subscribe the instance.\n */\nfunction createObservable(executor) {\n    const proxy = new ObserverProxy(executor);\n    return {\n        subscribe: proxy.subscribe.bind(proxy),\n        getProxy: () => {\n            return proxy;\n        },\n    };\n}\n\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/service-type.js\nvar service_type = __nested_webpack_require_488788__(328);\n;// CONCATENATED MODULE: ./node_modules/@connectrpc/connect/dist/esm/any-client.js\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create any client for the given service.\n *\n * The given createMethod function is called for each method definition\n * of the service. The function it returns is added to the client object\n * as a method.\n */\nfunction makeAnyClient(service, createMethod) {\n    const client = {};\n    for (const [localName, methodInfo] of Object.entries(service.methods)) {\n        const method = createMethod(Object.assign(Object.assign({}, methodInfo), { localName,\n            service }));\n        if (method != null) {\n            client[localName] = method;\n        }\n    }\n    return client;\n}\n\n;// CONCATENATED MODULE: ./node_modules/@connectrpc/connect/dist/esm/code.js\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Connect represents categories of errors as codes, and each code maps to a\n * specific HTTP status code. The codes and their semantics were chosen to\n * match gRPC. Only the codes below are valid  there are no user-defined\n * codes.\n *\n * See the specification at https://connectrpc.com/docs/protocol#error-codes\n * for details.\n */\nvar code_Code;\n(function (Code) {\n    /**\n     * Canceled, usually be the user\n     */\n    Code[Code[\"Canceled\"] = 1] = \"Canceled\";\n    /**\n     * Unknown error\n     */\n    Code[Code[\"Unknown\"] = 2] = \"Unknown\";\n    /**\n     * Argument invalid regardless of system state\n     */\n    Code[Code[\"InvalidArgument\"] = 3] = \"InvalidArgument\";\n    /**\n     * Operation expired, may or may not have completed.\n     */\n    Code[Code[\"DeadlineExceeded\"] = 4] = \"DeadlineExceeded\";\n    /**\n     * Entity not found.\n     */\n    Code[Code[\"NotFound\"] = 5] = \"NotFound\";\n    /**\n     * Entity already exists.\n     */\n    Code[Code[\"AlreadyExists\"] = 6] = \"AlreadyExists\";\n    /**\n     * Operation not authorized.\n     */\n    Code[Code[\"PermissionDenied\"] = 7] = \"PermissionDenied\";\n    /**\n     * Quota exhausted.\n     */\n    Code[Code[\"ResourceExhausted\"] = 8] = \"ResourceExhausted\";\n    /**\n     * Argument invalid in current system state.\n     */\n    Code[Code[\"FailedPrecondition\"] = 9] = \"FailedPrecondition\";\n    /**\n     * Operation aborted.\n     */\n    Code[Code[\"Aborted\"] = 10] = \"Aborted\";\n    /**\n     * Out of bounds, use instead of FailedPrecondition.\n     */\n    Code[Code[\"OutOfRange\"] = 11] = \"OutOfRange\";\n    /**\n     * Operation not implemented or disabled.\n     */\n    Code[Code[\"Unimplemented\"] = 12] = \"Unimplemented\";\n    /**\n     * Internal error, reserved for \"serious errors\".\n     */\n    Code[Code[\"Internal\"] = 13] = \"Internal\";\n    /**\n     * Unavailable, client should back off and retry.\n     */\n    Code[Code[\"Unavailable\"] = 14] = \"Unavailable\";\n    /**\n     * Unrecoverable data loss or corruption.\n     */\n    Code[Code[\"DataLoss\"] = 15] = \"DataLoss\";\n    /**\n     * Request isn't authenticated.\n     */\n    Code[Code[\"Unauthenticated\"] = 16] = \"Unauthenticated\";\n})(code_Code || (code_Code = {}));\n\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/message.js\nvar esm_message = __nested_webpack_require_488788__(561);\n;// CONCATENATED MODULE: ./node_modules/@connectrpc/connect/dist/esm/protocol-connect/code-string.js\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * codeToString returns the string representation of a Code.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction codeToString(value) {\n    const name = code_Code[value];\n    if (typeof name != \"string\") {\n        return value.toString();\n    }\n    return (name[0].toLowerCase() +\n        name.substring(1).replace(/[A-Z]/g, (c) => \"_\" + c.toLowerCase()));\n}\nlet stringToCode;\n/**\n * codeFromString parses the string representation of a Code in snake_case.\n * For example, the string \"permission_denied\" parses into Code.PermissionDenied.\n *\n * If the given string cannot be parsed, the function returns undefined.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction codeFromString(value) {\n    if (!stringToCode) {\n        stringToCode = {};\n        for (const value of Object.values(Code)) {\n            if (typeof value == \"string\") {\n                continue;\n            }\n            stringToCode[codeToString(value)] = value;\n        }\n    }\n    return stringToCode[value];\n}\n\n;// CONCATENATED MODULE: ./node_modules/@connectrpc/connect/dist/esm/connect-error.js\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n/**\n * ConnectError captures four pieces of information: a Code, an error\n * message, an optional cause of the error, and an optional collection of\n * arbitrary Protobuf messages called  \"details\".\n *\n * Because developer tools typically show just the error message, we prefix\n * it with the status code, so that the most important information is always\n * visible immediately.\n *\n * Error details are wrapped with google.protobuf.Any on the wire, so that\n * a server or middleware can attach arbitrary data to an error. Use the\n * method findDetails() to retrieve the details.\n */\nclass connect_error_ConnectError extends Error {\n    /**\n     * Create a new ConnectError.\n     * If no code is provided, code \"unknown\" is used.\n     * Outgoing details are only relevant for the server side - a service may\n     * raise an error with details, and it is up to the protocol implementation\n     * to encode and send the details along with error.\n     */\n    constructor(message, code = code_Code.Unknown, metadata, outgoingDetails, cause) {\n        super(createMessage(message, code));\n        this.name = \"ConnectError\";\n        // see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#example\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.rawMessage = message;\n        this.code = code;\n        this.metadata = new Headers(metadata !== null && metadata !== void 0 ? metadata : {});\n        this.details = outgoingDetails !== null && outgoingDetails !== void 0 ? outgoingDetails : [];\n        this.cause = cause;\n    }\n    /**\n     * Convert any value - typically a caught error into a ConnectError,\n     * following these rules:\n     * - If the value is already a ConnectError, return it as is.\n     * - If the value is an AbortError from the fetch API, return the message\n     *   of the AbortError with code Canceled.\n     * - For other Errors, return the error message with code Unknown by default.\n     * - For other values, return the values String representation as a message,\n     *   with the code Unknown by default.\n     * The original value will be used for the \"cause\" property for the new\n     * ConnectError.\n     */\n    static from(reason, code = code_Code.Unknown) {\n        if (reason instanceof connect_error_ConnectError) {\n            return reason;\n        }\n        if (reason instanceof Error) {\n            if (reason.name == \"AbortError\") {\n                // Fetch requests can only be canceled with an AbortController.\n                // We detect that condition by looking at the name of the raised\n                // error object, and translate to the appropriate status code.\n                return new connect_error_ConnectError(reason.message, code_Code.Canceled);\n            }\n            return new connect_error_ConnectError(reason.message, code, undefined, undefined, reason);\n        }\n        return new connect_error_ConnectError(String(reason), code, undefined, undefined, reason);\n    }\n    findDetails(typeOrRegistry) {\n        const registry = \"typeName\" in typeOrRegistry\n            ? {\n                findMessage: (typeName) => typeName === typeOrRegistry.typeName ? typeOrRegistry : undefined,\n            }\n            : typeOrRegistry;\n        const details = [];\n        for (const data of this.details) {\n            if (data instanceof esm_message/* Message */.v) {\n                if (registry.findMessage(data.getType().typeName)) {\n                    details.push(data);\n                }\n                continue;\n            }\n            const type = registry.findMessage(data.type);\n            if (type) {\n                try {\n                    details.push(type.fromBinary(data.value));\n                }\n                catch (_) {\n                    // We silently give up if we are unable to parse the detail, because\n                    // that appears to be the least worst behavior.\n                    // It is very unlikely that a user surrounds a catch body handling the\n                    // error with another try-catch statement, and we do not want to\n                    // recommend doing so.\n                }\n            }\n        }\n        return details;\n    }\n}\n/**\n * Create an error message, prefixing the given code.\n */\nfunction createMessage(message, code) {\n    return message.length\n        ? `[${codeToString(code)}] ${message}`\n        : `[${codeToString(code)}]`;\n}\n\n;// CONCATENATED MODULE: ./node_modules/@connectrpc/connect/dist/esm/protocol/async-iterable.js\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __asyncValues = ( false) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __await = ( false) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = ( false) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nvar __asyncDelegator = ( false) || function (o) {\n    var i, p;\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n};\n\n\n\n\nfunction pipeTo(source, ...rest) {\n    const [transforms, sink, opt] = pickTransformsAndSink(rest);\n    let iterable = source;\n    let abortable;\n    if ((opt === null || opt === void 0 ? void 0 : opt.propagateDownStreamError) === true) {\n        iterable = abortable = makeIterableAbortable(iterable);\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    iterable = pipe(iterable, ...transforms, { propagateDownStreamError: false });\n    return sink(iterable).catch((reason) => {\n        if (abortable) {\n            return abortable.abort(reason).then(() => Promise.reject(reason));\n        }\n        return Promise.reject(reason);\n    });\n}\n// pick transforms, the sink, and options from the pipeTo() rest parameter\nfunction pickTransformsAndSink(rest) {\n    let opt;\n    if (typeof rest[rest.length - 1] != \"function\") {\n        opt = rest.pop();\n    }\n    const sink = rest.pop();\n    return [rest, sink, opt];\n}\n/**\n * Creates an AsyncIterableSink that concatenates all elements from the input.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction sinkAll() {\n    return async function (iterable) {\n        var _a, e_1, _b, _c;\n        const all = [];\n        try {\n            for (var _d = true, iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = await iterable_1.next(), _a = iterable_1_1.done, !_a; _d = true) {\n                _c = iterable_1_1.value;\n                _d = false;\n                const chunk = _c;\n                all.push(chunk);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (!_d && !_a && (_b = iterable_1.return)) await _b.call(iterable_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return all;\n    };\n}\n/**\n * Creates an AsyncIterableSink that concatenates all chunks from the input into\n * a single Uint8Array.\n *\n * The iterable raises an error if the more than readMaxBytes are read.\n *\n * An optional length hint can be provided to optimize allocation and validation.\n * If more or less bytes are present in the source that the length hint indicates,\n * and error is raised.\n * If the length hint is larger than readMaxBytes, an error is raised.\n * If the length hint is not a positive integer, it is ignored.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction sinkAllBytes(readMaxBytes, lengthHint) {\n    return async function (iterable) {\n        return await readAllBytes(iterable, readMaxBytes, lengthHint);\n    };\n}\nfunction pipe(source, ...rest) {\n    var _a;\n    return __asyncGenerator(this, arguments, function* pipe_1() {\n        const [transforms, opt] = pickTransforms(rest);\n        let abortable;\n        const sourceIt = source[Symbol.asyncIterator]();\n        const cachedSource = {\n            [Symbol.asyncIterator]() {\n                return sourceIt;\n            },\n        };\n        let iterable = cachedSource;\n        if ((opt === null || opt === void 0 ? void 0 : opt.propagateDownStreamError) === true) {\n            iterable = abortable = makeIterableAbortable(iterable);\n        }\n        for (const t of transforms) {\n            iterable = t(iterable);\n        }\n        const it = iterable[Symbol.asyncIterator]();\n        try {\n            for (;;) {\n                const r = yield __await(it.next());\n                if (r.done === true) {\n                    break;\n                }\n                if (!abortable) {\n                    yield yield __await(r.value);\n                    continue;\n                }\n                try {\n                    yield yield __await(r.value);\n                }\n                catch (e) {\n                    yield __await(abortable.abort(e)); // propagate downstream error to the source\n                    throw e;\n                }\n            }\n        }\n        finally {\n            if ((opt === null || opt === void 0 ? void 0 : opt.propagateDownStreamError) === true) {\n                // Call return on the source iterable to indicate\n                // that we will no longer consume it and it should\n                // cleanup any allocated resources.\n                (_a = sourceIt.return) === null || _a === void 0 ? void 0 : _a.call(sourceIt).catch(() => {\n                    // return returns a promise, which we don't care about.\n                    //\n                    // Uncaught promises are thrown at sometime/somewhere by the event loop,\n                    // this is to ensure error is caught and ignored.\n                });\n            }\n        }\n    });\n}\nfunction pickTransforms(rest) {\n    let opt;\n    if (typeof rest[rest.length - 1] != \"function\") {\n        opt = rest.pop();\n    }\n    return [rest, opt];\n}\n/**\n * Creates an AsyncIterableTransform that catches any error from the input, and\n * passes it to the given catchError function.\n *\n * The catchError function may return a final value.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformCatch(catchError) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            // we deliberate avoid a for-await loop because we only want to catch upstream\n            // errors, not downstream errors (yield).\n            const it = iterable[Symbol.asyncIterator]();\n            for (;;) {\n                let r;\n                try {\n                    r = yield __await(it.next());\n                }\n                catch (e) {\n                    const caught = yield __await(catchError(e));\n                    if (caught !== undefined) {\n                        yield yield __await(caught);\n                    }\n                    break;\n                }\n                if (r.done === true) {\n                    break;\n                }\n                yield yield __await(r.value);\n            }\n        });\n    };\n}\n/**\n * Creates an AsyncIterableTransform that catches any error from the input, and\n * passes it to the given function. Unlike transformCatch(), the given function\n * is also called when no error is raised.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformCatchFinally(catchFinally) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            // we deliberate avoid a for-await loop because we only want to catch upstream\n            // errors, not downstream errors (yield).\n            let err;\n            const it = iterable[Symbol.asyncIterator]();\n            for (;;) {\n                let r;\n                try {\n                    r = yield __await(it.next());\n                }\n                catch (e) {\n                    err = e;\n                    break;\n                }\n                if (r.done === true) {\n                    break;\n                }\n                yield yield __await(r.value);\n            }\n            const caught = yield __await(catchFinally(err));\n            if (caught !== undefined) {\n                yield yield __await(caught);\n            }\n        });\n    };\n}\n/**\n * Creates an AsyncIterableTransform that appends a value.\n *\n * The element to append is provided by a function. If the function returns\n * undefined, no element is appended.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformAppend(provide) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_2, _b, _c;\n            try {\n                for (var _d = true, iterable_2 = __asyncValues(iterable), iterable_2_1; iterable_2_1 = yield __await(iterable_2.next()), _a = iterable_2_1.done, !_a; _d = true) {\n                    _c = iterable_2_1.value;\n                    _d = false;\n                    const chunk = _c;\n                    yield yield __await(chunk);\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_2.return)) yield __await(_b.call(iterable_2));\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n            const append = yield __await(provide());\n            if (append !== undefined) {\n                yield yield __await(append);\n            }\n        });\n    };\n}\n/**\n * Creates an AsyncIterableTransform that prepends an element.\n *\n * The element to prepend is provided by a function. If the function returns\n * undefined, no element is appended.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformPrepend(provide) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_3, _b, _c;\n            const prepend = yield __await(provide());\n            if (prepend !== undefined) {\n                yield yield __await(prepend);\n            }\n            try {\n                for (var _d = true, iterable_3 = __asyncValues(iterable), iterable_3_1; iterable_3_1 = yield __await(iterable_3.next()), _a = iterable_3_1.done, !_a; _d = true) {\n                    _c = iterable_3_1.value;\n                    _d = false;\n                    const chunk = _c;\n                    yield yield __await(chunk);\n                }\n            }\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_3.return)) yield __await(_b.call(iterable_3));\n                }\n                finally { if (e_3) throw e_3.error; }\n            }\n        });\n    };\n}\n/**\n * Creates an AsyncIterableTransform that reads all bytes from the input, and\n * concatenates them to a single Uint8Array.\n *\n * The iterable raises an error if the more than readMaxBytes are read.\n *\n * An optional length hint can be provided to optimize allocation and validation.\n * If more or less bytes are present in the source that the length hint indicates,\n * and error is raised.\n * If the length hint is larger than readMaxBytes, an error is raised.\n * If the length hint is not a positive integer, it is ignored.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformReadAllBytes(readMaxBytes, lengthHint) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            yield yield __await(yield __await(readAllBytes(iterable, readMaxBytes, lengthHint)));\n        });\n    };\n}\nfunction transformSerializeEnvelope(serialization, endStreamFlag, endSerialization) {\n    if (endStreamFlag === undefined || endSerialization === undefined) {\n        return function (iterable) {\n            return __asyncGenerator(this, arguments, function* () {\n                var _a, e_4, _b, _c;\n                try {\n                    for (var _d = true, iterable_4 = __asyncValues(iterable), iterable_4_1; iterable_4_1 = yield __await(iterable_4.next()), _a = iterable_4_1.done, !_a; _d = true) {\n                        _c = iterable_4_1.value;\n                        _d = false;\n                        const chunk = _c;\n                        const data = serialization.serialize(chunk);\n                        yield yield __await({ flags: 0, data });\n                    }\n                }\n                catch (e_4_1) { e_4 = { error: e_4_1 }; }\n                finally {\n                    try {\n                        if (!_d && !_a && (_b = iterable_4.return)) yield __await(_b.call(iterable_4));\n                    }\n                    finally { if (e_4) throw e_4.error; }\n                }\n            });\n        };\n    }\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_5, _b, _c;\n            try {\n                for (var _d = true, iterable_5 = __asyncValues(iterable), iterable_5_1; iterable_5_1 = yield __await(iterable_5.next()), _a = iterable_5_1.done, !_a; _d = true) {\n                    _c = iterable_5_1.value;\n                    _d = false;\n                    const chunk = _c;\n                    let data;\n                    let flags = 0;\n                    if (chunk.end) {\n                        flags = flags | endStreamFlag;\n                        data = endSerialization.serialize(chunk.value);\n                    }\n                    else {\n                        data = serialization.serialize(chunk.value);\n                    }\n                    yield yield __await({ flags, data });\n                }\n            }\n            catch (e_5_1) { e_5 = { error: e_5_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_5.return)) yield __await(_b.call(iterable_5));\n                }\n                finally { if (e_5) throw e_5.error; }\n            }\n        });\n    };\n}\nfunction transformParseEnvelope(serialization, endStreamFlag, endSerialization) {\n    // code path always yields ParsedEnvelopedMessage<T, E>\n    if (endSerialization && endStreamFlag !== undefined) {\n        return function (iterable) {\n            return __asyncGenerator(this, arguments, function* () {\n                var _a, e_6, _b, _c;\n                try {\n                    for (var _d = true, iterable_6 = __asyncValues(iterable), iterable_6_1; iterable_6_1 = yield __await(iterable_6.next()), _a = iterable_6_1.done, !_a; _d = true) {\n                        _c = iterable_6_1.value;\n                        _d = false;\n                        const { flags, data } = _c;\n                        if ((flags & endStreamFlag) === endStreamFlag) {\n                            yield yield __await({ value: endSerialization.parse(data), end: true });\n                        }\n                        else {\n                            yield yield __await({ value: serialization.parse(data), end: false });\n                        }\n                    }\n                }\n                catch (e_6_1) { e_6 = { error: e_6_1 }; }\n                finally {\n                    try {\n                        if (!_d && !_a && (_b = iterable_6.return)) yield __await(_b.call(iterable_6));\n                    }\n                    finally { if (e_6) throw e_6.error; }\n                }\n            });\n        };\n    }\n    // code path always yields T\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_7, _b, _c;\n            try {\n                for (var _d = true, iterable_7 = __asyncValues(iterable), iterable_7_1; iterable_7_1 = yield __await(iterable_7.next()), _a = iterable_7_1.done, !_a; _d = true) {\n                    _c = iterable_7_1.value;\n                    _d = false;\n                    const { flags, data } = _c;\n                    if (endStreamFlag !== undefined &&\n                        (flags & endStreamFlag) === endStreamFlag) {\n                        if (endSerialization === null) {\n                            throw new ConnectError(\"unexpected end flag\", Code.InvalidArgument);\n                        }\n                        // skips end-of-stream envelope\n                        continue;\n                    }\n                    yield yield __await(serialization.parse(data));\n                }\n            }\n            catch (e_7_1) { e_7 = { error: e_7_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_7.return)) yield __await(_b.call(iterable_7));\n                }\n                finally { if (e_7) throw e_7.error; }\n            }\n        });\n    };\n}\n/**\n * Creates an AsyncIterableTransform that takes enveloped messages as a source,\n * and compresses them if they are larger than compressMinBytes.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformCompressEnvelope(compression, compressMinBytes) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_8, _b, _c;\n            try {\n                for (var _d = true, iterable_8 = __asyncValues(iterable), iterable_8_1; iterable_8_1 = yield __await(iterable_8.next()), _a = iterable_8_1.done, !_a; _d = true) {\n                    _c = iterable_8_1.value;\n                    _d = false;\n                    const env = _c;\n                    yield yield __await(yield __await(envelopeCompress(env, compression, compressMinBytes)));\n                }\n            }\n            catch (e_8_1) { e_8 = { error: e_8_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_8.return)) yield __await(_b.call(iterable_8));\n                }\n                finally { if (e_8) throw e_8.error; }\n            }\n        });\n    };\n}\n/**\n * Creates an AsyncIterableTransform that takes enveloped messages as a source,\n * and decompresses them using the given compression.\n *\n * The iterable raises an error if the decompressed payload of an enveloped\n * message is larger than readMaxBytes, or if no compression is provided.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformDecompressEnvelope(compression, readMaxBytes) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_9, _b, _c;\n            try {\n                for (var _d = true, iterable_9 = __asyncValues(iterable), iterable_9_1; iterable_9_1 = yield __await(iterable_9.next()), _a = iterable_9_1.done, !_a; _d = true) {\n                    _c = iterable_9_1.value;\n                    _d = false;\n                    const env = _c;\n                    yield yield __await(yield __await(envelopeDecompress(env, compression, readMaxBytes)));\n                }\n            }\n            catch (e_9_1) { e_9 = { error: e_9_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_9.return)) yield __await(_b.call(iterable_9));\n                }\n                finally { if (e_9) throw e_9.error; }\n            }\n        });\n    };\n}\n/**\n * Create an AsyncIterableTransform that takes enveloped messages as a source,\n * and joins them into a stream of raw bytes.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformJoinEnvelopes() {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_10, _b, _c;\n            try {\n                for (var _d = true, iterable_10 = __asyncValues(iterable), iterable_10_1; iterable_10_1 = yield __await(iterable_10.next()), _a = iterable_10_1.done, !_a; _d = true) {\n                    _c = iterable_10_1.value;\n                    _d = false;\n                    const { flags, data } = _c;\n                    yield yield __await(encodeEnvelope(flags, data));\n                }\n            }\n            catch (e_10_1) { e_10 = { error: e_10_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_10.return)) yield __await(_b.call(iterable_10));\n                }\n                finally { if (e_10) throw e_10.error; }\n            }\n        });\n    };\n}\n/**\n * Create an AsyncIterableTransform that takes raw bytes as a source, and splits\n * them into enveloped messages.\n *\n * The iterable raises an error\n * - if the payload of an enveloped message is larger than readMaxBytes,\n * - if the stream ended before an enveloped message fully arrived,\n * - or if the stream ended with extraneous data.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformSplitEnvelope(readMaxBytes) {\n    // append chunk to buffer, returning updated buffer\n    function append(buffer, chunk) {\n        const n = new Uint8Array(buffer.byteLength + chunk.byteLength);\n        n.set(buffer);\n        n.set(chunk, buffer.length);\n        return n;\n    }\n    // tuple 0: envelope, or undefined if incomplete\n    // tuple 1: remainder of the buffer\n    function shiftEnvelope(buffer, header) {\n        if (buffer.byteLength < 5 + header.length) {\n            return [undefined, buffer];\n        }\n        return [\n            { flags: header.flags, data: buffer.subarray(5, 5 + header.length) },\n            buffer.subarray(5 + header.length),\n        ];\n    }\n    // undefined: header is incomplete\n    function peekHeader(buffer) {\n        if (buffer.byteLength < 5) {\n            return undefined;\n        }\n        const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n        const length = view.getUint32(1); // 4 bytes message length\n        const flags = view.getUint8(0); // first byte is flags\n        return { length, flags };\n    }\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_11, _b, _c;\n            let buffer = new Uint8Array(0);\n            try {\n                for (var _d = true, iterable_11 = __asyncValues(iterable), iterable_11_1; iterable_11_1 = yield __await(iterable_11.next()), _a = iterable_11_1.done, !_a; _d = true) {\n                    _c = iterable_11_1.value;\n                    _d = false;\n                    const chunk = _c;\n                    buffer = append(buffer, chunk);\n                    for (;;) {\n                        const header = peekHeader(buffer);\n                        if (!header) {\n                            break;\n                        }\n                        assertReadMaxBytes(readMaxBytes, header.length, true);\n                        let env;\n                        [env, buffer] = shiftEnvelope(buffer, header);\n                        if (!env) {\n                            break;\n                        }\n                        yield yield __await(env);\n                    }\n                }\n            }\n            catch (e_11_1) { e_11 = { error: e_11_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_11.return)) yield __await(_b.call(iterable_11));\n                }\n                finally { if (e_11) throw e_11.error; }\n            }\n            if (buffer.byteLength > 0) {\n                const header = peekHeader(buffer);\n                let message = \"protocol error: incomplete envelope\";\n                if (header) {\n                    message = `protocol error: promised ${header.length} bytes in enveloped message, got ${buffer.byteLength - 5} bytes`;\n                }\n                throw new ConnectError(message, Code.InvalidArgument);\n            }\n        });\n    };\n}\n/**\n * Reads all bytes from the source, and concatenates them to a single Uint8Array.\n *\n * Raises an error if:\n * - more than readMaxBytes are read\n * - lengthHint is a positive integer, but larger than readMaxBytes\n * - lengthHint is a positive integer, and the source contains more or less bytes\n *   than promised\n *\n * @private Internal code, does not follow semantic versioning.\n */\nasync function readAllBytes(iterable, readMaxBytes, lengthHint) {\n    var _a, e_12, _b, _c, _d, e_13, _e, _f;\n    const [ok, hint] = parseLengthHint(lengthHint);\n    if (ok) {\n        if (hint > readMaxBytes) {\n            assertReadMaxBytes(readMaxBytes, hint, true);\n        }\n        const buffer = new Uint8Array(hint);\n        let offset = 0;\n        try {\n            for (var _g = true, iterable_12 = __asyncValues(iterable), iterable_12_1; iterable_12_1 = await iterable_12.next(), _a = iterable_12_1.done, !_a; _g = true) {\n                _c = iterable_12_1.value;\n                _g = false;\n                const chunk = _c;\n                if (offset + chunk.byteLength > hint) {\n                    throw new ConnectError(`protocol error: promised ${hint} bytes, received ${offset + chunk.byteLength}`, Code.InvalidArgument);\n                }\n                buffer.set(chunk, offset);\n                offset += chunk.byteLength;\n            }\n        }\n        catch (e_12_1) { e_12 = { error: e_12_1 }; }\n        finally {\n            try {\n                if (!_g && !_a && (_b = iterable_12.return)) await _b.call(iterable_12);\n            }\n            finally { if (e_12) throw e_12.error; }\n        }\n        if (offset < hint) {\n            throw new ConnectError(`protocol error: promised ${hint} bytes, received ${offset}`, Code.InvalidArgument);\n        }\n        return buffer;\n    }\n    const chunks = [];\n    let count = 0;\n    try {\n        for (var _h = true, iterable_13 = __asyncValues(iterable), iterable_13_1; iterable_13_1 = await iterable_13.next(), _d = iterable_13_1.done, !_d; _h = true) {\n            _f = iterable_13_1.value;\n            _h = false;\n            const chunk = _f;\n            count += chunk.byteLength;\n            assertReadMaxBytes(readMaxBytes, count);\n            chunks.push(chunk);\n        }\n    }\n    catch (e_13_1) { e_13 = { error: e_13_1 }; }\n    finally {\n        try {\n            if (!_h && !_d && (_e = iterable_13.return)) await _e.call(iterable_13);\n        }\n        finally { if (e_13) throw e_13.error; }\n    }\n    const all = new Uint8Array(count);\n    let offset = 0;\n    for (let chunk = chunks.shift(); chunk; chunk = chunks.shift()) {\n        all.set(chunk, offset);\n        offset += chunk.byteLength;\n    }\n    return all;\n}\n// parse the lengthHint argument of readAllBytes()\nfunction parseLengthHint(lengthHint) {\n    if (lengthHint === undefined || lengthHint === null) {\n        return [false, 0];\n    }\n    const n = typeof lengthHint == \"string\" ? parseInt(lengthHint, 10) : lengthHint;\n    if (!Number.isSafeInteger(n) || n < 0) {\n        return [false, n];\n    }\n    return [true, n];\n}\n/**\n * Wait for the first element of an iterable without modifying the iterable.\n * This consumes the first element, but pushes it back on the stack.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nasync function untilFirst(iterable) {\n    const it = iterable[Symbol.asyncIterator]();\n    let first = await it.next();\n    return {\n        [Symbol.asyncIterator]() {\n            const w = {\n                async next() {\n                    if (first !== null) {\n                        const n = first;\n                        first = null;\n                        return n;\n                    }\n                    return await it.next();\n                },\n            };\n            if (it.throw !== undefined) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- can't handle mutated object sensibly\n                w.throw = (e) => it.throw(e);\n            }\n            if (it.return !== undefined) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion,@typescript-eslint/no-explicit-any -- can't handle mutated object sensibly\n                w.return = (value) => it.return(value);\n            }\n            return w;\n        },\n    };\n}\n/**\n * Wrap the given iterable and return an iterable with an abort() method.\n *\n * This function exists purely for convenience. Where one would typically have\n * to access the iterator directly, advance through all elements, and call\n * AsyncIterator.throw() to notify the upstream iterable, this function allows\n * to use convenient for-await loops and still notify the upstream iterable:\n *\n * ```ts\n * const abortable = makeIterableAbortable(iterable);\n * for await (const ele of abortable) {\n *   await abortable.abort(\"ERR\");\n * }\n * ```\n * There are a couple of limitations of this function:\n * - the given async iterable must implement throw\n * - the async iterable cannot be re-use\n * - if source catches errors and yields values for them, they are ignored, and\n *   the source may still dangle\n *\n * There are four possible ways an async function* can handle yield errors:\n * 1. don't catch errors at all - Abortable.abort() will resolve \"rethrown\"\n * 2. catch errors and rethrow - Abortable.abort() will resolve \"rethrown\"\n * 3. catch errors and return - Abortable.abort() will resolve \"completed\"\n * 4. catch errors and yield a value - Abortable.abort() will resolve \"caught\"\n *\n * Note that catching errors and yielding a value is problematic, and it should\n * be documented that this may leave the source in a dangling state.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction makeIterableAbortable(iterable) {\n    const innerCandidate = iterable[Symbol.asyncIterator]();\n    if (innerCandidate.throw === undefined) {\n        throw new Error(\"AsyncIterable does not implement throw\");\n    }\n    const inner = innerCandidate;\n    let aborted;\n    let resultPromise;\n    let it = {\n        next() {\n            resultPromise = inner.next().finally(() => {\n                resultPromise = undefined;\n            });\n            return resultPromise;\n        },\n        throw(e) {\n            return inner.throw(e);\n        },\n    };\n    if (innerCandidate.return !== undefined) {\n        it = Object.assign(Object.assign({}, it), { return(value) {\n                return inner.return(value);\n            } });\n    }\n    let used = false;\n    return {\n        abort(reason) {\n            if (aborted) {\n                return aborted.state;\n            }\n            const f = () => {\n                return inner.throw(reason).then((r) => (r.done === true ? \"completed\" : \"caught\"), () => \"rethrown\");\n            };\n            if (resultPromise) {\n                aborted = { reason, state: resultPromise.then(f, f) };\n                return aborted.state;\n            }\n            aborted = { reason, state: f() };\n            return aborted.state;\n        },\n        [Symbol.asyncIterator]() {\n            if (used) {\n                throw new Error(\"AsyncIterable cannot be re-used\");\n            }\n            used = true;\n            return it;\n        },\n    };\n}\n/**\n * Create a new WritableIterable.\n */\nfunction createWritableIterable() {\n    // We start with two queues to capture the read and write attempts.\n    //\n    // The writes and reads each check of their counterpart is\n    // already available and either interact/add themselves to the queue.\n    const readQueue = [];\n    const writeQueue = [];\n    let err = undefined;\n    let nextResolve;\n    let nextReject;\n    let nextPromise = new Promise((resolve, reject) => {\n        nextResolve = resolve;\n        nextReject = reject;\n    });\n    let closed = false;\n    // drain the readQueue in case of error/writer is closed by sending a\n    // done result.\n    function drain() {\n        for (const next of readQueue.splice(0, readQueue.length)) {\n            next({ done: true, value: undefined });\n        }\n    }\n    return {\n        close() {\n            closed = true;\n            drain();\n        },\n        async write(payload) {\n            if (closed) {\n                throw err !== null && err !== void 0 ? err : new Error(\"cannot write, WritableIterable already closed\");\n            }\n            const read = readQueue.shift();\n            if (read === undefined) {\n                // We didn't find a pending read so we add the payload to the write queue.\n                writeQueue.push(payload);\n            }\n            else {\n                // We found a pending read so we respond with the payload.\n                read({ done: false, value: payload });\n                if (readQueue.length > 0) {\n                    // If there are more in the read queue we can mark the write as complete.\n                    // as the error reporting is not guaranteed to be sequential and therefore cannot\n                    // to linked to a specific write.\n                    return;\n                }\n            }\n            // We await the next call for as many times as there are items in the queue + 1\n            //\n            // If there are no items in the write queue that means write happened and we just have\n            // to wait for one more call likewise if we are the nth write in the queue we\n            // have to wait for n writes to complete and one more.\n            const limit = writeQueue.length + 1;\n            for (let i = 0; i < limit; i++) {\n                await nextPromise;\n            }\n        },\n        [Symbol.asyncIterator]() {\n            return {\n                next() {\n                    // Resolve the nextPromise to indicate\n                    // pending writes that a read attempt has been made\n                    // after their write.\n                    //\n                    // We also need to reset the promise for future writes.\n                    nextResolve();\n                    nextPromise = new Promise((resolve, reject) => {\n                        nextResolve = resolve;\n                        nextReject = reject;\n                    });\n                    const write = writeQueue.shift();\n                    if (write !== undefined) {\n                        // We found a pending write so response with the payload.\n                        return Promise.resolve({ done: false, value: write });\n                    }\n                    if (closed) {\n                        return Promise.resolve({ done: true, value: undefined });\n                    }\n                    // We return a promise immediately that is either resolved/rejected\n                    // as writes happen.\n                    let readResolve;\n                    const readPromise = new Promise((resolve) => (readResolve = resolve));\n                    readQueue.push(readResolve); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n                    return readPromise;\n                },\n                throw(throwErr) {\n                    err = throwErr;\n                    closed = true;\n                    writeQueue.splice(0, writeQueue.length);\n                    nextPromise.catch(() => {\n                        // To make sure that the nextPromise is always resolved.\n                    });\n                    // This will reject all pending writes.\n                    nextReject(err);\n                    drain();\n                    return Promise.resolve({ done: true, value: undefined });\n                },\n                return() {\n                    closed = true;\n                    writeQueue.splice(0, writeQueue.length);\n                    // Resolve once for the write awaiting confirmation.\n                    nextResolve();\n                    // Reject all future writes.\n                    nextPromise = Promise.reject(new Error(\"cannot write, consumer called return\"));\n                    nextPromise.catch(() => {\n                        // To make sure that the nextPromise is always resolved.\n                    });\n                    drain();\n                    return Promise.resolve({ done: true, value: undefined });\n                },\n            };\n        },\n    };\n}\n/**\n * Create an asynchronous iterable from an array.\n *\n * @private Internal code, does not follow semantic versioning.\n */\n// eslint-disable-next-line @typescript-eslint/require-await\nfunction createAsyncIterable(items) {\n    return __asyncGenerator(this, arguments, function* createAsyncIterable_1() {\n        yield __await(yield* __asyncDelegator(__asyncValues(items)));\n    });\n}\n\n;// CONCATENATED MODULE: ./node_modules/@connectrpc/connect/dist/esm/promise-client.js\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar promise_client_asyncValues = ( false) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar promise_client_await = ( false) || function (v) { return this instanceof promise_client_await ? (this.v = v, this) : new promise_client_await(v); }\nvar promise_client_asyncDelegator = ( false) || function (o) {\n    var i, p;\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: promise_client_await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n};\nvar promise_client_asyncGenerator = ( false) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof promise_client_await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\n\n\n\n\n\n/**\n * Create a PromiseClient for the given service, invoking RPCs through the\n * given transport.\n */\nfunction createPromiseClient(service, transport) {\n    return makeAnyClient(service, (method) => {\n        switch (method.kind) {\n            case service_type/* MethodKind */.t.Unary:\n                return createUnaryFn(transport, service, method);\n            case service_type/* MethodKind */.t.ServerStreaming:\n                return createServerStreamingFn(transport, service, method);\n            case service_type/* MethodKind */.t.ClientStreaming:\n                return createClientStreamingFn(transport, service, method);\n            case service_type/* MethodKind */.t.BiDiStreaming:\n                return createBiDiStreamingFn(transport, service, method);\n            default:\n                return null;\n        }\n    });\n}\nfunction createUnaryFn(transport, service, method) {\n    return async function (input, options) {\n        var _a, _b;\n        const response = await transport.unary(service, method, options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.timeoutMs, options === null || options === void 0 ? void 0 : options.headers, input, options === null || options === void 0 ? void 0 : options.contextValues);\n        (_a = options === null || options === void 0 ? void 0 : options.onHeader) === null || _a === void 0 ? void 0 : _a.call(options, response.header);\n        (_b = options === null || options === void 0 ? void 0 : options.onTrailer) === null || _b === void 0 ? void 0 : _b.call(options, response.trailer);\n        return response.message;\n    };\n}\nfunction createServerStreamingFn(transport, service, method) {\n    return function (input, options) {\n        return handleStreamResponse(transport.stream(service, method, options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.timeoutMs, options === null || options === void 0 ? void 0 : options.headers, createAsyncIterable([input]), options === null || options === void 0 ? void 0 : options.contextValues), options);\n    };\n}\nfunction createClientStreamingFn(transport, service, method) {\n    return async function (request, options) {\n        var _a, e_1, _b, _c;\n        var _d, _e;\n        const response = await transport.stream(service, method, options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.timeoutMs, options === null || options === void 0 ? void 0 : options.headers, request, options === null || options === void 0 ? void 0 : options.contextValues);\n        (_d = options === null || options === void 0 ? void 0 : options.onHeader) === null || _d === void 0 ? void 0 : _d.call(options, response.header);\n        let singleMessage;\n        try {\n            for (var _f = true, _g = promise_client_asyncValues(response.message), _h; _h = await _g.next(), _a = _h.done, !_a; _f = true) {\n                _c = _h.value;\n                _f = false;\n                const message = _c;\n                singleMessage = message;\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (!_f && !_a && (_b = _g.return)) await _b.call(_g);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        if (!singleMessage) {\n            throw new connect_error_ConnectError(\"protocol error: missing response message\", code_Code.Internal);\n        }\n        (_e = options === null || options === void 0 ? void 0 : options.onTrailer) === null || _e === void 0 ? void 0 : _e.call(options, response.trailer);\n        return singleMessage;\n    };\n}\nfunction createBiDiStreamingFn(transport, service, method) {\n    return function (request, options) {\n        return handleStreamResponse(transport.stream(service, method, options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.timeoutMs, options === null || options === void 0 ? void 0 : options.headers, request, options === null || options === void 0 ? void 0 : options.contextValues), options);\n    };\n}\nfunction handleStreamResponse(stream, options) {\n    const it = (function () {\n        var _a, _b;\n        return promise_client_asyncGenerator(this, arguments, function* () {\n            const response = yield promise_client_await(stream);\n            (_a = options === null || options === void 0 ? void 0 : options.onHeader) === null || _a === void 0 ? void 0 : _a.call(options, response.header);\n            yield promise_client_await(yield* promise_client_asyncDelegator(promise_client_asyncValues(response.message)));\n            (_b = options === null || options === void 0 ? void 0 : options.onTrailer) === null || _b === void 0 ? void 0 : _b.call(options, response.trailer);\n        });\n    })()[Symbol.asyncIterator]();\n    // Create a new iterable to omit throw/return.\n    return {\n        [Symbol.asyncIterator]: () => ({\n            next: () => it.next(),\n        }),\n    };\n}\n\n;// CONCATENATED MODULE: ./node_modules/@connectrpc/connect/dist/esm/context-values.js\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * createContextValues creates a new ContextValues.\n */\nfunction createContextValues() {\n    return {\n        get(key) {\n            return key.id in this ? this[key.id] : key.defaultValue;\n        },\n        set(key, value) {\n            this[key.id] = value;\n            return this;\n        },\n        delete(key) {\n            delete this[key.id];\n            return this;\n        },\n    };\n}\n/**\n * createContextKey creates a new ContextKey.\n */\nfunction createContextKey(defaultValue, options) {\n    return { id: Symbol(options === null || options === void 0 ? void 0 : options.description), defaultValue };\n}\n\n;// CONCATENATED MODULE: ./node_modules/@connectrpc/connect/dist/esm/protocol/serialization.js\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n/**\n * Sets default JSON serialization options for connect-es.\n *\n * With standard protobuf JSON serialization, unknown JSON fields are\n * rejected by default. In connect-es, unknown JSON fields are ignored\n * by default.\n */\nfunction getJsonOptions(options) {\n    var _a;\n    const o = Object.assign({}, options);\n    (_a = o.ignoreUnknownFields) !== null && _a !== void 0 ? _a : (o.ignoreUnknownFields = true);\n    return o;\n}\n/**\n * Create an object that provides convenient access to request and response\n * message serialization for a given method.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction createMethodSerializationLookup(method, binaryOptions, jsonOptions, limitOptions) {\n    const inputBinary = limitSerialization(createBinarySerialization(method.I, binaryOptions), limitOptions);\n    const inputJson = limitSerialization(createJsonSerialization(method.I, jsonOptions), limitOptions);\n    const outputBinary = limitSerialization(createBinarySerialization(method.O, binaryOptions), limitOptions);\n    const outputJson = limitSerialization(createJsonSerialization(method.O, jsonOptions), limitOptions);\n    return {\n        getI(useBinaryFormat) {\n            return useBinaryFormat ? inputBinary : inputJson;\n        },\n        getO(useBinaryFormat) {\n            return useBinaryFormat ? outputBinary : outputJson;\n        },\n    };\n}\n/**\n * Returns functions to normalize and serialize the input message\n * of an RPC, and to parse the output message of an RPC.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction createClientMethodSerializers(method, useBinaryFormat, jsonOptions, binaryOptions) {\n    const input = useBinaryFormat\n        ? createBinarySerialization(method.I, binaryOptions)\n        : createJsonSerialization(method.I, jsonOptions);\n    const output = useBinaryFormat\n        ? createBinarySerialization(method.O, binaryOptions)\n        : createJsonSerialization(method.O, jsonOptions);\n    return { parse: output.parse, serialize: input.serialize };\n}\n/**\n * Apply I/O limits to a Serialization object, returning a new object.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction limitSerialization(serialization, limitOptions) {\n    return {\n        serialize(data) {\n            const bytes = serialization.serialize(data);\n            assertWriteMaxBytes(limitOptions.writeMaxBytes, bytes.byteLength);\n            return bytes;\n        },\n        parse(data) {\n            assertReadMaxBytes(limitOptions.readMaxBytes, data.byteLength, true);\n            return serialization.parse(data);\n        },\n    };\n}\n/**\n * Creates a Serialization object for serializing the given protobuf message\n * with the protobuf binary format.\n */\nfunction createBinarySerialization(messageType, options) {\n    return {\n        parse(data) {\n            try {\n                return messageType.fromBinary(data, options);\n            }\n            catch (e) {\n                const m = e instanceof Error ? e.message : String(e);\n                throw new connect_error_ConnectError(`parse binary: ${m}`, code_Code.InvalidArgument);\n            }\n        },\n        serialize(data) {\n            try {\n                return data.toBinary(options);\n            }\n            catch (e) {\n                const m = e instanceof Error ? e.message : String(e);\n                throw new connect_error_ConnectError(`serialize binary: ${m}`, code_Code.Internal);\n            }\n        },\n    };\n}\n/**\n * Creates a Serialization object for serializing the given protobuf message\n * with the protobuf canonical JSON encoding.\n *\n * By default, unknown fields are ignored.\n */\nfunction createJsonSerialization(messageType, options) {\n    var _a, _b;\n    const textEncoder = (_a = options === null || options === void 0 ? void 0 : options.textEncoder) !== null && _a !== void 0 ? _a : new TextEncoder();\n    const textDecoder = (_b = options === null || options === void 0 ? void 0 : options.textDecoder) !== null && _b !== void 0 ? _b : new TextDecoder();\n    const o = getJsonOptions(options);\n    return {\n        parse(data) {\n            try {\n                const json = textDecoder.decode(data);\n                return messageType.fromJsonString(json, o);\n            }\n            catch (e) {\n                throw connect_error_ConnectError.from(e, code_Code.InvalidArgument);\n            }\n        },\n        serialize(data) {\n            try {\n                const json = data.toJsonString(o);\n                return textEncoder.encode(json);\n            }\n            catch (e) {\n                throw connect_error_ConnectError.from(e, code_Code.Internal);\n            }\n        },\n    };\n}\n\n;// CONCATENATED MODULE: ./node_modules/@connectrpc/connect/dist/esm/protocol/signals.js\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n/**\n * Create an AbortController that is automatically aborted if one of the given\n * signals is aborted.\n *\n * For convenience, the linked AbortSignals can be undefined.\n *\n * If the controller or any of the signals is aborted, all event listeners are\n * removed.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction createLinkedAbortController(...signals) {\n    const controller = new AbortController();\n    const sa = signals\n        .filter((s) => s !== undefined)\n        .concat(controller.signal);\n    for (const signal of sa) {\n        if (signal.aborted) {\n            onAbort.apply(signal);\n            break;\n        }\n        signal.addEventListener(\"abort\", onAbort);\n    }\n    function onAbort() {\n        if (!controller.signal.aborted) {\n            controller.abort(getAbortSignalReason(this));\n        }\n        for (const signal of sa) {\n            signal.removeEventListener(\"abort\", onAbort);\n        }\n    }\n    return controller;\n}\n/**\n * Create a deadline signal. The returned object contains an AbortSignal, but\n * also a cleanup function to stop the timer, which must be called once the\n * calling code is no longer interested in the signal.\n *\n * Ideally, we would simply use AbortSignal.timeout(), but it is not widely\n * available yet.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction createDeadlineSignal(timeoutMs) {\n    const controller = new AbortController();\n    const listener = () => {\n        controller.abort(new connect_error_ConnectError(\"the operation timed out\", code_Code.DeadlineExceeded));\n    };\n    let timeoutId;\n    if (timeoutMs !== undefined) {\n        if (timeoutMs <= 0)\n            listener();\n        else\n            timeoutId = setTimeout(listener, timeoutMs);\n    }\n    return {\n        signal: controller.signal,\n        cleanup: () => clearTimeout(timeoutId),\n    };\n}\n/**\n * Returns the reason why an AbortSignal was aborted. Returns undefined if the\n * signal has not been aborted.\n *\n * The property AbortSignal.reason is not widely available. This function\n * returns an AbortError if the signal is aborted, but reason is undefined.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction getAbortSignalReason(signal) {\n    if (!signal.aborted) {\n        return undefined;\n    }\n    if (signal.reason !== undefined) {\n        return signal.reason;\n    }\n    // AbortSignal.reason is available in Node.js v16, v18, and later,\n    // and in all browsers since early 2022.\n    const e = new Error(\"This operation was aborted\");\n    e.name = \"AbortError\";\n    return e;\n}\n\n;// CONCATENATED MODULE: ./node_modules/@connectrpc/connect/dist/esm/protocol/normalize.js\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n *  Takes a partial protobuf messages of the\n *  specified message type as input, and returns full instances.\n */\nfunction normalize(type, message) {\n    return message instanceof esm_message/* Message */.v ? message : new type(message);\n}\n/**\n * Takes an AsyncIterable of partial protobuf messages of the\n * specified message type as input, and yields full instances.\n */\nfunction normalizeIterable(messageType, input) {\n    function transform(result) {\n        if (result.done === true) {\n            return result;\n        }\n        return {\n            done: result.done,\n            value: normalize(messageType, result.value),\n        };\n    }\n    return {\n        [Symbol.asyncIterator]() {\n            const it = input[Symbol.asyncIterator]();\n            const res = {\n                next: () => it.next().then(transform),\n            };\n            if (it.throw !== undefined) {\n                res.throw = (e) => it.throw(e).then(transform); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n            }\n            if (it.return !== undefined) {\n                res.return = (v) => it.return(v).then(transform); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n            }\n            return res;\n        },\n    };\n}\n\n;// CONCATENATED MODULE: ./node_modules/@connectrpc/connect/dist/esm/protocol/run-call.js\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n/**\n * Runs a unary method with the given interceptors. Note that this function\n * is only used when implementing a Transport.\n */\nfunction runUnaryCall(opt) {\n    const next = applyInterceptors(opt.next, opt.interceptors);\n    const [signal, abort, done] = setupSignal(opt);\n    const req = Object.assign(Object.assign({}, opt.req), { message: normalize(opt.req.method.I, opt.req.message), signal });\n    return next(req).then((res) => {\n        done();\n        return res;\n    }, abort);\n}\n/**\n * Runs a server-streaming method with the given interceptors. Note that this\n * function is only used when implementing a Transport.\n */\nfunction runStreamingCall(opt) {\n    const next = applyInterceptors(opt.next, opt.interceptors);\n    const [signal, abort, done] = setupSignal(opt);\n    const req = Object.assign(Object.assign({}, opt.req), { message: normalizeIterable(opt.req.method.I, opt.req.message), signal });\n    let doneCalled = false;\n    // Call return on the request iterable to indicate\n    // that we will no longer consume it and it should\n    // cleanup any allocated resources.\n    signal.addEventListener(\"abort\", function () {\n        var _a, _b;\n        const it = opt.req.message[Symbol.asyncIterator]();\n        // If the signal is aborted due to an error, we want to throw\n        // the error to the request iterator.\n        if (!doneCalled) {\n            (_a = it.throw) === null || _a === void 0 ? void 0 : _a.call(it, this.reason).catch(() => {\n                // throw returns a promise, which we don't care about.\n                //\n                // Uncaught promises are thrown at sometime/somewhere by the event loop,\n                // this is to ensure error is caught and ignored.\n            });\n        }\n        (_b = it.return) === null || _b === void 0 ? void 0 : _b.call(it).catch(() => {\n            // return returns a promise, which we don't care about.\n            //\n            // Uncaught promises are thrown at sometime/somewhere by the event loop,\n            // this is to ensure error is caught and ignored.\n        });\n    });\n    return next(req).then((res) => {\n        return Object.assign(Object.assign({}, res), { message: {\n                [Symbol.asyncIterator]() {\n                    const it = res.message[Symbol.asyncIterator]();\n                    return {\n                        next() {\n                            return it.next().then((r) => {\n                                if (r.done == true) {\n                                    doneCalled = true;\n                                    done();\n                                }\n                                return r;\n                            }, abort);\n                        },\n                        // We deliberately omit throw/return.\n                    };\n                },\n            } });\n    }, abort);\n}\n/**\n * Create an AbortSignal for Transport implementations. The signal is available\n * in UnaryRequest and StreamingRequest, and is triggered when the call is\n * aborted (via a timeout or explicit cancellation), errored (e.g. when reading\n * an error from the server from the wire), or finished successfully.\n *\n * Transport implementations can pass the signal to HTTP clients to ensure that\n * there are no unused connections leak.\n *\n * Returns a tuple:\n * [0]: The signal, which is also aborted if the optional deadline is reached.\n * [1]: Function to call if the Transport encountered an error.\n * [2]: Function to call if the Transport finished without an error.\n */\nfunction setupSignal(opt) {\n    const { signal, cleanup } = createDeadlineSignal(opt.timeoutMs);\n    const controller = createLinkedAbortController(opt.signal, signal);\n    return [\n        controller.signal,\n        function abort(reason) {\n            // We peek at the deadline signal because fetch() will throw an error on\n            // abort that discards the signal reason.\n            const e = connect_error_ConnectError.from(signal.aborted ? getAbortSignalReason(signal) : reason);\n            controller.abort(e);\n            cleanup();\n            return Promise.reject(e);\n        },\n        function done() {\n            cleanup();\n            controller.abort();\n        },\n    ];\n}\n/**\n * applyInterceptors takes the given UnaryFn or ServerStreamingFn, and wraps\n * it with each of the given interceptors, returning a new UnaryFn or\n * ServerStreamingFn.\n */\nfunction applyInterceptors(next, interceptors) {\n    var _a;\n    return ((_a = interceptors === null || interceptors === void 0 ? void 0 : interceptors.concat().reverse().reduce(\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    (n, i) => i(n), next)) !== null && _a !== void 0 ? _a : next);\n}\n\n;// CONCATENATED MODULE: ./node_modules/@connectrpc/connect/dist/esm/protocol/create-method-url.js\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create a URL for the given RPC. This simply adds the qualified\n * service name, a slash, and the method name to the path of the given\n * baseUrl.\n *\n * For example, the baseUri https://example.com and method \"Say\" from\n * the service example.ElizaService results in:\n * https://example.com/example.ElizaService/Say\n *\n * This format is used by the protocols Connect, gRPC and Twirp.\n *\n * Note that this function also accepts a protocol-relative baseUrl.\n * If given an empty string or \"/\" as a baseUrl, it returns just the\n * path.\n */\nfunction createMethodUrl(baseUrl, service, method) {\n    const s = typeof service == \"string\" ? service : service.typeName;\n    const m = typeof method == \"string\" ? method : method.name;\n    return baseUrl.toString().replace(/\\/?$/, `/${s}/${m}`);\n}\n\n;// CONCATENATED MODULE: ./node_modules/@connectrpc/connect/dist/esm/protocol/envelope.js\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n/**\n * Create a WHATWG ReadableStream of enveloped messages from a ReadableStream\n * of bytes.\n *\n * Ideally, this would simply be a TransformStream, but ReadableStream.pipeThrough\n * does not have the necessary availability at this time.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction createEnvelopeReadableStream(stream) {\n    let reader;\n    let buffer = new Uint8Array(0);\n    function append(chunk) {\n        const n = new Uint8Array(buffer.length + chunk.length);\n        n.set(buffer);\n        n.set(chunk, buffer.length);\n        buffer = n;\n    }\n    return new ReadableStream({\n        start() {\n            reader = stream.getReader();\n        },\n        async pull(controller) {\n            let header = undefined;\n            for (;;) {\n                if (header === undefined && buffer.byteLength >= 5) {\n                    let length = 0;\n                    for (let i = 1; i < 5; i++) {\n                        length = (length << 8) + buffer[i];\n                    }\n                    header = { flags: buffer[0], length };\n                }\n                if (header !== undefined && buffer.byteLength >= header.length + 5) {\n                    break;\n                }\n                const result = await reader.read();\n                if (result.done) {\n                    break;\n                }\n                append(result.value);\n            }\n            if (header === undefined) {\n                if (buffer.byteLength == 0) {\n                    controller.close();\n                    return;\n                }\n                controller.error(new connect_error_ConnectError(\"premature end of stream\", code_Code.DataLoss));\n                return;\n            }\n            const data = buffer.subarray(5, 5 + header.length);\n            buffer = buffer.subarray(5 + header.length);\n            controller.enqueue({\n                flags: header.flags,\n                data,\n            });\n        },\n    });\n}\n/**\n * Compress an EnvelopedMessage.\n *\n * Raises Internal if an enveloped message is already compressed.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nasync function envelope_envelopeCompress(envelope, compression, compressMinBytes) {\n    let { flags, data } = envelope;\n    if ((flags & compressedFlag) === compressedFlag) {\n        throw new ConnectError(\"invalid envelope, already compressed\", Code.Internal);\n    }\n    if (compression && data.byteLength >= compressMinBytes) {\n        data = await compression.compress(data);\n        flags = flags | compressedFlag;\n    }\n    return { data, flags };\n}\n/**\n * Decompress an EnvelopedMessage.\n *\n * Raises InvalidArgument if an envelope is compressed, but compression is null.\n *\n * Relies on the provided Compression to raise ResourceExhausted if the\n * *decompressed* message size is larger than readMaxBytes. If the envelope is\n * not compressed, readMaxBytes is not honored.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nasync function envelope_envelopeDecompress(envelope, compression, readMaxBytes) {\n    let { flags, data } = envelope;\n    if ((flags & compressedFlag) === compressedFlag) {\n        if (!compression) {\n            throw new ConnectError(\"received compressed envelope, but do not know how to decompress\", Code.InvalidArgument);\n        }\n        data = await compression.decompress(data, readMaxBytes);\n        flags = flags ^ compressedFlag;\n    }\n    return { data, flags };\n}\n/**\n * Encode a single enveloped message.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction envelope_encodeEnvelope(flags, data) {\n    const bytes = new Uint8Array(data.length + 5);\n    bytes.set(data, 5);\n    const v = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    v.setUint8(0, flags); // first byte is flags\n    v.setUint32(1, data.length); // 4 bytes message length\n    return bytes;\n}\n/**\n * Encode a set of enveloped messages.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction encodeEnvelopes(...envelopes) {\n    const len = envelopes.reduce((previousValue, currentValue) => previousValue + currentValue.data.length + 5, 0);\n    const bytes = new Uint8Array(len);\n    const v = new DataView(bytes.buffer);\n    let offset = 0;\n    for (const e of envelopes) {\n        v.setUint8(offset, e.flags); // first byte is flags\n        v.setUint32(offset + 1, e.data.length); // 4 bytes message length\n        bytes.set(e.data, offset + 5);\n        offset += e.data.length + 5;\n    }\n    return bytes;\n}\n\n;// CONCATENATED MODULE: ./node_modules/@connectrpc/connect/dist/esm/protocol-grpc/headers.js\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * @private Internal code, does not follow semantic versioning.\n */\nconst headerContentType = \"Content-Type\";\nconst headers_headerEncoding = \"Grpc-Encoding\";\nconst headers_headerAcceptEncoding = \"Grpc-Accept-Encoding\";\nconst headerTimeout = \"Grpc-Timeout\";\nconst headers_headerGrpcStatus = \"Grpc-Status\";\nconst headers_headerGrpcMessage = \"Grpc-Message\";\nconst headers_headerStatusDetailsBin = \"Grpc-Status-Details-Bin\";\nconst headerMessageType = \"Grpc-Message-Type\";\nconst headerUserAgent = \"User-Agent\";\n\n;// CONCATENATED MODULE: ./node_modules/@connectrpc/connect/dist/esm/protocol-grpc-web/headers.js\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * @private Internal code, does not follow semantic versioning.\n */\n\n/**\n * gRPC-web does not use the standard header User-Agent.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nconst headerXUserAgent = \"X-User-Agent\";\n/**\n * The canonical grpc/grpc-web JavaScript implementation sets\n * this request header with value \"1\".\n * Some servers may rely on the header to identify gRPC-web\n * requests. For example the proxy by improbable:\n * https://github.com/improbable-eng/grpc-web/blob/53aaf4cdc0fede7103c1b06f0cfc560c003a5c41/go/grpcweb/wrapper.go#L231\n *\n * @private Internal code, does not follow semantic versioning.\n */\nconst headerXGrpcWeb = \"X-Grpc-Web\";\n\n;// CONCATENATED MODULE: ./node_modules/@connectrpc/connect/dist/esm/protocol-grpc-web/content-type.js\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Regular Expression that matches any valid gRPC-web Content-Type header value.\n * Note that this includes application/grpc-web-text with the additional base64\n * encoding.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nconst contentTypeRegExp = /^application\\/grpc-web(-text)?(?:\\+(?:(json)(?:; ?charset=utf-?8)?|proto))?$/i;\nconst contentTypeProto = \"application/grpc-web+proto\";\nconst contentTypeJson = \"application/grpc-web+json\";\n/**\n * Parse a gRPC-web Content-Type header value.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction parseContentType(contentType) {\n    const match = contentType === null || contentType === void 0 ? void 0 : contentType.match(contentTypeRegExp);\n    if (!match) {\n        return undefined;\n    }\n    const text = !!match[1];\n    const binary = !match[2];\n    return { text, binary };\n}\n\n;// CONCATENATED MODULE: ./node_modules/@connectrpc/connect/dist/esm/protocol-grpc-web/request-header.js\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n/**\n * Creates headers for a gRPC-web request.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction requestHeader(useBinaryFormat, timeoutMs, userProvidedHeaders, setUserAgent) {\n    const result = new Headers(userProvidedHeaders !== null && userProvidedHeaders !== void 0 ? userProvidedHeaders : {});\n    // Note that we do not support the grpc-web-text format.\n    // https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md#protocol-differences-vs-grpc-over-http2\n    result.set(headerContentType, useBinaryFormat ? contentTypeProto : contentTypeJson);\n    result.set(headerXGrpcWeb, \"1\");\n    // Note that we do not strictly comply with gRPC user agents.\n    // We use \"connect-es/1.2.3\" where gRPC would use \"grpc-es/1.2.3\".\n    // See https://github.com/grpc/grpc/blob/c462bb8d485fc1434ecfae438823ca8d14cf3154/doc/PROTOCOL-HTTP2.md#user-agents\n    result.set(headerXUserAgent, \"connect-es/1.2.0\");\n    if (setUserAgent) {\n        result.set(headerUserAgent, \"connect-es/1.2.0\");\n    }\n    if (timeoutMs !== undefined) {\n        result.set(headerTimeout, `${timeoutMs}m`);\n    }\n    return result;\n}\n/**\n * Creates headers for a gRPC-web request with compression.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction requestHeaderWithCompression(useBinaryFormat, timeoutMs, userProvidedHeaders, acceptCompression, sendCompression, setUserAgent) {\n    const result = requestHeader(useBinaryFormat, timeoutMs, userProvidedHeaders, setUserAgent);\n    if (sendCompression != null) {\n        result.set(headerEncoding, sendCompression.name);\n    }\n    if (acceptCompression.length > 0) {\n        result.set(headerAcceptEncoding, acceptCompression.map((c) => c.name).join(\",\"));\n    }\n    return result;\n}\n\n;// CONCATENATED MODULE: ./node_modules/@connectrpc/connect/dist/esm/protocol-grpc/http-status.js\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * Determine the gRPC-web error code for the given HTTP status code.\n * See https://github.com/grpc/grpc/blob/master/doc/http-grpc-status-mapping.md.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction codeFromHttpStatus(httpStatus) {\n    switch (httpStatus) {\n        case 400: // Bad Request\n            return code_Code.Internal;\n        case 401: // Unauthorized\n            return code_Code.Unauthenticated;\n        case 403: // Forbidden\n            return code_Code.PermissionDenied;\n        case 404: // Not Found\n            return code_Code.Unimplemented;\n        case 429: // Too Many Requests\n            return code_Code.Unavailable;\n        case 502: // Bad Gateway\n            return code_Code.Unavailable;\n        case 503: // Service Unavailable\n            return code_Code.Unavailable;\n        case 504: // Gateway Timeout\n            return code_Code.Unavailable;\n        default:\n            // 200 is UNKNOWN because there should be a grpc-status in case of truly OK response.\n            return code_Code.Unknown;\n    }\n}\n\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/proto3.js + 2 modules\nvar proto3 = __nested_webpack_require_488788__(850);\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/any_pb.js\nvar any_pb = __nested_webpack_require_488788__(733);\n;// CONCATENATED MODULE: ./node_modules/@connectrpc/connect/dist/esm/protocol-grpc/gen/status_pb.js\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * The `Status` type defines a logical error model that is suitable for different\n * programming environments, including REST APIs and RPC APIs. It is used by\n * [gRPC](https://github.com/grpc). The error model is designed to be:\n *\n * - Simple to use and understand for most users\n * - Flexible enough to meet unexpected needs\n *\n * # Overview\n *\n * The `Status` message contains three pieces of data: error code, error message,\n * and error details. The error code should be an enum value of\n * [google.rpc.Code][google.rpc.Code], but it may accept additional error codes if needed.  The\n * error message should be a developer-facing English message that helps\n * developers *understand* and *resolve* the error. If a localized user-facing\n * error message is needed, put the localized message in the error details or\n * localize it in the client. The optional error details may contain arbitrary\n * information about the error. There is a predefined set of error detail types\n * in the package `google.rpc` which can be used for common error conditions.\n *\n * # Language mapping\n *\n * The `Status` message is the logical representation of the error model, but it\n * is not necessarily the actual wire format. When the `Status` message is\n * exposed in different client libraries and different wire protocols, it can be\n * mapped differently. For example, it will likely be mapped to some exceptions\n * in Java, but more likely mapped to some error codes in C.\n *\n * # Other uses\n *\n * The error model and the `Status` message can be used in a variety of\n * environments, either with or without APIs, to provide a\n * consistent developer experience across different environments.\n *\n * Example uses of this error model include:\n *\n * - Partial errors. If a service needs to return partial errors to the client,\n *     it may embed the `Status` in the normal response to indicate the partial\n *     errors.\n *\n * - Workflow errors. A typical workflow has multiple steps. Each step may\n *     have a `Status` message for error reporting purpose.\n *\n * - Batch operations. If a client uses batch request and batch response, the\n *     `Status` message should be used directly inside batch response, one for\n *     each error sub-response.\n *\n * - Asynchronous operations. If an API call embeds asynchronous operation\n *     results in its response, the status of those operations should be\n *     represented directly using the `Status` message.\n *\n * - Logging. If some API errors are stored in logs, the message `Status` could\n *     be used directly after any stripping needed for security/privacy reasons.\n *\n * @generated from message google.rpc.Status\n */\nclass status_pb_Status extends esm_message/* Message */.v {\n    constructor(data) {\n        super();\n        /**\n         * The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].\n         *\n         * @generated from field: int32 code = 1;\n         */\n        this.code = 0;\n        /**\n         * A developer-facing error message, which should be in English. Any\n         * user-facing error message should be localized and sent in the\n         * [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client.\n         *\n         * @generated from field: string message = 2;\n         */\n        this.message = \"\";\n        /**\n         * A list of messages that carry the error details.  There will be a\n         * common set of message types for APIs to use.\n         *\n         * @generated from field: repeated google.protobuf.Any details = 3;\n         */\n        this.details = [];\n        proto3/* proto3 */.w.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new status_pb_Status().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new status_pb_Status().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new status_pb_Status().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3/* proto3 */.w.util.equals(status_pb_Status, a, b);\n    }\n}\nstatus_pb_Status.runtime = proto3/* proto3 */.w;\nstatus_pb_Status.typeName = \"google.rpc.Status\";\nstatus_pb_Status.fields = proto3/* proto3 */.w.util.newFieldList(() => [\n    { no: 1, name: \"code\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */ },\n    { no: 2, name: \"message\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 3, name: \"details\", kind: \"message\", T: any_pb/* Any */.I, repeated: true },\n]);\n\n// EXTERNAL MODULE: ./node_modules/@bufbuild/protobuf/dist/esm/proto-base64.js\nvar proto_base64 = __nested_webpack_require_488788__(236);\n;// CONCATENATED MODULE: ./node_modules/@connectrpc/connect/dist/esm/http-headers.js\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n/**\n * Encode a single binary header value according to the Connect\n * and gRPC specifications.\n *\n * This function accepts raw binary data from a buffer, a string\n * with UTF-8 text, or a protobuf message. It encodes the input\n * with unpadded base64 and returns a string that can be used for\n * a header whose name ends with `-bin`.\n */\nfunction http_headers_encodeBinaryHeader(value) {\n    let bytes;\n    if (value instanceof Message) {\n        bytes = value.toBinary();\n    }\n    else if (typeof value == \"string\") {\n        bytes = new TextEncoder().encode(value);\n    }\n    else {\n        bytes = value instanceof Uint8Array ? value : new Uint8Array(value);\n    }\n    return protoBase64.enc(bytes).replace(/=+$/, \"\");\n}\nfunction decodeBinaryHeader(value, type, options) {\n    try {\n        const bytes = proto_base64/* protoBase64 */.W.dec(value);\n        if (type) {\n            return type.fromBinary(bytes, options);\n        }\n        return bytes;\n    }\n    catch (e) {\n        throw connect_error_ConnectError.from(e, code_Code.DataLoss);\n    }\n}\n/**\n * Merge two or more Headers objects by appending all fields from\n * all inputs to a new Headers object.\n */\nfunction appendHeaders(...headers) {\n    const h = new Headers();\n    for (const e of headers) {\n        e.forEach((value, key) => {\n            h.append(key, value);\n        });\n    }\n    return h;\n}\n\n;// CONCATENATED MODULE: ./node_modules/@connectrpc/connect/dist/esm/protocol-grpc/trailer-status.js\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n\n\n\n/**\n * The value of the Grpc-Status header or trailer in case of success.\n * Used by the gRPC and gRPC-web protocols.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nconst grpcStatusOk = \"0\";\n/**\n * Sets the fields \"grpc-status\" and \"grpc-message\" in the given\n * Headers object.\n * If an error is given and contains error details, the function\n * will also set the field \"grpc-status-details-bin\" with an encoded\n * google.rpc.Status message including the error details.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction setTrailerStatus(target, error) {\n    if (error) {\n        target.set(headerGrpcStatus, error.code.toString(10));\n        target.set(headerGrpcMessage, encodeURIComponent(error.rawMessage));\n        if (error.details.length > 0) {\n            const status = new Status({\n                code: error.code,\n                message: error.rawMessage,\n                details: error.details.map((value) => value instanceof Message\n                    ? Any.pack(value)\n                    : new Any({\n                        typeUrl: `type.googleapis.com/${value.type}`,\n                        value: value.value,\n                    })),\n            });\n            target.set(headerStatusDetailsBin, encodeBinaryHeader(status));\n        }\n    }\n    else {\n        target.set(headerGrpcStatus, grpcStatusOk.toString());\n    }\n    return target;\n}\n/**\n * Find an error status in the given Headers object, which can be either\n * a trailer, or a header (as allowed for so-called trailers-only responses).\n * The field \"grpc-status-details-bin\" is inspected, and if not present,\n * the fields \"grpc-status\" and \"grpc-message\" are used.\n * Returns an error only if the gRPC status code is > 0.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction findTrailerError(headerOrTrailer) {\n    // TODO\n    // let code: Code;\n    // let message: string = \"\";\n    var _a;\n    // Prefer the protobuf-encoded data to the grpc-status header.\n    const statusBytes = headerOrTrailer.get(headers_headerStatusDetailsBin);\n    if (statusBytes != null) {\n        const status = decodeBinaryHeader(statusBytes, status_pb_Status);\n        if (status.code == 0) {\n            return undefined;\n        }\n        const error = new connect_error_ConnectError(status.message, status.code, headerOrTrailer);\n        error.details = status.details.map((any) => ({\n            type: any.typeUrl.substring(any.typeUrl.lastIndexOf(\"/\") + 1),\n            value: any.value,\n        }));\n        return error;\n    }\n    const grpcStatus = headerOrTrailer.get(headers_headerGrpcStatus);\n    if (grpcStatus != null) {\n        if (grpcStatus === grpcStatusOk) {\n            return undefined;\n        }\n        const code = parseInt(grpcStatus, 10);\n        if (code in code_Code) {\n            return new connect_error_ConnectError(decodeURIComponent((_a = headerOrTrailer.get(headers_headerGrpcMessage)) !== null && _a !== void 0 ? _a : \"\"), code, headerOrTrailer);\n        }\n        return new connect_error_ConnectError(`invalid grpc-status: ${grpcStatus}`, code_Code.Internal, headerOrTrailer);\n    }\n    return undefined;\n}\n\n;// CONCATENATED MODULE: ./node_modules/@connectrpc/connect/dist/esm/protocol-grpc-web/validate-response.js\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n\n\n/**\n * Validates response status and header for the gRPC-web protocol.\n *\n * Throws a ConnectError if the header contains an error status,\n * or if the HTTP status indicates an error.\n *\n * Returns an object that indicates whether a gRPC status was found\n * in the response header. In this case, clients can not expect a\n * trailer.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction validateResponse(status, headers) {\n    var _a;\n    // For compatibility with the `grpc-web` package, we treat all HTTP status\n    // codes in the 200 range as valid, not just HTTP 200.\n    if (status >= 200 && status < 300) {\n        const err = findTrailerError(headers);\n        if (err) {\n            throw err;\n        }\n        return { foundStatus: headers.has(headers_headerGrpcStatus) };\n    }\n    throw new connect_error_ConnectError(decodeURIComponent((_a = headers.get(headers_headerGrpcMessage)) !== null && _a !== void 0 ? _a : `HTTP ${status}`), codeFromHttpStatus(status), headers);\n}\n/**\n * Validates response status and header for the gRPC-web protocol.\n * This function is identical to validateResponse(), but also verifies\n * that a given encoding header is acceptable.\n *\n * Returns an object with the response compression, and a boolean\n * indicating whether a gRPC status was found in the response header\n * (in this case, clients can not expect a trailer).\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction validateResponseWithCompression(acceptCompression, status, headers) {\n    const { foundStatus } = validateResponse(status, headers);\n    let compression;\n    const encoding = headers.get(headerEncoding);\n    if (encoding !== null && encoding.toLowerCase() !== \"identity\") {\n        compression = acceptCompression.find((c) => c.name === encoding);\n        if (!compression) {\n            throw new ConnectError(`unsupported response encoding \"${encoding}\"`, Code.InvalidArgument, headers);\n        }\n    }\n    return {\n        foundStatus,\n        compression,\n    };\n}\n\n;// CONCATENATED MODULE: ./node_modules/@connectrpc/connect/dist/esm/protocol-grpc-web/trailer.js\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * trailerFlag indicates that the data in a EnvelopedMessage\n * is a set of trailers of the gRPC-web protocol.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nconst trailerFlag = 0b10000000;\n/**\n * Parse a gRPC-web trailer, a set of header fields separated by CRLF.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction trailerParse(data) {\n    const headers = new Headers();\n    const lines = new TextDecoder().decode(data).split(\"\\r\\n\");\n    for (const line of lines) {\n        if (line === \"\") {\n            continue;\n        }\n        const i = line.indexOf(\":\");\n        if (i > 0) {\n            const name = line.substring(0, i).trim();\n            const value = line.substring(i + 1).trim();\n            headers.append(name, value);\n        }\n    }\n    return headers;\n}\n/**\n * Serialize a Headers object as a gRPC-web trailer.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction trailerSerialize(trailer) {\n    const lines = [];\n    trailer.forEach((value, key) => {\n        lines.push(`${key}: ${value}\\r\\n`);\n    });\n    return new TextEncoder().encode(lines.join(\"\"));\n}\n/**\n * Create a Serialization object that serializes a gRPC-web trailer, a Headers\n * object that is serialized as a set of header fields, separated by CRLF.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction createTrailerSerialization() {\n    return {\n        serialize: trailerSerialize,\n        parse: trailerParse,\n    };\n}\n\n;// CONCATENATED MODULE: ./node_modules/@connectrpc/connect/dist/esm/protocol-grpc/validate-trailer.js\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * Validates a trailer for the gRPC and the gRPC-web protocol.\n * Throws a ConnectError if the trailer contains an error status.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction validateTrailer(trailer, header) {\n    const err = findTrailerError(trailer);\n    if (err) {\n        header.forEach((value, key) => {\n            err.metadata.append(key, value);\n        });\n        throw err;\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/@connectrpc/connect-web/dist/esm/assert-fetch-api.js\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Asserts that the fetch API is available.\n */\nfunction assertFetchApi() {\n    try {\n        new Headers();\n    }\n    catch (_) {\n        throw new Error(\"connect-web requires the fetch API. Are you running on an old version of Node.js? Node.js is not supported in Connect for Web - please stay tuned for Connect for Node.\");\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/@connectrpc/connect-web/dist/esm/grpc-web-transport.js\n// Copyright 2021-2023 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar grpc_web_transport_await = ( false) || function (v) { return this instanceof grpc_web_transport_await ? (this.v = v, this) : new grpc_web_transport_await(v); }\nvar grpc_web_transport_asyncGenerator = ( false) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof grpc_web_transport_await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\n\n\n\n\n\n/**\n * Create a Transport for the gRPC-web protocol. The protocol encodes\n * trailers in the response body and makes unary and server-streaming\n * methods available to web browsers. It uses the fetch API to make\n * HTTP requests.\n *\n * Note that this transport does not implement the grpc-web-text format,\n * which applies base64 encoding to the request and response bodies to\n * support reading streaming responses from an XMLHttpRequest.\n */\nfunction createGrpcWebTransport(options) {\n    var _a;\n    assertFetchApi();\n    const useBinaryFormat = (_a = options.useBinaryFormat) !== null && _a !== void 0 ? _a : true;\n    return {\n        async unary(service, method, signal, timeoutMs, header, message, contextValues) {\n            var _a;\n            const { serialize, parse } = createClientMethodSerializers(method, useBinaryFormat, options.jsonOptions, options.binaryOptions);\n            timeoutMs =\n                timeoutMs === undefined\n                    ? options.defaultTimeoutMs\n                    : timeoutMs <= 0\n                        ? undefined\n                        : timeoutMs;\n            return await runUnaryCall({\n                interceptors: options.interceptors,\n                signal,\n                timeoutMs,\n                req: {\n                    stream: false,\n                    service,\n                    method,\n                    url: createMethodUrl(options.baseUrl, service, method),\n                    init: {\n                        method: \"POST\",\n                        credentials: (_a = options.credentials) !== null && _a !== void 0 ? _a : \"same-origin\",\n                        redirect: \"error\",\n                        mode: \"cors\",\n                    },\n                    header: requestHeader(useBinaryFormat, timeoutMs, header, false),\n                    contextValues: contextValues !== null && contextValues !== void 0 ? contextValues : createContextValues(),\n                    message,\n                },\n                next: async (req) => {\n                    var _a;\n                    const fetch = (_a = options.fetch) !== null && _a !== void 0 ? _a : globalThis.fetch;\n                    const response = await fetch(req.url, Object.assign(Object.assign({}, req.init), { headers: req.header, signal: req.signal, body: envelope_encodeEnvelope(0, serialize(req.message)) }));\n                    validateResponse(response.status, response.headers);\n                    if (!response.body) {\n                        throw \"missing response body\";\n                    }\n                    const reader = createEnvelopeReadableStream(response.body).getReader();\n                    let trailer;\n                    let message;\n                    for (;;) {\n                        const r = await reader.read();\n                        if (r.done) {\n                            break;\n                        }\n                        const { flags, data } = r.value;\n                        if (flags === trailerFlag) {\n                            if (trailer !== undefined) {\n                                throw \"extra trailer\";\n                            }\n                            // Unary responses require exactly one response message, but in\n                            // case of an error, it is perfectly valid to have a response body\n                            // that only contains error trailers.\n                            trailer = trailerParse(data);\n                            continue;\n                        }\n                        if (message !== undefined) {\n                            throw \"extra message\";\n                        }\n                        message = parse(data);\n                    }\n                    if (trailer === undefined) {\n                        throw \"missing trailer\";\n                    }\n                    validateTrailer(trailer, response.headers);\n                    if (message === undefined) {\n                        throw \"missing message\";\n                    }\n                    return {\n                        stream: false,\n                        header: response.headers,\n                        message,\n                        trailer,\n                    };\n                },\n            });\n        },\n        async stream(service, method, signal, timeoutMs, header, input, contextValues) {\n            var _a;\n            const { serialize, parse } = createClientMethodSerializers(method, useBinaryFormat, options.jsonOptions, options.binaryOptions);\n            function parseResponseBody(body, foundStatus, trailerTarget, header) {\n                return grpc_web_transport_asyncGenerator(this, arguments, function* parseResponseBody_1() {\n                    const reader = createEnvelopeReadableStream(body).getReader();\n                    if (foundStatus) {\n                        // A grpc-status: 0 response header was present. This is a \"trailers-only\"\n                        // response (a response without a body and no trailers).\n                        //\n                        // The spec seems to disallow a trailers-only response for status 0 - we are\n                        // lenient and only verify that the body is empty.\n                        //\n                        // > [...] Trailers-Only is permitted for calls that produce an immediate error.\n                        // See https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md\n                        if (!(yield grpc_web_transport_await(reader.read())).done) {\n                            throw \"extra data for trailers-only\";\n                        }\n                        return yield grpc_web_transport_await(void 0);\n                    }\n                    let trailerReceived = false;\n                    for (;;) {\n                        const result = yield grpc_web_transport_await(reader.read());\n                        if (result.done) {\n                            break;\n                        }\n                        const { flags, data } = result.value;\n                        if ((flags & trailerFlag) === trailerFlag) {\n                            if (trailerReceived) {\n                                throw \"extra trailer\";\n                            }\n                            trailerReceived = true;\n                            const trailer = trailerParse(data);\n                            validateTrailer(trailer, header);\n                            trailer.forEach((value, key) => trailerTarget.set(key, value));\n                            continue;\n                        }\n                        if (trailerReceived) {\n                            throw \"extra message\";\n                        }\n                        yield yield grpc_web_transport_await(parse(data));\n                        continue;\n                    }\n                    if (!trailerReceived) {\n                        throw \"missing trailer\";\n                    }\n                });\n            }\n            async function createRequestBody(input) {\n                if (method.kind != service_type/* MethodKind */.t.ServerStreaming) {\n                    throw \"The fetch API does not support streaming request bodies\";\n                }\n                const r = await input[Symbol.asyncIterator]().next();\n                if (r.done == true) {\n                    throw \"missing request message\";\n                }\n                return envelope_encodeEnvelope(0, serialize(r.value));\n            }\n            timeoutMs =\n                timeoutMs === undefined\n                    ? options.defaultTimeoutMs\n                    : timeoutMs <= 0\n                        ? undefined\n                        : timeoutMs;\n            return runStreamingCall({\n                interceptors: options.interceptors,\n                signal,\n                timeoutMs,\n                req: {\n                    stream: true,\n                    service,\n                    method,\n                    url: createMethodUrl(options.baseUrl, service, method),\n                    init: {\n                        method: \"POST\",\n                        credentials: (_a = options.credentials) !== null && _a !== void 0 ? _a : \"same-origin\",\n                        redirect: \"error\",\n                        mode: \"cors\",\n                    },\n                    header: requestHeader(useBinaryFormat, timeoutMs, header, false),\n                    contextValues: contextValues !== null && contextValues !== void 0 ? contextValues : createContextValues(),\n                    message: input,\n                },\n                next: async (req) => {\n                    var _a;\n                    const fetch = (_a = options.fetch) !== null && _a !== void 0 ? _a : globalThis.fetch;\n                    const fRes = await fetch(req.url, Object.assign(Object.assign({}, req.init), { headers: req.header, signal: req.signal, body: await createRequestBody(req.message) }));\n                    const { foundStatus } = validateResponse(fRes.status, fRes.headers);\n                    if (!fRes.body) {\n                        throw \"missing response body\";\n                    }\n                    const trailer = new Headers();\n                    const res = Object.assign(Object.assign({}, req), { header: fRes.headers, trailer, message: parseResponseBody(fRes.body, foundStatus, trailer, fRes.headers) });\n                    return res;\n                },\n            });\n        },\n    };\n}\n\n// EXTERNAL MODULE: ./src/api/yorkie/v1/yorkie_connect.js\nvar yorkie_connect = __nested_webpack_require_488788__(295);\n// EXTERNAL MODULE: ./src/api/yorkie/v1/resources_pb.js\nvar resources_pb = __nested_webpack_require_488788__(646);\n;// CONCATENATED MODULE: ./node_modules/long/index.js\n/**\n * @license\n * Copyright 2009 The Closure Library Authors\n * Copyright 2020 Daniel Wirtz / The long.js Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// WebAssembly optimizations to do native i64 multiplication and divide\nvar wasm = null;\ntry {\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11\n  ])), {}).exports;\n} catch (e) {\n  // no wasm support :(\n}\n\n/**\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\n *  See the from* functions below for more convenient ways of constructing Longs.\n * @exports Long\n * @class A Long class for representing a 64 bit two's-complement integer value.\n * @param {number} low The low (signed) 32 bits of the long\n * @param {number} high The high (signed) 32 bits of the long\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @constructor\n */\nfunction Long(low, high, unsigned) {\n\n  /**\n   * The low 32 bits as a signed value.\n   * @type {number}\n   */\n  this.low = low | 0;\n\n  /**\n   * The high 32 bits as a signed value.\n   * @type {number}\n   */\n  this.high = high | 0;\n\n  /**\n   * Whether unsigned or not.\n   * @type {boolean}\n   */\n  this.unsigned = !!unsigned;\n}\n\n// The internal representation of a long is the two given signed, 32-bit values.\n// We use 32-bit pieces because these are the size of integers on which\n// Javascript performs bit-operations.  For operations like addition and\n// multiplication, we split each number into 16 bit pieces, which can easily be\n// multiplied within Javascript's floating-point representation without overflow\n// or change in sign.\n//\n// In the algorithms below, we frequently reduce the negative case to the\n// positive case by negating the input(s) and then post-processing the result.\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n// a positive number, it overflows back into a negative).  Not handling this\n// case would often result in infinite recursion.\n//\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\n// methods on which they depend.\n\n/**\n * An indicator used to reliably determine if an object is a Long or not.\n * @type {boolean}\n * @const\n * @private\n */\nLong.prototype.__isLong__;\n\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\n\n/**\n * @function\n * @param {*} obj Object\n * @returns {boolean}\n * @inner\n */\nfunction isLong(obj) {\n  return (obj && obj[\"__isLong__\"]) === true;\n}\n\n/**\n * @function\n * @param {*} value number\n * @returns {number}\n * @inner\n */\nfunction ctz32(value) {\n  var c = Math.clz32(value & -value);\n  return value ? 31 - c : c;\n}\n\n/**\n * Tests if the specified object is a Long.\n * @function\n * @param {*} obj Object\n * @returns {boolean}\n */\nLong.isLong = isLong;\n\n/**\n * A cache of the Long representations of small integer values.\n * @type {!Object}\n * @inner\n */\nvar INT_CACHE = {};\n\n/**\n * A cache of the Long representations of small unsigned integer values.\n * @type {!Object}\n * @inner\n */\nvar UINT_CACHE = {};\n\n/**\n * @param {number} value\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromInt(value, unsigned) {\n  var obj, cachedObj, cache;\n  if (unsigned) {\n    value >>>= 0;\n    if (cache = (0 <= value && value < 256)) {\n      cachedObj = UINT_CACHE[value];\n      if (cachedObj)\n        return cachedObj;\n    }\n    obj = fromBits(value, 0, true);\n    if (cache)\n      UINT_CACHE[value] = obj;\n    return obj;\n  } else {\n    value |= 0;\n    if (cache = (-128 <= value && value < 128)) {\n      cachedObj = INT_CACHE[value];\n      if (cachedObj)\n        return cachedObj;\n    }\n    obj = fromBits(value, value < 0 ? -1 : 0, false);\n    if (cache)\n      INT_CACHE[value] = obj;\n    return obj;\n  }\n}\n\n/**\n * Returns a Long representing the given 32 bit integer value.\n * @function\n * @param {number} value The 32 bit integer in question\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\nLong.fromInt = fromInt;\n\n/**\n * @param {number} value\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromNumber(value, unsigned) {\n  if (isNaN(value))\n    return unsigned ? UZERO : ZERO;\n  if (unsigned) {\n    if (value < 0)\n      return UZERO;\n    if (value >= TWO_PWR_64_DBL)\n      return MAX_UNSIGNED_VALUE;\n  } else {\n    if (value <= -TWO_PWR_63_DBL)\n      return MIN_VALUE;\n    if (value + 1 >= TWO_PWR_63_DBL)\n      return MAX_VALUE;\n  }\n  if (value < 0)\n    return fromNumber(-value, unsigned).neg();\n  return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\n}\n\n/**\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n * @function\n * @param {number} value The number in question\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\nLong.fromNumber = fromNumber;\n\n/**\n * @param {number} lowBits\n * @param {number} highBits\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromBits(lowBits, highBits, unsigned) {\n  return new Long(lowBits, highBits, unsigned);\n}\n\n/**\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\n *  assumed to use 32 bits.\n * @function\n * @param {number} lowBits The low 32 bits\n * @param {number} highBits The high 32 bits\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\nLong.fromBits = fromBits;\n\n/**\n * @function\n * @param {number} base\n * @param {number} exponent\n * @returns {number}\n * @inner\n */\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\n\n/**\n * @param {string} str\n * @param {(boolean|number)=} unsigned\n * @param {number=} radix\n * @returns {!Long}\n * @inner\n */\nfunction fromString(str, unsigned, radix) {\n  if (str.length === 0)\n    throw Error('empty string');\n  if (typeof unsigned === 'number') {\n    // For goog.math.long compatibility\n    radix = unsigned;\n    unsigned = false;\n  } else {\n    unsigned = !!unsigned;\n  }\n  if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\n    return unsigned ? UZERO : ZERO;\n  radix = radix || 10;\n  if (radix < 2 || 36 < radix)\n    throw RangeError('radix');\n\n  var p;\n  if ((p = str.indexOf('-')) > 0)\n    throw Error('interior hyphen');\n  else if (p === 0) {\n    return fromString(str.substring(1), unsigned, radix).neg();\n  }\n\n  // Do several (8) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = fromNumber(pow_dbl(radix, 8));\n\n  var result = ZERO;\n  for (var i = 0; i < str.length; i += 8) {\n    var size = Math.min(8, str.length - i),\n      value = parseInt(str.substring(i, i + size), radix);\n    if (size < 8) {\n      var power = fromNumber(pow_dbl(radix, size));\n      result = result.mul(power).add(fromNumber(value));\n    } else {\n      result = result.mul(radixToPower);\n      result = result.add(fromNumber(value));\n    }\n  }\n  result.unsigned = unsigned;\n  return result;\n}\n\n/**\n * Returns a Long representation of the given string, written using the specified radix.\n * @function\n * @param {string} str The textual representation of the Long\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\n * @returns {!Long} The corresponding Long value\n */\nLong.fromString = fromString;\n\n/**\n * @function\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromValue(val, unsigned) {\n  if (typeof val === 'number')\n    return fromNumber(val, unsigned);\n  if (typeof val === 'string')\n    return fromString(val, unsigned);\n  // Throws for non-objects, converts non-instanceof Long:\n  return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\n}\n\n/**\n * Converts the specified value to a Long using the appropriate from* function for its type.\n * @function\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long}\n */\nLong.fromValue = fromValue;\n\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\n// no runtime penalty for these.\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_16_DBL = 1 << 16;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_24_DBL = 1 << 24;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n\n/**\n * @type {!Long}\n * @const\n * @inner\n */\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\n\n/**\n * @type {!Long}\n * @inner\n */\nvar ZERO = fromInt(0);\n\n/**\n * Signed zero.\n * @type {!Long}\n */\nLong.ZERO = ZERO;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar UZERO = fromInt(0, true);\n\n/**\n * Unsigned zero.\n * @type {!Long}\n */\nLong.UZERO = UZERO;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar ONE = fromInt(1);\n\n/**\n * Signed one.\n * @type {!Long}\n */\nLong.ONE = ONE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar UONE = fromInt(1, true);\n\n/**\n * Unsigned one.\n * @type {!Long}\n */\nLong.UONE = UONE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar NEG_ONE = fromInt(-1);\n\n/**\n * Signed negative one.\n * @type {!Long}\n */\nLong.NEG_ONE = NEG_ONE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);\n\n/**\n * Maximum signed value.\n * @type {!Long}\n */\nLong.MAX_VALUE = MAX_VALUE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);\n\n/**\n * Maximum unsigned value.\n * @type {!Long}\n */\nLong.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar MIN_VALUE = fromBits(0, 0x80000000 | 0, false);\n\n/**\n * Minimum signed value.\n * @type {!Long}\n */\nLong.MIN_VALUE = MIN_VALUE;\n\n/**\n * @alias Long.prototype\n * @inner\n */\nvar LongPrototype = Long.prototype;\n\n/**\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\n * @this {!Long}\n * @returns {number}\n */\nLongPrototype.toInt = function toInt() {\n  return this.unsigned ? this.low >>> 0 : this.low;\n};\n\n/**\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n * @this {!Long}\n * @returns {number}\n */\nLongPrototype.toNumber = function toNumber() {\n  if (this.unsigned)\n    return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\n  return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n};\n\n/**\n * Converts the Long to a string written in the specified radix.\n * @this {!Long}\n * @param {number=} radix Radix (2-36), defaults to 10\n * @returns {string}\n * @override\n * @throws {RangeError} If `radix` is out of range\n */\nLongPrototype.toString = function toString(radix) {\n  radix = radix || 10;\n  if (radix < 2 || 36 < radix)\n    throw RangeError('radix');\n  if (this.isZero())\n    return '0';\n  if (this.isNegative()) { // Unsigned Longs are never negative\n    if (this.eq(MIN_VALUE)) {\n      // We need to change the Long value before it can be negated, so we remove\n      // the bottom-most digit in this base and then recurse to do the rest.\n      var radixLong = fromNumber(radix),\n        div = this.div(radixLong),\n        rem1 = div.mul(radixLong).sub(this);\n      return div.toString(radix) + rem1.toInt().toString(radix);\n    } else\n      return '-' + this.neg().toString(radix);\n  }\n\n  // Do several (6) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\n    rem = this;\n  var result = '';\n  while (true) {\n    var remDiv = rem.div(radixToPower),\n      intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\n      digits = intval.toString(radix);\n    rem = remDiv;\n    if (rem.isZero())\n      return digits + result;\n    else {\n      while (digits.length < 6)\n        digits = '0' + digits;\n      result = '' + digits + result;\n    }\n  }\n};\n\n/**\n * Gets the high 32 bits as a signed integer.\n * @this {!Long}\n * @returns {number} Signed high bits\n */\nLongPrototype.getHighBits = function getHighBits() {\n  return this.high;\n};\n\n/**\n * Gets the high 32 bits as an unsigned integer.\n * @this {!Long}\n * @returns {number} Unsigned high bits\n */\nLongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\n  return this.high >>> 0;\n};\n\n/**\n * Gets the low 32 bits as a signed integer.\n * @this {!Long}\n * @returns {number} Signed low bits\n */\nLongPrototype.getLowBits = function getLowBits() {\n  return this.low;\n};\n\n/**\n * Gets the low 32 bits as an unsigned integer.\n * @this {!Long}\n * @returns {number} Unsigned low bits\n */\nLongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\n  return this.low >>> 0;\n};\n\n/**\n * Gets the number of bits needed to represent the absolute value of this Long.\n * @this {!Long}\n * @returns {number}\n */\nLongPrototype.getNumBitsAbs = function getNumBitsAbs() {\n  if (this.isNegative()) // Unsigned Longs are never negative\n    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n  var val = this.high != 0 ? this.high : this.low;\n  for (var bit = 31; bit > 0; bit--)\n    if ((val & (1 << bit)) != 0)\n      break;\n  return this.high != 0 ? bit + 33 : bit + 1;\n};\n\n/**\n * Tests if this Long's value equals zero.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isZero = function isZero() {\n  return this.high === 0 && this.low === 0;\n};\n\n/**\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\n * @returns {boolean}\n */\nLongPrototype.eqz = LongPrototype.isZero;\n\n/**\n * Tests if this Long's value is negative.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isNegative = function isNegative() {\n  return !this.unsigned && this.high < 0;\n};\n\n/**\n * Tests if this Long's value is positive or zero.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isPositive = function isPositive() {\n  return this.unsigned || this.high >= 0;\n};\n\n/**\n * Tests if this Long's value is odd.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isOdd = function isOdd() {\n  return (this.low & 1) === 1;\n};\n\n/**\n * Tests if this Long's value is even.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isEven = function isEven() {\n  return (this.low & 1) === 0;\n};\n\n/**\n * Tests if this Long's value equals the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.equals = function equals(other) {\n  if (!isLong(other))\n    other = fromValue(other);\n  if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\n    return false;\n  return this.high === other.high && this.low === other.low;\n};\n\n/**\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.eq = LongPrototype.equals;\n\n/**\n * Tests if this Long's value differs from the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.notEquals = function notEquals(other) {\n  return !this.eq(/* validates */ other);\n};\n\n/**\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.neq = LongPrototype.notEquals;\n\n/**\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.ne = LongPrototype.notEquals;\n\n/**\n * Tests if this Long's value is less than the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lessThan = function lessThan(other) {\n  return this.comp(/* validates */ other) < 0;\n};\n\n/**\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lt = LongPrototype.lessThan;\n\n/**\n * Tests if this Long's value is less than or equal the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\n  return this.comp(/* validates */ other) <= 0;\n};\n\n/**\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lte = LongPrototype.lessThanOrEqual;\n\n/**\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.le = LongPrototype.lessThanOrEqual;\n\n/**\n * Tests if this Long's value is greater than the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.greaterThan = function greaterThan(other) {\n  return this.comp(/* validates */ other) > 0;\n};\n\n/**\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.gt = LongPrototype.greaterThan;\n\n/**\n * Tests if this Long's value is greater than or equal the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\n  return this.comp(/* validates */ other) >= 0;\n};\n\n/**\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.gte = LongPrototype.greaterThanOrEqual;\n\n/**\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.ge = LongPrototype.greaterThanOrEqual;\n\n/**\n * Compares this Long's value with the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n *  if the given one is greater\n */\nLongPrototype.compare = function compare(other) {\n  if (!isLong(other))\n    other = fromValue(other);\n  if (this.eq(other))\n    return 0;\n  var thisNeg = this.isNegative(),\n    otherNeg = other.isNegative();\n  if (thisNeg && !otherNeg)\n    return -1;\n  if (!thisNeg && otherNeg)\n    return 1;\n  // At this point the sign bits are the same\n  if (!this.unsigned)\n    return this.sub(other).isNegative() ? -1 : 1;\n  // Both are positive if at least one is unsigned\n  return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\n};\n\n/**\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n *  if the given one is greater\n */\nLongPrototype.comp = LongPrototype.compare;\n\n/**\n * Negates this Long's value.\n * @this {!Long}\n * @returns {!Long} Negated Long\n */\nLongPrototype.negate = function negate() {\n  if (!this.unsigned && this.eq(MIN_VALUE))\n    return MIN_VALUE;\n  return this.not().add(ONE);\n};\n\n/**\n * Negates this Long's value. This is an alias of {@link Long#negate}.\n * @function\n * @returns {!Long} Negated Long\n */\nLongPrototype.neg = LongPrototype.negate;\n\n/**\n * Returns the sum of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|string} addend Addend\n * @returns {!Long} Sum\n */\nLongPrototype.add = function add(addend) {\n  if (!isLong(addend))\n    addend = fromValue(addend);\n\n  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n  var a48 = this.high >>> 16;\n  var a32 = this.high & 0xFFFF;\n  var a16 = this.low >>> 16;\n  var a00 = this.low & 0xFFFF;\n\n  var b48 = addend.high >>> 16;\n  var b32 = addend.high & 0xFFFF;\n  var b16 = addend.low >>> 16;\n  var b00 = addend.low & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 + b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 + b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 + b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 + b48;\n  c48 &= 0xFFFF;\n  return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n};\n\n/**\n * Returns the difference of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|string} subtrahend Subtrahend\n * @returns {!Long} Difference\n */\nLongPrototype.subtract = function subtract(subtrahend) {\n  if (!isLong(subtrahend))\n    subtrahend = fromValue(subtrahend);\n  return this.add(subtrahend.neg());\n};\n\n/**\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\n * @function\n * @param {!Long|number|string} subtrahend Subtrahend\n * @returns {!Long} Difference\n */\nLongPrototype.sub = LongPrototype.subtract;\n\n/**\n * Returns the product of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|string} multiplier Multiplier\n * @returns {!Long} Product\n */\nLongPrototype.multiply = function multiply(multiplier) {\n  if (this.isZero())\n    return this;\n  if (!isLong(multiplier))\n    multiplier = fromValue(multiplier);\n\n  // use wasm support if present\n  if (wasm) {\n    var low = wasm[\"mul\"](this.low,\n      this.high,\n      multiplier.low,\n      multiplier.high);\n    return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n  }\n\n  if (multiplier.isZero())\n    return this.unsigned ? UZERO : ZERO;\n  if (this.eq(MIN_VALUE))\n    return multiplier.isOdd() ? MIN_VALUE : ZERO;\n  if (multiplier.eq(MIN_VALUE))\n    return this.isOdd() ? MIN_VALUE : ZERO;\n\n  if (this.isNegative()) {\n    if (multiplier.isNegative())\n      return this.neg().mul(multiplier.neg());\n    else\n      return this.neg().mul(multiplier).neg();\n  } else if (multiplier.isNegative())\n    return this.mul(multiplier.neg()).neg();\n\n  // If both longs are small, use float multiplication\n  if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\n    return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n\n  // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n  // We can skip products that would overflow.\n\n  var a48 = this.high >>> 16;\n  var a32 = this.high & 0xFFFF;\n  var a16 = this.low >>> 16;\n  var a00 = this.low & 0xFFFF;\n\n  var b48 = multiplier.high >>> 16;\n  var b32 = multiplier.high & 0xFFFF;\n  var b16 = multiplier.low >>> 16;\n  var b00 = multiplier.low & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 * b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 * b00;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c16 += a00 * b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 * b00;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a16 * b16;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a00 * b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n  c48 &= 0xFFFF;\n  return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n};\n\n/**\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\n * @function\n * @param {!Long|number|string} multiplier Multiplier\n * @returns {!Long} Product\n */\nLongPrototype.mul = LongPrototype.multiply;\n\n/**\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\n *  unsigned if this Long is unsigned.\n * @this {!Long}\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Quotient\n */\nLongPrototype.divide = function divide(divisor) {\n  if (!isLong(divisor))\n    divisor = fromValue(divisor);\n  if (divisor.isZero())\n    throw Error('division by zero');\n\n  // use wasm support if present\n  if (wasm) {\n    // guard against signed division overflow: the largest\n    // negative number / -1 would be 1 larger than the largest\n    // positive number, due to two's complement.\n    if (!this.unsigned &&\n      this.high === -0x80000000 &&\n      divisor.low === -1 && divisor.high === -1) {\n      // be consistent with non-wasm code path\n      return this;\n    }\n    var low = (this.unsigned ? wasm[\"div_u\"] : wasm[\"div_s\"])(\n      this.low,\n      this.high,\n      divisor.low,\n      divisor.high\n    );\n    return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n  }\n\n  if (this.isZero())\n    return this.unsigned ? UZERO : ZERO;\n  var approx, rem, res;\n  if (!this.unsigned) {\n    // This section is only relevant for signed longs and is derived from the\n    // closure library as a whole.\n    if (this.eq(MIN_VALUE)) {\n      if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\n        return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\n      else if (divisor.eq(MIN_VALUE))\n        return ONE;\n      else {\n        // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n        var halfThis = this.shr(1);\n        approx = halfThis.div(divisor).shl(1);\n        if (approx.eq(ZERO)) {\n          return divisor.isNegative() ? ONE : NEG_ONE;\n        } else {\n          rem = this.sub(divisor.mul(approx));\n          res = approx.add(rem.div(divisor));\n          return res;\n        }\n      }\n    } else if (divisor.eq(MIN_VALUE))\n      return this.unsigned ? UZERO : ZERO;\n    if (this.isNegative()) {\n      if (divisor.isNegative())\n        return this.neg().div(divisor.neg());\n      return this.neg().div(divisor).neg();\n    } else if (divisor.isNegative())\n      return this.div(divisor.neg()).neg();\n    res = ZERO;\n  } else {\n    // The algorithm below has not been made for unsigned longs. It's therefore\n    // required to take special care of the MSB prior to running it.\n    if (!divisor.unsigned)\n      divisor = divisor.toUnsigned();\n    if (divisor.gt(this))\n      return UZERO;\n    if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\n      return UONE;\n    res = UZERO;\n  }\n\n  // Repeat the following until the remainder is less than other:  find a\n  // floating-point that approximates remainder / other *from below*, add this\n  // into the result, and subtract it from the remainder.  It is critical that\n  // the approximate value is less than or equal to the real value so that the\n  // remainder never becomes negative.\n  rem = this;\n  while (rem.gte(divisor)) {\n    // Approximate the result of division. This may be a little greater or\n    // smaller than the actual value.\n    approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n\n    // We will tweak the approximate result by changing it in the 48-th digit or\n    // the smallest non-fractional digit, whichever is larger.\n    var log2 = Math.ceil(Math.log(approx) / Math.LN2),\n      delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),\n\n      // Decrease the approximation until it is smaller than the remainder.  Note\n      // that if it is too large, the product overflows and is negative.\n      approxRes = fromNumber(approx),\n      approxRem = approxRes.mul(divisor);\n    while (approxRem.isNegative() || approxRem.gt(rem)) {\n      approx -= delta;\n      approxRes = fromNumber(approx, this.unsigned);\n      approxRem = approxRes.mul(divisor);\n    }\n\n    // We know the answer can't be zero... and actually, zero would cause\n    // infinite recursion since we would make no progress.\n    if (approxRes.isZero())\n      approxRes = ONE;\n\n    res = res.add(approxRes);\n    rem = rem.sub(approxRem);\n  }\n  return res;\n};\n\n/**\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Quotient\n */\nLongPrototype.div = LongPrototype.divide;\n\n/**\n * Returns this Long modulo the specified.\n * @this {!Long}\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\nLongPrototype.modulo = function modulo(divisor) {\n  if (!isLong(divisor))\n    divisor = fromValue(divisor);\n\n  // use wasm support if present\n  if (wasm) {\n    var low = (this.unsigned ? wasm[\"rem_u\"] : wasm[\"rem_s\"])(\n      this.low,\n      this.high,\n      divisor.low,\n      divisor.high\n    );\n    return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n  }\n\n  return this.sub(this.div(divisor).mul(divisor));\n};\n\n/**\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\nLongPrototype.mod = LongPrototype.modulo;\n\n/**\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\nLongPrototype.rem = LongPrototype.modulo;\n\n/**\n * Returns the bitwise NOT of this Long.\n * @this {!Long}\n * @returns {!Long}\n */\nLongPrototype.not = function not() {\n  return fromBits(~this.low, ~this.high, this.unsigned);\n};\n\n/**\n * Returns count leading zeros of this Long.\n * @this {!Long}\n * @returns {!number}\n */\nLongPrototype.countLeadingZeros = function countLeadingZeros() {\n  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;\n};\n\n/**\n * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.\n * @function\n * @param {!Long}\n * @returns {!number}\n */\nLongPrototype.clz = LongPrototype.countLeadingZeros;\n\n/**\n * Returns count trailing zeros of this Long.\n * @this {!Long}\n * @returns {!number}\n */\nLongPrototype.countTrailingZeros = function countTrailingZeros() {\n  return this.low ? ctz32(this.low) : ctz32(this.high) + 32;\n};\n\n/**\n * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.\n * @function\n * @param {!Long}\n * @returns {!number}\n */\nLongPrototype.ctz = LongPrototype.countTrailingZeros;\n\n/**\n * Returns the bitwise AND of this Long and the specified.\n * @this {!Long}\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\nLongPrototype.and = function and(other) {\n  if (!isLong(other))\n    other = fromValue(other);\n  return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n};\n\n/**\n * Returns the bitwise OR of this Long and the specified.\n * @this {!Long}\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\nLongPrototype.or = function or(other) {\n  if (!isLong(other))\n    other = fromValue(other);\n  return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n};\n\n/**\n * Returns the bitwise XOR of this Long and the given one.\n * @this {!Long}\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\nLongPrototype.xor = function xor(other) {\n  if (!isLong(other))\n    other = fromValue(other);\n  return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n};\n\n/**\n * Returns this Long with bits shifted to the left by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shiftLeft = function shiftLeft(numBits) {\n  if (isLong(numBits))\n    numBits = numBits.toInt();\n  if ((numBits &= 63) === 0)\n    return this;\n  else if (numBits < 32)\n    return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\n  else\n    return fromBits(0, this.low << (numBits - 32), this.unsigned);\n};\n\n/**\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shl = LongPrototype.shiftLeft;\n\n/**\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shiftRight = function shiftRight(numBits) {\n  if (isLong(numBits))\n    numBits = numBits.toInt();\n  if ((numBits &= 63) === 0)\n    return this;\n  else if (numBits < 32)\n    return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\n  else\n    return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\n};\n\n/**\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shr = LongPrototype.shiftRight;\n\n/**\n * Returns this Long with bits logically shifted to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\n  if (isLong(numBits)) numBits = numBits.toInt();\n  if ((numBits &= 63) === 0) return this;\n  if (numBits < 32) return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >>> numBits, this.unsigned);\n  if (numBits === 32) return fromBits(this.high, 0, this.unsigned);\n  return fromBits(this.high >>> (numBits - 32), 0, this.unsigned);\n};\n\n/**\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shru = LongPrototype.shiftRightUnsigned;\n\n/**\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\n\n/**\n * Returns this Long with bits rotated to the left by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotateLeft = function rotateLeft(numBits) {\n  var b;\n  if (isLong(numBits)) numBits = numBits.toInt();\n  if ((numBits &= 63) === 0) return this;\n  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n  if (numBits < 32) {\n    b = (32 - numBits);\n    return fromBits(((this.low << numBits) | (this.high >>> b)), ((this.high << numBits) | (this.low >>> b)), this.unsigned);\n  }\n  numBits -= 32;\n  b = (32 - numBits);\n  return fromBits(((this.high << numBits) | (this.low >>> b)), ((this.low << numBits) | (this.high >>> b)), this.unsigned);\n}\n/**\n * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotl = LongPrototype.rotateLeft;\n\n/**\n * Returns this Long with bits rotated to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotateRight = function rotateRight(numBits) {\n  var b;\n  if (isLong(numBits)) numBits = numBits.toInt();\n  if ((numBits &= 63) === 0) return this;\n  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n  if (numBits < 32) {\n    b = (32 - numBits);\n    return fromBits(((this.high << b) | (this.low >>> numBits)), ((this.low << b) | (this.high >>> numBits)), this.unsigned);\n  }\n  numBits -= 32;\n  b = (32 - numBits);\n  return fromBits(((this.low << b) | (this.high >>> numBits)), ((this.high << b) | (this.low >>> numBits)), this.unsigned);\n}\n/**\n * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotr = LongPrototype.rotateRight;\n\n/**\n * Converts this Long to signed.\n * @this {!Long}\n * @returns {!Long} Signed long\n */\nLongPrototype.toSigned = function toSigned() {\n  if (!this.unsigned)\n    return this;\n  return fromBits(this.low, this.high, false);\n};\n\n/**\n * Converts this Long to unsigned.\n * @this {!Long}\n * @returns {!Long} Unsigned long\n */\nLongPrototype.toUnsigned = function toUnsigned() {\n  if (this.unsigned)\n    return this;\n  return fromBits(this.low, this.high, true);\n};\n\n/**\n * Converts this Long to its byte representation.\n * @param {boolean=} le Whether little or big endian, defaults to big endian\n * @this {!Long}\n * @returns {!Array.<number>} Byte representation\n */\nLongPrototype.toBytes = function toBytes(le) {\n  return le ? this.toBytesLE() : this.toBytesBE();\n};\n\n/**\n * Converts this Long to its little endian byte representation.\n * @this {!Long}\n * @returns {!Array.<number>} Little endian byte representation\n */\nLongPrototype.toBytesLE = function toBytesLE() {\n  var hi = this.high,\n    lo = this.low;\n  return [\n    lo & 0xff,\n    lo >>> 8 & 0xff,\n    lo >>> 16 & 0xff,\n    lo >>> 24,\n    hi & 0xff,\n    hi >>> 8 & 0xff,\n    hi >>> 16 & 0xff,\n    hi >>> 24\n  ];\n};\n\n/**\n * Converts this Long to its big endian byte representation.\n * @this {!Long}\n * @returns {!Array.<number>} Big endian byte representation\n */\nLongPrototype.toBytesBE = function toBytesBE() {\n  var hi = this.high,\n    lo = this.low;\n  return [\n    hi >>> 24,\n    hi >>> 16 & 0xff,\n    hi >>> 8 & 0xff,\n    hi & 0xff,\n    lo >>> 24,\n    lo >>> 16 & 0xff,\n    lo >>> 8 & 0xff,\n    lo & 0xff\n  ];\n};\n\n/**\n * Creates a Long from its byte representation.\n * @param {!Array.<number>} bytes Byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @param {boolean=} le Whether little or big endian, defaults to big endian\n * @returns {Long} The corresponding Long value\n */\nLong.fromBytes = function fromBytes(bytes, unsigned, le) {\n  return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n};\n\n/**\n * Creates a Long from its little endian byte representation.\n * @param {!Array.<number>} bytes Little endian byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {Long} The corresponding Long value\n */\nLong.fromBytesLE = function fromBytesLE(bytes, unsigned) {\n  return new Long(\n    bytes[0] |\n    bytes[1] << 8 |\n    bytes[2] << 16 |\n    bytes[3] << 24,\n    bytes[4] |\n    bytes[5] << 8 |\n    bytes[6] << 16 |\n    bytes[7] << 24,\n    unsigned\n  );\n};\n\n/**\n * Creates a Long from its big endian byte representation.\n * @param {!Array.<number>} bytes Big endian byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {Long} The corresponding Long value\n */\nLong.fromBytesBE = function fromBytesBE(bytes, unsigned) {\n  return new Long(\n    bytes[4] << 24 |\n    bytes[5] << 16 |\n    bytes[6] << 8 |\n    bytes[7],\n    bytes[0] << 24 |\n    bytes[1] << 16 |\n    bytes[2] << 8 |\n    bytes[3],\n    unsigned\n  );\n};\n\n/* harmony default export */ const node_modules_long = (Long);\n\n;// CONCATENATED MODULE: ./src/util/error.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar error_Code;\n(function (Code) {\n    // Ok is returned when the operation completed successfully.\n    Code[\"Ok\"] = \"ok\";\n    // ClientNotActive is returned when the client is not active.\n    Code[\"ClientNotActive\"] = \"client-not-active\";\n    // Unimplemented is returned when the operation is not implemented.\n    Code[\"Unimplemented\"] = \"unimplemented\";\n    // Unsupported is returned when the operation is not supported.\n    Code[\"Unsupported\"] = \"unsupported\";\n    // DocumentNotAttached is returned when the document is not attached.\n    Code[\"DocumentNotAttached\"] = \"document-not-attached\";\n    // DocumentNotDetached is returned when the document is not detached.\n    Code[\"DocumentNotDetached\"] = \"document-not-detached\";\n    // DocumentRemoved is returned when the document is removed.\n    Code[\"DocumentRemoved\"] = \"document-removed\";\n    // InvalidObjectKey is returned when the object key is invalid.\n    Code[\"InvalidObjectKey\"] = \"invalid-object-key\";\n    // InvalidArgument is returned when the argument is invalid.\n    Code[\"InvalidArgument\"] = \"invalid-argument\";\n})(error_Code || (error_Code = {}));\n/**\n * `YorkieError` is an error returned by a Yorkie operation.\n */\nclass YorkieError extends Error {\n    constructor(code, message) {\n        super(message);\n        this.code = code;\n        this.message = message;\n        this.name = 'YorkieError';\n        this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/util/object.ts\n/*\n * Copyright 2023 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * `deepcopy` returns a deep copy of the given object.\n */\nfunction deepcopy(object) {\n    if (object instanceof Map) {\n        const pairs = Array.from(object);\n        return new Map(JSON.parse(JSON.stringify(pairs)));\n    }\n    return JSON.parse(JSON.stringify(object));\n}\n/**\n `isEmpty` returns whether parameter object is empty or not\n */\nconst isEmpty = (object) => {\n    if (!object) {\n        return true;\n    }\n    return Object.entries(object).length === 0;\n};\n/**\n * `stringifyObjectValues` makes values of attributes to JSON parsable string.\n */\nconst stringifyObjectValues = (attributes) => {\n    const attrs = {};\n    for (const [key, value] of Object.entries(attributes)) {\n        attrs[key] = JSON.stringify(value);\n    }\n    return attrs;\n};\n/**\n `parseObjectValues` returns the JSON parsable string values to the origin states.\n */\nconst parseObjectValues = (attrs) => {\n    const attributes = {};\n    for (const [key, value] of Object.entries(attrs)) {\n        attributes[key] = JSON.parse(value);\n    }\n    return attributes;\n};\n\n;// CONCATENATED MODULE: ./src/document/presence/presence.ts\n/*\n * Copyright 2023 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * `PresenceChangeType` represents the type of presence change.\n */\nvar PresenceChangeType;\n(function (PresenceChangeType) {\n    PresenceChangeType[\"Put\"] = \"put\";\n    PresenceChangeType[\"Clear\"] = \"clear\";\n})(PresenceChangeType || (PresenceChangeType = {}));\n/**\n * `Presence` represents a proxy for the Presence to be manipulated from the outside.\n */\nclass Presence {\n    constructor(changeContext, presence) {\n        this.context = changeContext;\n        this.presence = presence;\n    }\n    /**\n     * `set` updates the presence based on the partial presence.\n     */\n    set(presence, option) {\n        for (const key of Object.keys(presence)) {\n            this.presence[key] = presence[key];\n        }\n        this.context.setPresenceChange({\n            type: PresenceChangeType.Put,\n            presence: deepcopy(this.presence),\n        });\n        this.context.setReversePresence(presence, option);\n    }\n    /**\n     * `get` returns the presence value of the given key.\n     */\n    get(key) {\n        return this.presence[key];\n    }\n    /**\n     * `clear` clears the presence.\n     * @internal\n     */\n    clear() {\n        this.presence = {};\n        this.context.setPresenceChange({\n            type: PresenceChangeType.Clear,\n        });\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/time/actor_id.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * `InitialActorID` is the initial value of ActorID.\n */\nconst InitialActorID = '000000000000000000000000';\n/**\n * `MaxActorID` is the maximum value of ActorID.\n */\nconst MaxActorID = 'FFFFFFFFFFFFFFFFFFFFFFFF';\n\n;// CONCATENATED MODULE: ./src/document/time/ticket.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nconst TicketComparator = (p1, p2) => {\n    return p1.compare(p2);\n};\n/**\n * `TimeTicket` is a timestamp of the logical clock. Ticket is immutable.\n * It is created by `ChangeID`.\n *\n * @public\n */\nclass TimeTicket {\n    /** @hideconstructor */\n    constructor(lamport, delimiter, actorID) {\n        this.lamport = lamport;\n        this.delimiter = delimiter;\n        this.actorID = actorID;\n    }\n    /**\n     * `of` creates an instance of Ticket.\n     */\n    static of(lamport, delimiter, actorID) {\n        return new TimeTicket(lamport, delimiter, actorID);\n    }\n    /**\n     * `fromStruct` creates an instance of Ticket from the struct.\n     */\n    static fromStruct(struct) {\n        return TimeTicket.of(node_modules_long.fromString(struct.lamport, true), struct.delimiter, struct.actorID);\n    }\n    /**\n     * `toIDString` returns the lamport string for this Ticket.\n     */\n    toIDString() {\n        if (!this.actorID) {\n            return `${this.lamport.toString()}:nil:${this.delimiter}`;\n        }\n        return `${this.lamport.toString()}:${this.actorID}:${this.delimiter}`;\n    }\n    /**\n     * `toStruct` returns the structure of this Ticket.\n     */\n    toStruct() {\n        return {\n            lamport: this.getLamportAsString(),\n            delimiter: this.getDelimiter(),\n            actorID: this.getActorID(),\n        };\n    }\n    /**\n     * `toTestString` returns a string containing the meta data of the ticket\n     * for debugging purpose.\n     */\n    toTestString() {\n        if (!this.actorID) {\n            return `${this.lamport.toString()}:nil:${this.delimiter}`;\n        }\n        return `${this.lamport.toString()}:${this.actorID.slice(-2)}:${this.delimiter}`;\n    }\n    /**\n     * `setActor` creates a new instance of Ticket with the given actorID.\n     */\n    setActor(actorID) {\n        return new TimeTicket(this.lamport, this.delimiter, actorID);\n    }\n    /**\n     * `getLamportAsString` returns the lamport string.\n     */\n    getLamportAsString() {\n        return this.lamport.toString();\n    }\n    /**\n     * `getLamport` returns the lamport.\n     */\n    getLamport() {\n        return this.lamport;\n    }\n    /**\n     * `getDelimiter` returns delimiter.\n     */\n    getDelimiter() {\n        return this.delimiter;\n    }\n    /**\n     * `getActorID` returns actorID.\n     */\n    getActorID() {\n        return this.actorID;\n    }\n    /**\n     * `after` returns whether the given ticket was created later.\n     */\n    after(other) {\n        return this.compare(other) > 0;\n    }\n    /**\n     * `equals` returns whether the given ticket was created.\n     */\n    equals(other) {\n        return this.compare(other) === 0;\n    }\n    /**\n     * `compare` returns an integer comparing two Ticket.\n     *  The result will be 0 if id==other, -1 if `id < other`, and +1 if `id > other`.\n     *  If the receiver or argument is nil, it would panic at runtime.\n     */\n    compare(other) {\n        if (this.lamport.greaterThan(other.lamport)) {\n            return 1;\n        }\n        else if (other.lamport.greaterThan(this.lamport)) {\n            return -1;\n        }\n        const compare = this.actorID.localeCompare(other.actorID);\n        if (compare !== 0) {\n            return compare;\n        }\n        if (this.delimiter > other.delimiter) {\n            return 1;\n        }\n        else if (other.delimiter > this.delimiter) {\n            return -1;\n        }\n        return 0;\n    }\n}\nconst InitialDelimiter = 0;\nconst MaxDelemiter = 4294967295; // UInt32 MAX_VALUE\nconst MaxLamport = node_modules_long.MAX_VALUE;\nconst InitialTimeTicket = new TimeTicket(node_modules_long.fromNumber(0), InitialDelimiter, InitialActorID);\nconst MaxTimeTicket = new TimeTicket(MaxLamport, MaxDelemiter, MaxActorID);\n\n;// CONCATENATED MODULE: ./src/document/json/strings.ts\n/**\n * `EscapeString` escapes the given string.\n */\nfunction escapeString(str) {\n    return str.replace(/[\"'\\\\\\n\\r\\f\\b\\t\\u2028\\u2029]/g, function (character) {\n        switch (character) {\n            case '\"':\n            case '\\\\':\n                return '\\\\' + character;\n            case '\\n':\n                return '\\\\n';\n            case '\\r':\n                return '\\\\r';\n            case '\\f':\n                return '\\\\f';\n            case '\\b':\n                return '\\\\b';\n            case '\\t':\n                return '\\\\t';\n            case '\\u2028':\n                return '\\\\u2028';\n            case '\\u2029':\n                return '\\\\u2029';\n            default:\n                return character;\n        }\n    });\n}\n\n;// CONCATENATED MODULE: ./src/document/crdt/element.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * `CRDTElement` represents an element that has `TimeTicket`s.\n *\n * @internal\n */\nclass CRDTElement {\n    constructor(createdAt) {\n        this.createdAt = createdAt;\n    }\n    /**\n     * `getCreatedAt` returns the creation time of this element.\n     */\n    getCreatedAt() {\n        return this.createdAt;\n    }\n    /**\n     * `getID` returns the creation time of this element.\n     */\n    getID() {\n        return this.createdAt;\n    }\n    /**\n     * `getMovedAt` returns the move time of this element.\n     */\n    getMovedAt() {\n        return this.movedAt;\n    }\n    /**\n     * `getRemovedAt` returns the removal time of this element.\n     */\n    getRemovedAt() {\n        return this.removedAt;\n    }\n    /**\n     * `getPositionedAt` returns the time of this element when it was positioned\n     * in the document by undo/redo or move operation.\n     */\n    getPositionedAt() {\n        if (!this.movedAt) {\n            return this.createdAt;\n        }\n        return this.movedAt;\n    }\n    /**\n     * `setMovedAt` sets the move time of this element.\n     */\n    setMovedAt(movedAt) {\n        if (!this.movedAt || (movedAt && movedAt.after(this.movedAt))) {\n            this.movedAt = movedAt;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * `setRemovedAt` sets the remove time of this element.\n     */\n    setRemovedAt(removedAt) {\n        this.removedAt = removedAt;\n    }\n    /**\n     * `remove` removes this element.\n     */\n    remove(removedAt) {\n        if (removedAt &&\n            removedAt.after(this.getPositionedAt()) &&\n            (!this.removedAt || removedAt.after(this.removedAt))) {\n            // NOTE(chacha912): If it's a CRDTContainer, removedAt is marked only on\n            // the top-level element, without marking all descendant elements. This\n            // enhances the speed of deletion.\n            this.removedAt = removedAt;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * `isRemoved` check if this element was removed.\n     */\n    isRemoved() {\n        return !!this.removedAt;\n    }\n}\n/**\n *\n * `CRDTContainer` represents CRDTArray or CRDtObject.\n */\nclass CRDTContainer extends CRDTElement {\n    constructor(createdAt) {\n        super(createdAt);\n    }\n}\n/**\n * `CRDTGCElement` represents element which has garbage collecting method.\n */\nclass CRDTGCElement extends CRDTElement {\n}\n\n;// CONCATENATED MODULE: ./src/document/crdt/element_rht.ts\n/*\n * Copyright 2023 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * `ElementRHTNode` is a node of ElementRHT.\n */\nclass ElementRHTNode {\n    constructor(strKey, value) {\n        this.strKey = strKey;\n        this.value = value;\n    }\n    /**\n     * `of` creates a instance of ElementRHTNode.\n     */\n    static of(strKey, value) {\n        return new ElementRHTNode(strKey, value);\n    }\n    /**\n     * `isRemoved` checks whether this value was removed.\n     */\n    isRemoved() {\n        return this.value.isRemoved();\n    }\n    /**\n     * `getStrKey` returns the key of this node.\n     */\n    getStrKey() {\n        return this.strKey;\n    }\n    /**\n     * `getValue` return the value(element) of this node\n     */\n    getValue() {\n        return this.value;\n    }\n    /**\n     * `remove` removes a value base on removing time.\n     */\n    remove(removedAt) {\n        return this.value.remove(removedAt);\n    }\n}\n/**\n * ElementRHT is a hashtable with logical clock(Replicated hashtable)\n *\n */\nclass ElementRHT {\n    constructor() {\n        this.nodeMapByKey = new Map();\n        this.nodeMapByCreatedAt = new Map();\n    }\n    /**\n     * `create` creates an instance of ElementRHT.\n     */\n    static create() {\n        return new ElementRHT();\n    }\n    /**\n     * `set` sets the value of the given key.\n     */\n    set(key, value, executedAt) {\n        let removed;\n        const node = this.nodeMapByKey.get(key);\n        if (node != null && !node.isRemoved() && node.remove(executedAt)) {\n            removed = node.getValue();\n        }\n        const newNode = ElementRHTNode.of(key, value);\n        this.nodeMapByCreatedAt.set(value.getCreatedAt().toIDString(), newNode);\n        if (node == null || executedAt.after(node.getValue().getPositionedAt())) {\n            this.nodeMapByKey.set(key, newNode);\n            value.setMovedAt(executedAt);\n        }\n        return removed;\n    }\n    /**\n     * `delete` deletes the Element of the given key.\n     */\n    delete(createdAt, executedAt) {\n        if (!this.nodeMapByCreatedAt.has(createdAt.toIDString())) {\n            logger.fatal(`fail to find ${createdAt.toIDString()}`);\n        }\n        const node = this.nodeMapByCreatedAt.get(createdAt.toIDString());\n        node.remove(executedAt);\n        return node.getValue();\n    }\n    /**\n     * `subPathOf` returns the sub path of the given element.\n     */\n    subPathOf(createdAt) {\n        const node = this.nodeMapByCreatedAt.get(createdAt.toIDString());\n        if (!node) {\n            return;\n        }\n        return node.getStrKey();\n    }\n    /**\n     * `purge` physically purge child element.\n     */\n    purge(element) {\n        const node = this.nodeMapByCreatedAt.get(element.getCreatedAt().toIDString());\n        if (!node) {\n            logger.fatal(`fail to find ${element.getCreatedAt().toIDString()}`);\n            return;\n        }\n        const nodeByKey = this.nodeMapByKey.get(node.getStrKey());\n        if (node === nodeByKey) {\n            this.nodeMapByKey.delete(nodeByKey.getStrKey());\n        }\n        this.nodeMapByCreatedAt.delete(node.getValue().getCreatedAt().toIDString());\n    }\n    /**\n     * `deleteByKey` deletes the Element of the given key and removed time.\n     */\n    deleteByKey(key, removedAt) {\n        const node = this.nodeMapByKey.get(key);\n        if (node == null) {\n            return;\n        }\n        if (!node.remove(removedAt)) {\n            return;\n        }\n        return node.getValue();\n    }\n    /**\n     * `has` returns whether the element exists of the given key or not.\n     */\n    has(key) {\n        const node = this.nodeMapByKey.get(key);\n        if (node == null) {\n            return false;\n        }\n        return !node.isRemoved();\n    }\n    /**\n     * `getByID` returns the node of the given createdAt.\n     */\n    getByID(createdAt) {\n        return this.nodeMapByCreatedAt.get(createdAt.toIDString());\n    }\n    /**\n     * `get` returns the node of the given key.\n     */\n    get(key) {\n        const node = this.nodeMapByKey.get(key);\n        if (!node || node.isRemoved()) {\n            return;\n        }\n        return node;\n    }\n    // eslint-disable-next-line jsdoc/require-jsdoc\n    *[Symbol.iterator]() {\n        for (const [, node] of this.nodeMapByKey) {\n            yield node;\n        }\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/crdt/object.ts\n/*\n * Copyright 2023 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n/**\n * `CRDTObject` represents an object data type, but unlike regular JSON,\n * it has `TimeTicket`s which are created by logical clock.\n *\n */\nclass CRDTObject extends CRDTContainer {\n    /** @hideconstructor */\n    constructor(createdAt, memberNodes) {\n        super(createdAt);\n        this.memberNodes = memberNodes;\n    }\n    /**\n     * `create` creates a new instance of CRDTObject.\n     */\n    static create(createdAt, value) {\n        if (!value) {\n            return new CRDTObject(createdAt, ElementRHT.create());\n        }\n        const memberNodes = ElementRHT.create();\n        for (const [k, v] of Object.entries(value)) {\n            memberNodes.set(k, v.deepcopy(), v.getCreatedAt());\n        }\n        return new CRDTObject(createdAt, memberNodes);\n    }\n    /**\n     * `subPathOf` returns the sub path of the given element.\n     */\n    subPathOf(createdAt) {\n        return this.memberNodes.subPathOf(createdAt);\n    }\n    /**\n     * `purge` physically purges the given element.\n     */\n    purge(value) {\n        this.memberNodes.purge(value);\n    }\n    /**\n     * `set` sets the given element of the given key.\n     */\n    set(key, value, executedAt) {\n        return this.memberNodes.set(key, value, executedAt);\n    }\n    /**\n     * `delete` deletes the element of the given key.\n     */\n    delete(createdAt, executedAt) {\n        return this.memberNodes.delete(createdAt, executedAt);\n    }\n    /**\n     * `deleteByKey` deletes the element of the given key and execution time.\n     */\n    deleteByKey(key, executedAt) {\n        return this.memberNodes.deleteByKey(key, executedAt);\n    }\n    /**\n     * `get` returns the value of the given key.\n     */\n    get(key) {\n        const node = this.memberNodes.get(key);\n        return node === null || node === void 0 ? void 0 : node.getValue();\n    }\n    /**\n     * `getByID` returns the element of the given createAt.\n     */\n    getByID(createdAt) {\n        const node = this.memberNodes.getByID(createdAt);\n        return node === null || node === void 0 ? void 0 : node.getValue();\n    }\n    /**\n     * `has` returns whether the element exists of the given key or not.\n     */\n    has(key) {\n        return this.memberNodes.has(key);\n    }\n    /**\n     * `toJSON` returns the JSON encoding of this object.\n     */\n    toJSON() {\n        const json = [];\n        for (const [key, value] of this) {\n            json.push(`\"${escapeString(key)}\":${value.toJSON()}`);\n        }\n        return `{${json.join(',')}}`;\n    }\n    /**\n     * `toJS` returns the JavaScript object of this object.\n     */\n    toJS() {\n        return JSON.parse(this.toJSON());\n    }\n    /**\n     * `toJSForTest` returns value with meta data for testing.\n     */\n    toJSForTest() {\n        const values = {};\n        for (const [key, elem] of this) {\n            const { id, value, type } = elem.toJSForTest();\n            values[key] = {\n                key,\n                id,\n                value,\n                type,\n            };\n        }\n        return {\n            id: this.getCreatedAt().toTestString(),\n            value: values,\n            type: 'YORKIE_OBJECT',\n        };\n    }\n    /**\n     * `getKeys` returns array of keys in this object.\n     */\n    getKeys() {\n        const keys = Array();\n        for (const [key] of this) {\n            keys.push(key);\n        }\n        return keys;\n    }\n    /**\n     * `toSortedJSON` returns the sorted JSON encoding of this object.\n     */\n    toSortedJSON() {\n        var _a;\n        const keys = Array();\n        for (const [key] of this) {\n            keys.push(key);\n        }\n        const json = [];\n        for (const key of keys.sort()) {\n            const node = (_a = this.memberNodes.get(key)) === null || _a === void 0 ? void 0 : _a.getValue();\n            json.push(`\"${escapeString(key)}\":${node.toSortedJSON()}`);\n        }\n        return `{${json.join(',')}}`;\n    }\n    /**\n     * `getRHT` RHTNodes returns the RHTPQMap nodes.\n     */\n    getRHT() {\n        return this.memberNodes;\n    }\n    /**\n     * `deepcopy` copies itself deeply.\n     */\n    deepcopy() {\n        const clone = CRDTObject.create(this.getCreatedAt());\n        for (const node of this.memberNodes) {\n            clone.memberNodes.set(node.getStrKey(), node.getValue().deepcopy(), this.getPositionedAt());\n        }\n        clone.remove(this.getRemovedAt());\n        return clone;\n    }\n    /**\n     * `getDescendants` returns the descendants of this object by traversing.\n     */\n    getDescendants(callback) {\n        for (const node of this.memberNodes) {\n            const element = node.getValue();\n            if (callback(element, this)) {\n                return;\n            }\n            if (element instanceof CRDTContainer) {\n                element.getDescendants(callback);\n            }\n        }\n    }\n    /**\n     * eslint-disable-next-line jsdoc/require-jsdoc\n     * @internal\n     */\n    *[Symbol.iterator]() {\n        const keySet = new Set();\n        for (const node of this.memberNodes) {\n            if (!keySet.has(node.getStrKey())) {\n                keySet.add(node.getStrKey());\n                if (!node.isRemoved()) {\n                    yield [node.getStrKey(), node.getValue()];\n                }\n            }\n        }\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/operation/operation.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * `OpSource` represents the source of the operation. It is used to handle\n * corner cases in the operations created by undo/redo allow the removed\n * elements when executing them.\n */\nvar OpSource;\n(function (OpSource) {\n    OpSource[\"Local\"] = \"local\";\n    OpSource[\"Remote\"] = \"remote\";\n    OpSource[\"UndoRedo\"] = \"undoredo\";\n})(OpSource || (OpSource = {}));\n/**\n * `Operation` represents an operation to be executed on a document.\n */\nclass Operation {\n    constructor(parentCreatedAt, executedAt) {\n        this.parentCreatedAt = parentCreatedAt;\n        this.executedAt = executedAt;\n    }\n    /**\n     * `getParentCreatedAt` returns the creation time of the target element to\n     * execute the operation.\n     */\n    getParentCreatedAt() {\n        return this.parentCreatedAt;\n    }\n    /**\n     * `getExecutedAt` returns execution time of this operation.\n     */\n    getExecutedAt() {\n        // NOTE(chacha912): When an operation is in the undo/redo stack,\n        // it doesn't have an executedAt yet. The executedAt is set when\n        // the operation is executed through undo or redo.\n        if (!this.executedAt) {\n            throw new Error(`executedAt has not been set yet`);\n        }\n        return this.executedAt;\n    }\n    /**\n     * `setActor` sets the given actor to this operation.\n     */\n    setActor(actorID) {\n        if (this.executedAt) {\n            this.executedAt = this.executedAt.setActor(actorID);\n        }\n    }\n    /**\n     * `setExecutedAt` sets the executedAt.\n     */\n    setExecutedAt(executedAt) {\n        this.executedAt = executedAt;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/util/splay_tree.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * `SplayNode` is a node of SplayTree.\n */\nclass SplayNode {\n    constructor(value) {\n        this.value = value;\n        this.initWeight();\n    }\n    /**\n     * `getNodeString` returns a string of weight and value of this node.\n     */\n    getNodeString() {\n        return `${this.weight}${this.value}`;\n    }\n    /**\n     * `getValue` returns value of this node.\n     */\n    getValue() {\n        return this.value;\n    }\n    /**\n     * `getLeftWeight` returns left weight of this node.\n     */\n    getLeftWeight() {\n        return !this.hasLeft() ? 0 : this.left.getWeight();\n    }\n    /**\n     * `getRightWeight` returns right weight of this node.\n     */\n    getRightWeight() {\n        return !this.hasRight() ? 0 : this.right.getWeight();\n    }\n    /**\n     * `getWeight` returns weight of this node.\n     */\n    getWeight() {\n        return this.weight;\n    }\n    /**\n     * `getLeft` returns a left node.\n     */\n    getLeft() {\n        return this.left;\n    }\n    /**\n     * `getRight` returns a right node.\n     */\n    getRight() {\n        return this.right;\n    }\n    /**\n     * `getParent` returns parent of this node.\n     */\n    getParent() {\n        return this.parent;\n    }\n    /**\n     * `hasLeft` check if the left node exists\n     */\n    hasLeft() {\n        return !!this.left;\n    }\n    /**\n     * `hasRight` check if the right node exists\n     */\n    hasRight() {\n        return !!this.right;\n    }\n    /**\n     * `hasParent` check if the parent node exists\n     */\n    hasParent() {\n        return !!this.parent;\n    }\n    /**\n     * `setLeft` sets a left node.\n     */\n    setLeft(left) {\n        this.left = left;\n    }\n    /**\n     * `setRight` sets a right node.\n     */\n    setRight(right) {\n        this.right = right;\n    }\n    /**\n     * `setParent` sets a parent node.\n     */\n    setParent(parent) {\n        this.parent = parent;\n    }\n    /**\n     * `unlink` unlink parent, right and left node.\n     */\n    unlink() {\n        this.parent = undefined;\n        this.right = undefined;\n        this.left = undefined;\n    }\n    /**\n     * `hasLinks` checks if parent, right and left node exists.\n     */\n    hasLinks() {\n        return this.hasParent() || this.hasLeft() || this.hasRight();\n    }\n    /**\n     * `increaseWeight` increases weight.\n     */\n    increaseWeight(weight) {\n        this.weight += weight;\n    }\n    /**\n     * `initWeight` sets initial weight of this node.\n     */\n    initWeight() {\n        this.weight = this.getLength();\n    }\n}\n/**\n * SplayTree is weighted binary search tree which is based on Splay tree.\n * original paper on Splay Trees:\n * @see https://www.cs.cmu.edu/~sleator/papers/self-adjusting.pdf\n */\nclass SplayTree {\n    constructor(root) {\n        this.root = root;\n    }\n    /**\n     * `length` returns the size of this tree.\n     */\n    get length() {\n        return this.root ? this.root.getWeight() : 0;\n    }\n    /**\n     * `find` returns the Node and offset of the given index.\n     */\n    find(pos) {\n        if (!this.root || pos < 0) {\n            return [undefined, 0];\n        }\n        let node = this.root;\n        for (;;) {\n            if (node.hasLeft() && pos <= node.getLeftWeight()) {\n                node = node.getLeft();\n            }\n            else if (node.hasRight() &&\n                node.getLeftWeight() + node.getLength() < pos) {\n                pos -= node.getLeftWeight() + node.getLength();\n                node = node.getRight();\n            }\n            else {\n                pos -= node.getLeftWeight();\n                break;\n            }\n        }\n        if (pos > node.getLength()) {\n            logger.fatal(`out of index range: pos: ${pos} > node.length: ${node.getLength()}`);\n        }\n        return [node, pos];\n    }\n    /**\n     * Find the index of the given node in BST.\n     *\n     * @param node - the given node\n     * @returns the index of given node\n     */\n    indexOf(node) {\n        if (!node || (node !== this.root && !node.hasLinks())) {\n            return -1;\n        }\n        let index = 0;\n        let current = node;\n        let prev;\n        while (current) {\n            if (!prev || prev === current.getRight()) {\n                index +=\n                    current.getLength() +\n                        (current.hasLeft() ? current.getLeftWeight() : 0);\n            }\n            prev = current;\n            current = current.getParent();\n        }\n        return index - node.getLength();\n    }\n    /**\n     * `getRoot` returns root of this tree.\n     */\n    getRoot() {\n        return this.root;\n    }\n    /**\n     * `insert` inserts the node at the last.\n     */\n    insert(newNode) {\n        return this.insertAfter(this.root, newNode);\n    }\n    /**\n     * `insertAfter` inserts the node after the given previous node.\n     */\n    insertAfter(target, newNode) {\n        // TODO(Eithea): Consider moving the code below to insert()\n        if (!target) {\n            this.root = newNode;\n            return newNode;\n        }\n        this.splayNode(target);\n        this.root = newNode;\n        newNode.setRight(target.getRight());\n        if (target.hasRight()) {\n            target.getRight().setParent(newNode);\n        }\n        newNode.setLeft(target);\n        target.setParent(newNode);\n        target.setRight();\n        this.updateWeight(target);\n        this.updateWeight(newNode);\n        return newNode;\n    }\n    /**\n     * `updateWeight` recalculates the weight of this node with the value and children.\n     */\n    updateWeight(node) {\n        node.initWeight();\n        if (node.hasLeft()) {\n            node.increaseWeight(node.getLeftWeight());\n        }\n        if (node.hasRight()) {\n            node.increaseWeight(node.getRightWeight());\n        }\n    }\n    updateTreeWeight(node) {\n        while (node) {\n            this.updateWeight(node);\n            node = node.getParent();\n        }\n    }\n    /**\n     * `splayNode` moves the given node to the root.\n     */\n    splayNode(node) {\n        if (!node) {\n            return;\n        }\n        for (;;) {\n            if (this.isLeftChild(node.getParent()) && this.isRightChild(node)) {\n                // zig-zag\n                this.rotateLeft(node);\n                this.rotateRight(node);\n            }\n            else if (this.isRightChild(node.getParent()) &&\n                this.isLeftChild(node)) {\n                // zig-zag\n                this.rotateRight(node);\n                this.rotateLeft(node);\n            }\n            else if (this.isLeftChild(node.getParent()) && this.isLeftChild(node)) {\n                // zig-zig\n                this.rotateRight(node.getParent());\n                this.rotateRight(node);\n            }\n            else if (this.isRightChild(node.getParent()) &&\n                this.isRightChild(node)) {\n                // zig-zig\n                this.rotateLeft(node.getParent());\n                this.rotateLeft(node);\n            }\n            else {\n                // zig\n                if (this.isLeftChild(node)) {\n                    this.rotateRight(node);\n                }\n                else if (this.isRightChild(node)) {\n                    this.rotateLeft(node);\n                }\n                this.updateWeight(node);\n                return;\n            }\n        }\n    }\n    /**\n     * `delete` deletes target node of this tree.\n     */\n    delete(node) {\n        this.splayNode(node);\n        const leftTree = new SplayTree(node.getLeft());\n        if (leftTree.root) {\n            leftTree.root.setParent();\n        }\n        const rightTree = new SplayTree(node.getRight());\n        if (rightTree.root) {\n            rightTree.root.setParent();\n        }\n        if (leftTree.root) {\n            const rightmostNode = leftTree.getRightmost();\n            leftTree.splayNode(rightmostNode);\n            leftTree.root.setRight(rightTree.root);\n            if (rightTree.root) {\n                rightTree.root.setParent(leftTree.root);\n            }\n            this.root = leftTree.root;\n        }\n        else {\n            this.root = rightTree.root;\n        }\n        node.unlink();\n        if (this.root) {\n            this.updateWeight(this.root);\n        }\n    }\n    /**\n     * `deleteRange` separates the range between given 2 boundaries from this Tree.\n     * This function separates the range to delete as a subtree\n     * by splaying outer boundary nodes.\n     * leftBoundary must exist because of 0-indexed initial dummy node of tree,\n     * but rightBoundary can be nil means range to delete includes the end of tree.\n     * Refer to the design document in https://github.com/yorkie-team/yorkie/tree/main/design\n     */\n    deleteRange(leftBoundary, rightBoundary) {\n        if (!rightBoundary) {\n            this.splayNode(leftBoundary);\n            this.cutOffRight(leftBoundary);\n            return;\n        }\n        this.splayNode(leftBoundary);\n        this.splayNode(rightBoundary);\n        if (rightBoundary.getLeft() != leftBoundary) {\n            this.rotateRight(leftBoundary);\n        }\n        this.cutOffRight(leftBoundary);\n    }\n    cutOffRight(root) {\n        const nodesToFreeWeight = [];\n        this.traversePostorder(root.getRight(), nodesToFreeWeight);\n        for (const node of nodesToFreeWeight) {\n            node.initWeight();\n        }\n        this.updateTreeWeight(root);\n    }\n    /**\n     * `toTestString` returns a string containing the meta data of the Node\n     * for debugging purpose.\n     */\n    toTestString() {\n        const metaString = [];\n        this.traverseInorder(this.root, metaString);\n        return metaString\n            .map((n) => `[${n.getWeight()},${n.getLength()}]${n.getValue() || ''}`)\n            .join('');\n    }\n    /**\n     * `checkWeight` returns false when there is an incorrect weight node.\n     * for debugging purpose.\n     */\n    checkWeight() {\n        const nodes = [];\n        this.traverseInorder(this.root, nodes);\n        for (const node of nodes) {\n            if (node.getWeight() !=\n                node.getLength() + node.getLeftWeight() + node.getRightWeight()) {\n                return false;\n            }\n        }\n        return true;\n    }\n    getRightmost() {\n        let node = this.root;\n        while (node.hasRight()) {\n            node = node.getRight();\n        }\n        return node;\n    }\n    traverseInorder(node, stack) {\n        if (!node) {\n            return;\n        }\n        this.traverseInorder(node.getLeft(), stack);\n        stack.push(node);\n        this.traverseInorder(node.getRight(), stack);\n    }\n    traversePostorder(node, stack) {\n        if (!node) {\n            return;\n        }\n        this.traversePostorder(node.getLeft(), stack);\n        this.traversePostorder(node.getRight(), stack);\n        stack.push(node);\n    }\n    rotateLeft(pivot) {\n        const root = pivot.getParent();\n        if (root.hasParent()) {\n            if (root === root.getParent().getLeft()) {\n                root.getParent().setLeft(pivot);\n            }\n            else {\n                root.getParent().setRight(pivot);\n            }\n        }\n        else {\n            this.root = pivot;\n        }\n        pivot.setParent(root.getParent());\n        root.setRight(pivot.getLeft());\n        if (root.hasRight()) {\n            root.getRight().setParent(root);\n        }\n        pivot.setLeft(root);\n        pivot.getLeft().setParent(pivot);\n        this.updateWeight(root);\n        this.updateWeight(pivot);\n    }\n    rotateRight(pivot) {\n        const root = pivot.getParent();\n        if (root.hasParent()) {\n            if (root === root.getParent().getLeft()) {\n                root.getParent().setLeft(pivot);\n            }\n            else {\n                root.getParent().setRight(pivot);\n            }\n        }\n        else {\n            this.root = pivot;\n        }\n        pivot.setParent(root.getParent());\n        root.setLeft(pivot.getRight());\n        if (root.hasLeft()) {\n            root.getLeft().setParent(root);\n        }\n        pivot.setRight(root);\n        pivot.getRight().setParent(pivot);\n        this.updateWeight(root);\n        this.updateWeight(pivot);\n    }\n    isLeftChild(node) {\n        if (node && node.hasParent()) {\n            return node.getParent().getLeft() === node;\n        }\n        return false;\n    }\n    isRightChild(node) {\n        if (node && node.hasParent()) {\n            return node.getParent().getRight() === node;\n        }\n        return false;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/crdt/primitive.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\nvar PrimitiveType;\n(function (PrimitiveType) {\n    PrimitiveType[PrimitiveType[\"Null\"] = 0] = \"Null\";\n    PrimitiveType[PrimitiveType[\"Boolean\"] = 1] = \"Boolean\";\n    PrimitiveType[PrimitiveType[\"Integer\"] = 2] = \"Integer\";\n    PrimitiveType[PrimitiveType[\"Long\"] = 3] = \"Long\";\n    PrimitiveType[PrimitiveType[\"Double\"] = 4] = \"Double\";\n    PrimitiveType[PrimitiveType[\"String\"] = 5] = \"String\";\n    PrimitiveType[PrimitiveType[\"Bytes\"] = 6] = \"Bytes\";\n    PrimitiveType[PrimitiveType[\"Date\"] = 7] = \"Date\";\n})(PrimitiveType || (PrimitiveType = {}));\n/**\n * `Primitive` represents primitive data type including logical clock.\n * It has a type and a value.\n */\nclass Primitive extends CRDTElement {\n    constructor(value, createdAt) {\n        super(createdAt);\n        this.valueType = Primitive.getPrimitiveType(value);\n        this.value = value === undefined ? null : value;\n    }\n    /**\n     * `of` creates a new instance of Primitive.\n     */\n    static of(value, createdAt) {\n        return new Primitive(value, createdAt);\n    }\n    /**\n     * `valueFromBytes` parses the given bytes into value.\n     */\n    static valueFromBytes(primitiveType, bytes) {\n        switch (primitiveType) {\n            case PrimitiveType.Null:\n                return null;\n            case PrimitiveType.Boolean:\n                return bytes[0] ? true : false;\n            case PrimitiveType.Integer:\n                return bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24);\n            case PrimitiveType.Double: {\n                const view = new DataView(bytes.buffer);\n                bytes.forEach(function (b, i) {\n                    view.setUint8(i, b);\n                });\n                return view.getFloat64(0, true);\n            }\n            case PrimitiveType.String:\n                return new TextDecoder('utf-8').decode(bytes);\n            case PrimitiveType.Long:\n                return node_modules_long.fromBytesLE(Array.from(bytes));\n            case PrimitiveType.Bytes:\n                return bytes;\n            case PrimitiveType.Date:\n                return new Date(node_modules_long.fromBytesLE(Array.from(bytes), true).toNumber());\n            default:\n                throw new YorkieError(error_Code.Unimplemented, `unimplemented type: ${primitiveType}`);\n        }\n    }\n    /**\n     * `toJSON` returns the JSON encoding of the value.\n     */\n    toJSON() {\n        if (this.valueType === PrimitiveType.String) {\n            return `\"${escapeString(this.value)}\"`;\n        }\n        // TODO(hackerwins): We need to consider the case where the value is\n        // a byte array and a date.\n        return `${this.value}`;\n    }\n    /**\n     * `toSortedJSON` returns the sorted JSON encoding of the value.\n     */\n    toSortedJSON() {\n        return this.toJSON();\n    }\n    /**\n     * `toJSForTest` returns value with meta data for testing.\n     */\n    toJSForTest() {\n        return {\n            id: this.getCreatedAt().toTestString(),\n            value: this.value,\n            type: 'YORKIE_PRIMITIVE',\n        };\n    }\n    /**\n     * `deepcopy` copies itself deeply.\n     */\n    deepcopy() {\n        const primitive = Primitive.of(this.value, this.getCreatedAt());\n        primitive.setMovedAt(this.getMovedAt());\n        primitive.setRemovedAt(this.getRemovedAt());\n        return primitive;\n    }\n    /**\n     * `getType` returns the type of the value.\n     */\n    getType() {\n        return this.valueType;\n    }\n    /**\n     * `getPrimitiveType` returns the primitive type of the value.\n     */\n    static getPrimitiveType(value) {\n        switch (typeof value) {\n            case 'undefined':\n                return PrimitiveType.Null;\n            case 'boolean':\n                return PrimitiveType.Boolean;\n            case 'number':\n                if (this.isInteger(value)) {\n                    return PrimitiveType.Integer;\n                }\n                else {\n                    return PrimitiveType.Double;\n                }\n            case 'string':\n                return PrimitiveType.String;\n            case 'object':\n                if (value === null) {\n                    return PrimitiveType.Null;\n                }\n                else if (value instanceof node_modules_long) {\n                    return PrimitiveType.Long;\n                }\n                else if (value instanceof Uint8Array) {\n                    return PrimitiveType.Bytes;\n                }\n                else if (value instanceof Date) {\n                    return PrimitiveType.Date;\n                }\n        }\n        return;\n    }\n    /**\n     * `isSupport` check if the given value is supported type.\n     */\n    static isSupport(value) {\n        const primitiveType = Primitive.getPrimitiveType(value);\n        if (primitiveType === undefined) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * `isInteger` checks if the given number is integer.\n     */\n    static isInteger(num) {\n        return num % 1 === 0;\n    }\n    /**\n     * `isNumericType` checks numeric type by JSONPrimitive\n     */\n    isNumericType() {\n        const t = this.valueType;\n        return (t === PrimitiveType.Integer ||\n            t === PrimitiveType.Long ||\n            t === PrimitiveType.Double);\n    }\n    /**\n     * `getValue` returns the value of Primitive.\n     */\n    getValue() {\n        return this.value;\n    }\n    /**\n     * `toBytes` creates an array representing the value.\n     */\n    toBytes() {\n        switch (this.valueType) {\n            case PrimitiveType.Null: {\n                return new Uint8Array();\n            }\n            case PrimitiveType.Boolean: {\n                const boolVal = this.value;\n                return boolVal ? new Uint8Array([1]) : new Uint8Array([0]);\n            }\n            case PrimitiveType.Integer: {\n                const intVal = this.value;\n                return new Uint8Array([\n                    intVal & 0xff,\n                    (intVal >> 8) & 0xff,\n                    (intVal >> 16) & 0xff,\n                    (intVal >> 24) & 0xff,\n                ]);\n            }\n            case PrimitiveType.Double: {\n                const doubleVal = this.value;\n                const uint8Array = new Uint8Array(8);\n                const view = new DataView(uint8Array.buffer);\n                view.setFloat64(0, doubleVal, true);\n                return uint8Array;\n            }\n            case PrimitiveType.String: {\n                return new TextEncoder().encode(this.value);\n            }\n            case PrimitiveType.Long: {\n                const longVal = this.value;\n                const longToBytes = longVal.toBytesLE();\n                return Uint8Array.from(longToBytes);\n            }\n            case PrimitiveType.Bytes: {\n                const bytesVal = this.value;\n                return bytesVal;\n            }\n            case PrimitiveType.Date: {\n                const dateVal = this.value;\n                const dateToBytes = node_modules_long.fromNumber(dateVal.getTime(), true).toBytesLE();\n                return Uint8Array.from(dateToBytes);\n            }\n            default:\n                throw new YorkieError(error_Code.Unimplemented, `unimplemented type: ${this.valueType}`);\n        }\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/crdt/rga_tree_list.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n/**\n * `RGATreeListNode` is a node of RGATreeList.\n */\nclass RGATreeListNode extends SplayNode {\n    constructor(value) {\n        super(value);\n        this.value = value;\n    }\n    /**\n     * `createAfter` creates a new node after the given node.\n     */\n    static createAfter(prev, value) {\n        const newNode = new RGATreeListNode(value);\n        const prevNext = prev.next;\n        prev.next = newNode;\n        newNode.prev = prev;\n        newNode.next = prevNext;\n        if (prevNext) {\n            prevNext.prev = newNode;\n        }\n        return newNode;\n    }\n    /**\n     * `remove` removes value based on removing time.\n     */\n    remove(removedAt) {\n        return this.value.remove(removedAt);\n    }\n    /**\n     * `getCreatedAt` returns creation time of this value\n     */\n    getCreatedAt() {\n        return this.value.getCreatedAt();\n    }\n    /**\n     * `getPositionedAt` returns the time of this element when it was positioned\n     * in the array.\n     */\n    getPositionedAt() {\n        return this.value.getPositionedAt();\n    }\n    /**\n     * `release` releases prev and next node.\n     */\n    release() {\n        if (this.prev) {\n            this.prev.next = this.next;\n        }\n        if (this.next) {\n            this.next.prev = this.prev;\n        }\n        this.prev = undefined;\n        this.next = undefined;\n    }\n    /**\n     * `getLength` returns the length of this node.\n     */\n    getLength() {\n        return this.value.isRemoved() ? 0 : 1;\n    }\n    /**\n     * `getPrev` returns a previous node.\n     */\n    getPrev() {\n        return this.prev;\n    }\n    /**\n     * `getNext` returns a next node.\n     */\n    getNext() {\n        return this.next;\n    }\n    /**\n     * `getValue` returns a element value.\n     */\n    getValue() {\n        return this.value;\n    }\n    /**\n     * `isRemoved` checks if the value was removed.\n     */\n    isRemoved() {\n        return this.value.isRemoved();\n    }\n}\n/**\n * `RGATreeList` is a replicated growable array.\n *\n * @internal\n */\nclass RGATreeList {\n    constructor() {\n        const dummyValue = Primitive.of(0, InitialTimeTicket);\n        dummyValue.setRemovedAt(InitialTimeTicket);\n        this.dummyHead = new RGATreeListNode(dummyValue);\n        this.last = this.dummyHead;\n        this.nodeMapByIndex = new SplayTree();\n        this.nodeMapByCreatedAt = new Map();\n        this.nodeMapByIndex.insert(this.dummyHead);\n        this.nodeMapByCreatedAt.set(this.dummyHead.getCreatedAt().toIDString(), this.dummyHead);\n    }\n    /**\n     * `create` creates instance of RGATreeList.\n     */\n    static create() {\n        return new RGATreeList();\n    }\n    /**\n     * `length` returns size of RGATreeList.\n     */\n    get length() {\n        return this.nodeMapByIndex.length;\n    }\n    /**\n     * `findNextBeforeExecutedAt` returns the node by the given createdAt and\n     * executedAt. It passes through nodes created after executedAt from the\n     * given node and returns the next node.\n     * @param createdAt - created time\n     * @param executedAt - executed time\n     * @returns next node\n     */\n    findNextBeforeExecutedAt(createdAt, executedAt) {\n        let node = this.nodeMapByCreatedAt.get(createdAt.toIDString());\n        if (!node) {\n            logger.fatal(`cant find the given node: ${createdAt.toIDString()}`);\n        }\n        while (node.getNext() &&\n            node.getNext().getPositionedAt().after(executedAt)) {\n            node = node.getNext();\n        }\n        return node;\n    }\n    release(node) {\n        if (this.last === node) {\n            this.last = node.getPrev();\n        }\n        node.release();\n        this.nodeMapByIndex.delete(node);\n        this.nodeMapByCreatedAt.delete(node.getValue().getCreatedAt().toIDString());\n    }\n    /**\n     * `insertAfter` adds a new node with the value after the given node.\n     */\n    insertAfter(prevCreatedAt, value, executedAt = value.getCreatedAt()) {\n        const prevNode = this.findNextBeforeExecutedAt(prevCreatedAt, executedAt);\n        const newNode = RGATreeListNode.createAfter(prevNode, value);\n        if (prevNode === this.last) {\n            this.last = newNode;\n        }\n        this.nodeMapByIndex.insertAfter(prevNode, newNode);\n        this.nodeMapByCreatedAt.set(newNode.getCreatedAt().toIDString(), newNode);\n    }\n    /**\n     * `moveAfter` moves the given `createdAt` element\n     * after the `prevCreatedAt` element.\n     */\n    moveAfter(prevCreatedAt, createdAt, executedAt) {\n        const prevNode = this.nodeMapByCreatedAt.get(prevCreatedAt.toIDString());\n        if (!prevNode) {\n            logger.fatal(`cant find the given node: ${prevCreatedAt.toIDString()}`);\n        }\n        const node = this.nodeMapByCreatedAt.get(createdAt.toIDString());\n        if (!node) {\n            logger.fatal(`cant find the given node: ${createdAt.toIDString()}`);\n        }\n        if (prevNode !== node &&\n            (!node.getValue().getMovedAt() ||\n                executedAt.after(node.getValue().getMovedAt()))) {\n            this.release(node);\n            this.insertAfter(prevNode.getCreatedAt(), node.getValue(), executedAt);\n            node.getValue().setMovedAt(executedAt);\n        }\n    }\n    /**\n     * `insert` adds the given element after the last node.\n     */\n    insert(value) {\n        this.insertAfter(this.last.getCreatedAt(), value);\n    }\n    /**\n     * `getByID` returns the element of the given creation time.\n     */\n    getByID(createdAt) {\n        return this.nodeMapByCreatedAt.get(createdAt.toIDString());\n    }\n    /**\n     * `subPathOf` returns the sub path of the given element.\n     */\n    subPathOf(createdAt) {\n        const node = this.nodeMapByCreatedAt.get(createdAt.toIDString());\n        if (!node) {\n            return;\n        }\n        return String(this.nodeMapByIndex.indexOf(node));\n    }\n    /**\n     * `purge` physically purges element.\n     */\n    purge(element) {\n        const node = this.nodeMapByCreatedAt.get(element.getCreatedAt().toIDString());\n        if (!node) {\n            logger.fatal(`fail to find the given createdAt: ${element\n                .getCreatedAt()\n                .toIDString()}`);\n        }\n        this.release(node);\n    }\n    /**\n     * `getByIndex` returns node of the given index.\n     */\n    getByIndex(idx) {\n        if (idx >= this.length) {\n            return;\n        }\n        const [node, offset] = this.nodeMapByIndex.find(idx);\n        let rgaNode = node;\n        if ((idx === 0 && node === this.dummyHead) || offset > 0) {\n            do {\n                if (rgaNode) {\n                    rgaNode = rgaNode.getNext();\n                }\n            } while (rgaNode && rgaNode.isRemoved());\n        }\n        return rgaNode;\n    }\n    /**\n     * `getPrevCreatedAt` returns a creation time of the previous node.\n     */\n    getPrevCreatedAt(createdAt) {\n        let node = this.nodeMapByCreatedAt.get(createdAt.toIDString());\n        do {\n            node = node.getPrev();\n        } while (this.dummyHead !== node && node.isRemoved());\n        return node.getValue().getCreatedAt();\n    }\n    /**\n     * `delete` deletes the node of the given creation time.\n     */\n    delete(createdAt, editedAt) {\n        const node = this.nodeMapByCreatedAt.get(createdAt.toIDString());\n        const alreadyRemoved = node.isRemoved();\n        if (node.remove(editedAt) && !alreadyRemoved) {\n            this.nodeMapByIndex.splayNode(node);\n        }\n        return node.getValue();\n    }\n    /**\n     * `deleteByIndex` deletes the node of the given index.\n     */\n    deleteByIndex(index, editedAt) {\n        const node = this.getByIndex(index);\n        if (!node) {\n            return;\n        }\n        if (node.remove(editedAt)) {\n            this.nodeMapByIndex.splayNode(node);\n        }\n        return node.getValue();\n    }\n    /**\n     * `getHead` returns the value of head elements.\n     */\n    getHead() {\n        return this.dummyHead.getValue();\n    }\n    /**\n     * `getLast` returns the value of last elements.\n     */\n    getLast() {\n        return this.last.getValue();\n    }\n    /**\n     * `getLastCreatedAt` returns the creation time of last element.\n     */\n    getLastCreatedAt() {\n        return this.last.getCreatedAt();\n    }\n    /**\n     * `toTestString` returns a String containing the meta data of the node id\n     * for debugging purpose.\n     */\n    toTestString() {\n        const json = [];\n        for (const node of this) {\n            const elem = `${node.getCreatedAt().toIDString()}:${node\n                .getValue()\n                .toJSON()}`;\n            if (node.isRemoved()) {\n                json.push(`{${elem}}`);\n            }\n            else {\n                json.push(`[${elem}]`);\n            }\n        }\n        return json.join('');\n    }\n    // eslint-disable-next-line jsdoc/require-jsdoc\n    *[Symbol.iterator]() {\n        let node = this.dummyHead.getNext();\n        while (node) {\n            yield node;\n            node = node.getNext();\n        }\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/crdt/array.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * `CRDTArray` represents an array data type containing `CRDTElement`s.\n *\n * @internal\n */\nclass CRDTArray extends CRDTContainer {\n    /** @hideconstructor */\n    constructor(createdAt, elements) {\n        super(createdAt);\n        this.elements = elements;\n    }\n    /**\n     * `create` creates a new instance of Array.\n     */\n    static create(createdAt, value) {\n        if (!value) {\n            return new CRDTArray(createdAt, RGATreeList.create());\n        }\n        const elements = RGATreeList.create();\n        for (const v of value) {\n            elements.insertAfter(elements.getLastCreatedAt(), v.deepcopy());\n        }\n        return new CRDTArray(createdAt, elements);\n    }\n    /**\n     * `subPathOf` returns the sub path of the given element.\n     */\n    subPathOf(createdAt) {\n        return this.elements.subPathOf(createdAt);\n    }\n    /**\n     * `purge` physically purge the given element.\n     */\n    purge(element) {\n        this.elements.purge(element);\n    }\n    /**\n     * `insertAfter` adds a new node after the the given node.\n     */\n    insertAfter(prevCreatedAt, value) {\n        this.elements.insertAfter(prevCreatedAt, value);\n    }\n    /**\n     * `moveAfter` moves the given `createdAt` element after the `prevCreatedAt`.\n     */\n    moveAfter(prevCreatedAt, createdAt, executedAt) {\n        this.elements.moveAfter(prevCreatedAt, createdAt, executedAt);\n    }\n    /**\n     * `get` returns the element of the given index.\n     */\n    get(index) {\n        const node = this.elements.getByIndex(index);\n        return node === null || node === void 0 ? void 0 : node.getValue();\n    }\n    /**\n     * `getByID` returns the element of the given createAt.\n     */\n    getByID(createdAt) {\n        const node = this.elements.getByID(createdAt);\n        return node === null || node === void 0 ? void 0 : node.getValue();\n    }\n    /**\n     * `getHead` returns dummy head element.\n     */\n    getHead() {\n        return this.elements.getHead();\n    }\n    /**\n     * `getLast` returns last element.\n     */\n    getLast() {\n        return this.elements.getLast();\n    }\n    /**\n     * `getPrevCreatedAt` returns the creation time of the previous node.\n     */\n    getPrevCreatedAt(createdAt) {\n        return this.elements.getPrevCreatedAt(createdAt);\n    }\n    /**\n     * `delete` deletes the element of the given creation time.\n     */\n    delete(createdAt, editedAt) {\n        return this.elements.delete(createdAt, editedAt);\n    }\n    /**\n     * `deleteByIndex` deletes the element of given index and editedAt.\n     */\n    deleteByIndex(index, editedAt) {\n        return this.elements.deleteByIndex(index, editedAt);\n    }\n    /**\n     * `getLastCreatedAt` get last created element.\n     */\n    getLastCreatedAt() {\n        return this.elements.getLastCreatedAt();\n    }\n    /**\n     * `length` returns length of this elements.\n     */\n    get length() {\n        return this.elements.length;\n    }\n    /**\n     * eslint-disable-next-line jsdoc/require-jsdoc\n     * @internal\n     */\n    *[Symbol.iterator]() {\n        for (const node of this.elements) {\n            if (!node.isRemoved()) {\n                yield node.getValue();\n            }\n        }\n    }\n    /**\n     * `toTestString` returns a String containing the meta data of this value\n     * for debugging purpose.\n     */\n    toTestString() {\n        return this.elements.toTestString();\n    }\n    /**\n     * `getDescendants` traverse the descendants of this array.\n     */\n    getDescendants(callback) {\n        for (const node of this.elements) {\n            const element = node.getValue();\n            if (callback(element, this)) {\n                return;\n            }\n            if (element instanceof CRDTContainer) {\n                element.getDescendants(callback);\n            }\n        }\n    }\n    /**\n     * `toJSON` returns the JSON encoding of this array.\n     */\n    toJSON() {\n        const json = [];\n        for (const value of this) {\n            json.push(value.toJSON());\n        }\n        return `[${json.join(',')}]`;\n    }\n    /**\n     * `toJS` return the javascript object of this array.\n     */\n    toJS() {\n        return JSON.parse(this.toJSON());\n    }\n    /**\n     * `toJSForTest` returns value with meta data for testing.\n     */\n    toJSForTest() {\n        const values = {};\n        for (let i = 0; i < this.length; i++) {\n            const { id, value, type } = this.get(i).toJSForTest();\n            values[i] = {\n                key: String(i),\n                id,\n                value,\n                type,\n            };\n        }\n        return {\n            id: this.getCreatedAt().toTestString(),\n            value: values,\n            type: 'YORKIE_ARRAY',\n        };\n    }\n    /**\n     * `toSortedJSON` returns the sorted JSON encoding of this array.\n     */\n    toSortedJSON() {\n        return this.toJSON();\n    }\n    /**\n     * `getElements` returns an array of elements contained in this RGATreeList.\n     */\n    getElements() {\n        return this.elements;\n    }\n    /**\n     * `deepcopy` copies itself deeply.\n     */\n    deepcopy() {\n        const clone = CRDTArray.create(this.getCreatedAt());\n        for (const node of this.elements) {\n            clone.elements.insertAfter(clone.getLastCreatedAt(), node.getValue().deepcopy());\n        }\n        clone.remove(this.getRemovedAt());\n        return clone;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/operation/remove_operation.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n/**\n * `RemoveOperation` is an operation that removes an element from `CRDTContainer`.\n */\nclass RemoveOperation extends Operation {\n    constructor(parentCreatedAt, createdAt, executedAt) {\n        super(parentCreatedAt, executedAt);\n        this.createdAt = createdAt;\n    }\n    /**\n     * `create` creates a new instance of RemoveOperation.\n     */\n    static create(parentCreatedAt, createdAt, executedAt) {\n        return new RemoveOperation(parentCreatedAt, createdAt, executedAt);\n    }\n    /**\n     * `execute` executes this operation on the given `CRDTRoot`.\n     */\n    execute(root, source) {\n        var _a;\n        const container = root.findByCreatedAt(this.getParentCreatedAt());\n        if (!container) {\n            logger.fatal(`fail to find ${this.getParentCreatedAt()}`);\n        }\n        if (!(container instanceof CRDTContainer)) {\n            logger.fatal(`only object and array can execute remove: ${container}`);\n        }\n        // NOTE(chacha912): Handle cases where operation cannot be executed during undo and redo.\n        if (source === OpSource.UndoRedo) {\n            let parent = container.getByID(this.createdAt);\n            while (parent) {\n                if (parent.getRemovedAt()) {\n                    return;\n                }\n                parent = (_a = root.findElementPairByCreatedAt(parent.getCreatedAt())) === null || _a === void 0 ? void 0 : _a.parent;\n            }\n        }\n        const key = container.subPathOf(this.createdAt);\n        const reverseOp = this.toReverseOperation(container);\n        const elem = container.delete(this.createdAt, this.getExecutedAt());\n        root.registerRemovedElement(elem);\n        const opInfos = container instanceof CRDTArray\n            ? [\n                {\n                    type: 'remove',\n                    path: root.createPath(this.getParentCreatedAt()),\n                    index: Number(key),\n                },\n            ]\n            : [\n                {\n                    type: 'remove',\n                    path: root.createPath(this.getParentCreatedAt()),\n                    key,\n                },\n            ];\n        return { opInfos, reverseOp };\n    }\n    /**\n     * `toReverseOperation` returns the reverse operation of this operation.\n     */\n    toReverseOperation(parentObject) {\n        // TODO(Hyemmie): consider CRDTArray\n        if (parentObject instanceof CRDTObject) {\n            const key = parentObject.subPathOf(this.createdAt);\n            if (key !== undefined) {\n                const value = parentObject.get(key);\n                if (value !== undefined) {\n                    return SetOperation.create(key, value.deepcopy(), this.getParentCreatedAt());\n                }\n            }\n        }\n    }\n    /**\n     * `getEffectedCreatedAt` returns the creation time of the effected element.\n     */\n    getEffectedCreatedAt() {\n        return this.getParentCreatedAt();\n    }\n    /**\n     * `toTestString` returns a string containing the meta data.\n     */\n    toTestString() {\n        return `${this.getParentCreatedAt().toTestString()}.REMOVE.${this.createdAt.toTestString()}`;\n    }\n    /**\n     * `getCreatedAt` returns the creation time of the target element.\n     */\n    getCreatedAt() {\n        return this.createdAt;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/operation/set_operation.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n/**\n * `SetOperation` represents an operation that stores the value corresponding to the\n * given key in the Object.\n */\nclass SetOperation extends Operation {\n    constructor(key, value, parentCreatedAt, executedAt) {\n        super(parentCreatedAt, executedAt);\n        this.key = key;\n        this.value = value;\n    }\n    /**\n     * `create` creates a new instance of SetOperation.\n     */\n    static create(key, value, parentCreatedAt, executedAt) {\n        return new SetOperation(key, value, parentCreatedAt, executedAt);\n    }\n    /**\n     * `execute` executes this operation on the given `CRDTRoot`.\n     */\n    execute(root, source) {\n        var _a;\n        const obj = root.findByCreatedAt(this.getParentCreatedAt());\n        if (!obj) {\n            logger.fatal(`fail to find ${this.getParentCreatedAt()}`);\n        }\n        if (!(obj instanceof CRDTObject)) {\n            logger.fatal(`fail to execute, only object can execute set`);\n        }\n        // NOTE(chacha912): Handle cases where operation cannot be executed during undo and redo.\n        if (source === OpSource.UndoRedo) {\n            let parent = obj;\n            while (parent) {\n                if (parent.getRemovedAt()) {\n                    return;\n                }\n                parent = (_a = root.findElementPairByCreatedAt(parent.getCreatedAt())) === null || _a === void 0 ? void 0 : _a.parent;\n            }\n        }\n        const previousValue = obj.get(this.key);\n        const reverseOp = this.toReverseOperation(previousValue);\n        const value = this.value.deepcopy();\n        const removed = obj.set(this.key, value, this.getExecutedAt());\n        // NOTE(chacha912): When resetting elements with the pre-existing createdAt\n        // during undo/redo, it's essential to handle previously tombstoned elements.\n        // In non-GC languages, there may be a need to execute both deregister and purge.\n        if (source === OpSource.UndoRedo &&\n            root.findByCreatedAt(value.getCreatedAt())) {\n            root.deregisterElement(value);\n        }\n        root.registerElement(value, obj);\n        if (removed) {\n            root.registerRemovedElement(removed);\n        }\n        return {\n            opInfos: [\n                {\n                    type: 'set',\n                    path: root.createPath(this.getParentCreatedAt()),\n                    key: this.key,\n                },\n            ],\n            reverseOp,\n        };\n    }\n    /**\n     * `toReverseOperation` returns the reverse operation of this operation.\n     */\n    toReverseOperation(value) {\n        let reverseOp = RemoveOperation.create(this.getParentCreatedAt(), this.value.getCreatedAt());\n        if (value !== undefined && !value.isRemoved()) {\n            reverseOp = SetOperation.create(this.key, value.deepcopy(), this.getParentCreatedAt());\n        }\n        return reverseOp;\n    }\n    /**\n     * `getEffectedCreatedAt` returns the creation time of the effected element.\n     */\n    getEffectedCreatedAt() {\n        return this.value.getCreatedAt();\n    }\n    /**\n     * `toTestString` returns a string containing the meta data.\n     */\n    toTestString() {\n        return `${this.getParentCreatedAt().toTestString()}.SET.${this.key}=${this.value.toSortedJSON()}`;\n    }\n    /**\n     * `getKey` returns the key of this operation.\n     */\n    getKey() {\n        return this.key;\n    }\n    /**\n     * `getValue` returns the value of this operation.\n     */\n    getValue() {\n        return this.value;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/operation/add_operation.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n/**\n * `AddOperation` is an operation representing adding an element to an Array.\n */\nclass AddOperation extends Operation {\n    constructor(parentCreatedAt, prevCreatedAt, value, executedAt) {\n        super(parentCreatedAt, executedAt);\n        this.prevCreatedAt = prevCreatedAt;\n        this.value = value;\n    }\n    /**\n     * `create` creates a new instance of AddOperation.\n     */\n    static create(parentCreatedAt, prevCreatedAt, value, executedAt) {\n        return new AddOperation(parentCreatedAt, prevCreatedAt, value, executedAt);\n    }\n    /**\n     * `execute` executes this operation on the given `CRDTRoot`.\n     */\n    execute(root) {\n        const parentObject = root.findByCreatedAt(this.getParentCreatedAt());\n        if (!parentObject) {\n            logger.fatal(`fail to find ${this.getParentCreatedAt()}`);\n        }\n        if (!(parentObject instanceof CRDTArray)) {\n            logger.fatal(`fail to execute, only array can execute add`);\n        }\n        const array = parentObject;\n        const value = this.value.deepcopy();\n        array.insertAfter(this.prevCreatedAt, value);\n        root.registerElement(value, array);\n        return {\n            opInfos: [\n                {\n                    type: 'add',\n                    path: root.createPath(this.getParentCreatedAt()),\n                    index: Number(array.subPathOf(this.getEffectedCreatedAt())),\n                },\n            ],\n        };\n    }\n    /**\n     * `getEffectedCreatedAt` returns the creation time of the effected element.\n     */\n    getEffectedCreatedAt() {\n        return this.value.getCreatedAt();\n    }\n    /**\n     * `toTestString` returns a string containing the meta data.\n     */\n    toTestString() {\n        return `${this.getParentCreatedAt().toTestString()}.ADD.${this.value.toJSON()}`;\n    }\n    /**\n     * `getPrevCreatedAt` returns the creation time of previous element.\n     */\n    getPrevCreatedAt() {\n        return this.prevCreatedAt;\n    }\n    /**\n     * `getValue` returns the value of this operation.\n     */\n    getValue() {\n        return this.value;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/operation/move_operation.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n/**\n * `MoveOperation` is an operation representing moving an element to an Array.\n */\nclass MoveOperation extends Operation {\n    constructor(parentCreatedAt, prevCreatedAt, createdAt, executedAt) {\n        super(parentCreatedAt, executedAt);\n        this.prevCreatedAt = prevCreatedAt;\n        this.createdAt = createdAt;\n    }\n    /**\n     * `create` creates a new instance of MoveOperation.\n     */\n    static create(parentCreatedAt, prevCreatedAt, createdAt, executedAt) {\n        return new MoveOperation(parentCreatedAt, prevCreatedAt, createdAt, executedAt);\n    }\n    /**\n     * `execute` executes this operation on the given `CRDTRoot`.\n     */\n    execute(root) {\n        const parentObject = root.findByCreatedAt(this.getParentCreatedAt());\n        if (!parentObject) {\n            logger.fatal(`fail to find ${this.getParentCreatedAt()}`);\n        }\n        if (!(parentObject instanceof CRDTArray)) {\n            logger.fatal(`fail to execute, only array can execute move`);\n        }\n        const array = parentObject;\n        const previousIndex = Number(array.subPathOf(this.createdAt));\n        array.moveAfter(this.prevCreatedAt, this.createdAt, this.getExecutedAt());\n        const index = Number(array.subPathOf(this.createdAt));\n        return {\n            opInfos: [\n                {\n                    type: 'move',\n                    path: root.createPath(this.getParentCreatedAt()),\n                    index,\n                    previousIndex,\n                },\n            ],\n        };\n    }\n    /**\n     * `getEffectedCreatedAt` returns the creation time of the effected element.\n     */\n    getEffectedCreatedAt() {\n        return this.createdAt;\n    }\n    /**\n     * `toTestString` returns a string containing the meta data.\n     */\n    toTestString() {\n        return `${this.getParentCreatedAt().toTestString()}.MOVE`;\n    }\n    /**\n     * `getPrevCreatedAt` returns the creation time of previous element.\n     */\n    getPrevCreatedAt() {\n        return this.prevCreatedAt;\n    }\n    /**\n     * `getCreatedAt` returns the creation time of the target element.\n     */\n    getCreatedAt() {\n        return this.createdAt;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/crdt/rht.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * `RHTNode` is a node of RHT(Replicated Hashtable).\n */\nclass RHTNode {\n    constructor(key, value, updatedAt) {\n        this.key = key;\n        this.value = value;\n        this.updatedAt = updatedAt;\n    }\n    /**\n     * `of` creates a new instance of RHTNode.\n     */\n    static of(key, value, createdAt) {\n        return new RHTNode(key, value, createdAt);\n    }\n    /**\n     * `getKey` returns a key of node.\n     */\n    getKey() {\n        return this.key;\n    }\n    /**\n     * `getValue` returns a value of node.\n     */\n    getValue() {\n        return this.value;\n    }\n    /**\n     * `getUpdatedAt `returns updated time of node.\n     */\n    getUpdatedAt() {\n        return this.updatedAt;\n    }\n}\n/**\n * RHT is replicated hash table by creation time.\n * For more details about RHT: @see http://csl.skku.edu/papers/jpdc11.pdf\n */\nclass RHT {\n    constructor() {\n        this.nodeMapByKey = new Map();\n    }\n    /**\n     * `create` creates a new instance of RHT.\n     */\n    static create() {\n        return new RHT();\n    }\n    /**\n     * `set` sets the value of the given key.\n     */\n    set(key, value, executedAt) {\n        const prev = this.nodeMapByKey.get(key);\n        if (prev === undefined || executedAt.after(prev.getUpdatedAt())) {\n            const node = RHTNode.of(key, value, executedAt);\n            this.nodeMapByKey.set(key, node);\n        }\n    }\n    /**\n     * `has` returns whether the element exists of the given key or not.\n     */\n    has(key) {\n        return this.nodeMapByKey.has(key);\n    }\n    /**\n     * `get` returns the value of the given key.\n     */\n    get(key) {\n        if (!this.nodeMapByKey.has(key)) {\n            return;\n        }\n        return this.nodeMapByKey.get(key).getValue();\n    }\n    /**\n     * `deepcopy` copies itself deeply.\n     */\n    deepcopy() {\n        const rht = new RHT();\n        for (const [, node] of this.nodeMapByKey) {\n            rht.set(node.getKey(), node.getValue(), node.getUpdatedAt());\n        }\n        return rht;\n    }\n    /**\n     * `toJSON` returns the JSON encoding of this hashtable.\n     */\n    toJSON() {\n        const items = [];\n        for (const [key, node] of this.nodeMapByKey) {\n            items.push(`\"${escapeString(key)}\":\"${escapeString(node.getValue())}\"`);\n        }\n        return `{${items.join(',')}}`;\n    }\n    /**\n     * `toXML` converts the given RHT to XML string.\n     */\n    toXML() {\n        if (!this.size()) {\n            return '';\n        }\n        return ` ${[...this.nodeMapByKey]\n            .map(([k, v]) => `${k}=\"${JSON.parse(v.getValue())}\"`)\n            .join(' ')}`;\n    }\n    /**\n     * `size` returns the size of RHT\n     */\n    size() {\n        return this.nodeMapByKey.size;\n    }\n    /**\n     * `toObject` returns the object of this hashtable.\n     */\n    toObject() {\n        const obj = {};\n        for (const [key, node] of this.nodeMapByKey) {\n            obj[key] = node.getValue();\n        }\n        return obj;\n    }\n    // eslint-disable-next-line jsdoc/require-jsdoc\n    *[Symbol.iterator]() {\n        for (const [, node] of this.nodeMapByKey) {\n            yield node;\n        }\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/crdt/text.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n/**\n * `TextChangeType` is the type of TextChange.\n *\n */\nvar TextChangeType;\n(function (TextChangeType) {\n    TextChangeType[\"Content\"] = \"content\";\n    TextChangeType[\"Style\"] = \"style\";\n})(TextChangeType || (TextChangeType = {}));\n/**\n * `CRDTTextValue` is a value of Text\n * which has a attributes that expresses the text style.\n * Attributes are represented by RHT.\n *\n */\nclass CRDTTextValue {\n    /** @hideconstructor */\n    constructor(content) {\n        this.attributes = RHT.create();\n        this.content = content;\n    }\n    /**\n     * `create` creates a instance of CRDTTextValue.\n     */\n    static create(content) {\n        return new CRDTTextValue(content);\n    }\n    /**\n     * `length` returns the length of value.\n     */\n    get length() {\n        return this.content.length;\n    }\n    /**\n     * `substring` returns a sub-string value of the given range.\n     */\n    substring(indexStart, indexEnd) {\n        const value = new CRDTTextValue(this.content.substring(indexStart, indexEnd));\n        value.attributes = this.attributes.deepcopy();\n        return value;\n    }\n    /**\n     * `setAttr` sets attribute of the given key, updated time and value.\n     */\n    setAttr(key, content, updatedAt) {\n        this.attributes.set(key, content, updatedAt);\n    }\n    /**\n     * `getAttr` returns the attributes of this value.\n     */\n    getAttrs() {\n        return this.attributes;\n    }\n    /**\n     * `toString` returns the string representation of this value.\n     */\n    toString() {\n        return this.content;\n    }\n    /**\n     * `toJSON` returns the JSON encoding of this value.\n     */\n    toJSON() {\n        const content = escapeString(this.content);\n        const attrsObj = this.attributes.toObject();\n        const attrs = [];\n        for (const [key, v] of Object.entries(attrsObj)) {\n            const value = JSON.parse(v);\n            const item = typeof value === 'string'\n                ? `\"${escapeString(key)}\":\"${escapeString(value)}\"`\n                : `\"${escapeString(key)}\":${String(value)}`;\n            attrs.push(item);\n        }\n        attrs.sort();\n        if (attrs.length === 0) {\n            return `{\"val\":\"${content}\"}`;\n        }\n        return `{\"attrs\":{${attrs.join(',')}},\"val\":\"${content}\"}`;\n    }\n    /**\n     * `getAttributes` returns the attributes of this value.\n     */\n    getAttributes() {\n        return this.attributes.toObject();\n    }\n    /**\n     * `getContent` returns the internal content.\n     */\n    getContent() {\n        return this.content;\n    }\n}\n/**\n *  `CRDTText` is a custom CRDT data type to represent the contents of text editors.\n *\n */\nclass CRDTText extends CRDTGCElement {\n    constructor(rgaTreeSplit, createdAt) {\n        super(createdAt);\n        this.rgaTreeSplit = rgaTreeSplit;\n    }\n    /**\n     * `create` a instance of Text.\n     */\n    static create(rgaTreeSplit, createdAt) {\n        return new CRDTText(rgaTreeSplit, createdAt);\n    }\n    /**\n     * `edit` edits the given range with the given value and attributes.\n     *\n     * @internal\n     */\n    edit(range, content, editedAt, attributes, latestCreatedAtMapByActor) {\n        const crdtTextValue = content ? CRDTTextValue.create(content) : undefined;\n        if (crdtTextValue && attributes) {\n            for (const [k, v] of Object.entries(attributes)) {\n                crdtTextValue.setAttr(k, v, editedAt);\n            }\n        }\n        const [caretPos, latestCreatedAtMap, valueChanges] = this.rgaTreeSplit.edit(range, editedAt, crdtTextValue, latestCreatedAtMapByActor);\n        const changes = valueChanges.map((change) => ({\n            ...change,\n            value: change.value\n                ? {\n                    attributes: parseObjectValues(change.value.getAttributes()),\n                    content: change.value.getContent(),\n                }\n                : {\n                    attributes: undefined,\n                    content: '',\n                },\n            type: TextChangeType.Content,\n        }));\n        return [latestCreatedAtMap, changes, [caretPos, caretPos]];\n    }\n    /**\n     * `setStyle` applies the style of the given range.\n     * 01. split nodes with from and to\n     * 02. style nodes between from and to\n     *\n     * @param range - range of RGATreeSplitNode\n     * @param attributes - style attributes\n     * @param editedAt - edited time\n     * @internal\n     */\n    setStyle(range, attributes, editedAt, latestCreatedAtMapByActor) {\n        // 01. split nodes with from and to\n        const [, toRight] = this.rgaTreeSplit.findNodeWithSplit(range[1], editedAt);\n        const [, fromRight] = this.rgaTreeSplit.findNodeWithSplit(range[0], editedAt);\n        // 02. style nodes between from and to\n        const changes = [];\n        const nodes = this.rgaTreeSplit.findBetween(fromRight, toRight);\n        const createdAtMapByActor = new Map();\n        const toBeStyleds = [];\n        for (const node of nodes) {\n            const actorID = node.getCreatedAt().getActorID();\n            const latestCreatedAt = (latestCreatedAtMapByActor === null || latestCreatedAtMapByActor === void 0 ? void 0 : latestCreatedAtMapByActor.size)\n                ? latestCreatedAtMapByActor.has(actorID)\n                    ? latestCreatedAtMapByActor.get(actorID)\n                    : InitialTimeTicket\n                : MaxTimeTicket;\n            if (node.canStyle(editedAt, latestCreatedAt)) {\n                const latestCreatedAt = createdAtMapByActor.get(actorID);\n                const createdAt = node.getCreatedAt();\n                if (!latestCreatedAt || createdAt.after(latestCreatedAt)) {\n                    createdAtMapByActor.set(actorID, createdAt);\n                }\n                toBeStyleds.push(node);\n            }\n        }\n        for (const node of toBeStyleds) {\n            if (node.isRemoved()) {\n                continue;\n            }\n            const [fromIdx, toIdx] = this.rgaTreeSplit.findIndexesFromRange(node.createPosRange());\n            changes.push({\n                type: TextChangeType.Style,\n                actor: editedAt.getActorID(),\n                from: fromIdx,\n                to: toIdx,\n                value: {\n                    attributes: parseObjectValues(attributes),\n                },\n            });\n            for (const [key, value] of Object.entries(attributes)) {\n                node.getValue().setAttr(key, value, editedAt);\n            }\n        }\n        return [createdAtMapByActor, changes];\n    }\n    /**\n     * `indexRangeToPosRange` returns the position range of the given index range.\n     */\n    indexRangeToPosRange(fromIdx, toIdx) {\n        const fromPos = this.rgaTreeSplit.indexToPos(fromIdx);\n        if (fromIdx === toIdx) {\n            return [fromPos, fromPos];\n        }\n        return [fromPos, this.rgaTreeSplit.indexToPos(toIdx)];\n    }\n    /**\n     * `length` returns size of RGATreeList.\n     */\n    get length() {\n        return this.rgaTreeSplit.length;\n    }\n    /**\n     * `checkWeight` returns false when there is an incorrect weight node.\n     * for debugging purpose.\n     */\n    checkWeight() {\n        return this.rgaTreeSplit.checkWeight();\n    }\n    /**\n     * `toJSON` returns the JSON encoding of this text.\n     */\n    toJSON() {\n        const json = [];\n        for (const node of this.rgaTreeSplit) {\n            if (!node.isRemoved()) {\n                json.push(node.getValue().toJSON());\n            }\n        }\n        return `[${json.join(',')}]`;\n    }\n    /**\n     * `toSortedJSON` returns the sorted JSON encoding of this text.\n     */\n    toSortedJSON() {\n        return this.toJSON();\n    }\n    /**\n     * `toJSForTest` returns value with meta data for testing.\n     */\n    toJSForTest() {\n        return {\n            id: this.getCreatedAt().toTestString(),\n            value: JSON.parse(this.toJSON()),\n            type: 'YORKIE_TEXT',\n        };\n    }\n    /**\n     * `toString` returns the string representation of this text.\n     */\n    toString() {\n        return this.rgaTreeSplit.toString();\n    }\n    /**\n     * `values` returns the content-attributes pair array of this text.\n     */\n    values() {\n        const values = [];\n        for (const node of this.rgaTreeSplit) {\n            if (!node.isRemoved()) {\n                const value = node.getValue();\n                values.push({\n                    attributes: parseObjectValues(value.getAttributes()),\n                    content: value.getContent(),\n                });\n            }\n        }\n        return values;\n    }\n    /**\n     * `getRGATreeSplit` returns rgaTreeSplit.\n     *\n     * @internal\n     */\n    getRGATreeSplit() {\n        return this.rgaTreeSplit;\n    }\n    /**\n     * `toTestString` returns a String containing the meta data of this value\n     * for debugging purpose.\n     */\n    toTestString() {\n        return this.rgaTreeSplit.toTestString();\n    }\n    /**\n     * `getRemovedNodesLen` returns length of removed nodes\n     */\n    getRemovedNodesLen() {\n        return this.rgaTreeSplit.getRemovedNodesLen();\n    }\n    /**\n     * `purgeRemovedNodesBefore` purges removed nodes before the given time.\n     *\n     * @internal\n     */\n    purgeRemovedNodesBefore(ticket) {\n        return this.rgaTreeSplit.purgeRemovedNodesBefore(ticket);\n    }\n    /**\n     * `deepcopy` copies itself deeply.\n     */\n    deepcopy() {\n        const text = new CRDTText(this.rgaTreeSplit.deepcopy(), this.getCreatedAt());\n        text.remove(this.getRemovedAt());\n        return text;\n    }\n    /**\n     * `findIndexesFromRange` returns pair of integer offsets of the given range.\n     */\n    findIndexesFromRange(range) {\n        return this.rgaTreeSplit.findIndexesFromRange(range);\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/operation/edit_operation.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n/**\n * `EditOperation` is an operation representing editing Text. Most of the same as\n * Edit, but with additional style properties, attributes.\n */\nclass EditOperation extends Operation {\n    constructor(parentCreatedAt, fromPos, toPos, maxCreatedAtMapByActor, content, attributes, executedAt) {\n        super(parentCreatedAt, executedAt);\n        this.fromPos = fromPos;\n        this.toPos = toPos;\n        this.maxCreatedAtMapByActor = maxCreatedAtMapByActor;\n        this.content = content;\n        this.attributes = attributes;\n    }\n    /**\n     * `create` creates a new instance of EditOperation.\n     */\n    static create(parentCreatedAt, fromPos, toPos, maxCreatedAtMapByActor, content, attributes, executedAt) {\n        return new EditOperation(parentCreatedAt, fromPos, toPos, maxCreatedAtMapByActor, content, attributes, executedAt);\n    }\n    /**\n     * `execute` executes this operation on the given `CRDTRoot`.\n     */\n    execute(root) {\n        const parentObject = root.findByCreatedAt(this.getParentCreatedAt());\n        if (!parentObject) {\n            logger.fatal(`fail to find ${this.getParentCreatedAt()}`);\n        }\n        if (!(parentObject instanceof CRDTText)) {\n            logger.fatal(`fail to execute, only Text can execute edit`);\n        }\n        const text = parentObject;\n        const [, changes] = text.edit([this.fromPos, this.toPos], this.content, this.getExecutedAt(), Object.fromEntries(this.attributes), this.maxCreatedAtMapByActor);\n        if (!this.fromPos.equals(this.toPos)) {\n            root.registerElementHasRemovedNodes(text);\n        }\n        return {\n            opInfos: changes.map(({ from, to, value }) => {\n                return {\n                    type: 'edit',\n                    from,\n                    to,\n                    value,\n                    path: root.createPath(this.getParentCreatedAt()),\n                };\n            }),\n        };\n    }\n    /**\n     * `getEffectedCreatedAt` returns the creation time of the effected element.\n     */\n    getEffectedCreatedAt() {\n        return this.getParentCreatedAt();\n    }\n    /**\n     * `toTestString` returns a string containing the meta data.\n     */\n    toTestString() {\n        const parent = this.getParentCreatedAt().toTestString();\n        const fromPos = this.fromPos.toTestString();\n        const toPos = this.toPos.toTestString();\n        const content = this.content;\n        return `${parent}.EDIT(${fromPos},${toPos},${content})`;\n    }\n    /**\n     * `getFromPos` returns the start point of the editing range.\n     */\n    getFromPos() {\n        return this.fromPos;\n    }\n    /**\n     * `getToPos` returns the end point of the editing range.\n     */\n    getToPos() {\n        return this.toPos;\n    }\n    /**\n     * `getContent` returns the content of Edit.\n     */\n    getContent() {\n        return this.content;\n    }\n    /**\n     * `getAttributes` returns the attributes of this Edit.\n     */\n    getAttributes() {\n        return this.attributes || new Map();\n    }\n    /**\n     * `getMaxCreatedAtMapByActor` returns the map that stores the latest creation time\n     * by actor for the nodes included in the editing range.\n     */\n    getMaxCreatedAtMapByActor() {\n        return this.maxCreatedAtMapByActor;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/operation/style_operation.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n/**\n *  `StyleOperation` is an operation applies the style of the given range to Text.\n */\nclass StyleOperation extends Operation {\n    constructor(parentCreatedAt, fromPos, toPos, maxCreatedAtMapByActor, attributes, executedAt) {\n        super(parentCreatedAt, executedAt);\n        this.fromPos = fromPos;\n        this.toPos = toPos;\n        this.maxCreatedAtMapByActor = maxCreatedAtMapByActor;\n        this.attributes = attributes;\n    }\n    /**\n     * `create` creates a new instance of StyleOperation.\n     */\n    static create(parentCreatedAt, fromPos, toPos, maxCreatedAtMapByActor, attributes, executedAt) {\n        return new StyleOperation(parentCreatedAt, fromPos, toPos, maxCreatedAtMapByActor, attributes, executedAt);\n    }\n    /**\n     * `execute` executes this operation on the given `CRDTRoot`.\n     */\n    execute(root) {\n        const parentObject = root.findByCreatedAt(this.getParentCreatedAt());\n        if (!parentObject) {\n            logger.fatal(`fail to find ${this.getParentCreatedAt()}`);\n        }\n        if (!(parentObject instanceof CRDTText)) {\n            logger.fatal(`fail to execute, only Text can execute edit`);\n        }\n        const text = parentObject;\n        const [, changes] = text.setStyle([this.fromPos, this.toPos], this.attributes ? Object.fromEntries(this.attributes) : {}, this.getExecutedAt(), this.maxCreatedAtMapByActor);\n        return {\n            opInfos: changes.map(({ from, to, value }) => {\n                return {\n                    type: 'style',\n                    from,\n                    to,\n                    value,\n                    path: root.createPath(this.getParentCreatedAt()),\n                };\n            }),\n        };\n    }\n    /**\n     * `getEffectedCreatedAt` returns the creation time of the effected element.\n     */\n    getEffectedCreatedAt() {\n        return this.getParentCreatedAt();\n    }\n    /**\n     * `toTestString` returns a string containing the meta data.\n     */\n    toTestString() {\n        const parent = this.getParentCreatedAt().toTestString();\n        const fromPos = this.fromPos.toTestString();\n        const toPos = this.toPos.toTestString();\n        const attributes = this.attributes;\n        return `${parent}.STYL(${fromPos},${toPos},${JSON.stringify(attributes)})`;\n    }\n    /**\n     * `getFromPos` returns the start point of the editing range.\n     */\n    getFromPos() {\n        return this.fromPos;\n    }\n    /**\n     * `getToPos` returns the end point of the editing range.\n     */\n    getToPos() {\n        return this.toPos;\n    }\n    /**\n     * `getAttributes` returns the attributes of this operation.\n     */\n    getAttributes() {\n        return this.attributes;\n    }\n    /**\n     * `getMaxCreatedAtMapByActor` returns the map that stores the latest creation time\n     * by actor for the nodes included in the editing range.\n     */\n    getMaxCreatedAtMapByActor() {\n        return this.maxCreatedAtMapByActor;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/util/index_tree.ts\n/*\n * Copyright 2023 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * About `index`, `path`, `size` and `TreePos` in crdt.IndexTree.\n *\n * `index` of crdt.IndexTree represents a absolute position of a node in the tree.\n * `size` is used to calculate the relative index of nodes in the tree.\n * `index` in yorkie.IndexTree inspired by ProseMirror's index.\n *\n * For example, empty paragraph's size is 0 and index 0 is the position of the:\n *    0\n * <p> </p>,                                p.size = 0\n *\n * If a paragraph has <i>, its size becomes 2 and there are 3 indexes:\n *     0   1    2\n *  <p> <i> </i> </p>                       p.size = 2, i.size = 0\n *\n * If the paragraph has <i> and <b>, its size becomes 4:\n *     0   1    2   3   4\n *  <p> <i> </i> <b> </b> </p>              p.size = 4, i.size = 0, b.size = 0\n *     0   1    2   3    4    5   6\n *  <p> <i> </i> <b> </b> <s> </s> </p>     p.size = 6, i.size = 0, b.size = 0, s.size = 0\n *\n * If a paragraph has text, its size becomes length of the characters:\n *     0 1 2 3\n *  <p> A B C </p>                          p.size = 3,   text.size = 3\n *\n * So the size of a node is the sum of the size and type of its children:\n *  `size = children(element type).length * 2 + children.reduce((child, acc) => child.size + acc, 0)`\n *\n * `TreePos` is also used to represent the position in the tree. It contains node and offset.\n * `TreePos` can be converted to `index` and vice versa.\n *\n * For example, if a paragraph has <i>, there are 3 indexes:\n *     0   1    2\n *  <p> <i> </i> </p>                       p.size = 2, i.size = 0\n *\n * In this case, index of TreePos(p, 0) is 0, index of TreePos(p, 1) is 2.\n * Index 1 can be converted to TreePos(i, 0).\n *\n * `path` of crdt.IndexTree represents a position like `index` in crdt.IndexTree.\n * It contains offsets of each node from the root node as elements except the last.\n * The last element of the path represents the position in the parent node.\n *\n * Let's say we have a tree like this:\n *                     0 1 2\n * <p> <i> a b </i> <b> c d </b> </p>\n *\n * The path of the position between 'c' and 'd' is [1, 1]. The first element of the\n * path is the offset of the <b> in <p> and the second element represents the position\n * between 'c' and 'd' in <b>.\n */\n/**\n * `ElementPaddingSize` is the size of an element node as a child of another element node.\n * Because an element node could be considered as a pair of open and close tags.\n */\nconst ElementPaddingSize = 2;\n/**\n * `DefaultRootType` is the default type of the root node.\n * It is used when the type of the root node is not specified.\n */\nconst DefaultRootType = 'root';\n/**\n * `DefaultTextType` is the default type of the text node.\n * It is used when the type of the text node is not specified.\n */\nconst DefaultTextType = 'text';\n/**\n * `addSizeOfLeftSiblings` returns the size of left siblings of the given offset.\n */\nfunction addSizeOfLeftSiblings(parent, offset) {\n    let acc = 0;\n    const siblings = parent.children;\n    for (let i = 0; i < offset; i++) {\n        const leftSibling = siblings[i];\n        if (!leftSibling || leftSibling.isRemoved) {\n            continue;\n        }\n        acc += leftSibling.paddedSize;\n    }\n    return acc;\n}\n/**\n * `IndexTreeNode` is the node of IndexTree. It is used to represent the\n * document of text-based editors.\n */\nclass IndexTreeNode {\n    constructor(type, children = []) {\n        this.type = type;\n        this.size = 0;\n        this._children = children;\n        if (this.isText && this._children.length > 0) {\n            throw new Error(`Text node cannot have children: ${this.type}`);\n        }\n    }\n    /**\n     * `updateAncestorsSize` updates the size of the ancestors.\n     */\n    updateAncestorsSize() {\n        let parent = this.parent;\n        const sign = this.isRemoved ? -1 : 1;\n        while (parent) {\n            parent.size += this.paddedSize * sign;\n            parent = parent.parent;\n        }\n    }\n    /**\n     * `isText` returns true if the node is a text node.\n     */\n    get isText() {\n        // TODO(hackerwins): We need to get the type of text node from user.\n        // Consider the use schema to get the type of text node.\n        return this.type === DefaultTextType;\n    }\n    /**\n     * `paddedSize` returns the size of the node including padding size.\n     */\n    get paddedSize() {\n        return this.size + (this.isText ? 0 : ElementPaddingSize);\n    }\n    /**\n     * `isAncenstorOf` returns true if the node is an ancestor of the given node.\n     */\n    isAncestorOf(node) {\n        return ancestorOf(this, node);\n    }\n    /**\n     * `nextSibling` returns the next sibling of the node.\n     */\n    get nextSibling() {\n        const offset = this.parent.findOffset(this);\n        const sibling = this.parent.children[offset + 1];\n        if (sibling) {\n            return sibling;\n        }\n        return undefined;\n    }\n    /**\n     * `splitText` splits the given node at the given offset.\n     */\n    splitText(offset, absOffset) {\n        if (offset === 0 || offset === this.size) {\n            return;\n        }\n        const leftValue = this.value.slice(0, offset);\n        const rightValue = this.value.slice(offset);\n        if (!rightValue.length) {\n            return;\n        }\n        this.value = leftValue;\n        const rightNode = this.cloneText(offset + absOffset);\n        rightNode.value = rightValue;\n        this.parent.insertAfterInternal(rightNode, this);\n        return rightNode;\n    }\n    /**\n     * `children` returns the children of the node.\n     */\n    get children() {\n        // Tombstone nodes remain awhile in the tree during editing.\n        // They will be removed after the editing is done.\n        // So, we need to filter out the tombstone nodes to get the real children.\n        return this._children.filter((child) => !child.isRemoved);\n    }\n    /**\n     * `allChildren` returns all the children of the node including tombstone nodes.\n     * It returns the shallow copy of the children.\n     */\n    get allChildren() {\n        return [...this._children];\n    }\n    /**\n     * `hasTextChild` returns true if the node has an text child.\n     */\n    hasTextChild() {\n        return this.children.some((child) => child.isText);\n    }\n    /**\n     * `append` appends the given nodes to the children.\n     */\n    append(...newNode) {\n        if (this.isText) {\n            throw new Error('Text node cannot have children');\n        }\n        this._children.push(...newNode);\n        for (const node of newNode) {\n            node.parent = this;\n            node.updateAncestorsSize();\n        }\n    }\n    /**\n     * `prepend` prepends the given nodes to the children.\n     */\n    prepend(...newNode) {\n        if (this.isText) {\n            throw new Error('Text node cannot have children');\n        }\n        this._children.unshift(...newNode);\n        for (const node of newNode) {\n            node.parent = this;\n            if (!node.isRemoved) {\n                node.updateAncestorsSize();\n            }\n        }\n    }\n    /**\n     * `insertBefore` inserts the given node before the given child.\n     */\n    insertBefore(newNode, referenceNode) {\n        if (this.isText) {\n            throw new Error('Text node cannot have children');\n        }\n        const offset = this._children.indexOf(referenceNode);\n        if (offset === -1) {\n            throw new Error('child not found');\n        }\n        this.insertAtInternal(newNode, offset);\n        newNode.updateAncestorsSize();\n    }\n    /**\n     * `insertAfter` inserts the given node after the given child.\n     */\n    insertAfter(newNode, referenceNode) {\n        if (this.isText) {\n            throw new Error('Text node cannot have children');\n        }\n        const offset = this._children.indexOf(referenceNode);\n        if (offset === -1) {\n            throw new Error('child not found');\n        }\n        this.insertAtInternal(newNode, offset + 1);\n        newNode.updateAncestorsSize();\n    }\n    /**\n     * `insertAt` inserts the given node at the given offset.\n     */\n    insertAt(newNode, offset) {\n        if (this.isText) {\n            throw new Error('Text node cannot have children');\n        }\n        this.insertAtInternal(newNode, offset);\n        newNode.updateAncestorsSize();\n    }\n    /**\n     * `removeChild` removes the given child.\n     */\n    removeChild(child) {\n        if (this.isText) {\n            throw new Error('Text node cannot have children');\n        }\n        const offset = this._children.indexOf(child);\n        if (offset === -1) {\n            throw new Error('child not found');\n        }\n        this._children.splice(offset, 1);\n        child.parent = undefined;\n    }\n    /**\n     * `splitElement` splits the given element at the given offset.\n     */\n    splitElement(offset, issueTimeTicket) {\n        /**\n         * TODO(hackerwins): Define ID of split node for concurrent editing.\n         * Text has fixed content and its split nodes could have limited offset\n         * range. But element node could have arbitrary children and its split\n         * nodes could have arbitrary offset range. So, id could be duplicated\n         * and its order could be broken when concurrent editing happens.\n         * Currently, we use the similar ID of split element with the split text.\n         */\n        const clone = this.cloneElement(issueTimeTicket);\n        this.parent.insertAfterInternal(clone, this);\n        clone.updateAncestorsSize();\n        const leftChildren = this.children.slice(0, offset);\n        const rightChildren = this.children.slice(offset);\n        this._children = leftChildren;\n        clone._children = rightChildren;\n        this.size = this._children.reduce((acc, child) => acc + child.paddedSize, 0);\n        clone.size = clone._children.reduce((acc, child) => acc + child.paddedSize, 0);\n        for (const child of clone._children) {\n            child.parent = clone;\n        }\n        return clone;\n    }\n    /**\n     * `insertAfterInternal` inserts the given node after the given child.\n     * This method does not update the size of the ancestors.\n     */\n    insertAfterInternal(newNode, referenceNode) {\n        if (this.isText) {\n            throw new Error('Text node cannot have children');\n        }\n        const offset = this._children.indexOf(referenceNode);\n        if (offset === -1) {\n            throw new Error('child not found');\n        }\n        this.insertAtInternal(newNode, offset + 1);\n    }\n    /**\n     * `insertAtInternal` inserts the given node at the given index.\n     * This method does not update the size of the ancestors.\n     */\n    insertAtInternal(newNode, offset) {\n        if (this.isText) {\n            throw new Error('Text node cannot have children');\n        }\n        this._children.splice(offset, 0, newNode);\n        newNode.parent = this;\n    }\n    /**\n     * findOffset returns the offset of the given node in the children.\n     * It excludes the removed nodes.\n     */\n    findOffset(node) {\n        if (this.isText) {\n            throw new Error('Text node cannot have children');\n        }\n        if (node.isRemoved) {\n            const index = this._children.indexOf(node);\n            // If nodes are removed, the offset of the removed node is the number of\n            // nodes before the node excluding the removed nodes.\n            const refined = this.allChildren\n                .splice(0, index)\n                .filter((node) => !node.isRemoved).length;\n            return refined;\n        }\n        return this.children.indexOf(node);\n    }\n    /**\n     * `findBranchOffset` returns offset of the given descendant node in this node.\n     * If the given node is not a descendant of this node, it returns -1.\n     */\n    findBranchOffset(node) {\n        if (this.isText) {\n            throw new Error('Text node cannot have children');\n        }\n        let current = node;\n        while (current) {\n            const offset = this._children.indexOf(current);\n            if (offset !== -1) {\n                return offset;\n            }\n            current = current.parent;\n        }\n        return -1;\n    }\n}\n/**\n * `ancestorOf` returns true if the given node is an ancestor of the other node.\n */\nfunction ancestorOf(ancestor, node) {\n    if (ancestor === node) {\n        return false;\n    }\n    while (node.parent) {\n        if (node.parent === ancestor) {\n            return true;\n        }\n        node = node.parent;\n    }\n    return false;\n}\n// TagContained represents whether the opening or closing tag of a element is selected.\nvar TagContained;\n(function (TagContained) {\n    // All represents that both opening and closing tag of a element are selected.\n    TagContained[\"All\"] = \"All\";\n    // Opening represents that only the opening tag is selected.\n    TagContained[\"Opening\"] = \"Opening\";\n    // Closing represents that only the closing tag is selected.\n    TagContained[\"Closing\"] = \"Closing\";\n})(TagContained || (TagContained = {}));\n/**\n * `nodesBetween` iterates the nodes between the given range.\n * If the given range is collapsed, the callback is not called.\n * It traverses the tree with postorder traversal.\n * NOTE(sejongk): Nodes should not be removed in callback, because it leads wrong behaviors.\n */\nfunction nodesBetween(root, from, to, callback) {\n    if (from > to) {\n        throw new Error(`from is greater than to: ${from} > ${to}`);\n    }\n    if (from > root.size) {\n        throw new Error(`from is out of range: ${from} > ${root.size}`);\n    }\n    if (to > root.size) {\n        throw new Error(`to is out of range: ${to} > ${root.size}`);\n    }\n    if (from === to) {\n        return;\n    }\n    let pos = 0;\n    for (const child of root.children) {\n        // If the child is an element node, the size of the child.\n        if (from - child.paddedSize < pos && pos < to) {\n            // If the child is an element node, the range of the child\n            // is from - 1 to to - 1. Because the range of the element node is from\n            // the open tag to the close tag.\n            const fromChild = child.isText ? from - pos : from - pos - 1;\n            const toChild = child.isText ? to - pos : to - pos - 1;\n            nodesBetween(child, Math.max(0, fromChild), Math.min(toChild, child.size), callback);\n            // If the range spans outside the child,\n            // the callback is called with the child.\n            if (fromChild < 0 || toChild > child.size || child.isText) {\n                let contain;\n                if ((fromChild < 0 && toChild > child.size) || child.isText) {\n                    contain = TagContained.All;\n                }\n                else if (fromChild < 0) {\n                    contain = TagContained.Opening;\n                }\n                else {\n                    contain = TagContained.Closing;\n                }\n                callback(child, contain);\n            }\n        }\n        pos += child.paddedSize;\n    }\n}\n/**\n * `traverse` traverses the tree with postorder traversal.\n */\nfunction traverse(node, callback, depth = 0) {\n    for (const child of node.children) {\n        traverse(child, callback, depth + 1);\n    }\n    callback(node, depth);\n}\n/**\n * `traverseAll` traverses the whole tree (include tombstones) with postorder traversal.\n */\nfunction traverseAll(node, callback, depth = 0) {\n    for (const child of node._children) {\n        traverseAll(child, callback, depth + 1);\n    }\n    callback(node, depth);\n}\n/**\n * `findTreePos` finds the position of the given index in the given node.\n */\nfunction findTreePos(node, index, preferText = true) {\n    if (index > node.size) {\n        throw new Error(`index is out of range: ${index} > ${node.size}`);\n    }\n    if (node.isText) {\n        return { node, offset: index };\n    }\n    // offset is the index of the child node.\n    // pos is the window of the index in the given node.\n    let offset = 0;\n    let pos = 0;\n    for (const child of node.children) {\n        // The pos is in bothsides of the text node, we should traverse\n        // inside of the text node if preferText is true.\n        if (preferText && child.isText && child.size >= index - pos) {\n            return findTreePos(child, index - pos, preferText);\n        }\n        // The position is in leftside of the element node.\n        if (index === pos) {\n            return { node, offset };\n        }\n        // The position is in rightside of the element node and preferText is false.\n        if (!preferText && child.paddedSize === index - pos) {\n            return { node, offset: offset + 1 };\n        }\n        // The position is in middle the element node.\n        if (child.paddedSize > index - pos) {\n            // If we traverse inside of the element node, we should skip the open.\n            const skipOpenSize = 1;\n            return findTreePos(child, index - pos - skipOpenSize, preferText);\n        }\n        pos += child.paddedSize;\n        offset += 1;\n    }\n    // The position is in rightmost of the given node.\n    return { node, offset };\n}\n/**\n * `getAncestors` returns the ancestors of the given node.\n */\nfunction getAncestors(node) {\n    const ancestors = [];\n    let parent = node.parent;\n    while (parent) {\n        ancestors.unshift(parent);\n        parent = parent.parent;\n    }\n    return ancestors;\n}\n/**\n * `findCommonAncestor` finds the lowest common ancestor of the given nodes.\n */\nfunction findCommonAncestor(nodeA, nodeB) {\n    if (nodeA === nodeB) {\n        return nodeA;\n    }\n    const ancestorsOfA = getAncestors(nodeA);\n    const ancestorsOfB = getAncestors(nodeB);\n    let commonAncestor;\n    for (let i = 0; i < ancestorsOfA.length; i++) {\n        const ancestorOfA = ancestorsOfA[i];\n        const ancestorOfB = ancestorsOfB[i];\n        if (ancestorOfA !== ancestorOfB) {\n            break;\n        }\n        commonAncestor = ancestorOfA;\n    }\n    return commonAncestor;\n}\n/**\n * `findLeftmost` finds the leftmost node of the given tree.\n */\nfunction findLeftmost(node) {\n    if (node.isText || node.children.length === 0) {\n        return node;\n    }\n    return findLeftmost(node.children[0]);\n}\n/**\n * `findTextPos` returns the tree position of the given path element.\n */\nfunction findTextPos(node, pathElement) {\n    if (node.size < pathElement) {\n        throw new Error('unacceptable path');\n    }\n    for (let i = 0; i < node.children.length; i++) {\n        const child = node.children[i];\n        if (child.size < pathElement) {\n            pathElement -= child.size;\n        }\n        else {\n            node = child;\n            break;\n        }\n    }\n    return { node, offset: pathElement };\n}\n/**\n * `IndexTree` is a tree structure for linear indexing.\n */\nclass IndexTree {\n    constructor(root) {\n        this.root = root;\n    }\n    /**\n     * `nodeBetween` returns the nodes between the given range.\n     */\n    nodesBetween(from, to, callback) {\n        nodesBetween(this.root, from, to, callback);\n    }\n    /**\n     * `traverse` traverses the tree with postorder traversal.\n     */\n    traverse(callback) {\n        traverse(this.root, callback, 0);\n    }\n    /**\n     * `traverseAll` traverses the whole tree (include tombstones) with postorder traversal.\n     */\n    traverseAll(callback) {\n        traverseAll(this.root, callback, 0);\n    }\n    /**\n     * findTreePos finds the position of the given index in the tree.\n     */\n    findTreePos(index, preferText = true) {\n        return findTreePos(this.root, index, preferText);\n    }\n    /**\n     * `treePosToPath` returns path from given treePos\n     */\n    treePosToPath(treePos) {\n        const path = [];\n        let node = treePos.node;\n        if (node.isText) {\n            const offset = node.parent.findOffset(node);\n            if (offset === -1) {\n                throw new Error('invalid treePos');\n            }\n            const sizeOfLeftSiblings = addSizeOfLeftSiblings(node.parent, offset);\n            node = node.parent;\n            path.push(sizeOfLeftSiblings + treePos.offset);\n        }\n        else {\n            path.push(treePos.offset);\n        }\n        while (node.parent) {\n            const offset = node.parent.findOffset(node);\n            if (offset === -1) {\n                throw new Error('invalid treePos');\n            }\n            path.push(offset);\n            node = node.parent;\n        }\n        return path.reverse();\n    }\n    /**\n     * `pathToIndex` returns index from given path\n     */\n    pathToIndex(path) {\n        const treePos = this.pathToTreePos(path);\n        return this.indexOf(treePos);\n    }\n    /**\n     * `pathToTreePos` returns treePos from given path\n     */\n    pathToTreePos(path) {\n        if (!path.length) {\n            throw new Error('unacceptable path');\n        }\n        let node = this.root;\n        for (let i = 0; i < path.length - 1; i++) {\n            const pathElement = path[i];\n            node = node.children[pathElement];\n            if (!node) {\n                throw new Error('unacceptable path');\n            }\n        }\n        if (node.hasTextChild()) {\n            return findTextPos(node, path[path.length - 1]);\n        }\n        if (node.children.length < path[path.length - 1]) {\n            throw new Error('unacceptable path');\n        }\n        return {\n            node,\n            offset: path[path.length - 1],\n        };\n    }\n    /**\n     * `getRoot` returns the root node of the tree.\n     */\n    getRoot() {\n        return this.root;\n    }\n    /**\n     * `getSize` returns the size of the tree.\n     */\n    get size() {\n        return this.root.size;\n    }\n    /**\n     * `findPostorderRight` finds right node of the given tree position with\n     *  postorder traversal.\n     */\n    findPostorderRight(treePos) {\n        const { node, offset } = treePos;\n        if (node.isText) {\n            if (node.size === offset) {\n                const nextSibling = node.nextSibling;\n                if (nextSibling) {\n                    return nextSibling;\n                }\n                return node.parent;\n            }\n            return node;\n        }\n        if (node.children.length === offset) {\n            return node;\n        }\n        return findLeftmost(node.children[offset]);\n    }\n    /**\n     * `indexOf` returns the index of the given tree position.\n     */\n    indexOf(pos) {\n        let { node } = pos;\n        const { offset } = pos;\n        let size = 0;\n        let depth = 1;\n        if (node.isText) {\n            size += offset;\n            const parent = node.parent;\n            const offsetOfNode = parent.findOffset(node);\n            if (offsetOfNode === -1) {\n                throw new Error('invalid pos');\n            }\n            size += addSizeOfLeftSiblings(parent, offsetOfNode);\n            node = node.parent;\n        }\n        else {\n            size += addSizeOfLeftSiblings(node, offset);\n        }\n        while (node === null || node === void 0 ? void 0 : node.parent) {\n            const parent = node.parent;\n            const offsetOfNode = parent.findOffset(node);\n            if (offsetOfNode === -1) {\n                throw new Error('invalid pos');\n            }\n            size += addSizeOfLeftSiblings(parent, offsetOfNode);\n            depth++;\n            node = node.parent;\n        }\n        return size + depth - 1;\n    }\n    /**\n     * `indexToPath` returns the path of the given index.\n     */\n    indexToPath(index) {\n        const treePos = this.findTreePos(index);\n        return this.treePosToPath(treePos);\n    }\n}\n\n;// CONCATENATED MODULE: ./src/util/comparator.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nconst DefaultComparator = (a, b) => {\n    if (a === b) {\n        return 0;\n    }\n    else if (a < b) {\n        return -1;\n    }\n    else {\n        return 1;\n    }\n};\n\n;// CONCATENATED MODULE: ./src/util/llrb_tree.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * `LLRBNode` is node of LLRBTree.\n */\nclass LLRBNode {\n    constructor(key, value, isRed) {\n        this.key = key;\n        this.value = value;\n        this.isRed = isRed;\n    }\n}\n/**\n * `SortedMapIterator` is a interator for traversing LLRBTree.\n */\nclass SortedMapIterator {\n    constructor(root) {\n        this.stack = [];\n        this.traverseInorder(root);\n    }\n    // TODO: Replace with iterative approach, if we encounter performance problem.\n    traverseInorder(node) {\n        if (!node) {\n            return;\n        }\n        this.traverseInorder(node.left);\n        this.stack.push({\n            key: node.key,\n            value: node.value,\n        });\n        this.traverseInorder(node.right);\n    }\n}\n/**\n * LLRBTree is an implementation of Left-learning Red-Black Tree.\n *\n * Original paper on Left-leaning Red-Black Trees:\n * @see http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf\n *\n * Invariant 1: No red node has a red child\n * Invariant 2: Every leaf path has the same number of black nodes\n * Invariant 3: Only the left child can be red (left leaning)\n */\nclass LLRBTree {\n    constructor(comparator) {\n        this.comparator =\n            typeof comparator !== 'undefined' ? comparator : DefaultComparator;\n        this.counter = 0;\n    }\n    /**\n     * `put` puts the value of the given key.\n     */\n    put(key, value) {\n        this.root = this.putInternal(key, value, this.root);\n        this.root.isRed = false;\n        return value;\n    }\n    /**\n     * `get` gets a value of the given key.\n     */\n    get(key) {\n        const node = this.getInternal(key, this.root);\n        return node ? node.value : undefined;\n    }\n    /**\n     * `remove` removes a element of key.\n     */\n    remove(key) {\n        if (!this.isRed(this.root.left) && !this.isRed(this.root.right)) {\n            this.root.isRed = true;\n        }\n        this.root = this.removeInternal(this.root, key);\n        if (this.root) {\n            this.root.isRed = false;\n        }\n    }\n    /**\n     * `getIterator` returns a new instance of SortedMapIterator.\n     */\n    getIterator() {\n        return new SortedMapIterator(this.root);\n    }\n    /**\n     * `values` returns value array of LLRBTree.\n     */\n    values() {\n        const values = [];\n        for (const entry of this.getIterator().stack) {\n            values.push(entry.value);\n        }\n        return values;\n    }\n    /**\n     * `floorEntry` returns the entry for the greatest key less than or equal to the\n     *  given key. If there is no such key, returns `undefined`.\n     */\n    floorEntry(key) {\n        let node = this.root;\n        while (node) {\n            const compare = this.comparator(key, node.key);\n            if (compare > 0) {\n                if (node.right) {\n                    node.right.parent = node;\n                    node = node.right;\n                }\n                else {\n                    return node;\n                }\n            }\n            else if (compare < 0) {\n                if (node.left) {\n                    node.left.parent = node;\n                    node = node.left;\n                }\n                else {\n                    let parent = node.parent;\n                    let childNode = node;\n                    while (parent && childNode === parent.left) {\n                        childNode = parent;\n                        parent = parent.parent;\n                    }\n                    return parent;\n                }\n            }\n            else {\n                return node;\n            }\n        }\n        return;\n    }\n    /**\n     * `lastEntry` returns last entry of LLRBTree.\n     */\n    lastEntry() {\n        if (!this.root) {\n            return this.root;\n        }\n        let node = this.root;\n        while (node.right) {\n            node = node.right;\n        }\n        return node;\n    }\n    /**\n     * `size` is a size of LLRBTree.\n     */\n    size() {\n        return this.counter;\n    }\n    /**\n     * `isEmpty` checks if size is empty.\n     */\n    isEmpty() {\n        return this.counter === 0;\n    }\n    getInternal(key, node) {\n        while (node) {\n            const compare = this.comparator(key, node.key);\n            if (compare === 0) {\n                return node;\n            }\n            else if (compare < 0) {\n                node = node.left;\n            }\n            else if (compare > 0) {\n                node = node.right;\n            }\n        }\n        return;\n    }\n    putInternal(key, value, node) {\n        if (!node) {\n            this.counter += 1;\n            return new LLRBNode(key, value, true);\n        }\n        const compare = this.comparator(key, node.key);\n        if (compare < 0) {\n            node.left = this.putInternal(key, value, node.left);\n        }\n        else if (compare > 0) {\n            node.right = this.putInternal(key, value, node.right);\n        }\n        else {\n            node.value = value;\n        }\n        if (this.isRed(node.right) && !this.isRed(node.left)) {\n            node = this.rotateLeft(node);\n        }\n        if (this.isRed(node.left) && this.isRed(node.left.left)) {\n            node = this.rotateRight(node);\n        }\n        if (this.isRed(node.left) && this.isRed(node.right)) {\n            this.flipColors(node);\n        }\n        return node;\n    }\n    removeInternal(node, key) {\n        if (this.comparator(key, node.key) < 0) {\n            if (!this.isRed(node.left) && !this.isRed(node.left.left)) {\n                node = this.moveRedLeft(node);\n            }\n            node.left = this.removeInternal(node.left, key);\n        }\n        else {\n            if (this.isRed(node.left)) {\n                node = this.rotateRight(node);\n            }\n            if (this.comparator(key, node.key) === 0 && !node.right) {\n                this.counter -= 1;\n                return;\n            }\n            if (!this.isRed(node.right) && !this.isRed(node.right.left)) {\n                node = this.moveRedRight(node);\n            }\n            if (this.comparator(key, node.key) === 0) {\n                this.counter -= 1;\n                const smallest = this.min(node.right);\n                node.value = smallest.value;\n                node.key = smallest.key;\n                node.right = this.removeMin(node.right);\n            }\n            else {\n                node.right = this.removeInternal(node.right, key);\n            }\n        }\n        return this.fixUp(node);\n    }\n    min(node) {\n        if (!node.left) {\n            return node;\n        }\n        else {\n            return this.min(node.left);\n        }\n    }\n    removeMin(node) {\n        if (!node.left) {\n            return;\n        }\n        if (!this.isRed(node.left) && !this.isRed(node.left.left)) {\n            node = this.moveRedLeft(node);\n        }\n        node.left = this.removeMin(node.left);\n        return this.fixUp(node);\n    }\n    fixUp(node) {\n        if (this.isRed(node.right)) {\n            node = this.rotateLeft(node);\n        }\n        if (this.isRed(node.left) && this.isRed(node.left.left)) {\n            node = this.rotateRight(node);\n        }\n        if (this.isRed(node.left) && this.isRed(node.right)) {\n            this.flipColors(node);\n        }\n        return node;\n    }\n    moveRedLeft(node) {\n        this.flipColors(node);\n        if (this.isRed(node.right.left)) {\n            node.right = this.rotateRight(node.right);\n            node = this.rotateLeft(node);\n            this.flipColors(node);\n        }\n        return node;\n    }\n    moveRedRight(node) {\n        this.flipColors(node);\n        if (this.isRed(node.left.left)) {\n            node = this.rotateRight(node);\n            this.flipColors(node);\n        }\n        return node;\n    }\n    isRed(node) {\n        return node && node.isRed;\n    }\n    rotateLeft(node) {\n        const x = node.right;\n        node.right = x.left;\n        x.left = node;\n        x.isRed = x.left.isRed;\n        x.left.isRed = true;\n        return x;\n    }\n    rotateRight(node) {\n        const x = node.left;\n        node.left = x.right;\n        x.right = node;\n        x.isRed = x.right.isRed;\n        x.right.isRed = true;\n        return x;\n    }\n    flipColors(node) {\n        node.isRed = !node.isRed;\n        node.left.isRed = !node.left.isRed;\n        node.right.isRed = !node.right.isRed;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/crdt/tree.ts\n/*\n * Copyright 2023 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n/**\n * `TreeChangeType` represents the type of change in the tree.\n */\nvar TreeChangeType;\n(function (TreeChangeType) {\n    TreeChangeType[\"Content\"] = \"content\";\n    TreeChangeType[\"Style\"] = \"style\";\n})(TreeChangeType || (TreeChangeType = {}));\n/**\n * `CRDTTreePos` represent a position in the tree. It is used to identify a\n * position in the tree. It is composed of the parent ID and the left sibling\n * ID. If there's no left sibling in parent's children, then left sibling is\n * parent.\n */\nclass CRDTTreePos {\n    constructor(parentID, leftSiblingID) {\n        this.parentID = parentID;\n        this.leftSiblingID = leftSiblingID;\n    }\n    /**\n     * `of` creates a new instance of CRDTTreePos.\n     */\n    static of(parentID, leftSiblingID) {\n        return new CRDTTreePos(parentID, leftSiblingID);\n    }\n    /**\n     * `fromTreePos` creates a new instance of CRDTTreePos from the given TreePos.\n     */\n    static fromTreePos(pos) {\n        const { offset } = pos;\n        let { node } = pos;\n        let leftNode;\n        if (node.isText) {\n            if (node.parent.children[0] === node && offset === 0) {\n                leftNode = node.parent;\n            }\n            else {\n                leftNode = node;\n            }\n            node = node.parent;\n        }\n        else {\n            if (offset === 0) {\n                leftNode = node;\n            }\n            else {\n                leftNode = node.children[offset - 1];\n            }\n        }\n        return CRDTTreePos.of(node.id, CRDTTreeNodeID.of(leftNode.getCreatedAt(), leftNode.getOffset() + offset));\n    }\n    /**\n     * `getParentID` returns the parent ID.\n     */\n    getParentID() {\n        return this.parentID;\n    }\n    /**\n     * `fromStruct` creates a new instance of CRDTTreeNodeID from the given struct.\n     */\n    static fromStruct(struct) {\n        return CRDTTreePos.of(CRDTTreeNodeID.of(TimeTicket.fromStruct(struct.parentID.createdAt), struct.parentID.offset), CRDTTreeNodeID.of(TimeTicket.fromStruct(struct.leftSiblingID.createdAt), struct.leftSiblingID.offset));\n    }\n    /**\n     * `toStruct` returns the structure of this position.\n     */\n    toStruct() {\n        return {\n            parentID: {\n                createdAt: this.getParentID().getCreatedAt().toStruct(),\n                offset: this.getParentID().getOffset(),\n            },\n            leftSiblingID: {\n                createdAt: this.getLeftSiblingID().getCreatedAt().toStruct(),\n                offset: this.getLeftSiblingID().getOffset(),\n            },\n        };\n    }\n    /**\n     * `toTreeNodes` converts the pos to parent and left sibling nodes.\n     * If the position points to the middle of a node, then the left sibling node\n     * is the node that contains the position. Otherwise, the left sibling node is\n     * the node that is located at the left of the position.\n     */\n    toTreeNodes(tree) {\n        const parentID = this.getParentID();\n        const leftSiblingID = this.getLeftSiblingID();\n        const parentNode = tree.findFloorNode(parentID);\n        let leftNode = tree.findFloorNode(leftSiblingID);\n        if (!parentNode || !leftNode) {\n            throw new Error(`cannot find node at ${this}`);\n        }\n        /**\n         * NOTE(hackerwins): If the left node and the parent node are the same,\n         * it means that the position is the left-most of the parent node.\n         * We need to skip finding the left of the position.\n         */\n        if (!leftSiblingID.equals(parentID) &&\n            leftSiblingID.getOffset() > 0 &&\n            leftSiblingID.getOffset() === leftNode.id.getOffset() &&\n            leftNode.insPrevID) {\n            leftNode = tree.findFloorNode(leftNode.insPrevID);\n        }\n        return [parentNode, leftNode];\n    }\n    /**\n     * `getLeftSiblingID` returns the left sibling ID.\n     */\n    getLeftSiblingID() {\n        return this.leftSiblingID;\n    }\n    /**\n     * `equals` returns whether the given pos equals to this or not.\n     */\n    equals(other) {\n        return (this.getParentID()\n            .getCreatedAt()\n            .equals(other.getParentID().getCreatedAt()) &&\n            this.getParentID().getOffset() === other.getParentID().getOffset() &&\n            this.getLeftSiblingID()\n                .getCreatedAt()\n                .equals(other.getLeftSiblingID().getCreatedAt()) &&\n            this.getLeftSiblingID().getOffset() ===\n                other.getLeftSiblingID().getOffset());\n    }\n}\n/**\n * `CRDTTreeNodeID` represent an ID of a node in the tree. It is used to\n * identify a node in the tree. It is composed of the creation time of the node\n * and the offset from the beginning of the node if the node is split.\n *\n * Some of replicas may have nodes that are not split yet. In this case, we can\n * use `map.floorEntry()` to find the adjacent node.\n */\nclass CRDTTreeNodeID {\n    constructor(createdAt, offset) {\n        this.createdAt = createdAt;\n        this.offset = offset;\n    }\n    /**\n     * `of` creates a new instance of CRDTTreeNodeID.\n     */\n    static of(createdAt, offset) {\n        return new CRDTTreeNodeID(createdAt, offset);\n    }\n    /**\n     * `fromStruct` creates a new instance of CRDTTreeNodeID from the given struct.\n     */\n    static fromStruct(struct) {\n        return CRDTTreeNodeID.of(TimeTicket.fromStruct(struct.createdAt), struct.offset);\n    }\n    /**\n     * `createComparator` creates a comparator for CRDTTreeNodeID.\n     */\n    static createComparator() {\n        return (idA, idB) => {\n            const compare = idA.getCreatedAt().compare(idB.getCreatedAt());\n            if (compare !== 0) {\n                return compare;\n            }\n            if (idA.getOffset() > idB.getOffset()) {\n                return 1;\n            }\n            else if (idA.getOffset() < idB.getOffset()) {\n                return -1;\n            }\n            return 0;\n        };\n    }\n    /**\n     * `getCreatedAt` returns the creation time of the node.\n     */\n    getCreatedAt() {\n        return this.createdAt;\n    }\n    /**\n     * `equals` returns whether given ID equals to this ID or not.\n     */\n    equals(other) {\n        return (this.createdAt.compare(other.createdAt) === 0 &&\n            this.offset === other.offset);\n    }\n    /**\n     * `getOffset` returns returns the offset of the node.\n     */\n    getOffset() {\n        return this.offset;\n    }\n    /**\n     * `setOffset` sets the offset of the node.\n     */\n    setOffset(offset) {\n        this.offset = offset;\n    }\n    /**\n     * `toStruct` returns the structure of this position.\n     */\n    toStruct() {\n        return {\n            createdAt: this.createdAt.toStruct(),\n            offset: this.offset,\n        };\n    }\n    /**\n     * `toIDString` returns a string that can be used as an ID for this position.\n     */\n    toIDString() {\n        return `${this.createdAt.toIDString()}:${this.offset}`;\n    }\n}\n/**\n * `CRDTTreeNode` is a node of CRDTTree. It is includes the logical clock and\n * links to other nodes to resolve conflicts.\n */\nclass CRDTTreeNode extends IndexTreeNode {\n    constructor(id, type, opts, attributes, removedAt) {\n        super(type);\n        this._value = '';\n        this.id = id;\n        this.removedAt = removedAt;\n        attributes && (this.attrs = attributes);\n        if (typeof opts === 'string') {\n            this.value = opts;\n        }\n        else if (Array.isArray(opts)) {\n            this._children = opts;\n        }\n    }\n    /**\n     * `create` creates a new instance of CRDTTreeNode.\n     */\n    static create(id, type, opts, attributes) {\n        return new CRDTTreeNode(id, type, opts, attributes);\n    }\n    /**\n     * `deepcopy` copies itself deeply.\n     */\n    deepcopy() {\n        var _a;\n        const clone = new CRDTTreeNode(this.id, this.type);\n        clone.removedAt = this.removedAt;\n        clone._value = this._value;\n        clone.size = this.size;\n        clone.attrs = (_a = this.attrs) === null || _a === void 0 ? void 0 : _a.deepcopy();\n        clone._children = this._children.map((child) => {\n            const childClone = child.deepcopy();\n            childClone.parent = clone;\n            return childClone;\n        });\n        return clone;\n    }\n    /**\n     * `value` returns the value of the node.\n     */\n    get value() {\n        if (!this.isText) {\n            throw new Error(`cannot get value of element node: ${this.type}`);\n        }\n        return this._value;\n    }\n    /**\n     * `value` sets the value of the node.\n     */\n    set value(v) {\n        if (!this.isText) {\n            throw new Error(`cannot set value of element node: ${this.type}`);\n        }\n        this._value = v;\n        this.size = v.length;\n    }\n    /**\n     * `isRemoved` returns whether the node is removed or not.\n     */\n    get isRemoved() {\n        return !!this.removedAt;\n    }\n    /**\n     * `remove` marks the node as removed.\n     */\n    remove(removedAt) {\n        const alived = !this.removedAt;\n        if (!this.removedAt || this.removedAt.compare(removedAt) > 0) {\n            this.removedAt = removedAt;\n        }\n        if (alived) {\n            this.updateAncestorsSize();\n        }\n    }\n    /**\n     * `cloneText` clones this text node with the given offset.\n     */\n    cloneText(offset) {\n        return new CRDTTreeNode(CRDTTreeNodeID.of(this.id.getCreatedAt(), offset), this.type, undefined, undefined, this.removedAt);\n    }\n    /**\n     * `cloneElement` clones this element node with the given issueTimeTicket function.\n     */\n    cloneElement(issueTimeTicket) {\n        return new CRDTTreeNode(CRDTTreeNodeID.of(issueTimeTicket(), 0), this.type, undefined, undefined, this.removedAt);\n    }\n    /**\n     * `split` splits the given offset of this node.\n     */\n    split(tree, offset, issueTimeTicket) {\n        const split = this.isText\n            ? this.splitText(offset, this.id.getOffset())\n            : this.splitElement(offset, issueTimeTicket);\n        if (split) {\n            split.insPrevID = this.id;\n            if (this.insNextID) {\n                const insNext = tree.findFloorNode(this.insNextID);\n                insNext.insPrevID = split.id;\n                split.insNextID = this.insNextID;\n            }\n            this.insNextID = split.id;\n            tree.registerNode(split);\n        }\n        return split;\n    }\n    /**\n     * `getCreatedAt` returns the creation time of this element.\n     */\n    getCreatedAt() {\n        return this.id.getCreatedAt();\n    }\n    /**\n     * `getOffset` returns the offset of a pos.\n     */\n    getOffset() {\n        return this.id.getOffset();\n    }\n    /**\n     * `canDelete` checks if node is able to delete.\n     */\n    canDelete(editedAt, latestCreatedAt) {\n        return (!this.getCreatedAt().after(latestCreatedAt) &&\n            (!this.removedAt || editedAt.after(this.removedAt)));\n    }\n}\n/**\n * toTreeNode converts the given CRDTTreeNode to TreeNode.\n */\nfunction toTreeNode(node) {\n    var _a;\n    if (node.isText) {\n        const currentNode = node;\n        return {\n            type: currentNode.type,\n            value: currentNode.value,\n        };\n    }\n    return {\n        type: node.type,\n        children: node.children.map(toTreeNode),\n        attributes: node.attrs\n            ? parseObjectValues((_a = node.attrs) === null || _a === void 0 ? void 0 : _a.toObject())\n            : undefined,\n    };\n}\n/**\n * toXML converts the given CRDTNode to XML string.\n */\nfunction toXML(node) {\n    var _a;\n    if (node.isText) {\n        const currentNode = node;\n        return currentNode.value;\n    }\n    return `<${node.type}${((_a = node.attrs) === null || _a === void 0 ? void 0 : _a.toXML()) || ''}>${node.children\n        .map((child) => toXML(child))\n        .join('')}</${node.type}>`;\n}\n/**\n * `toTestTreeNode` converts the given CRDTNode JSON for debugging.\n */\nfunction toTestTreeNode(node) {\n    if (node.isText) {\n        const currentNode = node;\n        return {\n            type: currentNode.type,\n            value: currentNode.value,\n            size: currentNode.size,\n            isRemoved: currentNode.isRemoved,\n        };\n    }\n    return {\n        type: node.type,\n        children: node.children.map(toTestTreeNode),\n        size: node.size,\n        isRemoved: node.isRemoved,\n    };\n}\n/**\n * `CRDTTree` is a CRDT implementation of a tree.\n */\nclass CRDTTree extends CRDTGCElement {\n    constructor(root, createdAt) {\n        super(createdAt);\n        this.indexTree = new IndexTree(root);\n        this.nodeMapByID = new LLRBTree(CRDTTreeNodeID.createComparator());\n        this.removedNodeMap = new Map();\n        this.indexTree.traverse((node) => {\n            this.nodeMapByID.put(node.id, node);\n        });\n    }\n    /**\n     * `create` creates a new instance of `CRDTTree`.\n     */\n    static create(root, ticket) {\n        return new CRDTTree(root, ticket);\n    }\n    /**\n     * `findFloorNode` finds node of given id.\n     */\n    findFloorNode(id) {\n        const entry = this.nodeMapByID.floorEntry(id);\n        if (!entry || !entry.key.getCreatedAt().equals(id.getCreatedAt())) {\n            return;\n        }\n        return entry.value;\n    }\n    /**\n     * `registerNode` registers the given node to the tree.\n     */\n    registerNode(node) {\n        this.nodeMapByID.put(node.id, node);\n    }\n    /**\n     * `findNodesAndSplitText` finds `TreePos` of the given `CRDTTreeNodeID` and\n     * splits nodes if the position is in the middle of a text node.\n     *\n     * The ids of the given `pos` are the ids of the node in the CRDT perspective.\n     * This is different from `TreePos` which is a position of the tree in the\n     * physical perspective.\n     */\n    findNodesAndSplitText(pos, editedAt) {\n        // 01. Find the parent and left sibling node of the given position.\n        const [parent, leftSibling] = pos.toTreeNodes(this);\n        let leftNode = leftSibling;\n        // 02. Determine whether the position is left-most and the exact parent\n        // in the current tree.\n        const isLeftMost = parent === leftNode;\n        const realParent = leftNode.parent && !isLeftMost ? leftNode.parent : parent;\n        // 03. Split text node if the left node is a text node.\n        if (leftNode.isText) {\n            leftNode.split(this, pos.getLeftSiblingID().getOffset() - leftNode.id.getOffset());\n        }\n        // 04. Find the appropriate left node. If some nodes are inserted at the\n        // same position concurrently, then we need to find the appropriate left\n        // node. This is similar to RGA.\n        const allChildren = realParent.allChildren;\n        const index = isLeftMost ? 0 : allChildren.indexOf(leftNode) + 1;\n        for (let i = index; i < parent.allChildren.length; i++) {\n            const next = allChildren[i];\n            if (!next.id.getCreatedAt().after(editedAt)) {\n                break;\n            }\n            leftNode = next;\n        }\n        return [realParent, leftNode];\n    }\n    /**\n     * `style` applies the given attributes of the given range.\n     */\n    style(range, attributes, editedAt) {\n        const [fromParent, fromLeft] = this.findNodesAndSplitText(range[0], editedAt);\n        const [toParent, toLeft] = this.findNodesAndSplitText(range[1], editedAt);\n        const changes = [];\n        changes.push({\n            type: TreeChangeType.Style,\n            from: this.toIndex(fromParent, fromLeft),\n            to: this.toIndex(toParent, toLeft),\n            fromPath: this.toPath(fromParent, fromLeft),\n            toPath: this.toPath(toParent, toLeft),\n            actor: editedAt.getActorID(),\n            value: attributes ? parseObjectValues(attributes) : undefined,\n        });\n        this.traverseInPosRange(fromParent, fromLeft, toParent, toLeft, (node) => {\n            if (!node.isRemoved && !node.isText && attributes) {\n                if (!node.attrs) {\n                    node.attrs = new RHT();\n                }\n                for (const [key, value] of Object.entries(attributes)) {\n                    node.attrs.set(key, value, editedAt);\n                }\n            }\n        });\n        return changes;\n    }\n    /**\n     * `edit` edits the tree with the given range and content.\n     * If the content is undefined, the range will be removed.\n     */\n    edit(range, contents, splitLevel, editedAt, issueTimeTicket, latestCreatedAtMapByActor) {\n        // 01. find nodes from the given range and split nodes.\n        const [fromParent, fromLeft] = this.findNodesAndSplitText(range[0], editedAt);\n        const [toParent, toLeft] = this.findNodesAndSplitText(range[1], editedAt);\n        const toBeRemoveds = [];\n        const toBeMovedToFromParents = [];\n        const latestCreatedAtMap = new Map();\n        this.traverseInPosRange(fromParent, fromLeft, toParent, toLeft, (node, contain) => {\n            // NOTE(hackerwins): If the node overlaps as a closing tag with the\n            // range then we need to keep the node.\n            if (!node.isText && contain == TagContained.Closing) {\n                return;\n            }\n            // NOTE(hackerwins): If the node overlaps as an opening tag with the\n            // range then we need to move the remaining children to fromParent.\n            if (!node.isText && contain == TagContained.Opening) {\n                // TODO(hackerwins): Define more clearly merge-able rules\n                // between two parents. For now, we only merge two parents are\n                // both element nodes having text children.\n                // e.g. <p>a|b</p><p>c|d</p> -> <p>a|d</p>\n                // if (!fromParent.hasTextChild() || !toParent.hasTextChild()) {\n                //   return;\n                // }\n                for (const child of node.children) {\n                    if (toBeRemoveds.includes(child)) {\n                        continue;\n                    }\n                    toBeMovedToFromParents.push(child);\n                }\n            }\n            const actorID = node.getCreatedAt().getActorID();\n            const latestCreatedAt = latestCreatedAtMapByActor\n                ? latestCreatedAtMapByActor.has(actorID)\n                    ? latestCreatedAtMapByActor.get(actorID)\n                    : InitialTimeTicket\n                : MaxTimeTicket;\n            if (node.canDelete(editedAt, latestCreatedAt)) {\n                const latestCreatedAt = latestCreatedAtMap.get(actorID);\n                const createdAt = node.getCreatedAt();\n                if (!latestCreatedAt || createdAt.after(latestCreatedAt)) {\n                    latestCreatedAtMap.set(actorID, createdAt);\n                }\n                toBeRemoveds.push(node);\n            }\n        });\n        // TODO(hackerwins): If concurrent deletion happens, we need to seperate the\n        // range(from, to) into multiple ranges.\n        const changes = [];\n        changes.push({\n            type: TreeChangeType.Content,\n            from: this.toIndex(fromParent, fromLeft),\n            to: this.toIndex(toParent, toLeft),\n            fromPath: this.toPath(fromParent, fromLeft),\n            toPath: this.toPath(toParent, toLeft),\n            actor: editedAt.getActorID(),\n            value: (contents === null || contents === void 0 ? void 0 : contents.length)\n                ? contents.map((content) => toTreeNode(content))\n                : undefined,\n            splitLevel,\n        });\n        // 02. Delete: delete the nodes that are marked as removed.\n        for (const node of toBeRemoveds) {\n            node.remove(editedAt);\n            if (node.isRemoved) {\n                this.removedNodeMap.set(node.id.toIDString(), node);\n            }\n        }\n        // 03. Merge: move the nodes that are marked as moved.\n        for (const node of toBeMovedToFromParents) {\n            fromParent.append(node);\n        }\n        // 04. Split: split the element nodes for the given split level.\n        if (splitLevel > 0) {\n            let splitCount = 0;\n            let parent = fromParent;\n            let left = fromLeft;\n            while (splitCount < splitLevel) {\n                parent.split(this, parent.findOffset(left) + 1, issueTimeTicket);\n                left = parent;\n                parent = parent.parent;\n                splitCount++;\n            }\n        }\n        // 05. Insert: insert the given nodes at the given position.\n        if (contents === null || contents === void 0 ? void 0 : contents.length) {\n            let leftInChildren = fromLeft; // tree\n            for (const content of contents) {\n                // 05-1. Insert the content nodes to the tree.\n                if (leftInChildren === fromParent) {\n                    // 05-1-1. when there's no leftSibling, then insert content into very front of parent's children.\n                    fromParent.insertAt(content, 0);\n                }\n                else {\n                    // 05-1-2. insert after leftSibling\n                    fromParent.insertAfter(content, leftInChildren);\n                }\n                leftInChildren = content;\n                traverseAll(content, (node) => {\n                    // If insertion happens during concurrent editing and parent node has been removed,\n                    // make new nodes as tombstone immediately.\n                    if (fromParent.isRemoved) {\n                        node.remove(editedAt);\n                        this.removedNodeMap.set(node.id.toIDString(), node);\n                    }\n                    this.nodeMapByID.put(node.id, node);\n                });\n            }\n        }\n        return [changes, latestCreatedAtMap];\n    }\n    /**\n     * `editT` edits the given range with the given value.\n     * This method uses indexes instead of a pair of TreePos for testing.\n     */\n    editT(range, contents, splitLevel, editedAt, issueTimeTicket) {\n        const fromPos = this.findPos(range[0]);\n        const toPos = this.findPos(range[1]);\n        this.edit([fromPos, toPos], contents, splitLevel, editedAt, issueTimeTicket);\n    }\n    /**\n     * `move` move the given source range to the given target range.\n     */\n    move(target, source, ticket) {\n        // TODO(hackerwins, easylogic): Implement this with keeping references of the nodes.\n        throw new Error(`not implemented: ${target}, ${source}, ${ticket}`);\n    }\n    /**\n     * `purgeRemovedNodesBefore` physically purges nodes that have been removed.\n     */\n    purgeRemovedNodesBefore(ticket) {\n        var _a;\n        const nodesToBeRemoved = new Set();\n        let count = 0;\n        for (const [, node] of this.removedNodeMap) {\n            if (node.removedAt && ticket.compare(node.removedAt) >= 0) {\n                nodesToBeRemoved.add(node);\n                count++;\n            }\n        }\n        for (const node of nodesToBeRemoved) {\n            (_a = node.parent) === null || _a === void 0 ? void 0 : _a.removeChild(node);\n            this.nodeMapByID.remove(node.id);\n            this.purge(node);\n            this.removedNodeMap.delete(node.id.toIDString());\n        }\n        return count;\n    }\n    /**\n     * `purge` physically purges the given node from RGATreeSplit.\n     */\n    purge(node) {\n        const insPrevID = node.insPrevID;\n        const insNextID = node.insNextID;\n        if (insPrevID) {\n            const insPrev = this.findFloorNode(insPrevID);\n            insPrev.insNextID = insNextID;\n        }\n        if (insNextID) {\n            const insNext = this.findFloorNode(insNextID);\n            insNext.insPrevID = insPrevID;\n        }\n        node.insPrevID = undefined;\n        node.insNextID = undefined;\n    }\n    /**\n     * `findPos` finds the position of the given index in the tree.\n     */\n    findPos(index, preferText = true) {\n        const treePos = this.indexTree.findTreePos(index, preferText);\n        return CRDTTreePos.fromTreePos(treePos);\n    }\n    /**\n     * `getRemovedNodesLen` returns size of removed nodes.\n     */\n    getRemovedNodesLen() {\n        return this.removedNodeMap.size;\n    }\n    /**\n     * `pathToPosRange` converts the given path of the node to the range of the position.\n     */\n    pathToPosRange(path) {\n        const fromIdx = this.pathToIndex(path);\n        return [this.findPos(fromIdx), this.findPos(fromIdx + 1)];\n    }\n    /**\n     * `pathToPos` finds the position of the given index in the tree by path.\n     */\n    pathToPos(path) {\n        const index = this.indexTree.pathToIndex(path);\n        return this.findPos(index);\n    }\n    /**\n     * `getRoot` returns the root node of the tree.\n     */\n    getRoot() {\n        return this.indexTree.getRoot();\n    }\n    /**\n     * `getSize` returns the size of the tree.\n     */\n    getSize() {\n        return this.indexTree.size;\n    }\n    /**\n     * `getIndexTree` returns the index tree.\n     */\n    getIndexTree() {\n        return this.indexTree;\n    }\n    /**\n     * toXML returns the XML encoding of this tree.\n     */\n    toXML() {\n        return toXML(this.indexTree.getRoot());\n    }\n    /**\n     * `toJSON` returns the JSON encoding of this tree.\n     */\n    toJSON() {\n        return JSON.stringify(this.getRootTreeNode());\n    }\n    /**\n     * `toJSForTest` returns value with meta data for testing.\n     */\n    toJSForTest() {\n        return {\n            id: this.getCreatedAt().toTestString(),\n            value: JSON.parse(this.toJSON()),\n            type: 'YORKIE_TREE',\n        };\n    }\n    /**\n     * `getRootTreeNode` returns the converted value of this tree to TreeNode.\n     */\n    getRootTreeNode() {\n        return toTreeNode(this.indexTree.getRoot());\n    }\n    /**\n     * `toTestTreeNode` returns the JSON of this tree for debugging.\n     */\n    toTestTreeNode() {\n        return toTestTreeNode(this.indexTree.getRoot());\n    }\n    /**\n     * `toSortedJSON` returns the sorted JSON encoding of this tree.\n     */\n    toSortedJSON() {\n        return this.toJSON();\n    }\n    /**\n     * `deepcopy` copies itself deeply.\n     */\n    deepcopy() {\n        const root = this.getRoot();\n        return new CRDTTree(root.deepcopy(), this.getCreatedAt());\n    }\n    /**\n     * `toPath` converts the given CRDTTreeNodeID to the path of the tree.\n     */\n    toPath(parentNode, leftNode) {\n        const treePos = this.toTreePos(parentNode, leftNode);\n        if (!treePos) {\n            return [];\n        }\n        return this.indexTree.treePosToPath(treePos);\n    }\n    /**\n     * `toIndex` converts the given CRDTTreeNodeID to the index of the tree.\n     */\n    toIndex(parentNode, leftNode) {\n        const treePos = this.toTreePos(parentNode, leftNode);\n        if (!treePos) {\n            return -1;\n        }\n        return this.indexTree.indexOf(treePos);\n    }\n    /**\n     * `indexToPath` converts the given tree index to path.\n     */\n    indexToPath(index) {\n        return this.indexTree.indexToPath(index);\n    }\n    /**\n     * `pathToIndex` converts the given path to index.\n     */\n    pathToIndex(path) {\n        return this.indexTree.pathToIndex(path);\n    }\n    /**\n     * `indexRangeToPosRange` returns the position range from the given index range.\n     */\n    indexRangeToPosRange(range) {\n        const fromPos = this.findPos(range[0]);\n        if (range[0] === range[1]) {\n            return [fromPos, fromPos];\n        }\n        return [fromPos, this.findPos(range[1])];\n    }\n    /**\n     * `indexRangeToPosStructRange` converts the integer index range into the Tree position range structure.\n     */\n    indexRangeToPosStructRange(range) {\n        const [fromIdx, toIdx] = range;\n        const fromPos = this.findPos(fromIdx);\n        if (fromIdx === toIdx) {\n            return [fromPos.toStruct(), fromPos.toStruct()];\n        }\n        return [fromPos.toStruct(), this.findPos(toIdx).toStruct()];\n    }\n    /**\n     * `posRangeToPathRange` converts the given position range to the path range.\n     */\n    posRangeToPathRange(range, timeTicket) {\n        const [fromParent, fromLeft] = this.findNodesAndSplitText(range[0], timeTicket);\n        const [toParent, toLeft] = this.findNodesAndSplitText(range[1], timeTicket);\n        return [this.toPath(fromParent, fromLeft), this.toPath(toParent, toLeft)];\n    }\n    /**\n     * `posRangeToIndexRange` converts the given position range to the path range.\n     */\n    posRangeToIndexRange(range, timeTicket) {\n        const [fromParent, fromLeft] = this.findNodesAndSplitText(range[0], timeTicket);\n        const [toParent, toLeft] = this.findNodesAndSplitText(range[1], timeTicket);\n        return [this.toIndex(fromParent, fromLeft), this.toIndex(toParent, toLeft)];\n    }\n    /**\n     * `traverseInPosRange` traverses the tree in the given position range.\n     */\n    traverseInPosRange(fromParent, fromLeft, toParent, toLeft, callback) {\n        const fromIdx = this.toIndex(fromParent, fromLeft);\n        const toIdx = this.toIndex(toParent, toLeft);\n        return this.indexTree.nodesBetween(fromIdx, toIdx, callback);\n    }\n    /**\n     * `toTreePos` converts the given nodes to the position of the IndexTree.\n     */\n    toTreePos(parentNode, leftNode) {\n        if (!parentNode || !leftNode) {\n            return;\n        }\n        if (parentNode.isRemoved) {\n            let childNode;\n            while (parentNode.isRemoved) {\n                childNode = parentNode;\n                parentNode = childNode.parent;\n            }\n            const offset = parentNode.findOffset(childNode);\n            return {\n                node: parentNode,\n                offset,\n            };\n        }\n        if (parentNode === leftNode) {\n            return {\n                node: parentNode,\n                offset: 0,\n            };\n        }\n        let offset = parentNode.findOffset(leftNode);\n        if (!leftNode.isRemoved) {\n            if (leftNode.isText) {\n                return {\n                    node: leftNode,\n                    offset: leftNode.paddedSize,\n                };\n            }\n            offset++;\n        }\n        return {\n            node: parentNode,\n            offset,\n        };\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/operation/tree_edit_operation.ts\n/*\n * Copyright 2023 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n/**\n * `TreeEditOperation` is an operation representing Tree editing.\n */\nclass TreeEditOperation extends Operation {\n    constructor(parentCreatedAt, fromPos, toPos, contents, splitLevel, maxCreatedAtMapByActor, executedAt) {\n        super(parentCreatedAt, executedAt);\n        this.fromPos = fromPos;\n        this.toPos = toPos;\n        this.contents = contents;\n        this.splitLevel = splitLevel;\n        this.maxCreatedAtMapByActor = maxCreatedAtMapByActor;\n    }\n    /**\n     * `create` creates a new instance of EditOperation.\n     */\n    static create(parentCreatedAt, fromPos, toPos, contents, splitLevel, maxCreatedAtMapByActor, executedAt) {\n        return new TreeEditOperation(parentCreatedAt, fromPos, toPos, contents, splitLevel, maxCreatedAtMapByActor, executedAt);\n    }\n    /**\n     * `execute` executes this operation on the given `CRDTRoot`.\n     */\n    execute(root) {\n        var _a;\n        const parentObject = root.findByCreatedAt(this.getParentCreatedAt());\n        if (!parentObject) {\n            logger.fatal(`fail to find ${this.getParentCreatedAt()}`);\n        }\n        if (!(parentObject instanceof CRDTTree)) {\n            logger.fatal(`fail to execute, only Tree can execute edit`);\n        }\n        const editedAt = this.getExecutedAt();\n        const tree = parentObject;\n        const [changes] = tree.edit([this.fromPos, this.toPos], (_a = this.contents) === null || _a === void 0 ? void 0 : _a.map((content) => content.deepcopy()), this.splitLevel, editedAt, \n        /**\n         * TODO(sejongk): When splitting element nodes, a new nodeID is assigned with a different timeTicket.\n         * In the same change context, the timeTickets share the same lamport and actorID but have different delimiters,\n         * incremented by one for each.\n         * Therefore, it is possible to simulate later timeTickets using `editedAt` and the length of `contents`.\n         * This logic might be unclear; consider refactoring for multi-level concurrent editing in the Tree implementation.\n         */\n        (() => {\n            let delimiter = editedAt.getDelimiter();\n            if (this.contents !== undefined) {\n                delimiter += this.contents.length;\n            }\n            const issueTimeTicket = () => TimeTicket.of(editedAt.getLamport(), ++delimiter, editedAt.getActorID());\n            return issueTimeTicket;\n        })(), this.maxCreatedAtMapByActor);\n        if (!this.fromPos.equals(this.toPos)) {\n            root.registerElementHasRemovedNodes(tree);\n        }\n        return {\n            opInfos: changes.map(({ from, to, value, splitLevel, fromPath, toPath }) => {\n                return {\n                    type: 'tree-edit',\n                    path: root.createPath(this.getParentCreatedAt()),\n                    from,\n                    to,\n                    value,\n                    splitLevel,\n                    fromPath,\n                    toPath,\n                };\n            }),\n        };\n    }\n    /**\n     * `getEffectedCreatedAt` returns the creation time of the effected element.\n     */\n    getEffectedCreatedAt() {\n        return this.getParentCreatedAt();\n    }\n    /**\n     * `toTestString` returns a string containing the meta data.\n     */\n    toTestString() {\n        const parent = this.getParentCreatedAt().toTestString();\n        const fromPos = `${this.fromPos\n            .getLeftSiblingID()\n            .getCreatedAt()\n            .toTestString()}:${this.fromPos.getLeftSiblingID().getOffset()}`;\n        const toPos = `${this.toPos\n            .getLeftSiblingID()\n            .getCreatedAt()\n            .toTestString()}:${this.toPos.getLeftSiblingID().getOffset()}`;\n        const contents = this.contents;\n        return `${parent}.EDIT(${fromPos},${toPos},${contents === null || contents === void 0 ? void 0 : contents.join('')})`;\n    }\n    /**\n     * `getFromPos` returns the start point of the editing range.\n     */\n    getFromPos() {\n        return this.fromPos;\n    }\n    /**\n     * `getToPos` returns the end point of the editing range.\n     */\n    getToPos() {\n        return this.toPos;\n    }\n    /**\n     * `getContent` returns the content of Edit.\n     */\n    getContents() {\n        return this.contents;\n    }\n    /**\n     * `getSplitLevel` returns the split level of Edit.\n     */\n    getSplitLevel() {\n        return this.splitLevel;\n    }\n    /**\n     * `getMaxCreatedAtMapByActor` returns the map that stores the latest creation time\n     * by actor for the nodes included in the editing range.\n     */\n    getMaxCreatedAtMapByActor() {\n        return this.maxCreatedAtMapByActor;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/change/change_id.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n/**\n * `ChangeID` is for identifying the Change. This is immutable.\n */\nclass ChangeID {\n    constructor(clientSeq, lamport, actor) {\n        this.clientSeq = clientSeq;\n        this.lamport = lamport;\n        this.actor = actor;\n    }\n    /**\n     * `of` creates a new instance of ChangeID.\n     */\n    static of(clientSeq, lamport, actor) {\n        return new ChangeID(clientSeq, lamport, actor);\n    }\n    /**\n     * `next` creates a next ID of this ID.\n     */\n    next() {\n        return new ChangeID(this.clientSeq + 1, this.lamport.add(1), this.actor);\n    }\n    /**\n     * `syncLamport` syncs lamport timestamp with the given ID.\n     *\n     * {@link https://en.wikipedia.org/wiki/Lamport_timestamps#Algorithm}\n     */\n    syncLamport(otherLamport) {\n        if (otherLamport.greaterThan(this.lamport)) {\n            return new ChangeID(this.clientSeq, otherLamport, this.actor);\n        }\n        return new ChangeID(this.clientSeq, this.lamport.add(1), this.actor);\n    }\n    /**\n     * `createTimeTicket` creates a ticket of the given delimiter.\n     */\n    createTimeTicket(delimiter) {\n        return TimeTicket.of(this.lamport, delimiter, this.actor);\n    }\n    /**\n     * `setActor` sets the given actor.\n     */\n    setActor(actorID) {\n        return new ChangeID(this.clientSeq, this.lamport, actorID);\n    }\n    /**\n     * `getClientSeq` returns the client sequence of this ID.\n     */\n    getClientSeq() {\n        return this.clientSeq;\n    }\n    /**\n     * `getLamport` returns the lamport clock of this ID.\n     */\n    getLamport() {\n        return this.lamport;\n    }\n    /**\n     * `getLamportAsString` returns the lamport clock of this ID as a string.\n     */\n    getLamportAsString() {\n        return this.lamport.toString();\n    }\n    /**\n     * `getActorID` returns the actor of this ID.\n     */\n    getActorID() {\n        return this.actor;\n    }\n    /**\n     * `toTestString` returns a string containing the meta data of this ID.\n     */\n    toTestString() {\n        if (!this.actor) {\n            return `${this.lamport.toString()}:nil:${this.clientSeq}`;\n        }\n        return `${this.lamport.toString()}:${this.actor.substring(22, 24)}:${this.clientSeq}`;\n    }\n}\n/**\n * `InitialChangeID` represents the initial state ID. Usually this is used to\n * represent a state where nothing has been edited.\n */\nconst InitialChangeID = new ChangeID(0, node_modules_long.fromInt(0, true), InitialActorID);\n\n;// CONCATENATED MODULE: ./src/document/change/change.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * `Change` represents a unit of modification in the document.\n */\nclass Change {\n    constructor({ id, operations, presenceChange, message, }) {\n        this.id = id;\n        this.operations = operations || [];\n        this.presenceChange = presenceChange;\n        this.message = message;\n    }\n    /**\n     * `create` creates a new instance of Change.\n     */\n    static create({ id, operations, presenceChange, message, }) {\n        return new Change({ id, operations, presenceChange, message });\n    }\n    /**\n     * `getID` returns the ID of this change.\n     */\n    getID() {\n        return this.id;\n    }\n    /**\n     * `getMessage` returns the message of this change.\n     */\n    getMessage() {\n        return this.message;\n    }\n    /**\n     * `hasOperations` returns whether this change has operations or not.\n     */\n    hasOperations() {\n        return this.operations.length > 0;\n    }\n    /**\n     * `getOperations` returns the operations of this change.\n     */\n    getOperations() {\n        return this.operations;\n    }\n    /**\n     * `setActor` sets the given actor.\n     */\n    setActor(actorID) {\n        for (const operation of this.operations) {\n            operation.setActor(actorID);\n        }\n        this.id = this.id.setActor(actorID);\n    }\n    /**\n     * `hasPresenceChange` returns whether this change has presence change or not.\n     */\n    hasPresenceChange() {\n        return this.presenceChange !== undefined;\n    }\n    /**\n     * `getPresenceChange` returns the presence change of this change.\n     */\n    getPresenceChange() {\n        return this.presenceChange;\n    }\n    /**\n     * `execute` executes the operations of this change to the given root.\n     */\n    execute(root, presences, source) {\n        const changeOpInfos = [];\n        const reverseOps = [];\n        if (false) {}\n        for (const operation of this.operations) {\n            const executionResult = operation.execute(root, source);\n            // NOTE(hackerwins): If the element was removed while executing undo/redo,\n            // the operation is not executed and executionResult is undefined.\n            if (!executionResult)\n                continue;\n            const { opInfos, reverseOp } = executionResult;\n            changeOpInfos.push(...opInfos);\n            // TODO(hackerwins): This condition should be removed after implementing\n            // all reverse operations.\n            if (reverseOp) {\n                reverseOps.unshift(reverseOp);\n            }\n        }\n        if (this.presenceChange) {\n            if (this.presenceChange.type === PresenceChangeType.Put) {\n                presences.set(this.id.getActorID(), deepcopy(this.presenceChange.presence));\n            }\n            else {\n                presences.delete(this.id.getActorID());\n            }\n        }\n        return { opInfos: changeOpInfos, reverseOps };\n    }\n    /**\n     * `toTestString` returns a string containing the meta data of this change.\n     */\n    toTestString() {\n        return `${this.operations\n            .map((operation) => operation.toTestString())\n            .join(',')}`;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/change/change_pack.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * `ChangePack` is a unit for delivering changes in a document to the remote.\n *\n */\nclass ChangePack {\n    constructor(key, checkpoint, isRemoved, changes, snapshot, minSyncedTicket) {\n        this.documentKey = key;\n        this.checkpoint = checkpoint;\n        this.isRemoved = isRemoved;\n        this.changes = changes;\n        this.snapshot = snapshot;\n        this.minSyncedTicket = minSyncedTicket;\n    }\n    /**\n     * `create` creates a new instance of ChangePack.\n     */\n    static create(key, checkpoint, isRemoved, changes, snapshot, minSyncedTicket) {\n        return new ChangePack(key, checkpoint, isRemoved, changes, snapshot, minSyncedTicket);\n    }\n    /**\n     * `getKey` returns the document key of this pack.\n     */\n    getDocumentKey() {\n        return this.documentKey;\n    }\n    /**\n     * `getCheckpoint` returns the checkpoint of this pack.\n     */\n    getCheckpoint() {\n        return this.checkpoint;\n    }\n    /**\n     * `getIsRemoved` returns the whether this document is removed.\n     */\n    getIsRemoved() {\n        return this.isRemoved;\n    }\n    /**\n     * `getChanges` returns the changes of this pack.\n     */\n    getChanges() {\n        return this.changes;\n    }\n    /**\n     * `hasChanges` returns the whether this pack has changes or not.\n     */\n    hasChanges() {\n        return this.changes.length > 0;\n    }\n    /**\n     * `getChangeSize` returns the size of changes this pack has.\n     */\n    getChangeSize() {\n        return this.changes.length;\n    }\n    /**\n     * `hasSnapshot` returns the whether this pack has a snapshot or not.\n     */\n    hasSnapshot() {\n        return !!this.snapshot && !!this.snapshot.length;\n    }\n    /**\n     * `getSnapshot` returns the snapshot of this pack.\n     */\n    getSnapshot() {\n        return this.snapshot;\n    }\n    /**\n     * `getMinSyncedTicket` returns the minimum synced ticket of this pack.\n     */\n    getMinSyncedTicket() {\n        return this.minSyncedTicket;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/change/checkpoint.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * `Checkpoint` is used to determine the changes sent and received by the\n * client. This is immutable.\n *\n **/\nclass Checkpoint {\n    constructor(serverSeq, clientSeq) {\n        this.serverSeq = serverSeq;\n        this.clientSeq = clientSeq;\n    }\n    /**\n     * `of` creates a new instance of Checkpoint.\n     */\n    static of(serverSeq, clientSeq) {\n        return new Checkpoint(serverSeq, clientSeq);\n    }\n    /**\n     * `increaseClientSeq` creates a new instance with increased client sequence.\n     */\n    increaseClientSeq(inc) {\n        if (inc === 0) {\n            return this;\n        }\n        return new Checkpoint(this.serverSeq, this.clientSeq + inc);\n    }\n    /**\n     * `forward` creates a new instance with the given checkpoint if it is\n     * greater than the values of internal properties.\n     */\n    forward(other) {\n        if (this.equals(other)) {\n            return this;\n        }\n        const serverSeq = this.serverSeq.greaterThan(other.serverSeq)\n            ? this.serverSeq\n            : other.serverSeq;\n        const clientSeq = Math.max(this.clientSeq, other.clientSeq);\n        return Checkpoint.of(serverSeq, clientSeq);\n    }\n    /**\n     * `getServerSeqAsString` returns the server seq of this checkpoint as a\n     * string.\n     */\n    getServerSeqAsString() {\n        return this.serverSeq.toString();\n    }\n    /**\n     * `getClientSeq` returns the client seq of this checkpoint.\n     */\n    getClientSeq() {\n        return this.clientSeq;\n    }\n    /**\n     * `getServerSeq` returns the server seq of this checkpoint.\n     */\n    getServerSeq() {\n        return this.serverSeq;\n    }\n    /**\n     * `equals` returns whether the given checkpoint is equal to this checkpoint\n     * or not.\n     */\n    equals(other) {\n        return (this.clientSeq === other.clientSeq &&\n            this.serverSeq.equals(other.serverSeq));\n    }\n    /**\n     * `toTestString` returns a string containing the meta data of this\n     * checkpoint.\n     */\n    toTestString() {\n        return `serverSeq=${this.serverSeq}, clientSeq=${this.clientSeq}`;\n    }\n}\n/**\n * `InitialCheckpoint` is the initial value of the checkpoint.\n */\nconst InitialCheckpoint = new Checkpoint(node_modules_long.fromInt(0, true), 0);\n\n;// CONCATENATED MODULE: ./src/document/crdt/rga_tree_split.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n/**\n * `RGATreeSplitNodeID` is an ID of RGATreeSplitNode.\n */\nclass RGATreeSplitNodeID {\n    constructor(createdAt, offset) {\n        this.createdAt = createdAt;\n        this.offset = offset;\n    }\n    /**\n     * `of` creates a instance of RGATreeSplitNodeID.\n     */\n    static of(createdAt, offset) {\n        return new RGATreeSplitNodeID(createdAt, offset);\n    }\n    /**\n     * `fromStruct` creates a instance of RGATreeSplitNodeID from the struct.\n     */\n    static fromStruct(struct) {\n        return RGATreeSplitNodeID.of(TimeTicket.fromStruct(struct.createdAt), struct.offset);\n    }\n    /**\n     * `getCreatedAt` returns the creation time of this ID.\n     */\n    getCreatedAt() {\n        return this.createdAt;\n    }\n    /**\n     * `getOffset` returns returns the offset of this ID.\n     */\n    getOffset() {\n        return this.offset;\n    }\n    /**\n     * `equals` returns whether given ID equals to this ID or not.\n     */\n    equals(other) {\n        return (this.createdAt.compare(other.createdAt) === 0 &&\n            this.offset === other.offset);\n    }\n    /**\n     * `hasSameCreatedAt` returns whether given ID has same creation time with this ID.\n     */\n    hasSameCreatedAt(other) {\n        return this.createdAt.compare(other.createdAt) === 0;\n    }\n    /**\n     * `split` creates a new ID with an offset from this ID.\n     */\n    split(offset) {\n        return new RGATreeSplitNodeID(this.createdAt, this.offset + offset);\n    }\n    /**\n     * `toStruct` returns the structure of this node id.\n     */\n    toStruct() {\n        return {\n            createdAt: this.createdAt.toStruct(),\n            offset: this.offset,\n        };\n    }\n    /**\n     * `toTestString` returns a String containing\n     * the meta data of the node id for debugging purpose.\n     */\n    toTestString() {\n        return `${this.createdAt.toTestString()}:${this.offset}`;\n    }\n    /**\n     * `toIDString` returns a string that can be used as an ID for this node id.\n     */\n    toIDString() {\n        return `${this.createdAt.toIDString()}:${this.offset}`;\n    }\n}\nconst InitialRGATreeSplitNodeID = RGATreeSplitNodeID.of(InitialTimeTicket, 0);\n/**\n * `RGATreeSplitPos` is the position of the text inside the node.\n */\nclass RGATreeSplitPos {\n    constructor(id, relativeOffset) {\n        this.id = id;\n        this.relativeOffset = relativeOffset;\n    }\n    /**\n     * `of` creates a instance of RGATreeSplitPos.\n     */\n    static of(id, relativeOffset) {\n        return new RGATreeSplitPos(id, relativeOffset);\n    }\n    /**\n     * `fromStruct` creates a instance of RGATreeSplitPos from the struct.\n     */\n    static fromStruct(struct) {\n        const id = RGATreeSplitNodeID.fromStruct(struct.id);\n        return RGATreeSplitPos.of(id, struct.relativeOffset);\n    }\n    /**\n     * `getID` returns the ID of this RGATreeSplitPos.\n     */\n    getID() {\n        return this.id;\n    }\n    /**\n     * `getRelativeOffset` returns the relative offset of this RGATreeSplitPos.\n     */\n    getRelativeOffset() {\n        return this.relativeOffset;\n    }\n    /**\n     * `getAbsoluteID` returns the absolute id of this RGATreeSplitPos.\n     */\n    getAbsoluteID() {\n        return RGATreeSplitNodeID.of(this.id.getCreatedAt(), this.id.getOffset() + this.relativeOffset);\n    }\n    /**\n     *`toTestString` returns a String containing\n     * the meta data of the position for debugging purpose.\n     */\n    toTestString() {\n        return `${this.id.toTestString()}:${this.relativeOffset}`;\n    }\n    /**\n     * `toStruct` returns the structure of this node pos.\n     */\n    toStruct() {\n        return {\n            id: this.id.toStruct(),\n            relativeOffset: this.relativeOffset,\n        };\n    }\n    /**\n     * `equals` returns whether given pos equal to this pos or not.\n     */\n    equals(other) {\n        if (!this.id.equals(other.id)) {\n            return false;\n        }\n        return this.relativeOffset === other.relativeOffset;\n    }\n}\n/**\n * `RGATreeSplitNode` is a node of RGATreeSplit.\n */\nclass RGATreeSplitNode extends SplayNode {\n    constructor(id, value, removedAt) {\n        super(value);\n        this.id = id;\n        this.removedAt = removedAt;\n    }\n    /**\n     * `create` creates a instance of RGATreeSplitNode.\n     */\n    static create(id, value) {\n        return new RGATreeSplitNode(id, value);\n    }\n    /**\n     * `createComparator` creates a function to compare two RGATreeSplitNodeID.\n     */\n    static createComparator() {\n        return (p1, p2) => {\n            const compare = p1.getCreatedAt().compare(p2.getCreatedAt());\n            if (compare !== 0) {\n                return compare;\n            }\n            if (p1.getOffset() > p2.getOffset()) {\n                return 1;\n            }\n            else if (p1.getOffset() < p2.getOffset()) {\n                return -1;\n            }\n            return 0;\n        };\n    }\n    /**\n     * `getID` returns the ID of this RGATreeSplitNode.\n     */\n    getID() {\n        return this.id;\n    }\n    /**\n     * `getCreatedAt` returns creation time of the Id of RGATreeSplitNode.\n     */\n    getCreatedAt() {\n        return this.id.getCreatedAt();\n    }\n    /**\n     * `getLength` returns the length of this node.\n     */\n    getLength() {\n        if (this.removedAt) {\n            return 0;\n        }\n        return this.getContentLength();\n    }\n    /**\n     * `getContentLength` returns the length of this value.\n     */\n    getContentLength() {\n        return (this.value && this.value.length) || 0;\n    }\n    /**\n     * `getPrev` returns a previous node of this node.\n     */\n    getPrev() {\n        return this.prev;\n    }\n    /**\n     * `getNext` returns a next node of this node.\n     */\n    getNext() {\n        return this.next;\n    }\n    /**\n     * `getInsPrev` returns a previous node of this node insertion.\n     */\n    getInsPrev() {\n        return this.insPrev;\n    }\n    /**\n     * `getInsNext` returns a next node of this node insertion.\n     */\n    getInsNext() {\n        return this.insNext;\n    }\n    /**\n     * `getInsPrevID` returns a ID of previous node insertion.\n     */\n    getInsPrevID() {\n        return this.insPrev.getID();\n    }\n    /**\n     * `setPrev` sets previous node of this node.\n     */\n    setPrev(node) {\n        this.prev = node;\n        if (node) {\n            node.next = this;\n        }\n    }\n    /**\n     * `setNext` sets next node of this node.\n     */\n    setNext(node) {\n        this.next = node;\n        if (node) {\n            node.prev = this;\n        }\n    }\n    /**\n     * `setInsPrev` sets previous node of this node insertion.\n     */\n    setInsPrev(node) {\n        this.insPrev = node;\n        if (node) {\n            node.insNext = this;\n        }\n    }\n    /**\n     * `setInsNext` sets next node of this node insertion.\n     */\n    setInsNext(node) {\n        this.insNext = node;\n        if (node) {\n            node.insPrev = this;\n        }\n    }\n    /**\n     * `hasNext` checks if next node exists.\n     */\n    hasNext() {\n        return !!this.next;\n    }\n    /**\n     * `hasInsPrev` checks if previous insertion node exists.\n     */\n    hasInsPrev() {\n        return !!this.insPrev;\n    }\n    /**\n     * `isRemoved` checks if removed time exists.\n     */\n    isRemoved() {\n        return !!this.removedAt;\n    }\n    /**\n     * `getRemovedAt` returns the remove time of this node.\n     */\n    getRemovedAt() {\n        return this.removedAt;\n    }\n    /**\n     * `split` creates a new split node of the given offset.\n     */\n    split(offset) {\n        return new RGATreeSplitNode(this.id.split(offset), this.splitValue(offset), this.removedAt);\n    }\n    /**\n     * `canDelete` checks if node is able to delete.\n     */\n    canDelete(editedAt, latestCreatedAt) {\n        return (!this.getCreatedAt().after(latestCreatedAt) &&\n            (!this.removedAt || editedAt.after(this.removedAt)));\n    }\n    /**\n     * `canStyle` checks if node is able to set style.\n     */\n    canStyle(editedAt, latestCreatedAt) {\n        return (!this.getCreatedAt().after(latestCreatedAt) &&\n            (!this.removedAt || editedAt.after(this.removedAt)));\n    }\n    /**\n     * `remove` removes node of given edited time.\n     */\n    remove(editedAt) {\n        this.removedAt = editedAt;\n    }\n    /**\n     * `createRange` creates ranges of RGATreeSplitPos.\n     */\n    createPosRange() {\n        return [\n            RGATreeSplitPos.of(this.id, 0),\n            RGATreeSplitPos.of(this.id, this.getLength()),\n        ];\n    }\n    /**\n     * `deepcopy` returns a new instance of this RGATreeSplitNode without structural info.\n     */\n    deepcopy() {\n        return new RGATreeSplitNode(this.id, this.value, this.removedAt);\n    }\n    /**\n     * `toTestString` returns a String containing\n     * the meta data of the node for debugging purpose.\n     */\n    toTestString() {\n        return `${this.id.toTestString()} ${this.value ? this.value : ''}`;\n    }\n    splitValue(offset) {\n        const value = this.value;\n        this.value = value.substring(0, offset);\n        return value.substring(offset, value.length);\n    }\n}\n/**\n * `RGATreeSplit` is a block-based list with improved index-based lookup in RGA.\n * The difference from RGATreeList is that it has data on a block basis to\n * reduce the size of CRDT metadata. When an edit occurs on a block,\n * the block is split.\n *\n */\nclass RGATreeSplit {\n    constructor() {\n        this.head = RGATreeSplitNode.create(InitialRGATreeSplitNodeID);\n        this.treeByIndex = new SplayTree();\n        this.treeByID = new LLRBTree(RGATreeSplitNode.createComparator());\n        this.removedNodeMap = new Map();\n        this.treeByIndex.insert(this.head);\n        this.treeByID.put(this.head.getID(), this.head);\n    }\n    /**\n     * `create` creates a instance RGATreeSplit.\n     */\n    static create() {\n        return new RGATreeSplit();\n    }\n    /**\n     * `edit` does following steps\n     * 1. split nodes with from and to\n     * 2. delete between from and to\n     * 3. insert a new node\n     * 4. add removed node\n     * @param range - range of RGATreeSplitNode\n     * @param editedAt - edited time\n     * @param value - value\n     * @param latestCreatedAtMapByActor - latestCreatedAtMapByActor\n     * @returns `[RGATreeSplitPos, Map<string, TimeTicket>, Array<Change>]`\n     */\n    edit(range, editedAt, value, latestCreatedAtMapByActor) {\n        // 01. split nodes with from and to\n        const [toLeft, toRight] = this.findNodeWithSplit(range[1], editedAt);\n        const [fromLeft, fromRight] = this.findNodeWithSplit(range[0], editedAt);\n        // 02. delete between from and to\n        const nodesToDelete = this.findBetween(fromRight, toRight);\n        const [changes, latestCreatedAtMap, removedNodeMapByNodeKey] = this.deleteNodes(nodesToDelete, editedAt, latestCreatedAtMapByActor);\n        const caretID = toRight ? toRight.getID() : toLeft.getID();\n        let caretPos = RGATreeSplitPos.of(caretID, 0);\n        // 03. insert a new node\n        if (value) {\n            const idx = this.posToIndex(fromLeft.createPosRange()[1], true);\n            const inserted = this.insertAfter(fromLeft, RGATreeSplitNode.create(RGATreeSplitNodeID.of(editedAt, 0), value));\n            if (changes.length && changes[changes.length - 1].from === idx) {\n                changes[changes.length - 1].value = value;\n            }\n            else {\n                changes.push({\n                    actor: editedAt.getActorID(),\n                    from: idx,\n                    to: idx,\n                    value,\n                });\n            }\n            caretPos = RGATreeSplitPos.of(inserted.getID(), inserted.getContentLength());\n        }\n        // 04. add removed node\n        for (const [key, removedNode] of removedNodeMapByNodeKey) {\n            this.removedNodeMap.set(key, removedNode);\n        }\n        return [caretPos, latestCreatedAtMap, changes];\n    }\n    /**\n     * `indexToPos` finds RGATreeSplitPos of given offset.\n     */\n    indexToPos(idx) {\n        const [node, offset] = this.treeByIndex.find(idx);\n        const splitNode = node;\n        return RGATreeSplitPos.of(splitNode.getID(), offset);\n    }\n    /**\n     * `findIndexesFromRange` finds indexes based on range.\n     */\n    findIndexesFromRange(range) {\n        const [fromPos, toPos] = range;\n        return [this.posToIndex(fromPos, false), this.posToIndex(toPos, true)];\n    }\n    /**\n     * `posToIndex` converts the given position to index.\n     */\n    posToIndex(pos, preferToLeft) {\n        const absoluteID = pos.getAbsoluteID();\n        const node = preferToLeft\n            ? this.findFloorNodePreferToLeft(absoluteID)\n            : this.findFloorNode(absoluteID);\n        if (!node) {\n            logger.fatal(`the node of the given id should be found: ${absoluteID.toTestString()}`);\n        }\n        const index = this.treeByIndex.indexOf(node);\n        const offset = node.isRemoved()\n            ? 0\n            : absoluteID.getOffset() - node.getID().getOffset();\n        return index + offset;\n    }\n    /**\n     * `findNode` finds node of given id.\n     */\n    findNode(id) {\n        return this.findFloorNode(id);\n    }\n    /**\n     * `length` returns size of RGATreeSplit.\n     */\n    get length() {\n        return this.treeByIndex.length;\n    }\n    /**\n     * `checkWeight` returns false when there is an incorrect weight node.\n     * for debugging purpose.\n     */\n    checkWeight() {\n        return this.treeByIndex.checkWeight();\n    }\n    /**\n     * `toString` returns the string encoding of this RGATreeSplit.\n     */\n    toString() {\n        const str = [];\n        for (const node of this) {\n            if (!node.isRemoved()) {\n                str.push(node.getValue());\n            }\n        }\n        return str.join('');\n    }\n    // eslint-disable-next-line jsdoc/require-jsdoc\n    *[Symbol.iterator]() {\n        let node = this.head.getNext();\n        while (node) {\n            yield node;\n            node = node.getNext();\n        }\n    }\n    /**\n     * `getHead` returns head of RGATreeSplitNode.\n     */\n    getHead() {\n        return this.head;\n    }\n    /**\n     * `deepcopy` copies itself deeply.\n     */\n    deepcopy() {\n        const clone = new RGATreeSplit();\n        let node = this.head.getNext();\n        let prev = clone.head;\n        let current;\n        while (node) {\n            current = clone.insertAfter(prev, node.deepcopy());\n            if (node.hasInsPrev()) {\n                const insPrevNode = clone.findNode(node.getInsPrevID());\n                current.setInsPrev(insPrevNode);\n            }\n            prev = current;\n            node = node.getNext();\n        }\n        return clone;\n    }\n    /**\n     * `toTestString` returns a String containing the meta data of the node\n     * for debugging purpose.\n     */\n    toTestString() {\n        const result = [];\n        let node = this.head;\n        while (node) {\n            if (node.isRemoved()) {\n                result.push(`{${node.toTestString()}}`);\n            }\n            else {\n                result.push(`[${node.toTestString()}]`);\n            }\n            node = node.getNext();\n        }\n        return result.join('');\n    }\n    /**\n     * `insertAfter` inserts the given node after the given previous node.\n     */\n    insertAfter(prevNode, newNode) {\n        const next = prevNode.getNext();\n        newNode.setPrev(prevNode);\n        if (next) {\n            next.setPrev(newNode);\n        }\n        this.treeByID.put(newNode.getID(), newNode);\n        this.treeByIndex.insertAfter(prevNode, newNode);\n        return newNode;\n    }\n    /**\n     * `findNodeWithSplit` splits and return nodes of the given position.\n     */\n    findNodeWithSplit(pos, editedAt) {\n        const absoluteID = pos.getAbsoluteID();\n        let node = this.findFloorNodePreferToLeft(absoluteID);\n        const relativeOffset = absoluteID.getOffset() - node.getID().getOffset();\n        this.splitNode(node, relativeOffset);\n        while (node.hasNext() && node.getNext().getCreatedAt().after(editedAt)) {\n            node = node.getNext();\n        }\n        return [node, node.getNext()];\n    }\n    findFloorNodePreferToLeft(id) {\n        let node = this.findFloorNode(id);\n        if (!node) {\n            logger.fatal(`the node of the given id should be found: ${id.toTestString()}`);\n        }\n        if (id.getOffset() > 0 && node.getID().getOffset() == id.getOffset()) {\n            // NOTE: InsPrev may not be present due to GC.\n            if (!node.hasInsPrev()) {\n                return node;\n            }\n            node = node.getInsPrev();\n        }\n        return node;\n    }\n    findFloorNode(id) {\n        const entry = this.treeByID.floorEntry(id);\n        if (!entry) {\n            return;\n        }\n        if (!entry.key.equals(id) && !entry.key.hasSameCreatedAt(id)) {\n            return;\n        }\n        return entry.value;\n    }\n    /**\n     * `findBetween` returns nodes between fromNode and toNode.\n     */\n    findBetween(fromNode, toNode) {\n        const nodes = [];\n        let current = fromNode;\n        while (current && current !== toNode) {\n            nodes.push(current);\n            current = current.getNext();\n        }\n        return nodes;\n    }\n    splitNode(node, offset) {\n        if (offset > node.getContentLength()) {\n            logger.fatal('offset should be less than or equal to length');\n        }\n        if (offset === 0) {\n            return node;\n        }\n        else if (offset === node.getContentLength()) {\n            return node.getNext();\n        }\n        const splitNode = node.split(offset);\n        this.treeByIndex.updateWeight(splitNode);\n        this.insertAfter(node, splitNode);\n        const insNext = node.getInsNext();\n        if (insNext) {\n            insNext.setInsPrev(splitNode);\n        }\n        splitNode.setInsPrev(node);\n        return splitNode;\n    }\n    deleteNodes(candidates, editedAt, latestCreatedAtMapByActor) {\n        if (!candidates.length) {\n            return [[], new Map(), new Map()];\n        }\n        // There are 2 types of nodes in `candidates`: should delete, should not delete.\n        // `nodesToKeep` contains nodes should not delete,\n        // then is used to find the boundary of the range to be deleted.\n        const [nodesToDelete, nodesToKeep] = this.filterNodes(candidates, editedAt, latestCreatedAtMapByActor);\n        const createdAtMapByActor = new Map();\n        const removedNodeMap = new Map();\n        // First we need to collect indexes for change.\n        const changes = this.makeChanges(nodesToKeep, editedAt);\n        for (const node of nodesToDelete) {\n            // Then make nodes be tombstones and map that.\n            const actorID = node.getCreatedAt().getActorID();\n            if (!createdAtMapByActor.has(actorID) ||\n                node.getID().getCreatedAt().after(createdAtMapByActor.get(actorID))) {\n                createdAtMapByActor.set(actorID, node.getID().getCreatedAt());\n            }\n            removedNodeMap.set(node.getID().toIDString(), node);\n            node.remove(editedAt);\n        }\n        // Finally remove index nodes of tombstones.\n        this.deleteIndexNodes(nodesToKeep);\n        return [changes, createdAtMapByActor, removedNodeMap];\n    }\n    filterNodes(candidates, editedAt, latestCreatedAtMapByActor) {\n        const isRemote = !!latestCreatedAtMapByActor;\n        const nodesToDelete = [];\n        const nodesToKeep = [];\n        const [leftEdge, rightEdge] = this.findEdgesOfCandidates(candidates);\n        nodesToKeep.push(leftEdge);\n        for (const node of candidates) {\n            const actorID = node.getCreatedAt().getActorID();\n            const latestCreatedAt = isRemote\n                ? latestCreatedAtMapByActor.has(actorID)\n                    ? latestCreatedAtMapByActor.get(actorID)\n                    : InitialTimeTicket\n                : MaxTimeTicket;\n            if (node.canDelete(editedAt, latestCreatedAt)) {\n                nodesToDelete.push(node);\n            }\n            else {\n                nodesToKeep.push(node);\n            }\n        }\n        nodesToKeep.push(rightEdge);\n        return [nodesToDelete, nodesToKeep];\n    }\n    /**\n     * `findEdgesOfCandidates` finds the edges outside `candidates`,\n     * (which has not already been deleted, or be undefined but not yet implemented)\n     * right edge is undefined means `candidates` contains the end of text.\n     */\n    findEdgesOfCandidates(candidates) {\n        return [\n            candidates[0].getPrev(),\n            candidates[candidates.length - 1].getNext(),\n        ];\n    }\n    makeChanges(boundaries, editedAt) {\n        const changes = [];\n        let fromIdx, toIdx;\n        for (let i = 0; i < boundaries.length - 1; i++) {\n            const leftBoundary = boundaries[i];\n            const rightBoundary = boundaries[i + 1];\n            if (leftBoundary.getNext() == rightBoundary) {\n                continue;\n            }\n            [fromIdx] = this.findIndexesFromRange(leftBoundary.getNext().createPosRange());\n            if (rightBoundary) {\n                [, toIdx] = this.findIndexesFromRange(rightBoundary.getPrev().createPosRange());\n            }\n            else {\n                toIdx = this.treeByIndex.length;\n            }\n            if (fromIdx < toIdx) {\n                changes.push({\n                    actor: editedAt.getActorID(),\n                    from: fromIdx,\n                    to: toIdx,\n                });\n            }\n        }\n        return changes.reverse();\n    }\n    /**\n     * `deleteIndexNodes` clears the index nodes of the given deletion boundaries.\n     * The boundaries mean the nodes that will not be deleted in the range.\n     */\n    deleteIndexNodes(boundaries) {\n        for (let i = 0; i < boundaries.length - 1; i++) {\n            const leftBoundary = boundaries[i];\n            const rightBoundary = boundaries[i + 1];\n            // If there is no node to delete between boundaries, do notting.\n            if (leftBoundary.getNext() != rightBoundary) {\n                this.treeByIndex.deleteRange(leftBoundary, rightBoundary);\n            }\n        }\n    }\n    /**\n     * `getRemovedNodesLen` returns size of removed nodes.\n     */\n    getRemovedNodesLen() {\n        return this.removedNodeMap.size;\n    }\n    /**\n     * `purgeRemovedNodesBefore` physically purges nodes that have been removed.\n     */\n    purgeRemovedNodesBefore(ticket) {\n        let count = 0;\n        for (const [, node] of this.removedNodeMap) {\n            if (node.getRemovedAt() && ticket.compare(node.getRemovedAt()) >= 0) {\n                this.treeByIndex.delete(node);\n                this.purge(node);\n                this.treeByID.remove(node.getID());\n                this.removedNodeMap.delete(node.getID().toIDString());\n                count++;\n            }\n        }\n        return count;\n    }\n    /**\n     * `purge` physically purges the given node from RGATreeSplit.\n     */\n    purge(node) {\n        const prev = node.getPrev();\n        const next = node.getNext();\n        const insPrev = node.getInsPrev();\n        const insNext = node.getInsNext();\n        if (prev) {\n            prev.setNext(next);\n        }\n        if (next) {\n            next.setPrev(prev);\n        }\n        node.setPrev(undefined);\n        node.setNext(undefined);\n        if (insPrev) {\n            insPrev.setInsNext(insNext);\n        }\n        if (insNext) {\n            insNext.setInsPrev(insPrev);\n        }\n        node.setInsPrev(undefined);\n        node.setInsNext(undefined);\n    }\n}\n\n;// CONCATENATED MODULE: ./src/util/number.ts\n/*\n * Copyright 2023 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n `removeDecimal` returns a number with the decimal part removed.\n */\nconst removeDecimal = (number) => number < 0 ? Math.ceil(number) : Math.floor(number);\n\n;// CONCATENATED MODULE: ./src/document/crdt/counter.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\nvar CounterType;\n(function (CounterType) {\n    CounterType[CounterType[\"IntegerCnt\"] = 0] = \"IntegerCnt\";\n    CounterType[CounterType[\"LongCnt\"] = 1] = \"LongCnt\";\n})(CounterType || (CounterType = {}));\n/**\n * `CRDTCounter` is a CRDT implementation of a counter. It is used to represent\n * a number that can be incremented or decremented.\n *\n * @internal\n */\nclass CRDTCounter extends CRDTElement {\n    constructor(valueType, value, createdAt) {\n        super(createdAt);\n        this.valueType = valueType;\n        switch (valueType) {\n            case CounterType.IntegerCnt:\n                if (typeof value === 'number') {\n                    if (value > Math.pow(2, 31) - 1 || value < -Math.pow(2, 31)) {\n                        this.value = node_modules_long.fromNumber(value).toInt();\n                    }\n                    else {\n                        this.value = removeDecimal(value);\n                    }\n                }\n                else {\n                    this.value = value.toInt();\n                }\n                break;\n            case CounterType.LongCnt:\n                if (typeof value === 'number') {\n                    this.value = node_modules_long.fromNumber(value);\n                }\n                else {\n                    this.value = value;\n                }\n                break;\n            default:\n                throw new YorkieError(error_Code.Unimplemented, `unimplemented type: ${valueType}`);\n        }\n    }\n    /**\n     * `of` creates a new instance of Counter.\n     */\n    static create(valueType, value, createdAt) {\n        return new CRDTCounter(valueType, value, createdAt);\n    }\n    /**\n     * `valueFromBytes` parses the given bytes into value.\n     */\n    static valueFromBytes(counterType, bytes) {\n        switch (counterType) {\n            case CounterType.IntegerCnt:\n                return bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24);\n            case CounterType.LongCnt:\n                return node_modules_long.fromBytesLE(Array.from(bytes));\n            default:\n                throw new YorkieError(error_Code.Unimplemented, `unimplemented type: ${counterType}`);\n        }\n    }\n    /**\n     * `toJSON` returns the JSON encoding of the value.\n     */\n    toJSON() {\n        return `${this.value}`;\n    }\n    /**\n     * `toSortedJSON` returns the sorted JSON encoding of the value.\n     */\n    toSortedJSON() {\n        return this.toJSON();\n    }\n    /**\n     * `toJSForTest` returns value with meta data for testing.\n     */\n    toJSForTest() {\n        return {\n            id: this.getCreatedAt().toTestString(),\n            value: this.value,\n            type: 'YORKIE_COUNTER',\n        };\n    }\n    /**\n     * `deepcopy` copies itself deeply.\n     */\n    deepcopy() {\n        const counter = CRDTCounter.create(this.valueType, this.value, this.getCreatedAt());\n        counter.setMovedAt(this.getMovedAt());\n        return counter;\n    }\n    /**\n     * `getType` returns the type of the value.\n     */\n    getType() {\n        return this.valueType;\n    }\n    /**\n     * `getCounterType` returns counter type of given value.\n     */\n    static getCounterType(value) {\n        switch (typeof value) {\n            case 'object':\n                if (value instanceof node_modules_long) {\n                    return CounterType.LongCnt;\n                }\n                else {\n                    return;\n                }\n            case 'number':\n                if (value > Math.pow(2, 31) - 1 || value < -Math.pow(2, 31)) {\n                    return CounterType.LongCnt;\n                }\n                else {\n                    return CounterType.IntegerCnt;\n                }\n            default:\n                return;\n        }\n    }\n    /**\n     * `isSupport` check if there is a counter type of given value.\n     */\n    static isSupport(value) {\n        return !!CRDTCounter.getCounterType(value);\n    }\n    /**\n     * `isInteger` checks if the num is integer.\n     */\n    static isInteger(num) {\n        return num % 1 === 0;\n    }\n    /**\n     * `isNumericType` check numeric type by JSONCounter.\n     */\n    isNumericType() {\n        const t = this.valueType;\n        return t === CounterType.IntegerCnt || t === CounterType.LongCnt;\n    }\n    /**\n     * `getValueType` get counter value type.\n     */\n    getValueType() {\n        return this.valueType;\n    }\n    /**\n     * `getValue` get counter value.\n     */\n    getValue() {\n        return this.value;\n    }\n    /**\n     * `toBytes` creates an array representing the value.\n     */\n    toBytes() {\n        switch (this.valueType) {\n            case CounterType.IntegerCnt: {\n                const intVal = this.value;\n                return new Uint8Array([\n                    intVal & 0xff,\n                    (intVal >> 8) & 0xff,\n                    (intVal >> 16) & 0xff,\n                    (intVal >> 24) & 0xff,\n                ]);\n            }\n            case CounterType.LongCnt: {\n                const longVal = this.value;\n                const longToBytes = longVal.toBytesLE();\n                return Uint8Array.from(longToBytes);\n            }\n            default:\n                throw new YorkieError(error_Code.Unimplemented, `unimplemented type: ${this.valueType}`);\n        }\n    }\n    /**\n     * `increase` increases numeric data.\n     */\n    increase(v) {\n        /**\n         * `checkNumericType` checks if the given target is a numeric type.\n         */\n        function checkNumericType(target) {\n            if (!target.isNumericType()) {\n                throw new TypeError(`Unsupported type of value: ${typeof target.getValue()}`);\n            }\n        }\n        checkNumericType(this);\n        checkNumericType(v);\n        if (this.valueType === CounterType.LongCnt) {\n            this.value = this.value.add(v.getValue());\n        }\n        else {\n            if (v.getType() === PrimitiveType.Long) {\n                this.value = this.value + v.getValue().toInt();\n            }\n            else {\n                this.value = node_modules_long.fromNumber(this.value + removeDecimal(v.getValue())).toInt();\n            }\n        }\n        return this;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/operation/increase_operation.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n/**\n * `IncreaseOperation` represents an operation that increments a numeric value to Counter.\n * Among Primitives, numeric types Integer, Long are used as values.\n */\nclass IncreaseOperation extends Operation {\n    constructor(parentCreatedAt, value, executedAt) {\n        super(parentCreatedAt, executedAt);\n        this.value = value;\n    }\n    /**\n     * `create` creates a new instance of IncreaseOperation.\n     */\n    static create(parentCreatedAt, value, executedAt) {\n        return new IncreaseOperation(parentCreatedAt, value, executedAt);\n    }\n    /**\n     * `execute` executes this operation on the given `CRDTRoot`.\n     */\n    execute(root) {\n        const parentObject = root.findByCreatedAt(this.getParentCreatedAt());\n        if (!parentObject) {\n            logger.fatal(`fail to find ${this.getParentCreatedAt()}`);\n        }\n        if (!(parentObject instanceof CRDTCounter)) {\n            logger.fatal(`fail to execute, only Counter can execute increase`);\n        }\n        const counter = parentObject;\n        const value = this.value.deepcopy();\n        counter.increase(value);\n        return {\n            opInfos: [\n                {\n                    type: 'increase',\n                    path: root.createPath(this.getParentCreatedAt()),\n                    value: value.getValue(),\n                },\n            ],\n            reverseOp: this.toReverseOperation(),\n        };\n    }\n    /**\n     * `toReverseOperation` returns the reverse operation of this operation.\n     */\n    toReverseOperation() {\n        const primitiveValue = this.value.deepcopy();\n        const valueType = primitiveValue.getType();\n        const value = valueType === PrimitiveType.Long\n            ? primitiveValue.getValue().multiply(-1)\n            : primitiveValue.getValue() * -1;\n        const reverseOp = IncreaseOperation.create(this.getParentCreatedAt(), Primitive.of(value, primitiveValue.getCreatedAt()));\n        return reverseOp;\n    }\n    /**\n     * `getEffectedCreatedAt` returns the creation time of the effected element.\n     */\n    getEffectedCreatedAt() {\n        return this.getParentCreatedAt();\n    }\n    /**\n     * `toTestString` returns a string containing the meta data.\n     */\n    toTestString() {\n        return `${this.getParentCreatedAt().toTestString()}.INCREASE.${this.value.toJSON()}`;\n    }\n    /**\n     * `getValue` returns the value of this operation.\n     */\n    getValue() {\n        return this.value;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/operation/tree_style_operation.ts\n/*\n * Copyright 2023 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n/**\n * `TreeStyleOperation` represents an operation that modifies the style of the\n * node in the Tree.\n */\nclass TreeStyleOperation extends Operation {\n    constructor(parentCreatedAt, fromPos, toPos, attributes, executedAt) {\n        super(parentCreatedAt, executedAt);\n        this.fromPos = fromPos;\n        this.toPos = toPos;\n        this.attributes = attributes;\n    }\n    /**\n     * `create` creates a new instance of TreeStyleOperation.\n     */\n    static create(parentCreatedAt, fromPos, toPos, attributes, executedAt) {\n        return new TreeStyleOperation(parentCreatedAt, fromPos, toPos, attributes, executedAt);\n    }\n    /**\n     * `execute` executes this operation on the given `CRDTRoot`.\n     */\n    execute(root) {\n        const parentObject = root.findByCreatedAt(this.getParentCreatedAt());\n        if (!parentObject) {\n            logger.fatal(`fail to find ${this.getParentCreatedAt()}`);\n        }\n        if (!(parentObject instanceof CRDTTree)) {\n            logger.fatal(`fail to execute, only Tree can execute edit`);\n        }\n        const attributes = {};\n        [...this.attributes].forEach(([key, value]) => (attributes[key] = value));\n        const tree = parentObject;\n        const changes = tree.style([this.fromPos, this.toPos], attributes, this.getExecutedAt());\n        return {\n            opInfos: changes.map(({ from, to, value, fromPath }) => {\n                return {\n                    type: 'tree-style',\n                    from,\n                    to,\n                    value,\n                    fromPath,\n                    path: root.createPath(this.getParentCreatedAt()),\n                };\n            }),\n        };\n    }\n    /**\n     * `getEffectedCreatedAt` returns the creation time of the effected element.\n     */\n    getEffectedCreatedAt() {\n        return this.getParentCreatedAt();\n    }\n    /**\n     * `toTestString` returns a string containing the meta data.\n     */\n    toTestString() {\n        const parent = this.getParentCreatedAt().toTestString();\n        const fromPos = `${this.fromPos\n            .getLeftSiblingID()\n            .getCreatedAt()\n            .toTestString()}:${this.fromPos.getLeftSiblingID().getOffset()}`;\n        const toPos = `${this.toPos\n            .getLeftSiblingID()\n            .getCreatedAt()\n            .toTestString()}:${this.toPos.getLeftSiblingID().getOffset()}`;\n        return `${parent}.STYLE(${fromPos},${toPos},${Object.entries(this.attributes || {})\n            .map(([k, v]) => `${k}:\"${v}\"`)\n            .join(' ')})`;\n    }\n    /**\n     * `getFromPos` returns the start point of the editing range.\n     */\n    getFromPos() {\n        return this.fromPos;\n    }\n    /**\n     * `getToPos` returns the end point of the editing range.\n     */\n    getToPos() {\n        return this.toPos;\n    }\n    /**\n     * `getAttributes` returns the attributes of Style.\n     */\n    getAttributes() {\n        return this.attributes;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/api/converter.ts\n/*\n * Copyright 2023 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * `toPresence` converts the given model to Protobuf format.\n */\nfunction toPresence(presence) {\n    const pbPresence = new resources_pb.Presence();\n    const pbDataMap = pbPresence.data;\n    for (const [key, value] of Object.entries(presence)) {\n        pbDataMap[key] = JSON.stringify(value);\n    }\n    return pbPresence;\n}\n/**\n * `toPresenceChange` converts the given model to Protobuf format.\n */\nfunction toPresenceChange(presenceChange) {\n    if (presenceChange.type === PresenceChangeType.Put) {\n        return new resources_pb.PresenceChange({\n            type: resources_pb.PresenceChange_ChangeType.PUT,\n            presence: toPresence(presenceChange.presence),\n        });\n    }\n    if (presenceChange.type === PresenceChangeType.Clear) {\n        return new resources_pb.PresenceChange({\n            type: resources_pb.PresenceChange_ChangeType.CLEAR,\n        });\n    }\n    throw new YorkieError(error_Code.Unimplemented, `unimplemented type`);\n}\n/**\n * `toCheckpoint` converts the given model to Protobuf format.\n */\nfunction toCheckpoint(checkpoint) {\n    return new resources_pb.Checkpoint({\n        serverSeq: checkpoint.getServerSeqAsString(),\n        clientSeq: checkpoint.getClientSeq(),\n    });\n}\n/**\n * `toChangeID` converts the given model to Protobuf format.\n */\nfunction toChangeID(changeID) {\n    return new resources_pb.ChangeID({\n        clientSeq: changeID.getClientSeq(),\n        lamport: changeID.getLamportAsString(),\n        actorId: toUint8Array(changeID.getActorID()),\n    });\n}\n/**\n * `toTimeTicket` converts the given model to Protobuf format.\n */\nfunction toTimeTicket(ticket) {\n    if (!ticket) {\n        return;\n    }\n    return new resources_pb.TimeTicket({\n        lamport: ticket.getLamportAsString(),\n        delimiter: ticket.getDelimiter(),\n        actorId: toUint8Array(ticket.getActorID()),\n    });\n}\n/**\n * `toValueType` converts the given model to Protobuf format.\n */\nfunction toValueType(valueType) {\n    switch (valueType) {\n        case PrimitiveType.Null:\n            return resources_pb.ValueType.NULL;\n        case PrimitiveType.Boolean:\n            return resources_pb.ValueType.BOOLEAN;\n        case PrimitiveType.Integer:\n            return resources_pb.ValueType.INTEGER;\n        case PrimitiveType.Long:\n            return resources_pb.ValueType.LONG;\n        case PrimitiveType.Double:\n            return resources_pb.ValueType.DOUBLE;\n        case PrimitiveType.String:\n            return resources_pb.ValueType.STRING;\n        case PrimitiveType.Bytes:\n            return resources_pb.ValueType.BYTES;\n        case PrimitiveType.Date:\n            return resources_pb.ValueType.DATE;\n        default:\n            throw new YorkieError(error_Code.Unsupported, `unsupported type: ${valueType}`);\n    }\n}\n/**\n * `toCounterType` converts the given model to Protobuf format.\n */\nfunction toCounterType(valueType) {\n    switch (valueType) {\n        case CounterType.IntegerCnt:\n            return resources_pb.ValueType.INTEGER_CNT;\n        case CounterType.LongCnt:\n            return resources_pb.ValueType.LONG_CNT;\n        default:\n            throw new YorkieError(error_Code.Unsupported, `unsupported type: ${valueType}`);\n    }\n}\n/**\n * `toElementSimple` converts the given model to Protobuf format.\n */\nfunction toElementSimple(element) {\n    if (element instanceof CRDTObject) {\n        return new resources_pb.JSONElementSimple({\n            type: resources_pb.ValueType.JSON_OBJECT,\n            createdAt: toTimeTicket(element.getCreatedAt()),\n            value: objectToBytes(element),\n        });\n    }\n    if (element instanceof CRDTArray) {\n        return new resources_pb.JSONElementSimple({\n            type: resources_pb.ValueType.JSON_ARRAY,\n            createdAt: toTimeTicket(element.getCreatedAt()),\n            value: arrayToBytes(element),\n        });\n    }\n    if (element instanceof CRDTText) {\n        return new resources_pb.JSONElementSimple({\n            type: resources_pb.ValueType.TEXT,\n            createdAt: toTimeTicket(element.getCreatedAt()),\n        });\n    }\n    if (element instanceof Primitive) {\n        return new resources_pb.JSONElementSimple({\n            type: toValueType(element.getType()),\n            createdAt: toTimeTicket(element.getCreatedAt()),\n            value: element.toBytes(),\n        });\n    }\n    if (element instanceof CRDTCounter) {\n        return new resources_pb.JSONElementSimple({\n            type: toCounterType(element.getType()),\n            createdAt: toTimeTicket(element.getCreatedAt()),\n            value: element.toBytes(),\n        });\n    }\n    if (element instanceof CRDTTree) {\n        return new resources_pb.JSONElementSimple({\n            type: resources_pb.ValueType.TREE,\n            createdAt: toTimeTicket(element.getCreatedAt()),\n            value: treeToBytes(element),\n        });\n    }\n    throw new YorkieError(error_Code.Unimplemented, `unimplemented element`);\n}\n/**\n * `toTextNodeID` converts the given model to Protobuf format.\n */\nfunction toTextNodeID(id) {\n    return new resources_pb.TextNodeID({\n        createdAt: toTimeTicket(id.getCreatedAt()),\n        offset: id.getOffset(),\n    });\n}\n/**\n * `toTextNodePos` converts the given model to Protobuf format.\n */\nfunction toTextNodePos(pos) {\n    return new resources_pb.TextNodePos({\n        createdAt: toTimeTicket(pos.getID().getCreatedAt()),\n        offset: pos.getID().getOffset(),\n        relativeOffset: pos.getRelativeOffset(),\n    });\n}\n/**\n * `toTreePos` converts the given model to Protobuf format.\n */\nfunction toTreePos(pos) {\n    return new resources_pb.TreePos({\n        parentId: toTreeNodeID(pos.getParentID()),\n        leftSiblingId: toTreeNodeID(pos.getLeftSiblingID()),\n    });\n}\n/**\n * `toTreeNodeID` converts the given model to Protobuf format.\n */\nfunction toTreeNodeID(treeNodeID) {\n    return new resources_pb.TreeNodeID({\n        createdAt: toTimeTicket(treeNodeID.getCreatedAt()),\n        offset: treeNodeID.getOffset(),\n    });\n}\n/**\n * `toOperation` converts the given model to Protobuf format.\n */\nfunction toOperation(operation) {\n    const pbOperation = new resources_pb.Operation();\n    if (operation instanceof SetOperation) {\n        const setOperation = operation;\n        const pbSetOperation = new resources_pb.Operation_Set();\n        pbSetOperation.parentCreatedAt = toTimeTicket(setOperation.getParentCreatedAt());\n        pbSetOperation.key = setOperation.getKey();\n        pbSetOperation.value = toElementSimple(setOperation.getValue());\n        pbSetOperation.executedAt = toTimeTicket(setOperation.getExecutedAt());\n        pbOperation.body.case = 'set';\n        pbOperation.body.value = pbSetOperation;\n    }\n    else if (operation instanceof AddOperation) {\n        const addOperation = operation;\n        const pbAddOperation = new resources_pb.Operation_Add();\n        pbAddOperation.parentCreatedAt = toTimeTicket(addOperation.getParentCreatedAt());\n        pbAddOperation.prevCreatedAt = toTimeTicket(addOperation.getPrevCreatedAt());\n        pbAddOperation.value = toElementSimple(addOperation.getValue());\n        pbAddOperation.executedAt = toTimeTicket(addOperation.getExecutedAt());\n        pbOperation.body.case = 'add';\n        pbOperation.body.value = pbAddOperation;\n    }\n    else if (operation instanceof MoveOperation) {\n        const moveOperation = operation;\n        const pbMoveOperation = new resources_pb.Operation_Move();\n        pbMoveOperation.parentCreatedAt = toTimeTicket(moveOperation.getParentCreatedAt());\n        pbMoveOperation.prevCreatedAt = toTimeTicket(moveOperation.getPrevCreatedAt());\n        pbMoveOperation.createdAt = toTimeTicket(moveOperation.getCreatedAt());\n        pbMoveOperation.executedAt = toTimeTicket(moveOperation.getExecutedAt());\n        pbOperation.body.case = 'move';\n        pbOperation.body.value = pbMoveOperation;\n    }\n    else if (operation instanceof RemoveOperation) {\n        const removeOperation = operation;\n        const pbRemoveOperation = new resources_pb.Operation_Remove();\n        pbRemoveOperation.parentCreatedAt = toTimeTicket(removeOperation.getParentCreatedAt());\n        pbRemoveOperation.createdAt = toTimeTicket(removeOperation.getCreatedAt());\n        pbRemoveOperation.executedAt = toTimeTicket(removeOperation.getExecutedAt());\n        pbOperation.body.case = 'remove';\n        pbOperation.body.value = pbRemoveOperation;\n    }\n    else if (operation instanceof EditOperation) {\n        const editOperation = operation;\n        const pbEditOperation = new resources_pb.Operation_Edit();\n        pbEditOperation.parentCreatedAt = toTimeTicket(editOperation.getParentCreatedAt());\n        pbEditOperation.from = toTextNodePos(editOperation.getFromPos());\n        pbEditOperation.to = toTextNodePos(editOperation.getToPos());\n        const pbCreatedAtMapByActor = pbEditOperation.createdAtMapByActor;\n        for (const [key, value] of editOperation.getMaxCreatedAtMapByActor()) {\n            pbCreatedAtMapByActor[key] = toTimeTicket(value);\n        }\n        pbEditOperation.content = editOperation.getContent();\n        const pbAttributes = pbEditOperation.attributes;\n        for (const [key, value] of editOperation.getAttributes()) {\n            pbAttributes[key] = value;\n        }\n        pbEditOperation.executedAt = toTimeTicket(editOperation.getExecutedAt());\n        pbOperation.body.case = 'edit';\n        pbOperation.body.value = pbEditOperation;\n    }\n    else if (operation instanceof StyleOperation) {\n        const styleOperation = operation;\n        const pbStyleOperation = new resources_pb.Operation_Style();\n        pbStyleOperation.parentCreatedAt = toTimeTicket(styleOperation.getParentCreatedAt());\n        pbStyleOperation.from = toTextNodePos(styleOperation.getFromPos());\n        pbStyleOperation.to = toTextNodePos(styleOperation.getToPos());\n        const pbCreatedAtMapByActor = pbStyleOperation.createdAtMapByActor;\n        for (const [key, value] of styleOperation.getMaxCreatedAtMapByActor()) {\n            pbCreatedAtMapByActor[key] = toTimeTicket(value);\n        }\n        const pbAttributes = pbStyleOperation.attributes;\n        for (const [key, value] of styleOperation.getAttributes()) {\n            pbAttributes[key] = value;\n        }\n        pbStyleOperation.executedAt = toTimeTicket(styleOperation.getExecutedAt());\n        pbOperation.body.case = 'style';\n        pbOperation.body.value = pbStyleOperation;\n    }\n    else if (operation instanceof IncreaseOperation) {\n        const increaseOperation = operation;\n        const pbIncreaseOperation = new resources_pb.Operation_Increase();\n        pbIncreaseOperation.parentCreatedAt = toTimeTicket(increaseOperation.getParentCreatedAt());\n        pbIncreaseOperation.value = toElementSimple(increaseOperation.getValue());\n        pbIncreaseOperation.executedAt = toTimeTicket(increaseOperation.getExecutedAt());\n        pbOperation.body.case = 'increase';\n        pbOperation.body.value = pbIncreaseOperation;\n    }\n    else if (operation instanceof TreeEditOperation) {\n        const treeEditOperation = operation;\n        const pbTreeEditOperation = new resources_pb.Operation_TreeEdit();\n        const pbCreatedAtMapByActor = pbTreeEditOperation.createdAtMapByActor;\n        for (const [key, value] of treeEditOperation.getMaxCreatedAtMapByActor()) {\n            pbCreatedAtMapByActor[key] = toTimeTicket(value);\n        }\n        pbTreeEditOperation.parentCreatedAt = toTimeTicket(treeEditOperation.getParentCreatedAt());\n        pbTreeEditOperation.from = toTreePos(treeEditOperation.getFromPos());\n        pbTreeEditOperation.to = toTreePos(treeEditOperation.getToPos());\n        pbTreeEditOperation.contents = toTreeNodesWhenEdit(treeEditOperation.getContents());\n        pbTreeEditOperation.splitLevel = treeEditOperation.getSplitLevel();\n        pbTreeEditOperation.executedAt = toTimeTicket(treeEditOperation.getExecutedAt());\n        pbOperation.body.case = 'treeEdit';\n        pbOperation.body.value = pbTreeEditOperation;\n    }\n    else if (operation instanceof TreeStyleOperation) {\n        const treeStyleOperation = operation;\n        const pbTreeStyleOperation = new resources_pb.Operation_TreeStyle();\n        pbTreeStyleOperation.parentCreatedAt = toTimeTicket(treeStyleOperation.getParentCreatedAt());\n        pbTreeStyleOperation.from = toTreePos(treeStyleOperation.getFromPos());\n        pbTreeStyleOperation.to = toTreePos(treeStyleOperation.getToPos());\n        const attributesMap = pbTreeStyleOperation.attributes;\n        for (const [key, value] of treeStyleOperation.getAttributes()) {\n            attributesMap[key] = value;\n        }\n        pbTreeStyleOperation.executedAt = toTimeTicket(treeStyleOperation.getExecutedAt());\n        pbOperation.body.case = 'treeStyle';\n        pbOperation.body.value = pbTreeStyleOperation;\n    }\n    else {\n        throw new YorkieError(error_Code.Unimplemented, 'unimplemented operation');\n    }\n    return pbOperation;\n}\n/**\n * `toOperations` converts the given model to Protobuf format.\n */\nfunction toOperations(operations) {\n    const pbOperations = [];\n    for (const operation of operations) {\n        pbOperations.push(toOperation(operation));\n    }\n    return pbOperations;\n}\n/**\n * `toChange` converts the given model to Protobuf format.\n */\nfunction toChange(change) {\n    const pbChange = new resources_pb.Change({\n        id: toChangeID(change.getID()),\n        message: change.getMessage(),\n    });\n    if (change.hasOperations()) {\n        pbChange.operations = toOperations(change.getOperations());\n    }\n    if (change.hasPresenceChange()) {\n        pbChange.presenceChange = toPresenceChange(change.getPresenceChange());\n    }\n    return pbChange;\n}\n/**\n * `toChanges` converts the given model to Protobuf format.\n */\nfunction toChanges(changes) {\n    const pbChanges = [];\n    for (const change of changes) {\n        pbChanges.push(toChange(change));\n    }\n    return pbChanges;\n}\n/**\n * `toRHTNodes` converts the given model to Protobuf format.\n */\nfunction toRHTNodes(rht) {\n    const pbRHTNodes = [];\n    for (const rhtNode of rht) {\n        pbRHTNodes.push(new resources_pb.RHTNode({\n            key: rhtNode.getStrKey(),\n            element: toElement(rhtNode.getValue()),\n        }));\n    }\n    return pbRHTNodes;\n}\n/**\n * `toRGANodes` converts the given model to Protobuf format.\n */\nfunction toRGANodes(rgaTreeList) {\n    const pbRGANodes = [];\n    for (const rgaTreeListNode of rgaTreeList) {\n        pbRGANodes.push(new resources_pb.RGANode({\n            element: toElement(rgaTreeListNode.getValue()),\n        }));\n    }\n    return pbRGANodes;\n}\n/**\n * `toTextNodes` converts the given model to Protobuf format.\n */\nfunction toTextNodes(rgaTreeSplit) {\n    const pbTextNodes = [];\n    for (const textNode of rgaTreeSplit) {\n        const pbTextNode = new resources_pb.TextNode();\n        pbTextNode.id = toTextNodeID(textNode.getID());\n        pbTextNode.value = textNode.getValue().getContent();\n        pbTextNode.removedAt = toTimeTicket(textNode.getRemovedAt());\n        const pbNodeAttrsMap = pbTextNode.attributes;\n        const attrs = textNode.getValue().getAttrs();\n        for (const attr of attrs) {\n            const pbNodeAttr = new resources_pb.NodeAttr();\n            pbNodeAttr.value = attr.getValue();\n            pbNodeAttr.updatedAt = toTimeTicket(attr.getUpdatedAt());\n            pbNodeAttrsMap[attr.getKey()] = pbNodeAttr;\n        }\n        pbTextNodes.push(pbTextNode);\n    }\n    return pbTextNodes;\n}\n/**\n * `toTreeNodesWhenEdit` converts the given model to Protobuf format.\n */\nfunction toTreeNodesWhenEdit(nodes) {\n    const pbTreeNodesList = [];\n    if (!nodes || !nodes.length) {\n        return pbTreeNodesList;\n    }\n    for (const node of nodes) {\n        pbTreeNodesList.push(new resources_pb.TreeNodes({\n            content: toTreeNodes(node),\n        }));\n    }\n    return pbTreeNodesList;\n}\n/**\n * `toTreeNodes` converts the given model to Protobuf format.\n */\nfunction toTreeNodes(node) {\n    if (!node) {\n        return [];\n    }\n    const pbTreeNodes = [];\n    traverse(node, (n, depth) => {\n        const pbTreeNode = new resources_pb.TreeNode({\n            id: toTreeNodeID(n.id),\n            type: n.type,\n            removedAt: toTimeTicket(n.removedAt),\n            depth,\n        });\n        if (n.isText) {\n            pbTreeNode.value = n.value;\n        }\n        if (n.insPrevID) {\n            pbTreeNode.insPrevId = toTreeNodeID(n.insPrevID);\n        }\n        if (n.insNextID) {\n            pbTreeNode.insNextId = toTreeNodeID(n.insNextID);\n        }\n        if (n.attrs) {\n            for (const attr of n.attrs) {\n                pbTreeNode.attributes[attr.getKey()] = new resources_pb.NodeAttr({\n                    value: attr.getValue(),\n                    updatedAt: toTimeTicket(attr.getUpdatedAt()),\n                });\n            }\n        }\n        pbTreeNodes.push(pbTreeNode);\n    });\n    return pbTreeNodes;\n}\n/**\n * `toObject` converts the given model to Protobuf format.\n */\nfunction toObject(obj) {\n    const pbElement = new resources_pb.JSONElement();\n    pbElement.body.case = 'jsonObject';\n    pbElement.body.value = new resources_pb.JSONElement_JSONObject({\n        nodes: toRHTNodes(obj.getRHT()),\n        createdAt: toTimeTicket(obj.getCreatedAt()),\n        movedAt: toTimeTicket(obj.getMovedAt()),\n        removedAt: toTimeTicket(obj.getRemovedAt()),\n    });\n    return pbElement;\n}\n/**\n * `toArray` converts the given model to Protobuf format.\n */\nfunction toArray(arr) {\n    const pbElement = new resources_pb.JSONElement();\n    pbElement.body.case = 'jsonArray';\n    pbElement.body.value = new resources_pb.JSONElement_JSONArray({\n        nodes: toRGANodes(arr.getElements()),\n        createdAt: toTimeTicket(arr.getCreatedAt()),\n        movedAt: toTimeTicket(arr.getMovedAt()),\n        removedAt: toTimeTicket(arr.getRemovedAt()),\n    });\n    return pbElement;\n}\n/**\n * `toPrimitive` converts the given model to Protobuf format.\n */\nfunction toPrimitive(primitive) {\n    const pbElement = new resources_pb.JSONElement();\n    pbElement.body.case = 'primitive';\n    pbElement.body.value = new resources_pb.JSONElement_Primitive({\n        type: toValueType(primitive.getType()),\n        value: primitive.toBytes(),\n        createdAt: toTimeTicket(primitive.getCreatedAt()),\n        movedAt: toTimeTicket(primitive.getMovedAt()),\n        removedAt: toTimeTicket(primitive.getRemovedAt()),\n    });\n    return pbElement;\n}\n/**\n * `toText` converts the given model to Protobuf format.\n */\nfunction toText(text) {\n    const pbElement = new resources_pb.JSONElement();\n    pbElement.body.case = 'text';\n    pbElement.body.value = new resources_pb.JSONElement_Text({\n        nodes: toTextNodes(text.getRGATreeSplit()),\n        createdAt: toTimeTicket(text.getCreatedAt()),\n        movedAt: toTimeTicket(text.getMovedAt()),\n        removedAt: toTimeTicket(text.getRemovedAt()),\n    });\n    return pbElement;\n}\n/**\n * `toCounter` converts the given model to Protobuf format.\n */\nfunction toCounter(counter) {\n    const pbElement = new resources_pb.JSONElement();\n    pbElement.body.case = 'counter';\n    pbElement.body.value = new resources_pb.JSONElement_Counter({\n        type: toCounterType(counter.getType()),\n        value: counter.toBytes(),\n        createdAt: toTimeTicket(counter.getCreatedAt()),\n        movedAt: toTimeTicket(counter.getMovedAt()),\n        removedAt: toTimeTicket(counter.getRemovedAt()),\n    });\n    return pbElement;\n}\n/**\n * `toTree` converts the given model to Protobuf format.\n */\nfunction toTree(tree) {\n    const pbElement = new resources_pb.JSONElement();\n    pbElement.body.case = 'tree';\n    pbElement.body.value = new resources_pb.JSONElement_Tree({\n        nodes: toTreeNodes(tree.getRoot()),\n        createdAt: toTimeTicket(tree.getCreatedAt()),\n        movedAt: toTimeTicket(tree.getMovedAt()),\n        removedAt: toTimeTicket(tree.getRemovedAt()),\n    });\n    return pbElement;\n}\n/**\n * `toElement` converts the given model to Protobuf format.\n */\nfunction toElement(element) {\n    if (element instanceof CRDTObject) {\n        return toObject(element);\n    }\n    if (element instanceof CRDTArray) {\n        return toArray(element);\n    }\n    if (element instanceof Primitive) {\n        return toPrimitive(element);\n    }\n    if (element instanceof CRDTText) {\n        return toText(element);\n    }\n    if (element instanceof CRDTCounter) {\n        return toCounter(element);\n    }\n    if (element instanceof CRDTTree) {\n        return toTree(element);\n    }\n    throw new YorkieError(error_Code.Unimplemented, `unimplemented element`);\n}\n/**\n * `toChangePack` converts the given model to Protobuf format.\n */\nfunction toChangePack(pack) {\n    return new resources_pb.ChangePack({\n        documentKey: pack.getDocumentKey(),\n        checkpoint: toCheckpoint(pack.getCheckpoint()),\n        isRemoved: pack.getIsRemoved(),\n        changes: toChanges(pack.getChanges()),\n        snapshot: pack.getSnapshot(),\n        minSyncedTicket: toTimeTicket(pack.getMinSyncedTicket()),\n    });\n}\n/**\n * `fromChangeID` converts the given Protobuf format to model format.\n */\nfunction fromChangeID(pbChangeID) {\n    return ChangeID.of(pbChangeID.clientSeq, node_modules_long.fromString(pbChangeID.lamport, true), toHexString(pbChangeID.actorId));\n}\n/**\n * `fromTimeTicket` converts the given Protobuf format to model format.\n */\nfunction fromTimeTicket(pbTimeTicket) {\n    if (!pbTimeTicket) {\n        return;\n    }\n    return TimeTicket.of(node_modules_long.fromString(pbTimeTicket.lamport, true), pbTimeTicket.delimiter, toHexString(pbTimeTicket.actorId));\n}\n/**\n * `fromPresence` converts the given Protobuf format to model format.\n */\nfunction fromPresence(pbPresence) {\n    const data = {};\n    Object.entries(pbPresence.data).forEach(([key, value]) => {\n        data[key] = JSON.parse(value);\n    });\n    return data;\n}\n/**\n * `fromPresenceChange` converts the given Protobuf format to model format.\n */\nfunction fromPresenceChange(pbPresenceChange) {\n    const type = pbPresenceChange.type;\n    if (type === resources_pb.PresenceChange_ChangeType.PUT) {\n        const presence = fromPresence(pbPresenceChange.presence);\n        return {\n            type: PresenceChangeType.Put,\n            presence,\n        };\n    }\n    if (type === resources_pb.PresenceChange_ChangeType.CLEAR) {\n        return {\n            type: PresenceChangeType.Clear,\n        };\n    }\n    throw new YorkieError(error_Code.Unsupported, `unsupported type: ${type}`);\n}\n/**\n * `fromPresences` converts the given Protobuf format to model format.\n */\nfunction fromPresences(pbPresences) {\n    const presences = new Map();\n    Object.entries(pbPresences).forEach(([actorID, pbPresence]) => {\n        presences.set(actorID, fromPresence(pbPresence));\n    });\n    return presences;\n}\n/**\n * `fromValueType` converts the given Protobuf format to model format.\n */\nfunction fromValueType(pbValueType) {\n    switch (pbValueType) {\n        case resources_pb.ValueType.NULL:\n            return PrimitiveType.Null;\n        case resources_pb.ValueType.BOOLEAN:\n            return PrimitiveType.Boolean;\n        case resources_pb.ValueType.INTEGER:\n            return PrimitiveType.Integer;\n        case resources_pb.ValueType.LONG:\n            return PrimitiveType.Long;\n        case resources_pb.ValueType.DOUBLE:\n            return PrimitiveType.Double;\n        case resources_pb.ValueType.STRING:\n            return PrimitiveType.String;\n        case resources_pb.ValueType.BYTES:\n            return PrimitiveType.Bytes;\n        case resources_pb.ValueType.DATE:\n            return PrimitiveType.Date;\n    }\n    throw new YorkieError(error_Code.Unimplemented, `unimplemented value type: ${pbValueType}`);\n}\n/**\n * `fromCounterType` converts the given Protobuf format to model format.\n */\nfunction fromCounterType(pbValueType) {\n    switch (pbValueType) {\n        case resources_pb.ValueType.INTEGER_CNT:\n            return CounterType.IntegerCnt;\n        case resources_pb.ValueType.LONG_CNT:\n            return CounterType.LongCnt;\n    }\n    throw new YorkieError(error_Code.Unimplemented, `unimplemented value type: ${pbValueType}`);\n}\n/**\n * `fromElementSimple` converts the given Protobuf format to model format.\n */\nfunction fromElementSimple(pbElementSimple) {\n    switch (pbElementSimple.type) {\n        case resources_pb.ValueType.JSON_OBJECT:\n            if (!pbElementSimple.value) {\n                return CRDTObject.create(fromTimeTicket(pbElementSimple.createdAt));\n            }\n            return bytesToObject(pbElementSimple.value);\n        case resources_pb.ValueType.JSON_ARRAY:\n            if (!pbElementSimple.value) {\n                return CRDTArray.create(fromTimeTicket(pbElementSimple.createdAt));\n            }\n            return bytesToArray(pbElementSimple.value);\n        case resources_pb.ValueType.TEXT:\n            return CRDTText.create(RGATreeSplit.create(), fromTimeTicket(pbElementSimple.createdAt));\n        case resources_pb.ValueType.TREE:\n            return bytesToTree(pbElementSimple.value);\n        case resources_pb.ValueType.NULL:\n        case resources_pb.ValueType.BOOLEAN:\n        case resources_pb.ValueType.INTEGER:\n        case resources_pb.ValueType.LONG:\n        case resources_pb.ValueType.DOUBLE:\n        case resources_pb.ValueType.STRING:\n        case resources_pb.ValueType.BYTES:\n        case resources_pb.ValueType.DATE:\n            return Primitive.of(Primitive.valueFromBytes(fromValueType(pbElementSimple.type), pbElementSimple.value), fromTimeTicket(pbElementSimple.createdAt));\n        case resources_pb.ValueType.INTEGER_CNT:\n        case resources_pb.ValueType.LONG_CNT:\n            return CRDTCounter.create(fromCounterType(pbElementSimple.type), CRDTCounter.valueFromBytes(fromCounterType(pbElementSimple.type), pbElementSimple.value), fromTimeTicket(pbElementSimple.createdAt));\n    }\n}\n/**\n * `fromTextNodePos` converts the given Protobuf format to model format.\n */\nfunction fromTextNodePos(pbTextNodePos) {\n    return RGATreeSplitPos.of(RGATreeSplitNodeID.of(fromTimeTicket(pbTextNodePos.createdAt), pbTextNodePos.offset), pbTextNodePos.relativeOffset);\n}\n/**\n * `fromTextNodeID` converts the given Protobuf format to model format.\n */\nfunction fromTextNodeID(pbTextNodeID) {\n    return RGATreeSplitNodeID.of(fromTimeTicket(pbTextNodeID.createdAt), pbTextNodeID.offset);\n}\n/**\n * `fromTextNode` converts the given Protobuf format to model format.\n */\nfunction fromTextNode(pbTextNode) {\n    const textValue = CRDTTextValue.create(pbTextNode.value);\n    Object.entries(pbTextNode.attributes).forEach(([key, value]) => {\n        textValue.setAttr(key, value.value, fromTimeTicket(value.updatedAt));\n    });\n    const textNode = RGATreeSplitNode.create(fromTextNodeID(pbTextNode.id), textValue);\n    textNode.remove(fromTimeTicket(pbTextNode.removedAt));\n    return textNode;\n}\n/**\n * `fromTreePos` converts the given Protobuf format to model format.\n */\nfunction fromTreePos(pbTreePos) {\n    return CRDTTreePos.of(fromTreeNodeID(pbTreePos.parentId), fromTreeNodeID(pbTreePos.leftSiblingId));\n}\n/**\n * `fromTreeNodeID` converts the given Protobuf format to model format.\n */\nfunction fromTreeNodeID(pbTreeNodeID) {\n    return CRDTTreeNodeID.of(fromTimeTicket(pbTreeNodeID.createdAt), pbTreeNodeID.offset);\n}\n/**\n * `fromTreeNodesWhenEdit` converts the given Protobuf format to model format.\n */\nfunction fromTreeNodesWhenEdit(pbTreeNodes) {\n    if (!pbTreeNodes.length) {\n        return;\n    }\n    const treeNodes = [];\n    pbTreeNodes.forEach((node) => {\n        const treeNode = fromTreeNodes(node.content);\n        treeNodes.push(treeNode);\n    });\n    return treeNodes;\n}\n/**\n * `fromTreeNodes` converts the given Protobuf format to model format.\n */\nfunction fromTreeNodes(pbTreeNodes) {\n    if (pbTreeNodes.length === 0) {\n        return;\n    }\n    const nodes = [];\n    for (const pbTreeNode of pbTreeNodes) {\n        nodes.push(fromTreeNode(pbTreeNode));\n    }\n    const root = nodes[nodes.length - 1];\n    for (let i = nodes.length - 2; i >= 0; i--) {\n        let parent;\n        for (let j = i + 1; j < nodes.length; j++) {\n            if (pbTreeNodes[i].depth - 1 === pbTreeNodes[j].depth) {\n                parent = nodes[j];\n                break;\n            }\n        }\n        parent.prepend(nodes[i]);\n    }\n    // build CRDTTree from the root to construct the links between nodes.\n    return CRDTTree.create(root, InitialTimeTicket).getRoot();\n}\n/**\n * `fromTreeNode` converts the given Protobuf format to model format.\n */\nfunction fromTreeNode(pbTreeNode) {\n    const id = fromTreeNodeID(pbTreeNode.id);\n    const node = CRDTTreeNode.create(id, pbTreeNode.type);\n    if (node.isText) {\n        node.value = pbTreeNode.value;\n    }\n    else {\n        const attrs = RHT.create();\n        Object.entries(pbTreeNode.attributes).forEach(([key, value]) => {\n            attrs.set(key, value.value, fromTimeTicket(value.updatedAt));\n        });\n        node.attrs = attrs;\n    }\n    if (pbTreeNode.insPrevId) {\n        node.insPrevID = fromTreeNodeID(pbTreeNode.insPrevId);\n    }\n    if (pbTreeNode.insPrevId) {\n        node.insNextID = fromTreeNodeID(pbTreeNode.insNextId);\n    }\n    node.removedAt = fromTimeTicket(pbTreeNode.removedAt);\n    return node;\n}\n/**\n * `fromOperations` converts the given Protobuf format to model format.\n */\nfunction fromOperations(pbOperations) {\n    const operations = [];\n    for (const pbOperation of pbOperations) {\n        let operation;\n        if (pbOperation.body.case === 'set') {\n            const pbSetOperation = pbOperation.body.value;\n            operation = SetOperation.create(pbSetOperation.key, fromElementSimple(pbSetOperation.value), fromTimeTicket(pbSetOperation.parentCreatedAt), fromTimeTicket(pbSetOperation.executedAt));\n        }\n        else if (pbOperation.body.case === 'add') {\n            const pbAddOperation = pbOperation.body.value;\n            operation = AddOperation.create(fromTimeTicket(pbAddOperation.parentCreatedAt), fromTimeTicket(pbAddOperation.prevCreatedAt), fromElementSimple(pbAddOperation.value), fromTimeTicket(pbAddOperation.executedAt));\n        }\n        else if (pbOperation.body.case === 'move') {\n            const pbMoveOperation = pbOperation.body.value;\n            operation = MoveOperation.create(fromTimeTicket(pbMoveOperation.parentCreatedAt), fromTimeTicket(pbMoveOperation.prevCreatedAt), fromTimeTicket(pbMoveOperation.createdAt), fromTimeTicket(pbMoveOperation.executedAt));\n        }\n        else if (pbOperation.body.case === 'remove') {\n            const pbRemoveOperation = pbOperation.body.value;\n            operation = RemoveOperation.create(fromTimeTicket(pbRemoveOperation.parentCreatedAt), fromTimeTicket(pbRemoveOperation.createdAt), fromTimeTicket(pbRemoveOperation.executedAt));\n        }\n        else if (pbOperation.body.case === 'edit') {\n            const pbEditOperation = pbOperation.body.value;\n            const createdAtMapByActor = new Map();\n            Object.entries(pbEditOperation.createdAtMapByActor).forEach(([key, value]) => {\n                createdAtMapByActor.set(key, fromTimeTicket(value));\n            });\n            const attributes = new Map();\n            Object.entries(pbEditOperation.attributes).forEach(([key, value]) => {\n                attributes.set(key, value);\n            });\n            operation = EditOperation.create(fromTimeTicket(pbEditOperation.parentCreatedAt), fromTextNodePos(pbEditOperation.from), fromTextNodePos(pbEditOperation.to), createdAtMapByActor, pbEditOperation.content, attributes, fromTimeTicket(pbEditOperation.executedAt));\n        }\n        else if (pbOperation.body.case === 'style') {\n            const pbStyleOperation = pbOperation.body.value;\n            const createdAtMapByActor = new Map();\n            Object.entries(pbStyleOperation.createdAtMapByActor).forEach(([key, value]) => {\n                createdAtMapByActor.set(key, fromTimeTicket(value));\n            });\n            const attributes = new Map();\n            Object.entries(pbStyleOperation.attributes).forEach(([key, value]) => {\n                attributes.set(key, value);\n            });\n            operation = StyleOperation.create(fromTimeTicket(pbStyleOperation.parentCreatedAt), fromTextNodePos(pbStyleOperation.from), fromTextNodePos(pbStyleOperation.to), createdAtMapByActor, attributes, fromTimeTicket(pbStyleOperation.executedAt));\n        }\n        else if (pbOperation.body.case === 'select') {\n            // TODO(hackerwins): Select is deprecated.\n            continue;\n        }\n        else if (pbOperation.body.case === 'increase') {\n            const pbIncreaseOperation = pbOperation.body.value;\n            operation = IncreaseOperation.create(fromTimeTicket(pbIncreaseOperation.parentCreatedAt), fromElementSimple(pbIncreaseOperation.value), fromTimeTicket(pbIncreaseOperation.executedAt));\n        }\n        else if (pbOperation.body.case === 'treeEdit') {\n            const pbTreeEditOperation = pbOperation.body.value;\n            const createdAtMapByActor = new Map();\n            Object.entries(pbTreeEditOperation.createdAtMapByActor).forEach(([key, value]) => {\n                createdAtMapByActor.set(key, fromTimeTicket(value));\n            });\n            operation = TreeEditOperation.create(fromTimeTicket(pbTreeEditOperation.parentCreatedAt), fromTreePos(pbTreeEditOperation.from), fromTreePos(pbTreeEditOperation.to), fromTreeNodesWhenEdit(pbTreeEditOperation.contents), pbTreeEditOperation.splitLevel, createdAtMapByActor, fromTimeTicket(pbTreeEditOperation.executedAt));\n        }\n        else if (pbOperation.body.case === 'treeStyle') {\n            const pbTreeStyleOperation = pbOperation.body.value;\n            const attributes = new Map();\n            Object.entries(pbTreeStyleOperation.attributes).forEach(([key, value]) => {\n                attributes.set(key, value);\n            });\n            operation = TreeStyleOperation.create(fromTimeTicket(pbTreeStyleOperation.parentCreatedAt), fromTreePos(pbTreeStyleOperation.from), fromTreePos(pbTreeStyleOperation.to), attributes, fromTimeTicket(pbTreeStyleOperation.executedAt));\n        }\n        else {\n            throw new YorkieError(error_Code.Unimplemented, `unimplemented operation`);\n        }\n        operations.push(operation);\n    }\n    return operations;\n}\n/**\n * `fromChanges` converts the given Protobuf format to model format.\n */\nfunction fromChanges(pbChanges) {\n    const changes = [];\n    for (const pbChange of pbChanges) {\n        changes.push(Change.create({\n            id: fromChangeID(pbChange.id),\n            operations: fromOperations(pbChange.operations),\n            presenceChange: pbChange.presenceChange\n                ? fromPresenceChange(pbChange.presenceChange)\n                : undefined,\n            message: pbChange.message,\n        }));\n    }\n    return changes;\n}\n/**\n * `fromCheckpoint` converts the given Protobuf format to model format.\n */\nfunction fromCheckpoint(pbCheckpoint) {\n    return Checkpoint.of(node_modules_long.fromString(pbCheckpoint.serverSeq, true), pbCheckpoint.clientSeq);\n}\n/**\n * `fromChangePack` converts the given Protobuf format to model format.\n */\nfunction fromChangePack(pbPack) {\n    return ChangePack.create(pbPack.documentKey, fromCheckpoint(pbPack.checkpoint), pbPack.isRemoved, fromChanges(pbPack.changes), pbPack.snapshot, fromTimeTicket(pbPack.minSyncedTicket));\n}\n/**\n * `fromObject` converts the given Protobuf format to model format.\n */\nfunction fromObject(pbObject) {\n    const rht = new ElementRHT();\n    for (const pbRHTNode of pbObject.nodes) {\n        const value = fromElement(pbRHTNode.element);\n        rht.set(pbRHTNode.key, value, value.getPositionedAt());\n    }\n    const obj = new CRDTObject(fromTimeTicket(pbObject.createdAt), rht);\n    obj.setMovedAt(fromTimeTicket(pbObject.movedAt));\n    obj.setRemovedAt(fromTimeTicket(pbObject.removedAt));\n    return obj;\n}\n/**\n * `fromArray` converts the given Protobuf format to model format.\n */\nfunction fromArray(pbArray) {\n    const rgaTreeList = new RGATreeList();\n    for (const pbRGANode of pbArray.nodes) {\n        // eslint-disable-next-line\n        rgaTreeList.insert(fromElement(pbRGANode.element));\n    }\n    const arr = new CRDTArray(fromTimeTicket(pbArray.createdAt), rgaTreeList);\n    arr.setMovedAt(fromTimeTicket(pbArray.movedAt));\n    arr.setRemovedAt(fromTimeTicket(pbArray.removedAt));\n    return arr;\n}\n/**\n * `fromPrimitive` converts the given Protobuf format to model format.\n */\nfunction fromPrimitive(pbPrimitive) {\n    const primitive = Primitive.of(Primitive.valueFromBytes(fromValueType(pbPrimitive.type), pbPrimitive.value), fromTimeTicket(pbPrimitive.createdAt));\n    primitive.setMovedAt(fromTimeTicket(pbPrimitive.movedAt));\n    primitive.setRemovedAt(fromTimeTicket(pbPrimitive.removedAt));\n    return primitive;\n}\n/**\n * `fromText` converts the given Protobuf format to model format.\n */\nfunction fromText(pbText) {\n    const rgaTreeSplit = new RGATreeSplit();\n    let prev = rgaTreeSplit.getHead();\n    for (const pbNode of pbText.nodes) {\n        const current = rgaTreeSplit.insertAfter(prev, fromTextNode(pbNode));\n        if (pbNode.insPrevId) {\n            current.setInsPrev(rgaTreeSplit.findNode(fromTextNodeID(pbNode.insPrevId)));\n        }\n        prev = current;\n    }\n    const text = new CRDTText(rgaTreeSplit, fromTimeTicket(pbText.createdAt));\n    text.setMovedAt(fromTimeTicket(pbText.movedAt));\n    text.setRemovedAt(fromTimeTicket(pbText.removedAt));\n    return text;\n}\n/**\n * `fromCounter` converts the given Protobuf format to model format.\n */\nfunction fromCounter(pbCounter) {\n    const counter = CRDTCounter.create(fromCounterType(pbCounter.type), CRDTCounter.valueFromBytes(fromCounterType(pbCounter.type), pbCounter.value), fromTimeTicket(pbCounter.createdAt));\n    counter.setMovedAt(fromTimeTicket(pbCounter.movedAt));\n    counter.setRemovedAt(fromTimeTicket(pbCounter.removedAt));\n    return counter;\n}\n/**\n * `fromTree` converts the given Protobuf format to model format.\n */\nfunction fromTree(pbTree) {\n    const root = fromTreeNodes(pbTree.nodes);\n    return CRDTTree.create(root, fromTimeTicket(pbTree.createdAt));\n}\n/**\n * `fromElement` converts the given Protobuf format to model format.\n */\nfunction fromElement(pbElement) {\n    if (pbElement.body.case === 'jsonObject') {\n        return fromObject(pbElement.body.value);\n    }\n    else if (pbElement.body.case === 'jsonArray') {\n        return fromArray(pbElement.body.value);\n    }\n    else if (pbElement.body.case === 'primitive') {\n        return fromPrimitive(pbElement.body.value);\n    }\n    else if (pbElement.body.case === 'text') {\n        return fromText(pbElement.body.value);\n    }\n    else if (pbElement.body.case === 'counter') {\n        return fromCounter(pbElement.body.value);\n    }\n    else if (pbElement.body.case === 'tree') {\n        return fromTree(pbElement.body.value);\n    }\n    else {\n        throw new YorkieError(error_Code.Unimplemented, `unimplemented element`);\n    }\n}\n/**\n * `bytesToSnapshot` creates a Snapshot from the given byte array.\n */\nfunction bytesToSnapshot(bytes) {\n    if (!bytes) {\n        return {\n            root: CRDTObject.create(InitialTimeTicket),\n            presences: new Map(),\n        };\n    }\n    const snapshot = resources_pb.Snapshot.fromBinary(bytes);\n    return {\n        root: fromElement(snapshot.root),\n        presences: fromPresences(snapshot.presences),\n    };\n}\n/**\n * `bytesToObject` creates an JSONObject from the given byte array.\n */\nfunction bytesToObject(bytes) {\n    if (!bytes) {\n        throw new Error('bytes is empty');\n    }\n    const pbElement = resources_pb.JSONElement.fromBinary(bytes);\n    return fromObject(pbElement.body.value);\n}\n/**\n * `objectToBytes` converts the given JSONObject to byte array.\n */\nfunction objectToBytes(obj) {\n    return toElement(obj).toBinary();\n}\n/**\n * `bytesToArray` creates an CRDTArray from the given bytes.\n */\nfunction bytesToArray(bytes) {\n    if (!bytes) {\n        throw new Error('bytes is empty');\n    }\n    const pbElement = resources_pb.JSONElement.fromBinary(bytes);\n    return fromArray(pbElement.body.value);\n}\n/**\n * `arrayToBytes` converts the given CRDTArray to bytes.\n */\nfunction arrayToBytes(array) {\n    return toArray(array).toBinary();\n}\n/**\n * `bytesToTree` creates an CRDTTree from the given bytes.\n */\nfunction bytesToTree(bytes) {\n    if (!bytes) {\n        throw new Error('bytes is empty');\n    }\n    const pbElement = resources_pb.JSONElement.fromBinary(bytes);\n    return fromTree(pbElement.body.value);\n}\n/**\n * `treeToBytes` converts the given tree to bytes.\n */\nfunction treeToBytes(tree) {\n    return toTree(tree).toBinary();\n}\n/**\n * `bytesToHex` creates an hex string from the given byte array.\n */\nfunction bytesToHex(bytes) {\n    if (!bytes) {\n        return '';\n    }\n    return Array.from(bytes)\n        .map((b) => b.toString(16).padStart(2, '0'))\n        .join('');\n}\n/**\n * `toHexString` converts the given byte array to hex string.\n */\nfunction toHexString(bytes) {\n    return bytesToHex(bytes);\n}\n/**\n * `hexToBytes` converts the given hex string to byte array.\n */\nfunction hexToBytes(hex) {\n    return new Uint8Array(hex.match(/.{1,2}/g).map((byte) => parseInt(byte, 16)));\n}\n/**\n * `toUnit8Array` converts the given hex string to byte array.\n */\nfunction toUint8Array(hex) {\n    return hexToBytes(hex);\n}\n/**\n * `converter` is a converter that converts the given model to protobuf format.\n * is also used to convert models to bytes and vice versa.\n */\nconst converter = {\n    fromPresence,\n    toChangePack,\n    fromChangePack,\n    fromChanges,\n    objectToBytes,\n    bytesToObject,\n    bytesToSnapshot,\n    toHexString,\n    toUint8Array,\n};\n\n;// CONCATENATED MODULE: ./src/client/attachment.ts\n\n/**\n * `Attachment` is a class that manages the state of the document.\n */\nclass Attachment {\n    constructor(reconnectStreamDelay, doc, docID, isRealtimeSync) {\n        this.reconnectStreamDelay = reconnectStreamDelay;\n        this.doc = doc;\n        this.docID = docID;\n        this.isRealtimeSync = isRealtimeSync;\n        this.syncMode = SyncMode.PushPull;\n        this.remoteChangeEventReceived = false;\n    }\n    /**\n     * `changeRealtimeSync` changes whether to synchronize the document in realtime or not.\n     */\n    changeRealtimeSync(isRealtimeSync) {\n        if (this.isRealtimeSync === isRealtimeSync) {\n            return false;\n        }\n        if (isRealtimeSync) {\n            this.isRealtimeSync = true;\n            return true;\n        }\n        this.cancelWatchStream();\n        this.isRealtimeSync = false;\n        return true;\n    }\n    /**\n     * `changeSyncMode` changes the sync mode of the document.\n     */\n    changeSyncMode(syncMode) {\n        this.syncMode = syncMode;\n    }\n    /**\n     * `needRealtimeSync` returns whether the document needs to be synced in real time.\n     */\n    needRealtimeSync() {\n        return (this.isRealtimeSync &&\n            (this.doc.hasLocalChanges() || this.remoteChangeEventReceived));\n    }\n    /**\n     * `runWatchLoop` runs the watch loop.\n     */\n    async runWatchLoop(watchStreamCreator) {\n        const doLoop = async () => {\n            if (this.watchStream) {\n                return Promise.resolve();\n            }\n            if (this.watchLoopTimerID) {\n                clearTimeout(this.watchLoopTimerID);\n                this.watchLoopTimerID = undefined;\n            }\n            try {\n                [this.watchStream, this.watchAbortController] =\n                    await watchStreamCreator(() => {\n                        this.watchStream = undefined;\n                        this.watchAbortController = undefined;\n                        this.watchLoopTimerID = setTimeout(doLoop, this.reconnectStreamDelay);\n                    });\n            }\n            catch (err) {\n                // TODO(hackerwins): For now, if the creation of the watch stream fails,\n                // it is considered normal and the watch loop is executed again after a\n                // certain period of time.\n                // In the future, we need to find a better way to handle this.\n            }\n        };\n        await doLoop();\n    }\n    /**\n     * `cancelWatchStream` cancels the watch stream.\n     */\n    cancelWatchStream() {\n        if (this.watchStream && this.watchAbortController) {\n            this.watchAbortController.abort();\n            this.watchStream = undefined;\n            this.watchAbortController = undefined;\n        }\n        clearTimeout(this.watchLoopTimerID);\n        this.watchLoopTimerID = undefined;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/change/context.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n/**\n * `ChangeContext` is used to record the context of modification when editing\n * a document. Each time we add an operation, a new time ticket is issued.\n * Finally returns a Change after the modification has been completed.\n */\nclass ChangeContext {\n    constructor(id, root, presence, message) {\n        this.id = id;\n        this.delimiter = InitialDelimiter;\n        this.root = root;\n        this.operations = [];\n        this.previousPresence = deepcopy(presence);\n        this.presenceChange = undefined;\n        this.reversePresenceKeys = new Set();\n        this.message = message;\n    }\n    /**\n     * `create` creates a new instance of ChangeContext.\n     */\n    static create(id, root, presence, message) {\n        return new ChangeContext(id, root, presence, message);\n    }\n    /**\n     * `push` pushes the given operation to this context.\n     */\n    push(operation) {\n        this.operations.push(operation);\n    }\n    /**\n     * `registerElement` registers the given element to the root.\n     */\n    registerElement(element, parent) {\n        this.root.registerElement(element, parent);\n    }\n    /**\n     * `registerRemovedElement` register removed element for garbage collection.\n     */\n    registerRemovedElement(deleted) {\n        this.root.registerRemovedElement(deleted);\n    }\n    /**\n     * `registerElementHasRemovedNodes` register GC element has removed node for\n     * garbage collection.\n     */\n    registerElementHasRemovedNodes(elem) {\n        this.root.registerElementHasRemovedNodes(elem);\n    }\n    /**\n     * `getChange` creates a new instance of Change in this context.\n     */\n    getChange() {\n        return Change.create({\n            id: this.id,\n            operations: this.operations,\n            presenceChange: this.presenceChange,\n            message: this.message,\n        });\n    }\n    /**\n     * `hasChange` returns whether this context has change or not.\n     */\n    hasChange() {\n        return this.operations.length > 0 || this.presenceChange !== undefined;\n    }\n    /**\n     * `setPresenceChange` registers the presence change to this context.\n     */\n    setPresenceChange(presenceChange) {\n        this.presenceChange = presenceChange;\n    }\n    /**\n     * `setReversePresence` registers the previous presence to undo presence updates.\n     */\n    setReversePresence(presence, option) {\n        for (const key of Object.keys(presence)) {\n            if (option === null || option === void 0 ? void 0 : option.addToHistory) {\n                this.reversePresenceKeys.add(key);\n            }\n            else {\n                this.reversePresenceKeys.delete(key);\n            }\n        }\n    }\n    /**\n     * `toReversePresence` returns the reverse presence of this context.\n     */\n    getReversePresence() {\n        if (this.reversePresenceKeys.size === 0)\n            return undefined;\n        const reversePresence = {};\n        for (const key of this.reversePresenceKeys) {\n            reversePresence[key] = this.previousPresence[key];\n        }\n        return reversePresence;\n    }\n    /**\n     * `issueTimeTicket` creates a time ticket to be used to create a new operation.\n     */\n    issueTimeTicket() {\n        this.delimiter += 1;\n        return this.id.createTimeTicket(this.delimiter);\n    }\n    /**\n     * `getLastTimeTicket` returns the last time ticket issued in this context.\n     */\n    getLastTimeTicket() {\n        return this.id.createTimeTicket(this.delimiter);\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/crdt/root.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n/**\n * `CRDTRoot` is a structure that represents the root. It has a hash table of\n * all elements to find a specific element when applying remote changes\n * received from server.\n *\n * Every element has a unique `TimeTicket` at creation, which allows us to find\n * a particular element.\n */\nclass CRDTRoot {\n    constructor(rootObject) {\n        this.rootObject = rootObject;\n        this.elementPairMapByCreatedAt = new Map();\n        this.removedElementSetByCreatedAt = new Set();\n        this.elementHasRemovedNodesSetByCreatedAt = new Set();\n        this.opsForTest = [];\n        this.registerElement(rootObject, undefined);\n    }\n    /**\n     * `create` creates a new instance of Root.\n     */\n    static create() {\n        return new CRDTRoot(CRDTObject.create(InitialTimeTicket));\n    }\n    /**\n     * `findByCreatedAt` returns the element of given creation time.\n     */\n    findByCreatedAt(createdAt) {\n        const pair = this.elementPairMapByCreatedAt.get(createdAt.toIDString());\n        if (!pair) {\n            return;\n        }\n        return pair.element;\n    }\n    /**\n     * `findElementPairByCreatedAt` returns the element and parent pair\n     * of given creation time.\n     */\n    findElementPairByCreatedAt(createdAt) {\n        return this.elementPairMapByCreatedAt.get(createdAt.toIDString());\n    }\n    /**\n     * `createSubPaths` creates an array of the sub paths for the given element.\n     */\n    createSubPaths(createdAt) {\n        let pair = this.elementPairMapByCreatedAt.get(createdAt.toIDString());\n        if (!pair) {\n            return [];\n        }\n        const subPaths = [];\n        while (pair.parent) {\n            const createdAt = pair.element.getCreatedAt();\n            const subPath = pair.parent.subPathOf(createdAt);\n            if (subPath === undefined) {\n                logger.fatal(`cant find the given element: ${createdAt.toIDString()}`);\n            }\n            subPaths.unshift(subPath);\n            pair = this.elementPairMapByCreatedAt.get(pair.parent.getCreatedAt().toIDString());\n        }\n        subPaths.unshift('$');\n        return subPaths;\n    }\n    /**\n     * `createPath` creates path of the given element.\n     */\n    createPath(createdAt) {\n        return this.createSubPaths(createdAt).join('.');\n    }\n    /**\n     * `registerElement` registers the given element and its descendants to hash table.\n     */\n    registerElement(element, parent) {\n        this.elementPairMapByCreatedAt.set(element.getCreatedAt().toIDString(), {\n            parent,\n            element,\n        });\n        if (element instanceof CRDTContainer) {\n            element.getDescendants((elem, parent) => {\n                this.registerElement(elem, parent);\n                return false;\n            });\n        }\n    }\n    /**\n     * `deregisterElement` deregister the given element and its descendants from hash table.\n     */\n    deregisterElement(element) {\n        let count = 0;\n        const deregisterElementInternal = (elem) => {\n            const createdAt = elem.getCreatedAt().toIDString();\n            this.elementPairMapByCreatedAt.delete(createdAt);\n            this.removedElementSetByCreatedAt.delete(createdAt);\n            count++;\n            if (elem instanceof CRDTContainer) {\n                elem.getDescendants((e) => {\n                    deregisterElementInternal(e);\n                    return false;\n                });\n            }\n        };\n        deregisterElementInternal(element);\n        return count;\n    }\n    /**\n     * `registerRemovedElement` registers the given element to the hash set.\n     */\n    registerRemovedElement(element) {\n        this.removedElementSetByCreatedAt.add(element.getCreatedAt().toIDString());\n    }\n    /**\n     * `registerElementHasRemovedNodes` registers the given GC element to the\n     * hash set.\n     */\n    registerElementHasRemovedNodes(elem) {\n        this.elementHasRemovedNodesSetByCreatedAt.add(elem.getCreatedAt().toIDString());\n    }\n    /**\n     * `getElementMapSize` returns the size of element map.\n     */\n    getElementMapSize() {\n        return this.elementPairMapByCreatedAt.size;\n    }\n    /**\n     * `getRemovedElementSetSize()` returns the size of removed element set.\n     */\n    getRemovedElementSetSize() {\n        return this.removedElementSetByCreatedAt.size;\n    }\n    /**\n     * `getObject` returns root object.\n     */\n    getObject() {\n        return this.rootObject;\n    }\n    /**\n     * `getGarbageLen` returns length of nodes which can be garbage collected.\n     */\n    getGarbageLen() {\n        let count = 0;\n        for (const createdAt of this.removedElementSetByCreatedAt) {\n            count++;\n            const pair = this.elementPairMapByCreatedAt.get(createdAt);\n            if (pair.element instanceof CRDTContainer) {\n                pair.element.getDescendants(() => {\n                    count++;\n                    return false;\n                });\n            }\n        }\n        for (const createdAt of this.elementHasRemovedNodesSetByCreatedAt) {\n            const pair = this.elementPairMapByCreatedAt.get(createdAt);\n            const elem = pair.element;\n            count += elem.getRemovedNodesLen();\n        }\n        return count;\n    }\n    /**\n     * `deepcopy` copies itself deeply.\n     */\n    deepcopy() {\n        return new CRDTRoot(this.rootObject.deepcopy());\n    }\n    /**\n     * `garbageCollect` purges elements that were removed before the given time.\n     */\n    garbageCollect(ticket) {\n        let count = 0;\n        for (const createdAt of this.removedElementSetByCreatedAt) {\n            const pair = this.elementPairMapByCreatedAt.get(createdAt);\n            if (pair.element.getRemovedAt() &&\n                ticket.compare(pair.element.getRemovedAt()) >= 0) {\n                pair.parent.purge(pair.element);\n                count += this.deregisterElement(pair.element);\n            }\n        }\n        for (const createdAt of this.elementHasRemovedNodesSetByCreatedAt) {\n            const pair = this.elementPairMapByCreatedAt.get(createdAt);\n            const elem = pair.element;\n            const removedNodeCnt = elem.purgeRemovedNodesBefore(ticket);\n            if (removedNodeCnt > 0) {\n                this.elementHasRemovedNodesSetByCreatedAt.delete(elem.getCreatedAt().toIDString());\n            }\n            count += removedNodeCnt;\n        }\n        return count;\n    }\n    /**\n     * `toJSON` returns the JSON encoding of this root object.\n     */\n    toJSON() {\n        return this.rootObject.toJSON();\n    }\n    /**\n     * `toSortedJSON` returns the sorted JSON encoding of this root object.\n     */\n    toSortedJSON() {\n        return this.rootObject.toSortedJSON();\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/json/object.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n/**\n * `createJSONObject` creates a new instance of JSONObject.\n */\nfunction createJSONObject(context, target) {\n    const objectProxy = new ObjectProxy(context);\n    return new Proxy(target, objectProxy.getHandlers());\n}\n/**\n * `ObjectProxy` is a proxy representing `Object`.\n */\nclass ObjectProxy {\n    constructor(context) {\n        this.context = context;\n        this.handlers = {\n            set: (target, key, value) => {\n                if (logger.isEnabled(LogLevel.Trivial)) {\n                    logger.trivial(`obj[${key}]=${JSON.stringify(value)}`);\n                }\n                ObjectProxy.setInternal(context, target, key, value);\n                return true;\n            },\n            get: (target, keyOrMethod) => {\n                if (logger.isEnabled(LogLevel.Trivial)) {\n                    logger.trivial(`obj[${keyOrMethod}]`);\n                }\n                if (keyOrMethod === 'getID') {\n                    return () => {\n                        return target.getCreatedAt();\n                    };\n                }\n                else if (keyOrMethod === 'toJSON' || keyOrMethod === 'toString') {\n                    return () => {\n                        return target.toJSON();\n                    };\n                }\n                else if (keyOrMethod === 'toJS') {\n                    return () => {\n                        return target.toJS();\n                    };\n                }\n                else if (keyOrMethod === 'toJSForTest') {\n                    return () => {\n                        return target.toJSForTest();\n                    };\n                }\n                return toJSONElement(context, target.get(keyOrMethod));\n            },\n            ownKeys: (target) => {\n                return target.getKeys();\n            },\n            getOwnPropertyDescriptor: () => {\n                return {\n                    enumerable: true,\n                    configurable: true,\n                };\n            },\n            deleteProperty: (target, key) => {\n                if (logger.isEnabled(LogLevel.Trivial)) {\n                    logger.trivial(`obj[${key}]`);\n                }\n                ObjectProxy.deleteInternal(context, target, key);\n                return true;\n            },\n        };\n    }\n    /**\n     * `setInternal` sets a new Object for the given key\n     */\n    static setInternal(context, target, key, value) {\n        if (key.includes('.')) {\n            throw new YorkieError(error_Code.InvalidObjectKey, `key must not contain the '.'.`);\n        }\n        const createdAt = context.issueTimeTicket();\n        const element = buildCRDTElement(context, value, createdAt);\n        const removed = target.set(key, element, createdAt);\n        context.registerElement(element, target);\n        if (removed) {\n            context.registerRemovedElement(removed);\n        }\n        context.push(SetOperation.create(key, element.deepcopy(), target.getCreatedAt(), createdAt));\n    }\n    /**\n     * `buildObjectMembers` constructs an object where all values from the\n     * user-provided object are transformed into CRDTElements.\n     * This function takes an object and iterates through its values,\n     * converting each value into a corresponding CRDTElement.\n     */\n    static buildObjectMembers(context, value) {\n        const members = {};\n        for (const [k, v] of Object.entries(value)) {\n            if (k.includes('.')) {\n                throw new YorkieError(error_Code.InvalidObjectKey, `key must not contain the '.'.`);\n            }\n            const createdAt = context.issueTimeTicket();\n            const elem = buildCRDTElement(context, v, createdAt);\n            members[k] = elem;\n        }\n        return members;\n    }\n    /**\n     * `deleteInternal` deletes the value of the given key.\n     */\n    static deleteInternal(context, target, key) {\n        const ticket = context.issueTimeTicket();\n        const deleted = target.deleteByKey(key, ticket);\n        if (!deleted) {\n            return;\n        }\n        context.push(RemoveOperation.create(target.getCreatedAt(), deleted.getCreatedAt(), ticket));\n        context.registerRemovedElement(deleted);\n    }\n    /**\n     * `getHandlers` gets handlers.\n     */\n    getHandlers() {\n        return this.handlers;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/json/array.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n/**\n * `createJSONArray` creates a new instance of JSONArray.\n */\nfunction createJSONArray(context, target) {\n    const arrayProxy = new ArrayProxy(context, target);\n    return new Proxy(target, arrayProxy.getHandlers());\n}\n/**\n * `isNumericString` checks if value is numeric string.\n */\nfunction isNumericString(val) {\n    if (typeof val === 'string' || val instanceof String) {\n        return !isNaN(val);\n    }\n    return false;\n}\n/**\n * `isReadOnlyArrayMethod` checks if the method is a standard array read-only operation.\n */\nfunction isReadOnlyArrayMethod(method) {\n    return [\n        'concat',\n        'entries',\n        'every',\n        'filter',\n        'find',\n        'findIndex',\n        'forEach',\n        'join',\n        'keys',\n        'map',\n        'reduce',\n        'reduceRight',\n        'slice',\n        'some',\n        'toLocaleString',\n        'toString',\n        'values',\n    ].includes(method);\n}\n/**\n * `ArrayProxy` is a proxy for Array.\n */\nclass ArrayProxy {\n    constructor(context, array) {\n        this.context = context;\n        this.array = array;\n        this.handlers = {\n            get: (target, method, receiver) => {\n                if (method === 'getID') {\n                    return () => {\n                        return target.getCreatedAt();\n                    };\n                }\n                else if (method === 'getElementByID') {\n                    return (createdAt) => {\n                        const elem = target.getByID(createdAt);\n                        if (!elem || elem.isRemoved()) {\n                            return;\n                        }\n                        return toWrappedElement(context, elem);\n                    };\n                }\n                else if (method === 'getElementByIndex') {\n                    return (index) => {\n                        const elem = target.get(index);\n                        return toWrappedElement(context, elem);\n                    };\n                }\n                else if (method === 'getLast') {\n                    return () => {\n                        return toWrappedElement(context, target.getLast());\n                    };\n                }\n                else if (method === 'deleteByID') {\n                    return (createdAt) => {\n                        const deleted = ArrayProxy.deleteInternalByID(context, target, createdAt);\n                        return toWrappedElement(context, deleted);\n                    };\n                }\n                else if (method === 'insertAfter') {\n                    return (prevID, value) => {\n                        const inserted = ArrayProxy.insertAfterInternal(context, target, prevID, value);\n                        return toWrappedElement(context, inserted);\n                    };\n                }\n                else if (method === 'insertBefore') {\n                    return (nextID, value) => {\n                        const inserted = ArrayProxy.insertBeforeInternal(context, target, nextID, value);\n                        return toWrappedElement(context, inserted);\n                    };\n                }\n                else if (method === 'moveBefore') {\n                    return (nextID, id) => {\n                        ArrayProxy.moveBeforeInternal(context, target, nextID, id);\n                    };\n                    // JavaScript Native API\n                }\n                else if (method === 'moveAfter') {\n                    return (prevID, id) => {\n                        ArrayProxy.moveAfterInternal(context, target, prevID, id);\n                    };\n                }\n                else if (method === 'moveFront') {\n                    return (id) => {\n                        ArrayProxy.moveFrontInternal(context, target, id);\n                    };\n                }\n                else if (method === 'moveLast') {\n                    return (id) => {\n                        ArrayProxy.moveLastInternal(context, target, id);\n                    };\n                }\n                else if (isNumericString(method)) {\n                    return toJSONElement(context, target.get(Number(method)));\n                }\n                else if (method === 'push') {\n                    return (value) => {\n                        return ArrayProxy.pushInternal(context, target, value);\n                    };\n                }\n                else if (method === 'splice') {\n                    return (start, deleteCount, ...items) => {\n                        return ArrayProxy.splice(context, target, start, deleteCount, ...items);\n                    };\n                }\n                else if (method === 'length') {\n                    return target.length;\n                }\n                else if (typeof method === 'symbol' && method === Symbol.iterator) {\n                    return ArrayProxy.iteratorInternal.bind(this, context, target);\n                }\n                else if (method === 'includes') {\n                    return (searchElement, fromIndex) => {\n                        return ArrayProxy.includes(context, target, searchElement, fromIndex);\n                    };\n                }\n                else if (method === 'indexOf') {\n                    return (searchElement, fromIndex) => {\n                        return ArrayProxy.indexOf(context, target, searchElement, fromIndex);\n                    };\n                }\n                else if (method === 'lastIndexOf') {\n                    return (searchElement, fromIndex) => {\n                        return ArrayProxy.lastIndexOf(context, target, searchElement, fromIndex);\n                    };\n                }\n                else if (method === 'toTestString') {\n                    return () => ArrayProxy.toTestString(target);\n                }\n                else if (typeof method === 'string' &&\n                    isReadOnlyArrayMethod(method)) {\n                    return (...args) => {\n                        const arr = Array.from(target).map((elem) => toJSONElement(context, elem));\n                        return Array.prototype[method].apply(arr, args);\n                    };\n                }\n                // TODO we need to distinguish between the case we need to call default\n                // behavior and the case where we need to call an internal method\n                // throw new TypeError(`Unsupported method: ${String(method)}`);\n                return Reflect.get(target, method, receiver);\n            },\n            deleteProperty: (target, key) => {\n                if (logger.isEnabled(LogLevel.Trivial)) {\n                    logger.trivial(`array[${key}]`);\n                }\n                ArrayProxy.deleteInternalByIndex(context, target, Number.parseInt(key));\n                return true;\n            },\n        };\n    }\n    // eslint-disable-next-line jsdoc/require-jsdoc\n    static *iteratorInternal(change, target) {\n        for (const elem of target) {\n            yield toWrappedElement(change, elem);\n        }\n    }\n    /**\n     * `buildArrayElements` constructs array elements based on the user-provided array.\n     */\n    static buildArrayElements(context, value) {\n        const elements = [];\n        for (const v of value) {\n            const createdAt = context.issueTimeTicket();\n            const elem = buildCRDTElement(context, v, createdAt);\n            elements.push(elem);\n        }\n        return elements;\n    }\n    /**\n     * `pushInternal` pushes the value to the target array.\n     */\n    static pushInternal(context, target, value) {\n        ArrayProxy.insertAfterInternal(context, target, target.getLastCreatedAt(), value);\n        return target.length;\n    }\n    /**\n     * `moveBeforeInternal` moves the given `createdAt` element\n     * after the previously created element.\n     */\n    static moveBeforeInternal(context, target, nextCreatedAt, createdAt) {\n        const ticket = context.issueTimeTicket();\n        const prevCreatedAt = target.getPrevCreatedAt(nextCreatedAt);\n        target.moveAfter(prevCreatedAt, createdAt, ticket);\n        context.push(MoveOperation.create(target.getCreatedAt(), prevCreatedAt, createdAt, ticket));\n    }\n    /**\n     * `moveAfterInternal` moves the given `createdAt` element\n     * after the specific element.\n     */\n    static moveAfterInternal(context, target, prevCreatedAt, createdAt) {\n        const ticket = context.issueTimeTicket();\n        target.moveAfter(prevCreatedAt, createdAt, ticket);\n        context.push(MoveOperation.create(target.getCreatedAt(), prevCreatedAt, createdAt, ticket));\n    }\n    /**\n     * `moveFrontInternal` moves the given `createdAt` element\n     * at the first of array.\n     */\n    static moveFrontInternal(context, target, createdAt) {\n        const ticket = context.issueTimeTicket();\n        const head = target.getHead();\n        target.moveAfter(head.getCreatedAt(), createdAt, ticket);\n        context.push(MoveOperation.create(target.getCreatedAt(), head.getCreatedAt(), createdAt, ticket));\n    }\n    /**\n     * `moveLastInternal` moves the given `createdAt` element\n     * at the last of array.\n     */\n    static moveLastInternal(context, target, createdAt) {\n        const ticket = context.issueTimeTicket();\n        const last = target.getLastCreatedAt();\n        target.moveAfter(last, createdAt, ticket);\n        context.push(MoveOperation.create(target.getCreatedAt(), last, createdAt, ticket));\n    }\n    /**\n     * `insertAfterInternal` inserts the value after the previously created element.\n     */\n    static insertAfterInternal(context, target, prevCreatedAt, value) {\n        const createdAt = context.issueTimeTicket();\n        const element = buildCRDTElement(context, value, createdAt);\n        target.insertAfter(prevCreatedAt, element);\n        context.registerElement(element, target);\n        context.push(AddOperation.create(target.getCreatedAt(), prevCreatedAt, element.deepcopy(), createdAt));\n        return element;\n    }\n    /**\n     * `insertBeforeInternal` inserts the value before the previously created element.\n     */\n    static insertBeforeInternal(context, target, nextCreatedAt, value) {\n        return ArrayProxy.insertAfterInternal(context, target, target.getPrevCreatedAt(nextCreatedAt), value);\n    }\n    /**\n     * `deleteInternalByIndex` deletes target element of given index.\n     */\n    static deleteInternalByIndex(context, target, index) {\n        const ticket = context.issueTimeTicket();\n        const deleted = target.deleteByIndex(index, ticket);\n        if (!deleted) {\n            return;\n        }\n        context.push(RemoveOperation.create(target.getCreatedAt(), deleted.getCreatedAt(), ticket));\n        context.registerRemovedElement(deleted);\n        return deleted;\n    }\n    /**\n     * `deleteInternalByID` deletes the element of the given ID.\n     */\n    static deleteInternalByID(context, target, createdAt) {\n        const ticket = context.issueTimeTicket();\n        const deleted = target.delete(createdAt, ticket);\n        context.push(RemoveOperation.create(target.getCreatedAt(), deleted.getCreatedAt(), ticket));\n        context.registerRemovedElement(deleted);\n        return deleted;\n    }\n    /**\n     * `splice` is a method to remove elements from the array.\n     */\n    static splice(context, target, start, deleteCount, ...items) {\n        const length = target.length;\n        const from = start >= 0 ? Math.min(start, length) : Math.max(length + start, 0);\n        const to = deleteCount === undefined\n            ? length\n            : deleteCount < 0\n                ? from\n                : Math.min(from + deleteCount, length);\n        const removeds = [];\n        for (let i = from; i < to; i++) {\n            const removed = ArrayProxy.deleteInternalByIndex(context, target, from);\n            if (removed) {\n                const removedElem = removed.deepcopy();\n                removedElem.setRemovedAt();\n                removeds.push(toJSONElement(context, removedElem));\n            }\n        }\n        if (items) {\n            let previousID = from === 0 ? target.getHead().getID() : target.get(from - 1).getID();\n            for (const item of items) {\n                const newElem = ArrayProxy.insertAfterInternal(context, target, previousID, item);\n                previousID = newElem.getID();\n            }\n        }\n        return removeds;\n    }\n    /**\n     * `includes` returns true if the given element is in the array.\n     */\n    static includes(context, target, searchElement, fromIndex) {\n        var _a;\n        const length = target.length;\n        const from = fromIndex === undefined\n            ? 0\n            : fromIndex < 0\n                ? Math.max(fromIndex + length, 0)\n                : fromIndex;\n        if (from >= length)\n            return false;\n        if (Primitive.isSupport(searchElement)) {\n            const arr = Array.from(target).map((elem) => toJSONElement(context, elem));\n            return arr.includes(searchElement, from);\n        }\n        for (let i = from; i < length; i++) {\n            if (((_a = target.get(i)) === null || _a === void 0 ? void 0 : _a.getID()) === searchElement.getID()) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * `indexOf` returns the index of the given element.\n     */\n    static indexOf(context, target, searchElement, fromIndex) {\n        var _a;\n        const length = target.length;\n        const from = fromIndex === undefined\n            ? 0\n            : fromIndex < 0\n                ? Math.max(fromIndex + length, 0)\n                : fromIndex;\n        if (from >= length)\n            return -1;\n        if (Primitive.isSupport(searchElement)) {\n            const arr = Array.from(target).map((elem) => toJSONElement(context, elem));\n            return arr.indexOf(searchElement, from);\n        }\n        for (let i = from; i < length; i++) {\n            if (((_a = target.get(i)) === null || _a === void 0 ? void 0 : _a.getID()) === searchElement.getID()) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    /**\n     * `lastIndexOf` returns the last index of the given element.\n     */\n    static lastIndexOf(context, target, searchElement, fromIndex) {\n        var _a;\n        const length = target.length;\n        const from = fromIndex === undefined || fromIndex >= length\n            ? length - 1\n            : fromIndex < 0\n                ? fromIndex + length\n                : fromIndex;\n        if (from < 0)\n            return -1;\n        if (Primitive.isSupport(searchElement)) {\n            const arr = Array.from(target).map((elem) => toJSONElement(context, elem));\n            return arr.lastIndexOf(searchElement, from);\n        }\n        for (let i = from; i > 0; i--) {\n            if (((_a = target.get(i)) === null || _a === void 0 ? void 0 : _a.getID()) === searchElement.getID()) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    /**\n     * `toTestString` returns a String containing the meta data of the node\n     * for debugging purpose.\n     */\n    static toTestString(target) {\n        return target.toTestString();\n    }\n    /**\n     * `getHandlers` gets handlers.\n     */\n    getHandlers() {\n        return this.handlers;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/json/text.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n/**\n * `Text` is an extended data type for the contents of a text editor.\n */\nclass Text {\n    constructor(context, text) {\n        this.context = context;\n        this.text = text;\n    }\n    /**\n     * `initialize` initialize this text with context and internal text.\n     * @internal\n     */\n    initialize(context, text) {\n        this.context = context;\n        this.text = text;\n    }\n    /**\n     * `getID` returns the ID of this text.\n     */\n    getID() {\n        return this.text.getID();\n    }\n    /**\n     * `edit` edits this text with the given content.\n     */\n    edit(fromIdx, toIdx, content, attributes) {\n        if (!this.context || !this.text) {\n            logger.fatal('it is not initialized yet');\n            return;\n        }\n        if (fromIdx > toIdx) {\n            logger.fatal('from should be less than or equal to to');\n            return;\n        }\n        const range = this.text.indexRangeToPosRange(fromIdx, toIdx);\n        if (logger.isEnabled(LogLevel.Debug)) {\n            logger.debug(`EDIT: f:${fromIdx}->${range[0].toTestString()}, t:${toIdx}->${range[1].toTestString()} c:${content}`);\n        }\n        const attrs = attributes ? stringifyObjectValues(attributes) : undefined;\n        const ticket = this.context.issueTimeTicket();\n        const [maxCreatedAtMapByActor, , rangeAfterEdit] = this.text.edit(range, content, ticket, attrs);\n        this.context.push(new EditOperation(this.text.getCreatedAt(), range[0], range[1], maxCreatedAtMapByActor, content, attrs ? new Map(Object.entries(attrs)) : new Map(), ticket));\n        if (!range[0].equals(range[1])) {\n            this.context.registerElementHasRemovedNodes(this.text);\n        }\n        return this.text.findIndexesFromRange(rangeAfterEdit);\n    }\n    /**\n     * `delete` deletes the text in the given range.\n     */\n    delete(fromIdx, toIdx) {\n        return this.edit(fromIdx, toIdx, '');\n    }\n    /**\n     * `empty` makes the text empty.\n     */\n    empty() {\n        return this.edit(0, this.length, '');\n    }\n    /**\n     * `setStyle` styles this text with the given attributes.\n     */\n    setStyle(fromIdx, toIdx, attributes) {\n        if (!this.context || !this.text) {\n            logger.fatal('it is not initialized yet');\n            return false;\n        }\n        if (fromIdx > toIdx) {\n            logger.fatal('from should be less than or equal to to');\n            return false;\n        }\n        const range = this.text.indexRangeToPosRange(fromIdx, toIdx);\n        if (logger.isEnabled(LogLevel.Debug)) {\n            logger.debug(`STYL: f:${fromIdx}->${range[0].toTestString()}, t:${toIdx}->${range[1].toTestString()} a:${JSON.stringify(attributes)}`);\n        }\n        const attrs = stringifyObjectValues(attributes);\n        const ticket = this.context.issueTimeTicket();\n        const [maxCreatedAtMapByActor] = this.text.setStyle(range, attrs, ticket);\n        this.context.push(new StyleOperation(this.text.getCreatedAt(), range[0], range[1], maxCreatedAtMapByActor, new Map(Object.entries(attrs)), ticket));\n        return true;\n    }\n    /**\n     * `indexRangeToPosRange` returns TextRangeStruct of the given index range.\n     */\n    indexRangeToPosRange(range) {\n        if (!this.context || !this.text) {\n            logger.fatal('it is not initialized yet');\n            // @ts-ignore\n            return;\n        }\n        const textRange = this.text.indexRangeToPosRange(range[0], range[1]);\n        return [textRange[0].toStruct(), textRange[1].toStruct()];\n    }\n    /**\n     * `posRangeToIndexRange` returns indexes of the given TextRangeStruct.\n     */\n    posRangeToIndexRange(range) {\n        if (!this.context || !this.text) {\n            logger.fatal('it is not initialized yet');\n            // @ts-ignore\n            return;\n        }\n        const textRange = this.text.findIndexesFromRange([\n            RGATreeSplitPos.fromStruct(range[0]),\n            RGATreeSplitPos.fromStruct(range[1]),\n        ]);\n        return [textRange[0], textRange[1]];\n    }\n    /**\n     * `toTestString` returns a String containing the meta data of the node\n     * for debugging purpose.\n     */\n    toTestString() {\n        if (!this.context || !this.text) {\n            logger.fatal('it is not initialized yet');\n            // @ts-ignore\n            return;\n        }\n        return this.text.toTestString();\n    }\n    /**\n     * `values` returns values of this text.\n     */\n    values() {\n        if (!this.context || !this.text) {\n            logger.fatal('it is not initialized yet');\n            // @ts-ignore\n            return;\n        }\n        return this.text.values();\n    }\n    /**\n     * `length` returns size of RGATreeList.\n     */\n    get length() {\n        return this.text.length;\n    }\n    /**\n     * `checkWeight` returns false when there is an incorrect weight node.\n     * for debugging purpose.\n     */\n    checkWeight() {\n        return this.text.checkWeight();\n    }\n    /**\n     * `toString` returns the string representation of this text.\n     */\n    toString() {\n        if (!this.context || !this.text) {\n            logger.fatal('it is not initialized yet');\n            return '';\n        }\n        return this.text.toString();\n    }\n    /**\n     * `createRangeForTest` returns pair of RGATreeSplitNodePos of the given indexes\n     * for testing purpose.\n     */\n    createRangeForTest(fromIdx, toIdx) {\n        if (!this.context || !this.text) {\n            logger.fatal('it is not initialized yet');\n            // @ts-ignore\n            return;\n        }\n        return this.text.indexRangeToPosRange(fromIdx, toIdx);\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/json/counter.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n/**\n * `Counter` is a custom data type that is used to counter.\n */\nclass Counter {\n    constructor(valueType, value) {\n        this.valueType = valueType;\n        this.value = value;\n    }\n    /**\n     * `initialize` initialize this text with context and internal text.\n     * @internal\n     */\n    initialize(context, counter) {\n        this.valueType = counter.getValueType();\n        this.context = context;\n        this.counter = counter;\n        this.value = counter.getValue();\n    }\n    /**\n     * `getID` returns the ID of this text.\n     */\n    getID() {\n        return this.counter.getID();\n    }\n    /**\n     * `getValue` returns the value of this counter;\n     * @internal\n     */\n    getValue() {\n        return this.value;\n    }\n    /**\n     * `getValueType` returns the value type of this counter.\n     */\n    getValueType() {\n        return this.valueType;\n    }\n    /**\n     * `increase` increases numeric data.\n     */\n    increase(v) {\n        if (!this.context || !this.counter) {\n            logger.fatal('it is not initialized yet');\n            // @ts-ignore\n            return;\n        }\n        const ticket = this.context.issueTimeTicket();\n        const value = Primitive.of(v, ticket);\n        if (!value.isNumericType()) {\n            throw new TypeError(`Unsupported type of value: ${typeof value.getValue()}`);\n        }\n        this.counter.increase(value);\n        this.context.push(IncreaseOperation.create(this.counter.getCreatedAt(), value, ticket));\n        return this;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/json/tree.ts\n/*\n * Copyright 2023 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n/**\n * `buildDescendants` builds descendants of the given tree node.\n */\nfunction buildDescendants(treeNode, parent, context) {\n    const { type } = treeNode;\n    const ticket = context.issueTimeTicket();\n    if (type === DefaultTextType) {\n        validateTextNode(treeNode);\n        const { value } = treeNode;\n        const textNode = CRDTTreeNode.create(CRDTTreeNodeID.of(ticket, 0), type, value);\n        parent.append(textNode);\n    }\n    else {\n        const { children = [] } = treeNode;\n        let { attributes } = treeNode;\n        let attrs;\n        if (typeof attributes === 'object' && !isEmpty(attributes)) {\n            attributes = stringifyObjectValues(attributes);\n            attrs = new RHT();\n            for (const [key, value] of Object.entries(attributes)) {\n                attrs.set(key, value, ticket);\n            }\n        }\n        const elementNode = CRDTTreeNode.create(CRDTTreeNodeID.of(ticket, 0), type, undefined, attrs);\n        parent.append(elementNode);\n        for (const child of children) {\n            buildDescendants(child, elementNode, context);\n        }\n    }\n}\n/**\n * createCRDTTreeNode returns CRDTTreeNode by given TreeNode.\n */\nfunction createCRDTTreeNode(context, content) {\n    const { type } = content;\n    const ticket = context.issueTimeTicket();\n    let root;\n    if (content.type === DefaultTextType) {\n        const { value } = content;\n        root = CRDTTreeNode.create(CRDTTreeNodeID.of(ticket, 0), type, value);\n    }\n    else if (content) {\n        const { children = [] } = content;\n        let { attributes } = content;\n        let attrs;\n        if (typeof attributes === 'object' && !isEmpty(attributes)) {\n            attributes = stringifyObjectValues(attributes);\n            attrs = new RHT();\n            for (const [key, value] of Object.entries(attributes)) {\n                attrs.set(key, value, ticket);\n            }\n        }\n        root = CRDTTreeNode.create(CRDTTreeNodeID.of(context.issueTimeTicket(), 0), type, undefined, attrs);\n        for (const child of children) {\n            buildDescendants(child, root, context);\n        }\n    }\n    return root;\n}\n/**\n * `validateTextNode` ensures that a text node has a non-empty string value.\n */\nfunction validateTextNode(textNode) {\n    if (!textNode.value.length) {\n        throw new Error('text node cannot have empty value');\n    }\n    return true;\n}\n/**\n * `validateTreeNodes` ensures that treeNodes consists of only one type.\n */\nfunction validateTreeNodes(treeNodes) {\n    if (!treeNodes.length) {\n        return true;\n    }\n    const firstTreeNodeType = treeNodes[0].type;\n    if (firstTreeNodeType === DefaultTextType) {\n        for (const treeNode of treeNodes) {\n            const { type } = treeNode;\n            if (type !== DefaultTextType) {\n                throw new Error('element node and text node cannot be passed together');\n            }\n            validateTextNode(treeNode);\n        }\n    }\n    else {\n        for (const treeNode of treeNodes) {\n            const { type } = treeNode;\n            if (type === DefaultTextType) {\n                throw new Error('element node and text node cannot be passed together');\n            }\n        }\n    }\n    return true;\n}\n/**\n * `Tree` is a CRDT-based tree structure that is used to represent the document\n * tree of text-based editor such as ProseMirror.\n */\nclass Tree {\n    constructor(initialRoot) {\n        this.initialRoot = initialRoot;\n    }\n    /**\n     * `initialize` initialize this tree with context and internal tree.\n     * @internal\n     */\n    initialize(context, tree) {\n        this.context = context;\n        this.tree = tree;\n    }\n    /**\n     * `getID` returns the ID of this tree.\n     */\n    getID() {\n        return this.tree.getID();\n    }\n    /**\n     * `buildRoot` builds the root of this tree with the given initial root\n     * which set by the user.\n     */\n    buildRoot(context) {\n        if (!this.initialRoot) {\n            return CRDTTreeNode.create(CRDTTreeNodeID.of(context.issueTimeTicket(), 0), DefaultRootType);\n        }\n        // TODO(hackerwins): Need to use the ticket of operation of creating tree.\n        const root = CRDTTreeNode.create(CRDTTreeNodeID.of(context.issueTimeTicket(), 0), this.initialRoot.type);\n        for (const child of this.initialRoot.children) {\n            buildDescendants(child, root, context);\n        }\n        return root;\n    }\n    /**\n     * `getSize` returns the size of this tree.\n     */\n    getSize() {\n        if (!this.context || !this.tree) {\n            throw new Error('it is not initialized yet');\n        }\n        return this.tree.getSize();\n    }\n    /**\n     * `getIndexTree` returns the index tree of this tree.\n     */\n    getIndexTree() {\n        if (!this.context || !this.tree) {\n            throw new Error('it is not initialized yet');\n        }\n        return this.tree.getIndexTree();\n    }\n    /**\n     * `styleByPath` sets the attributes to the elements of the given path.\n     */\n    styleByPath(path, attributes) {\n        if (!this.context || !this.tree) {\n            throw new Error('it is not initialized yet');\n        }\n        if (!path.length) {\n            throw new Error('path should not be empty');\n        }\n        const [fromPos, toPos] = this.tree.pathToPosRange(path);\n        const ticket = this.context.issueTimeTicket();\n        const attrs = attributes ? stringifyObjectValues(attributes) : undefined;\n        this.tree.style([fromPos, toPos], attrs, ticket);\n        this.context.push(TreeStyleOperation.create(this.tree.getCreatedAt(), fromPos, toPos, attrs ? new Map(Object.entries(attrs)) : new Map(), ticket));\n    }\n    /**\n     * `style` sets the attributes to the elements of the given range.\n     */\n    style(fromIdx, toIdx, attributes) {\n        if (!this.context || !this.tree) {\n            throw new Error('it is not initialized yet');\n        }\n        if (fromIdx > toIdx) {\n            throw new Error('from should be less than or equal to to');\n        }\n        const fromPos = this.tree.findPos(fromIdx);\n        const toPos = this.tree.findPos(toIdx);\n        const ticket = this.context.issueTimeTicket();\n        const attrs = attributes ? stringifyObjectValues(attributes) : undefined;\n        this.tree.style([fromPos, toPos], attrs, ticket);\n        this.context.push(TreeStyleOperation.create(this.tree.getCreatedAt(), fromPos, toPos, attrs ? new Map(Object.entries(attrs)) : new Map(), ticket));\n    }\n    editInternal(fromPos, toPos, contents, splitLevel = 0) {\n        var _a;\n        if (contents.length !== 0 && contents[0]) {\n            validateTreeNodes(contents);\n            if (contents[0].type !== DefaultTextType) {\n                for (const content of contents) {\n                    const { children = [] } = content;\n                    validateTreeNodes(children);\n                }\n            }\n        }\n        const ticket = this.context.getLastTimeTicket();\n        let crdtNodes = new Array();\n        if (((_a = contents[0]) === null || _a === void 0 ? void 0 : _a.type) === DefaultTextType) {\n            let compVal = '';\n            for (const content of contents) {\n                const { value } = content;\n                compVal += value;\n            }\n            crdtNodes.push(CRDTTreeNode.create(CRDTTreeNodeID.of(this.context.issueTimeTicket(), 0), DefaultTextType, compVal));\n        }\n        else {\n            crdtNodes = contents\n                .map((content) => content && createCRDTTreeNode(this.context, content))\n                .filter((a) => a);\n        }\n        const [, maxCreatedAtMapByActor] = this.tree.edit([fromPos, toPos], crdtNodes.length\n            ? crdtNodes.map((crdtNode) => crdtNode === null || crdtNode === void 0 ? void 0 : crdtNode.deepcopy())\n            : undefined, splitLevel, ticket, () => this.context.issueTimeTicket());\n        this.context.push(TreeEditOperation.create(this.tree.getCreatedAt(), fromPos, toPos, crdtNodes.length ? crdtNodes : undefined, splitLevel, maxCreatedAtMapByActor, ticket));\n        if (!fromPos.equals(toPos)) {\n            this.context.registerElementHasRemovedNodes(this.tree);\n        }\n        return true;\n    }\n    /**\n     * `editByPath` edits this tree with the given node and path.\n     */\n    editByPath(fromPath, toPath, content, splitLevel = 0) {\n        if (!this.context || !this.tree) {\n            throw new Error('it is not initialized yet');\n        }\n        if (fromPath.length !== toPath.length) {\n            throw new Error('path length should be equal');\n        }\n        if (!fromPath.length || !toPath.length) {\n            throw new Error('path should not be empty');\n        }\n        const fromPos = this.tree.pathToPos(fromPath);\n        const toPos = this.tree.pathToPos(toPath);\n        return this.editInternal(fromPos, toPos, content ? [content] : [], splitLevel);\n    }\n    /**\n     * `editBulkByPath` edits this tree with the given node and path.\n     */\n    editBulkByPath(fromPath, toPath, contents, splitLevel = 0) {\n        if (!this.context || !this.tree) {\n            throw new Error('it is not initialized yet');\n        }\n        if (fromPath.length !== toPath.length) {\n            throw new Error('path length should be equal');\n        }\n        if (!fromPath.length || !toPath.length) {\n            throw new Error('path should not be empty');\n        }\n        const fromPos = this.tree.pathToPos(fromPath);\n        const toPos = this.tree.pathToPos(toPath);\n        return this.editInternal(fromPos, toPos, contents, splitLevel);\n    }\n    /**\n     * `edit` edits this tree with the given nodes.\n     */\n    edit(fromIdx, toIdx, content, splitLevel = 0) {\n        if (!this.context || !this.tree) {\n            throw new Error('it is not initialized yet');\n        }\n        if (fromIdx > toIdx) {\n            throw new Error('from should be less than or equal to to');\n        }\n        const fromPos = this.tree.findPos(fromIdx);\n        const toPos = this.tree.findPos(toIdx);\n        return this.editInternal(fromPos, toPos, content ? [content] : [], splitLevel);\n    }\n    /**\n     * `editBulk` edits this tree with the given nodes.\n     */\n    editBulk(fromIdx, toIdx, contents, splitLevel = 0) {\n        if (!this.context || !this.tree) {\n            throw new Error('it is not initialized yet');\n        }\n        if (fromIdx > toIdx) {\n            throw new Error('from should be less than or equal to to');\n        }\n        const fromPos = this.tree.findPos(fromIdx);\n        const toPos = this.tree.findPos(toIdx);\n        return this.editInternal(fromPos, toPos, contents, splitLevel);\n    }\n    /**\n     * `toXML` returns the XML string of this tree.\n     */\n    toXML() {\n        if (!this.context || !this.tree) {\n            throw new Error('it is not initialized yet');\n        }\n        return this.tree.toXML();\n    }\n    /**\n     * `toJSON` returns the JSON string of this tree.\n     */\n    toJSON() {\n        if (!this.context || !this.tree) {\n            throw new Error('it is not initialized yet');\n        }\n        return this.tree.toJSON();\n    }\n    /**\n     * `getRootTreeNode` returns TreeNode of this tree.\n     */\n    getRootTreeNode() {\n        if (!this.context || !this.tree) {\n            throw new Error('it is not initialized yet');\n        }\n        return this.tree.getRootTreeNode();\n    }\n    /**\n     * `indexToPath` returns the path of the given index.\n     */\n    indexToPath(index) {\n        if (!this.context || !this.tree) {\n            throw new Error('it is not initialized yet');\n        }\n        return this.tree.indexToPath(index);\n    }\n    /**\n     * `pathToIndex` returns the index of given path.\n     */\n    pathToIndex(path) {\n        if (!this.context || !this.tree) {\n            throw new Error('it is not initialized yet');\n        }\n        return this.tree.pathToIndex(path);\n    }\n    /**\n     * `pathRangeToPosRange` converts the path range into the position range.\n     */\n    pathRangeToPosRange(range) {\n        if (!this.context || !this.tree) {\n            logger.fatal('it is not initialized yet');\n            // @ts-ignore\n            return;\n        }\n        const indexRange = [\n            this.tree.pathToIndex(range[0]),\n            this.tree.pathToIndex(range[1]),\n        ];\n        const posRange = this.tree.indexRangeToPosRange(indexRange);\n        return [posRange[0].toStruct(), posRange[1].toStruct()];\n    }\n    /**\n     * `indexRangeToPosRange` converts the index range into the position range.\n     */\n    indexRangeToPosRange(range) {\n        if (!this.context || !this.tree) {\n            logger.fatal('it is not initialized yet');\n            // @ts-ignore\n            return;\n        }\n        return this.tree.indexRangeToPosStructRange(range);\n    }\n    /**\n     * `posRangeToIndexRange` converts the position range into the index range.\n     */\n    posRangeToIndexRange(range) {\n        if (!this.context || !this.tree) {\n            logger.fatal('it is not initialized yet');\n            // @ts-ignore\n            return;\n        }\n        const posRange = [\n            CRDTTreePos.fromStruct(range[0]),\n            CRDTTreePos.fromStruct(range[1]),\n        ];\n        return this.tree.posRangeToIndexRange(posRange, this.context.getLastTimeTicket());\n    }\n    /**\n     * `posRangeToPathRange` converts the position range into the path range.\n     */\n    posRangeToPathRange(range) {\n        if (!this.context || !this.tree) {\n            logger.fatal('it is not initialized yet');\n            // @ts-ignore\n            return;\n        }\n        const posRange = [\n            CRDTTreePos.fromStruct(range[0]),\n            CRDTTreePos.fromStruct(range[1]),\n        ];\n        return this.tree.posRangeToPathRange(posRange, this.context.getLastTimeTicket());\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/json/element.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * `createJSON` create a new instance of JSONObject.\n */\nfunction createJSON(context, target) {\n    return createJSONObject(context, target);\n}\n/**\n * `toWrappedElement` converts the CRDT type to `WrappedElement`.\n */\nfunction toWrappedElement(context, elem) {\n    if (!elem) {\n        return;\n    }\n    else if (elem instanceof Primitive) {\n        return elem;\n    }\n    else if (elem instanceof CRDTObject) {\n        return createJSONObject(context, elem);\n    }\n    else if (elem instanceof CRDTArray) {\n        return createJSONArray(context, elem);\n    }\n    else if (elem instanceof CRDTText) {\n        return new Text(context, elem);\n    }\n    else if (elem instanceof CRDTCounter) {\n        const counter = new Counter(CounterType.IntegerCnt, 0);\n        counter.initialize(context, elem);\n        return counter;\n    }\n    else if (elem instanceof CRDTTree) {\n        const tree = new Tree();\n        tree.initialize(context, elem);\n        return tree;\n    }\n    throw new TypeError(`Unsupported type of element: ${typeof elem}`);\n}\n/**\n * `toJSONElement` converts the CRDT type to `JSONElement`.\n */\nfunction toJSONElement(context, elem) {\n    const wrappedElement = toWrappedElement(context, elem);\n    if (wrappedElement instanceof Primitive) {\n        return wrappedElement.getValue();\n    }\n    return wrappedElement;\n}\n/**\n * `buildCRDTElement` constructs a CRDTElement from the given value.\n */\nfunction buildCRDTElement(context, value, createdAt) {\n    let element;\n    if (Primitive.isSupport(value)) {\n        element = Primitive.of(value, createdAt);\n    }\n    else if (Array.isArray(value)) {\n        element = CRDTArray.create(createdAt, ArrayProxy.buildArrayElements(context, value));\n    }\n    else if (typeof value === 'object') {\n        if (value instanceof Text) {\n            element = CRDTText.create(RGATreeSplit.create(), createdAt);\n            value.initialize(context, element);\n        }\n        else if (value instanceof Counter) {\n            element = CRDTCounter.create(value.getValueType(), value.getValue(), createdAt);\n            value.initialize(context, element);\n        }\n        else if (value instanceof Tree) {\n            element = CRDTTree.create(value.buildRoot(context), createdAt);\n            value.initialize(context, element);\n        }\n        else {\n            element = CRDTObject.create(createdAt, ObjectProxy.buildObjectMembers(context, value));\n        }\n    }\n    else {\n        throw new TypeError(`Unsupported type of value: ${typeof value}`);\n    }\n    return element;\n}\n\n;// CONCATENATED MODULE: ./src/document/history.ts\n/**\n * `MaxUndoRedoStackDepth` is the maximum depth of undo/redo stack.\n */\nconst MaxUndoRedoStackDepth = 50;\n/**\n * `History` is a class that stores the history of the document.\n */\nclass History {\n    constructor() {\n        this.undoStack = [];\n        this.redoStack = [];\n    }\n    /**\n     * `hasUndo` returns true if there are undo operations.\n     */\n    hasUndo() {\n        return this.undoStack.length > 0;\n    }\n    /**\n     * `hasRedo` returns true if there are redo operations.\n     */\n    hasRedo() {\n        return this.redoStack.length > 0;\n    }\n    /**\n     * `pushUndo` pushes new undo operations of a change to undo stack.\n     */\n    pushUndo(undoOps) {\n        if (this.undoStack.length >= MaxUndoRedoStackDepth) {\n            this.undoStack.shift();\n        }\n        this.undoStack.push(undoOps);\n    }\n    /**\n     * `popUndo` pops the last undo operations of a change from undo stack.\n     */\n    popUndo() {\n        return this.undoStack.pop();\n    }\n    /**\n     * `pushRedo` pushes new redo operations of a change to redo stack.\n     */\n    pushRedo(redoOps) {\n        if (this.redoStack.length >= MaxUndoRedoStackDepth) {\n            this.redoStack.shift();\n        }\n        this.redoStack.push(redoOps);\n    }\n    /**\n     * `popRedo` pops the last redo operations of a change from redo stack.\n     */\n    popRedo() {\n        return this.redoStack.pop();\n    }\n    /**\n     * `clearRedo` flushes remaining redo operations.\n     */\n    clearRedo() {\n        this.redoStack = [];\n    }\n    /**\n     * `getUndoStackForTest` returns the undo stack for test.\n     */\n    getUndoStackForTest() {\n        return this.undoStack;\n    }\n    /**\n     * `getRedoStackForTest` returns the redo stack for test.\n     */\n    getRedoStackForTest() {\n        return this.redoStack;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/document/document.ts\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * `DocumentStatus` represents the status of the document.\n * @public\n */\nvar DocumentStatus;\n(function (DocumentStatus) {\n    /**\n     * Detached means that the document is not attached to the client.\n     * The actor of the ticket is created without being assigned.\n     */\n    DocumentStatus[\"Detached\"] = \"detached\";\n    /**\n     * Attached means that this document is attached to the client.\n     * The actor of the ticket is created with being assigned by the client.\n     */\n    DocumentStatus[\"Attached\"] = \"attached\";\n    /**\n     * Removed means that this document is removed. If the document is removed,\n     * it cannot be edited.\n     */\n    DocumentStatus[\"Removed\"] = \"removed\";\n})(DocumentStatus || (DocumentStatus = {}));\n/**\n * `DocEventType` represents the type of the event that occurs in `Document`.\n * @public\n */\nvar DocEventType;\n(function (DocEventType) {\n    /**\n     * snapshot event type\n     */\n    DocEventType[\"Snapshot\"] = \"snapshot\";\n    /**\n     * local document change event type\n     */\n    DocEventType[\"LocalChange\"] = \"local-change\";\n    /**\n     * remote document change event type\n     */\n    DocEventType[\"RemoteChange\"] = \"remote-change\";\n    /**\n     * `Initialized` means that online clients have been loaded from the server.\n     */\n    DocEventType[\"Initialized\"] = \"initialized\";\n    /**\n     * `Watched` means that the client has established a connection with the server,\n     * enabling real-time synchronization.\n     */\n    DocEventType[\"Watched\"] = \"watched\";\n    /**\n     * `Unwatched` means that the connection has been disconnected.\n     */\n    DocEventType[\"Unwatched\"] = \"unwatched\";\n    /**\n     * `PresenceChanged` means that the presences of the client has updated.\n     */\n    DocEventType[\"PresenceChanged\"] = \"presence-changed\";\n})(DocEventType || (DocEventType = {}));\n/**\n * `Document` is a CRDT-based data type. We can represent the model\n * of the application and edit it even while offline.\n *\n * @public\n */\nclass Document {\n    constructor(key, opts) {\n        this.opts = opts || {};\n        this.key = key;\n        this.status = DocumentStatus.Detached;\n        this.root = CRDTRoot.create();\n        this.changeID = InitialChangeID;\n        this.checkpoint = InitialCheckpoint;\n        this.localChanges = [];\n        this.eventStream = createObservable((observer) => {\n            this.eventStreamObserver = observer;\n        });\n        this.onlineClients = new Set();\n        this.presences = new Map();\n        this.isUpdating = false;\n        this.internalHistory = new History();\n        this.history = {\n            canUndo: this.canUndo.bind(this),\n            canRedo: this.canRedo.bind(this),\n            undo: this.undo.bind(this),\n            redo: this.redo.bind(this),\n        };\n    }\n    /**\n     * `update` executes the given updater to update this document.\n     */\n    update(updater, message) {\n        if (this.getStatus() === DocumentStatus.Removed) {\n            throw new YorkieError(error_Code.DocumentRemoved, `${this.key} is removed`);\n        }\n        // 01. Update the clone object and create a change.\n        this.ensureClone();\n        const actorID = this.changeID.getActorID();\n        const context = ChangeContext.create(this.changeID.next(), this.clone.root, this.clone.presences.get(actorID) || {}, message);\n        try {\n            const proxy = createJSON(context, this.clone.root.getObject());\n            if (!this.presences.has(actorID)) {\n                this.clone.presences.set(actorID, {});\n            }\n            // NOTE(hackerwins): The updater should not be able to call undo/redo.\n            // If the updater calls undo/redo, an error will be thrown.\n            this.isUpdating = true;\n            updater(proxy, new Presence(context, this.clone.presences.get(actorID)));\n        }\n        catch (err) {\n            // drop clone because it is contaminated.\n            this.clone = undefined;\n            logger.error(err);\n            throw err;\n        }\n        finally {\n            this.isUpdating = false;\n        }\n        // 02. Update the root object and presences from changes.\n        if (context.hasChange()) {\n            if (logger.isEnabled(LogLevel.Trivial)) {\n                logger.trivial(`trying to update a local change: ${this.toJSON()}`);\n            }\n            const change = context.getChange();\n            const { opInfos, reverseOps } = change.execute(this.root, this.presences, OpSource.Local);\n            const reversePresence = context.getReversePresence();\n            if (reversePresence) {\n                reverseOps.push({\n                    type: 'presence',\n                    value: reversePresence,\n                });\n            }\n            this.localChanges.push(change);\n            if (reverseOps.length > 0) {\n                this.internalHistory.pushUndo(reverseOps);\n            }\n            // NOTE(chacha912): Clear redo when a new local operation is applied.\n            if (opInfos.length > 0) {\n                this.internalHistory.clearRedo();\n            }\n            this.changeID = change.getID();\n            // 03. Publish the document change event.\n            // NOTE(chacha912): Check opInfos, which represent the actually executed operations.\n            if (opInfos.length > 0) {\n                this.publish({\n                    type: DocEventType.LocalChange,\n                    value: {\n                        message: change.getMessage() || '',\n                        operations: opInfos,\n                        actor: actorID,\n                    },\n                });\n            }\n            if (change.hasPresenceChange()) {\n                this.publish({\n                    type: DocEventType.PresenceChanged,\n                    value: {\n                        clientID: actorID,\n                        presence: this.getPresence(actorID),\n                    },\n                });\n            }\n            if (logger.isEnabled(LogLevel.Trivial)) {\n                logger.trivial(`after update a local change: ${this.toJSON()}`);\n            }\n        }\n    }\n    /**\n     * `subscribe` registers a callback to subscribe to events on the document.\n     */\n    subscribe(arg1, arg2, arg3, arg4) {\n        if (typeof arg1 === 'string') {\n            if (typeof arg2 !== 'function') {\n                throw new Error('Second argument must be a callback function');\n            }\n            if (arg1 === 'presence') {\n                const callback = arg2;\n                return this.eventStream.subscribe((event) => {\n                    if (event.type !== DocEventType.Initialized &&\n                        event.type !== DocEventType.Watched &&\n                        event.type !== DocEventType.Unwatched &&\n                        event.type !== DocEventType.PresenceChanged) {\n                        return;\n                    }\n                    callback(event);\n                }, arg3, arg4);\n            }\n            if (arg1 === 'my-presence') {\n                const callback = arg2;\n                return this.eventStream.subscribe((event) => {\n                    if (event.type !== DocEventType.Initialized &&\n                        event.type !== DocEventType.Watched &&\n                        event.type !== DocEventType.Unwatched &&\n                        event.type !== DocEventType.PresenceChanged) {\n                        return;\n                    }\n                    if (event.type !== DocEventType.Initialized &&\n                        event.value.clientID !== this.changeID.getActorID()) {\n                        return;\n                    }\n                    callback(event);\n                }, arg3, arg4);\n            }\n            if (arg1 === 'others') {\n                const callback = arg2;\n                return this.eventStream.subscribe((event) => {\n                    if (event.type !== DocEventType.Watched &&\n                        event.type !== DocEventType.Unwatched &&\n                        event.type !== DocEventType.PresenceChanged) {\n                        return;\n                    }\n                    if (event.value.clientID !== this.changeID.getActorID()) {\n                        callback(event);\n                    }\n                }, arg3, arg4);\n            }\n            const target = arg1;\n            const callback = arg2;\n            return this.eventStream.subscribe((event) => {\n                if (event.type === DocEventType.Initialized ||\n                    event.type === DocEventType.Watched ||\n                    event.type === DocEventType.Unwatched ||\n                    event.type === DocEventType.PresenceChanged) {\n                    return;\n                }\n                if (event.type === DocEventType.Snapshot) {\n                    target === '$' && callback(event);\n                    return;\n                }\n                const { message, operations, actor } = event.value;\n                const targetOps = [];\n                for (const op of operations) {\n                    if (this.isSameElementOrChildOf(op.path, target)) {\n                        targetOps.push(op);\n                    }\n                }\n                targetOps.length &&\n                    callback({\n                        type: event.type,\n                        value: {\n                            message,\n                            operations: targetOps,\n                            actor,\n                        },\n                    });\n            }, arg3, arg4);\n        }\n        if (typeof arg1 === 'function') {\n            const callback = arg1;\n            const error = arg2;\n            const complete = arg3;\n            return this.eventStream.subscribe((event) => {\n                if (event.type === DocEventType.Initialized ||\n                    event.type === DocEventType.Watched ||\n                    event.type === DocEventType.Unwatched ||\n                    event.type === DocEventType.PresenceChanged) {\n                    return;\n                }\n                callback(event);\n            }, error, complete);\n        }\n        throw new Error(`\"${arg1}\" is not a valid`);\n    }\n    /**\n     * `publish` triggers an event in this document, which can be received by\n     * callback functions from document.subscribe().\n     */\n    publish(event) {\n        if (this.eventStreamObserver) {\n            this.eventStreamObserver.next(event);\n        }\n    }\n    isSameElementOrChildOf(elem, parent) {\n        if (parent === elem) {\n            return true;\n        }\n        const nodePath = elem.split('.');\n        const targetPath = parent.split('.');\n        return targetPath.every((path, index) => path === nodePath[index]);\n    }\n    /**\n     * `applyChangePack` applies the given change pack into this document.\n     * 1. Remove local changes applied to server.\n     * 2. Update the checkpoint.\n     * 3. Do Garbage collection.\n     *\n     * @param pack - change pack\n     * @internal\n     */\n    applyChangePack(pack) {\n        if (pack.hasSnapshot()) {\n            this.applySnapshot(pack.getCheckpoint().getServerSeq(), pack.getSnapshot());\n        }\n        else if (pack.hasChanges()) {\n            this.applyChanges(pack.getChanges());\n        }\n        // 02. Remove local changes applied to server.\n        while (this.localChanges.length) {\n            const change = this.localChanges[0];\n            if (change.getID().getClientSeq() > pack.getCheckpoint().getClientSeq()) {\n                break;\n            }\n            this.localChanges.shift();\n        }\n        // 03. Update the checkpoint.\n        this.checkpoint = this.checkpoint.forward(pack.getCheckpoint());\n        // 04. Do Garbage collection.\n        this.garbageCollect(pack.getMinSyncedTicket());\n        // 05. Update the status.\n        if (pack.getIsRemoved()) {\n            this.setStatus(DocumentStatus.Removed);\n        }\n        if (logger.isEnabled(LogLevel.Trivial)) {\n            logger.trivial(`${this.root.toJSON()}`);\n        }\n    }\n    /**\n     * `getCheckpoint` returns the checkpoint of this document.\n     *\n     * @internal\n     */\n    getCheckpoint() {\n        return this.checkpoint;\n    }\n    /**\n     * `getChangeID` returns the change id of this document.\n     *\n     * @internal\n     */\n    getChangeID() {\n        return this.changeID;\n    }\n    /**\n     * `hasLocalChanges` returns whether this document has local changes or not.\n     *\n     * @internal\n     */\n    hasLocalChanges() {\n        return this.localChanges.length > 0;\n    }\n    /**\n     * `ensureClone` make a clone of root.\n     *\n     * @internal\n     */\n    ensureClone() {\n        if (this.clone) {\n            return;\n        }\n        this.clone = {\n            root: this.root.deepcopy(),\n            presences: deepcopy(this.presences),\n        };\n    }\n    /**\n     * `createChangePack` create change pack of the local changes to send to the\n     * remote server.\n     *\n     * @internal\n     */\n    createChangePack() {\n        const changes = Array.from(this.localChanges);\n        const checkpoint = this.checkpoint.increaseClientSeq(changes.length);\n        return ChangePack.create(this.key, checkpoint, false, changes);\n    }\n    /**\n     * `setActor` sets actor into this document. This is also applied in the local\n     * changes the document has.\n     *\n     * @internal\n     */\n    setActor(actorID) {\n        for (const change of this.localChanges) {\n            change.setActor(actorID);\n        }\n        this.changeID = this.changeID.setActor(actorID);\n        // TODO also apply into root.\n    }\n    /**\n     * `getKey` returns the key of this document.\n     *\n     * @internal\n     */\n    getKey() {\n        return this.key;\n    }\n    /**\n     * `setStatus` updates the status of this document.\n     *\n     * @internal\n     */\n    setStatus(status) {\n        this.status = status;\n    }\n    /**\n     * `getStatus` returns the status of this document.\n     *\n     * @internal\n     */\n    getStatus() {\n        return this.status;\n    }\n    /**\n     * `getClone` return clone object.\n     *\n     * @internal\n     */\n    getCloneRoot() {\n        if (!this.clone) {\n            return;\n        }\n        return this.clone.root.getObject();\n    }\n    /**\n     * `getRoot` returns a new proxy of cloned root.\n     */\n    getRoot() {\n        this.ensureClone();\n        const context = ChangeContext.create(this.changeID.next(), this.clone.root, this.clone.presences.get(this.changeID.getActorID()) || {});\n        return createJSON(context, this.clone.root.getObject());\n    }\n    /**\n     * `getOpsForTest` returns the operations of this document for testing.\n     */\n    getOpsForTest() {\n        return this.root.opsForTest;\n    }\n    /**\n     * `garbageCollect` purges elements that were removed before the given time.\n     *\n     * @internal\n     */\n    garbageCollect(ticket) {\n        if (this.opts.disableGC) {\n            return 0;\n        }\n        if (this.clone) {\n            this.clone.root.garbageCollect(ticket);\n        }\n        return this.root.garbageCollect(ticket);\n    }\n    /**\n     * `getRootObject` returns root object.\n     *\n     * @internal\n     */\n    getRootObject() {\n        return this.root.getObject();\n    }\n    /**\n     * `getGarbageLen` returns the length of elements should be purged.\n     *\n     * @internal\n     */\n    getGarbageLen() {\n        return this.root.getGarbageLen();\n    }\n    /**\n     * `getGarbageLenFromClone` returns the length of elements should be purged from clone.\n     */\n    getGarbageLenFromClone() {\n        return this.clone.root.getGarbageLen();\n    }\n    /**\n     * `toJSON` returns the JSON encoding of this document.\n     */\n    toJSON() {\n        return this.root.toJSON();\n    }\n    /**\n     * `toSortedJSON` returns the sorted JSON encoding of this document.\n     */\n    toSortedJSON() {\n        return this.root.toSortedJSON();\n    }\n    /**\n     * `applySnapshot` applies the given snapshot into this document.\n     */\n    applySnapshot(serverSeq, snapshot) {\n        const { root, presences } = converter.bytesToSnapshot(snapshot);\n        this.root = new CRDTRoot(root);\n        this.presences = presences;\n        this.changeID = this.changeID.syncLamport(serverSeq);\n        // drop clone because it is contaminated.\n        this.clone = undefined;\n        this.publish({\n            type: DocEventType.Snapshot,\n            value: snapshot,\n        });\n    }\n    /**\n     * `applyChanges` applies the given changes into this document.\n     */\n    applyChanges(changes) {\n        if (logger.isEnabled(LogLevel.Debug)) {\n            logger.debug(`trying to apply ${changes.length} remote changes.` +\n                `elements:${this.root.getElementMapSize()}, ` +\n                `removeds:${this.root.getRemovedElementSetSize()}`);\n        }\n        if (logger.isEnabled(LogLevel.Trivial)) {\n            logger.trivial(changes\n                .map((change) => `${change.getID().toTestString()}\\t${change.toTestString()}`)\n                .join('\\n'));\n        }\n        this.ensureClone();\n        for (const change of changes) {\n            change.execute(this.clone.root, this.clone.presences, OpSource.Remote);\n            let presenceEvent;\n            const actorID = change.getID().getActorID();\n            if (change.hasPresenceChange() && this.onlineClients.has(actorID)) {\n                const presenceChange = change.getPresenceChange();\n                switch (presenceChange.type) {\n                    case PresenceChangeType.Put:\n                        // NOTE(chacha912): When the user exists in onlineClients, but\n                        // their presence was initially absent, we can consider that we have\n                        // received their initial presence, so trigger the 'watched' event.\n                        presenceEvent = {\n                            type: this.presences.has(actorID)\n                                ? DocEventType.PresenceChanged\n                                : DocEventType.Watched,\n                            value: {\n                                clientID: actorID,\n                                presence: presenceChange.presence,\n                            },\n                        };\n                        break;\n                    case PresenceChangeType.Clear:\n                        // NOTE(chacha912): When the user exists in onlineClients, but\n                        // PresenceChange(clear) is received, we can consider it as detachment\n                        // occurring before unwatching.\n                        // Detached user is no longer participating in the document, we remove\n                        // them from the online clients and trigger the 'unwatched' event.\n                        presenceEvent = {\n                            type: DocEventType.Unwatched,\n                            value: {\n                                clientID: actorID,\n                                presence: this.getPresence(actorID),\n                            },\n                        };\n                        this.removeOnlineClient(actorID);\n                        break;\n                    default:\n                        break;\n                }\n            }\n            const { opInfos } = change.execute(this.root, this.presences, OpSource.Remote);\n            // DocEvent should be emitted synchronously with applying changes.\n            // This is because 3rd party model should be synced with the Document\n            // after RemoteChange event is emitted. If the event is emitted\n            // asynchronously, the model can be changed and breaking consistency.\n            if (opInfos.length > 0) {\n                this.publish({\n                    type: DocEventType.RemoteChange,\n                    value: {\n                        actor: actorID,\n                        message: change.getMessage() || '',\n                        operations: opInfos,\n                    },\n                });\n            }\n            if (presenceEvent) {\n                this.publish(presenceEvent);\n            }\n            this.changeID = this.changeID.syncLamport(change.getID().getLamport());\n        }\n        if (logger.isEnabled(LogLevel.Debug)) {\n            logger.debug(`after appling ${changes.length} remote changes.` +\n                `elements:${this.root.getElementMapSize()}, ` +\n                ` removeds:${this.root.getRemovedElementSetSize()}`);\n        }\n    }\n    /**\n     * `getValueByPath` returns the JSONElement corresponding to the given path.\n     */\n    getValueByPath(path) {\n        if (!path.startsWith('$')) {\n            throw new YorkieError(error_Code.InvalidArgument, `path must start with \"$\"`);\n        }\n        const pathArr = path.split('.');\n        pathArr.shift();\n        let value = this.getRoot();\n        for (const key of pathArr) {\n            value = value[key];\n            if (value === undefined)\n                return undefined;\n        }\n        return value;\n    }\n    /**\n     * `setOnlineClients` sets the given online client set.\n     *\n     * @internal\n     */\n    setOnlineClients(onlineClients) {\n        this.onlineClients = onlineClients;\n    }\n    /**\n     * `addOnlineClient` adds the given clientID into the online client set.\n     *\n     * @internal\n     */\n    addOnlineClient(clientID) {\n        this.onlineClients.add(clientID);\n    }\n    /**\n     * `removeOnlineClient` removes the clientID from the online client set.\n     *\n     * @internal\n     */\n    removeOnlineClient(clientID) {\n        this.onlineClients.delete(clientID);\n    }\n    /**\n     * `hasPresence` returns whether the given clientID has a presence or not.\n     *\n     * @internal\n     */\n    hasPresence(clientID) {\n        return this.presences.has(clientID);\n    }\n    /**\n     * `getMyPresence` returns the presence of the current client.\n     */\n    getMyPresence() {\n        if (this.status !== DocumentStatus.Attached) {\n            return {};\n        }\n        const p = this.presences.get(this.changeID.getActorID());\n        return deepcopy(p);\n    }\n    /**\n     * `getPresence` returns the presence of the given clientID.\n     */\n    getPresence(clientID) {\n        if (!this.onlineClients.has(clientID))\n            return;\n        const p = this.presences.get(clientID);\n        return p ? deepcopy(p) : undefined;\n    }\n    /**\n     * `getPresenceForTest` returns the presence of the given clientID\n     * regardless of whether the client is online or not.\n     *\n     * @internal\n     */\n    getPresenceForTest(clientID) {\n        const p = this.presences.get(clientID);\n        return p ? deepcopy(p) : undefined;\n    }\n    /**\n     * `getPresences` returns the presences of online clients.\n     */\n    getPresences() {\n        const presences = [];\n        for (const clientID of this.onlineClients) {\n            if (this.presences.has(clientID)) {\n                presences.push({\n                    clientID,\n                    presence: deepcopy(this.presences.get(clientID)),\n                });\n            }\n        }\n        return presences;\n    }\n    /**\n     * `canUndo` returns whether there are any operations to undo.\n     */\n    canUndo() {\n        return this.internalHistory.hasUndo() && !this.isUpdating;\n    }\n    /**\n     * `canRedo` returns whether there are any operations to redo.\n     */\n    canRedo() {\n        return this.internalHistory.hasRedo() && !this.isUpdating;\n    }\n    /**\n     * `undo` undoes the last operation executed by the current client.\n     * It does not impact operations made by other clients.\n     */\n    undo() {\n        if (this.isUpdating) {\n            throw new Error('Undo is not allowed during an update');\n        }\n        const undoOps = this.internalHistory.popUndo();\n        if (undoOps === undefined) {\n            throw new Error('There is no operation to be undone');\n        }\n        this.ensureClone();\n        // TODO(chacha912): After resolving the presence initialization issue,\n        // remove default presence.(#608)\n        const context = ChangeContext.create(this.changeID.next(), this.clone.root, this.clone.presences.get(this.changeID.getActorID()) || {});\n        // apply undo operation in the context to generate a change\n        for (const undoOp of undoOps) {\n            if (!(undoOp instanceof Operation)) {\n                // apply presence change to the context\n                const presence = new Presence(context, deepcopy(this.clone.presences.get(this.changeID.getActorID())));\n                presence.set(undoOp.value, { addToHistory: true });\n                continue;\n            }\n            const ticket = context.issueTimeTicket();\n            undoOp.setExecutedAt(ticket);\n            context.push(undoOp);\n        }\n        const change = context.getChange();\n        change.execute(this.clone.root, this.clone.presences, OpSource.UndoRedo);\n        const { opInfos, reverseOps } = change.execute(this.root, this.presences, OpSource.UndoRedo);\n        const reversePresence = context.getReversePresence();\n        if (reversePresence) {\n            reverseOps.push({\n                type: 'presence',\n                value: reversePresence,\n            });\n        }\n        if (reverseOps.length > 0) {\n            this.internalHistory.pushRedo(reverseOps);\n        }\n        // NOTE(chacha912): When there is no applied operation or presence\n        // during undo/redo, skip propagating change remotely.\n        if (!change.hasPresenceChange() && opInfos.length === 0) {\n            return;\n        }\n        this.localChanges.push(change);\n        this.changeID = change.getID();\n        const actorID = this.changeID.getActorID();\n        if (opInfos.length > 0) {\n            this.publish({\n                type: DocEventType.LocalChange,\n                value: {\n                    message: change.getMessage() || '',\n                    operations: opInfos,\n                    actor: actorID,\n                },\n            });\n        }\n        if (change.hasPresenceChange()) {\n            this.publish({\n                type: DocEventType.PresenceChanged,\n                value: {\n                    clientID: actorID,\n                    presence: this.getPresence(actorID),\n                },\n            });\n        }\n    }\n    /**\n     * `redo` redoes the last operation executed by the current client.\n     * It does not impact operations made by other clients.\n     */\n    redo() {\n        if (this.isUpdating) {\n            throw new Error('Redo is not allowed during an update');\n        }\n        const redoOps = this.internalHistory.popRedo();\n        if (redoOps === undefined) {\n            throw new Error('There is no operation to be redone');\n        }\n        this.ensureClone();\n        const context = ChangeContext.create(this.changeID.next(), this.clone.root, this.clone.presences.get(this.changeID.getActorID()) || {});\n        // apply redo operation in the context to generate a change\n        for (const redoOp of redoOps) {\n            if (!(redoOp instanceof Operation)) {\n                // apply presence change to the context\n                const presence = new Presence(context, deepcopy(this.clone.presences.get(this.changeID.getActorID())));\n                presence.set(redoOp.value, { addToHistory: true });\n                continue;\n            }\n            const ticket = context.issueTimeTicket();\n            redoOp.setExecutedAt(ticket);\n            context.push(redoOp);\n        }\n        const change = context.getChange();\n        change.execute(this.clone.root, this.clone.presences, OpSource.UndoRedo);\n        const { opInfos, reverseOps } = change.execute(this.root, this.presences, OpSource.UndoRedo);\n        const reversePresence = context.getReversePresence();\n        if (reversePresence) {\n            reverseOps.push({\n                type: 'presence',\n                value: reversePresence,\n            });\n        }\n        if (reverseOps.length > 0) {\n            this.internalHistory.pushUndo(reverseOps);\n        }\n        // NOTE(chacha912): When there is no applied operation or presence\n        // during undo/redo, skip propagating change remotely.\n        if (!change.hasPresenceChange() && opInfos.length === 0) {\n            return;\n        }\n        this.localChanges.push(change);\n        this.changeID = change.getID();\n        const actorID = this.changeID.getActorID();\n        if (opInfos.length > 0) {\n            this.publish({\n                type: DocEventType.LocalChange,\n                value: {\n                    message: change.getMessage() || '',\n                    operations: opInfos,\n                    actor: actorID,\n                },\n            });\n        }\n        if (change.hasPresenceChange()) {\n            this.publish({\n                type: DocEventType.PresenceChanged,\n                value: {\n                    clientID: actorID,\n                    presence: this.getPresence(actorID),\n                },\n            });\n        }\n    }\n    /**\n     * `getUndoStackForTest` returns the undo stack for test.\n     */\n    getUndoStackForTest() {\n        return this.internalHistory.getUndoStackForTest();\n    }\n    /**\n     * `getRedoStackForTest` returns the redo stack for test.\n     */\n    getRedoStackForTest() {\n        return this.internalHistory.getRedoStackForTest();\n    }\n}\n\n;// CONCATENATED MODULE: ./src/client/auth_interceptor.ts\n/*\n * Copyright 2021 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * `createAuthInterceptor` creates an interceptor to add the Authorization header for each\n * request.\n */\nfunction createAuthInterceptor(apiKey, token) {\n    return (next) => async (req) => {\n        if (apiKey) {\n            req.header.set('x-api-key', apiKey);\n        }\n        if (token) {\n            req.header.set('authorization', token);\n        }\n        return await next(req);\n    };\n}\n\n;// CONCATENATED MODULE: ./package.json\nconst package_namespaceObject = JSON.parse('{\"u2\":\"yorkie-js-sdk\",\"i8\":\"0.4.11\"}');\n;// CONCATENATED MODULE: ./src/client/metric_interceptor.ts\n/*\n * Copyright 2021 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * `createMetricInterceptor` creates an interceptor to add the x-yorkie-user-agent header for each\n * request.\n */\nfunction createMetricInterceptor() {\n    return (next) => async (req) => {\n        req.header.set('x-yorkie-user-agent', package_namespaceObject.u2 + '/' + package_namespaceObject.i8);\n        return await next(req);\n    };\n}\n\n;// CONCATENATED MODULE: ./src/client/client.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * `SyncMode` is the mode of synchronization. It is used to determine\n * whether to push and pull changes in PushPullChanges API.\n * @public\n */\nvar SyncMode;\n(function (SyncMode) {\n    /**\n     * `PushPull` is the mode that pushes and pulls changes.\n     */\n    SyncMode[\"PushPull\"] = \"pushpull\";\n    /**\n     * `PushOnly` is the mode that pushes changes only.\n     */\n    SyncMode[\"PushOnly\"] = \"pushonly\";\n})(SyncMode || (SyncMode = {}));\n/**\n * `ClientStatus` represents the status of the client.\n * @public\n */\nvar ClientStatus;\n(function (ClientStatus) {\n    /**\n     * `Deactivated` means that the client is not activated. It is the initial\n     * status of the client. If the client is deactivated, all `Document`s of the\n     * client are also not used.\n     */\n    ClientStatus[\"Deactivated\"] = \"deactivated\";\n    /**\n     * `Activated` means that the client is activated. If the client is activated,\n     * all `Document`s of the client are also ready to be used.\n     */\n    ClientStatus[\"Activated\"] = \"activated\";\n})(ClientStatus || (ClientStatus = {}));\n/**\n * `StreamConnectionStatus` represents whether the stream connection between the\n * client and the server is connected or not.\n * @public\n */\nvar StreamConnectionStatus;\n(function (StreamConnectionStatus) {\n    /**\n     * `Connected` means that the stream connection is connected.\n     */\n    StreamConnectionStatus[\"Connected\"] = \"connected\";\n    /**\n     * `Disconnected` means that the stream connection is disconnected.\n     */\n    StreamConnectionStatus[\"Disconnected\"] = \"disconnected\";\n})(StreamConnectionStatus || (StreamConnectionStatus = {}));\n/**\n * `DocumentSyncResultType` represents the result of synchronizing the document\n *  with the server.\n * @public\n */\nvar DocumentSyncResultType;\n(function (DocumentSyncResultType) {\n    /**\n     * type when Document synced successfully.\n     */\n    DocumentSyncResultType[\"Synced\"] = \"synced\";\n    /**\n     * type when Document sync failed.\n     */\n    DocumentSyncResultType[\"SyncFailed\"] = \"sync-failed\";\n})(DocumentSyncResultType || (DocumentSyncResultType = {}));\n/**\n * `ClientEventType` represents the type of the event that the client can emit.\n * @public\n */\nvar ClientEventType;\n(function (ClientEventType) {\n    /**\n     * `StatusChanged` means that the status of the client has changed.\n     */\n    ClientEventType[\"StatusChanged\"] = \"status-changed\";\n    /**\n     * `DocumentChanged` means that the document has changed.\n     */\n    ClientEventType[\"DocumentChanged\"] = \"document-changed\";\n    /**\n     * `StreamConnectionStatusChanged` means that the stream connection status of\n     * the client has changed.\n     */\n    ClientEventType[\"StreamConnectionStatusChanged\"] = \"stream-connection-status-changed\";\n    /**\n     * `DocumentSynced` means that the document has been synced with the server.\n     */\n    ClientEventType[\"DocumentSynced\"] = \"document-synced\";\n})(ClientEventType || (ClientEventType = {}));\n/**\n * `DefaultClientOptions` is the default options for Client.\n */\nconst DefaultClientOptions = {\n    syncLoopDuration: 50,\n    retrySyncLoopDelay: 1000,\n    reconnectStreamDelay: 1000,\n};\n/**\n * `Client` is a normal client that can communicate with the server.\n * It has documents and sends changes of the documents in local\n * to the server to synchronize with other replicas in remote.\n *\n * @public\n */\nclass Client {\n    /**\n     * @param rpcAddr - the address of the RPC server.\n     * @param opts - the options of the client.\n     */\n    constructor(rpcAddr, opts) {\n        opts = opts || DefaultClientOptions;\n        this.key = opts.key ? opts.key : uuid();\n        this.status = ClientStatus.Deactivated;\n        this.attachmentMap = new Map();\n        // TODO(hackerwins): Consider to group the options as a single object.\n        this.apiKey = opts.apiKey || '';\n        this.syncLoopDuration =\n            opts.syncLoopDuration || DefaultClientOptions.syncLoopDuration;\n        this.reconnectStreamDelay =\n            opts.reconnectStreamDelay || DefaultClientOptions.reconnectStreamDelay;\n        this.retrySyncLoopDelay =\n            opts.retrySyncLoopDelay || DefaultClientOptions.retrySyncLoopDelay;\n        // Here we make the client itself, combining the service\n        // definition with the transport.\n        this.rpcClient = createPromiseClient(yorkie_connect/* YorkieService */.V, createGrpcWebTransport({\n            baseUrl: rpcAddr,\n            interceptors: [\n                createAuthInterceptor(opts.apiKey, opts.token),\n                createMetricInterceptor(),\n            ],\n        }));\n        this.eventStream = createObservable((observer) => {\n            this.eventStreamObserver = observer;\n        });\n    }\n    /**\n     * `activate` activates this client. That is, it registers itself to the server\n     * and receives a unique ID from the server. The given ID is used to\n     * distinguish different clients.\n     */\n    activate() {\n        if (this.isActive()) {\n            return Promise.resolve();\n        }\n        return this.rpcClient\n            .activateClient({\n            clientKey: this.key,\n        }, { headers: { 'x-shard-key': this.apiKey } })\n            .then((res) => {\n            this.id = res.clientId;\n            this.status = ClientStatus.Activated;\n            this.runSyncLoop();\n            this.eventStreamObserver.next({\n                type: ClientEventType.StatusChanged,\n                value: this.status,\n            });\n            logger.info(`[AC] c:\"${this.getKey()}\" activated, id:\"${this.id}\"`);\n        })\n            .catch((err) => {\n            logger.error(`[AC] c:\"${this.getKey()}\" err :`, err);\n            throw err;\n        });\n    }\n    /**\n     * `deactivate` deactivates this client.\n     */\n    deactivate() {\n        if (this.status === ClientStatus.Deactivated) {\n            return Promise.resolve();\n        }\n        for (const [key] of this.attachmentMap) {\n            this.detachInternal(key);\n        }\n        return this.rpcClient\n            .deactivateClient({\n            clientId: this.id,\n        }, { headers: { 'x-shard-key': this.apiKey } })\n            .then(() => {\n            this.status = ClientStatus.Deactivated;\n            this.eventStreamObserver.next({\n                type: ClientEventType.StatusChanged,\n                value: this.status,\n            });\n            logger.info(`[DC] c\"${this.getKey()}\" deactivated`);\n        })\n            .catch((err) => {\n            logger.error(`[DC] c:\"${this.getKey()}\" err :`, err);\n            throw err;\n        });\n    }\n    /**\n     * `attach` attaches the given document to this client. It tells the server that\n     * this client will synchronize the given document.\n     */\n    attach(doc, options = {}) {\n        var _a;\n        if (!this.isActive()) {\n            throw new YorkieError(error_Code.ClientNotActive, `${this.key} is not active`);\n        }\n        if (doc.getStatus() !== DocumentStatus.Detached) {\n            throw new YorkieError(error_Code.DocumentNotDetached, `${doc.getKey()} is not detached`);\n        }\n        doc.setActor(this.id);\n        doc.update((_, p) => p.set(options.initialPresence || {}));\n        const isRealtimeSync = (_a = options.isRealtimeSync) !== null && _a !== void 0 ? _a : true;\n        return this.rpcClient\n            .attachDocument({\n            clientId: this.id,\n            changePack: converter.toChangePack(doc.createChangePack()),\n        }, {\n            headers: { 'x-shard-key': `${this.apiKey}/${doc.getKey()}` },\n        })\n            .then(async (res) => {\n            const pack = converter.fromChangePack(res.changePack);\n            doc.applyChangePack(pack);\n            if (doc.getStatus() === DocumentStatus.Removed) {\n                return doc;\n            }\n            doc.setStatus(DocumentStatus.Attached);\n            this.attachmentMap.set(doc.getKey(), new Attachment(this.reconnectStreamDelay, doc, res.documentId, isRealtimeSync));\n            if (isRealtimeSync) {\n                await this.runWatchLoop(doc.getKey());\n            }\n            logger.info(`[AD] c:\"${this.getKey()}\" attaches d:\"${doc.getKey()}\"`);\n            return doc;\n        })\n            .catch((err) => {\n            logger.error(`[AD] c:\"${this.getKey()}\" err :`, err);\n            throw err;\n        });\n    }\n    /**\n     * `detach` detaches the given document from this client. It tells the\n     * server that this client will no longer synchronize the given document.\n     *\n     * To collect garbage things like CRDT tombstones left on the document, all\n     * the changes should be applied to other replicas before GC time. For this,\n     * if the document is no longer used by this client, it should be detached.\n     */\n    detach(doc, options = {}) {\n        var _a;\n        if (!this.isActive()) {\n            throw new YorkieError(error_Code.ClientNotActive, `${this.key} is not active`);\n        }\n        const attachment = this.attachmentMap.get(doc.getKey());\n        if (!attachment) {\n            throw new YorkieError(error_Code.DocumentNotAttached, `${doc.getKey()} is not attached`);\n        }\n        doc.update((_, p) => p.clear());\n        return this.rpcClient\n            .detachDocument({\n            clientId: this.id,\n            documentId: attachment.docID,\n            changePack: converter.toChangePack(doc.createChangePack()),\n            removeIfNotAttached: (_a = options.removeIfNotAttached) !== null && _a !== void 0 ? _a : false,\n        }, {\n            headers: { 'x-shard-key': `${this.apiKey}/${doc.getKey()}` },\n        })\n            .then((res) => {\n            const pack = converter.fromChangePack(res.changePack);\n            doc.applyChangePack(pack);\n            if (doc.getStatus() !== DocumentStatus.Removed) {\n                doc.setStatus(DocumentStatus.Detached);\n            }\n            this.detachInternal(doc.getKey());\n            logger.info(`[DD] c:\"${this.getKey()}\" detaches d:\"${doc.getKey()}\"`);\n            return doc;\n        })\n            .catch((err) => {\n            logger.error(`[DD] c:\"${this.getKey()}\" err :`, err);\n            throw err;\n        });\n    }\n    /**\n     * `pause` changes the synchronization mode of the given document to manual.\n     */\n    pause(doc) {\n        if (!this.isActive()) {\n            throw new YorkieError(error_Code.ClientNotActive, `${this.key} is not active`);\n        }\n        return this.changeRealtimeSync(doc, false);\n    }\n    /**\n     * `resume` changes the synchronization mode of the given document to realtime.\n     */\n    resume(doc) {\n        if (!this.isActive()) {\n            throw new YorkieError(error_Code.ClientNotActive, `${this.key} is not active`);\n        }\n        return this.changeRealtimeSync(doc, true);\n    }\n    /**\n     * `pauseRemoteChanges` pauses the synchronization of remote changes,\n     * allowing only local changes to be applied.\n     */\n    pauseRemoteChanges(doc) {\n        if (!this.isActive()) {\n            throw new YorkieError(error_Code.ClientNotActive, `${this.key} is not active`);\n        }\n        const attachment = this.attachmentMap.get(doc.getKey());\n        if (!attachment) {\n            throw new YorkieError(error_Code.DocumentNotAttached, `${doc.getKey()} is not attached`);\n        }\n        attachment.changeSyncMode(SyncMode.PushOnly);\n    }\n    /**\n     * `resumeRemoteChanges` resumes the synchronization of remote changes,\n     * allowing both local and remote changes to be applied.\n     */\n    resumeRemoteChanges(doc) {\n        if (!this.isActive()) {\n            throw new YorkieError(error_Code.ClientNotActive, `${this.key} is not active`);\n        }\n        const attachment = this.attachmentMap.get(doc.getKey());\n        if (!attachment) {\n            throw new YorkieError(error_Code.DocumentNotAttached, `${doc.getKey()} is not attached`);\n        }\n        attachment.changeSyncMode(SyncMode.PushPull);\n        attachment.remoteChangeEventReceived = true;\n    }\n    /**\n     * `changeRealtimeSync` changes the synchronization mode of the given document.\n     */\n    async changeRealtimeSync(doc, isRealtimeSync) {\n        // TODO(hackerwins): We need to consider extracting this method to `attachment`\n        // with other methods like runWatchLoop, disconnectWatchStream.\n        const attachment = this.attachmentMap.get(doc.getKey());\n        if (!attachment) {\n            throw new YorkieError(error_Code.DocumentNotAttached, `${doc.getKey()} is not attached`);\n        }\n        if (!attachment.changeRealtimeSync(isRealtimeSync)) {\n            return doc;\n        }\n        if (isRealtimeSync) {\n            await this.runWatchLoop(doc.getKey());\n            return doc;\n        }\n        this.eventStreamObserver.next({\n            type: ClientEventType.StreamConnectionStatusChanged,\n            value: StreamConnectionStatus.Disconnected,\n        });\n        logger.debug(`[WD] c:\"${this.getKey()}\" unwatches`);\n        return doc;\n    }\n    /**\n     * `sync` pushes local changes of the attached documents to the server and\n     * receives changes of the remote replica from the server then apply them to\n     * local documents.\n     */\n    sync(doc, syncMode = SyncMode.PushPull) {\n        if (!this.isActive()) {\n            throw new YorkieError(error_Code.ClientNotActive, `${this.key} is not active`);\n        }\n        const promises = [];\n        if (doc) {\n            // prettier-ignore\n            const attachment = this.attachmentMap.get(doc.getKey());\n            if (!attachment) {\n                throw new YorkieError(error_Code.DocumentNotAttached, `${doc.getKey()} is not attached`);\n            }\n            promises.push(this.syncInternal(attachment, syncMode));\n        }\n        else {\n            this.attachmentMap.forEach((attachment) => {\n                promises.push(this.syncInternal(attachment, attachment.syncMode));\n            });\n        }\n        return Promise.all(promises).catch((err) => {\n            this.eventStreamObserver.next({\n                type: ClientEventType.DocumentSynced,\n                value: DocumentSyncResultType.SyncFailed,\n            });\n            throw err;\n        });\n    }\n    /**\n     * `remove` removes the given document.\n     */\n    remove(doc) {\n        if (!this.isActive()) {\n            throw new YorkieError(error_Code.ClientNotActive, `${this.key} is not active`);\n        }\n        const attachment = this.attachmentMap.get(doc.getKey());\n        if (!attachment) {\n            throw new YorkieError(error_Code.DocumentNotAttached, `${doc.getKey()} is not attached`);\n        }\n        doc.setActor(this.id);\n        const pbChangePack = converter.toChangePack(doc.createChangePack());\n        pbChangePack.isRemoved = true;\n        return this.rpcClient\n            .removeDocument({\n            clientId: this.id,\n            documentId: attachment.docID,\n            changePack: pbChangePack,\n        }, {\n            headers: { 'x-shard-key': `${this.apiKey}/${doc.getKey()}` },\n        })\n            .then((res) => {\n            const pack = converter.fromChangePack(res.changePack);\n            doc.applyChangePack(pack);\n            this.detachInternal(doc.getKey());\n            logger.info(`[RD] c:\"${this.getKey()}\" removes d:\"${doc.getKey()}\"`);\n        })\n            .catch((err) => {\n            logger.error(`[RD] c:\"${this.getKey()}\" err :`, err);\n            throw err;\n        });\n    }\n    /**\n     * `subscribe` subscribes to the given topics.\n     */\n    subscribe(nextOrObserver, error, complete) {\n        return this.eventStream.subscribe(nextOrObserver, error, complete);\n    }\n    /**\n     * `getID` returns a ActorID of client.\n     */\n    getID() {\n        return this.id;\n    }\n    /**\n     * `getKey` returns a key of client.\n     */\n    getKey() {\n        return this.key;\n    }\n    /**\n     * `isActive` checks if the client is active.\n     */\n    isActive() {\n        return this.status === ClientStatus.Activated;\n    }\n    /**\n     * `getStatus` returns the status of this client.\n     */\n    getStatus() {\n        return this.status;\n    }\n    runSyncLoop() {\n        const doLoop = () => {\n            if (!this.isActive()) {\n                logger.debug(`[SL] c:\"${this.getKey()}\" exit sync loop`);\n                return;\n            }\n            const syncJobs = [];\n            for (const [, attachment] of this.attachmentMap) {\n                if (attachment.needRealtimeSync()) {\n                    attachment.remoteChangeEventReceived = false;\n                    syncJobs.push(this.syncInternal(attachment, attachment.syncMode));\n                }\n            }\n            Promise.all(syncJobs)\n                .then(() => setTimeout(doLoop, this.syncLoopDuration))\n                .catch((err) => {\n                logger.error(`[SL] c:\"${this.getKey()}\" sync failed:`, err);\n                this.eventStreamObserver.next({\n                    type: ClientEventType.DocumentSynced,\n                    value: DocumentSyncResultType.SyncFailed,\n                });\n                setTimeout(doLoop, this.retrySyncLoopDelay);\n            });\n        };\n        logger.debug(`[SL] c:\"${this.getKey()}\" run sync loop`);\n        doLoop();\n    }\n    async runWatchLoop(docKey) {\n        const attachment = this.attachmentMap.get(docKey);\n        if (!attachment) {\n            throw new YorkieError(error_Code.DocumentNotAttached, `${docKey} is not attached`);\n        }\n        return attachment.runWatchLoop((onDisconnect) => {\n            if (!this.isActive()) {\n                return Promise.reject(new YorkieError(error_Code.ClientNotActive, `${this.key} is not active`));\n            }\n            const ac = new AbortController();\n            const stream = this.rpcClient.watchDocument({\n                clientId: this.id,\n                documentId: attachment.docID,\n            }, {\n                headers: { 'x-shard-key': `${this.apiKey}/${docKey}` },\n                signal: ac.signal,\n            });\n            this.eventStreamObserver.next({\n                type: ClientEventType.StreamConnectionStatusChanged,\n                value: StreamConnectionStatus.Connected,\n            });\n            logger.info(`[WD] c:\"${this.getKey()}\" watches d:\"${docKey}\"`);\n            return new Promise((resolve, reject) => {\n                const handleStream = async () => {\n                    try {\n                        for await (const resp of stream) {\n                            this.handleWatchDocumentsResponse(attachment, resp);\n                            // NOTE(hackerwins): When the first response is received, we need to\n                            // resolve the promise to notify that the watch stream is ready.\n                            if (resp.body.case === 'initialization') {\n                                resolve([stream, ac]);\n                            }\n                        }\n                    }\n                    catch (err) {\n                        this.eventStreamObserver.next({\n                            type: ClientEventType.StreamConnectionStatusChanged,\n                            value: StreamConnectionStatus.Disconnected,\n                        });\n                        logger.debug(`[WD] c:\"${this.getKey()}\" unwatches`);\n                        onDisconnect();\n                        reject(err);\n                    }\n                };\n                handleStream();\n            });\n        });\n    }\n    handleWatchDocumentsResponse(attachment, resp) {\n        const docKey = attachment.doc.getKey();\n        if (resp.body.case === 'initialization') {\n            const clientIDs = resp.body.value.clientIds;\n            const onlineClients = new Set();\n            for (const clientID of clientIDs) {\n                onlineClients.add(clientID);\n            }\n            attachment.doc.setOnlineClients(onlineClients);\n            attachment.doc.publish({\n                type: DocEventType.Initialized,\n                value: attachment.doc.getPresences(),\n            });\n            return;\n        }\n        else if (resp.body.case === 'event') {\n            const pbWatchEvent = resp.body.value;\n            const eventType = pbWatchEvent.type;\n            const publisher = pbWatchEvent.publisher;\n            switch (eventType) {\n                case resources_pb.DocEventType.DOCUMENT_CHANGED:\n                    attachment.remoteChangeEventReceived = true;\n                    this.eventStreamObserver.next({\n                        type: ClientEventType.DocumentChanged,\n                        value: [docKey],\n                    });\n                    break;\n                case resources_pb.DocEventType.DOCUMENT_WATCHED:\n                    attachment.doc.addOnlineClient(publisher);\n                    // NOTE(chacha912): We added to onlineClients, but we won't trigger watched event\n                    // unless we also know their initial presence data at this point.\n                    if (attachment.doc.hasPresence(publisher)) {\n                        attachment.doc.publish({\n                            type: DocEventType.Watched,\n                            value: {\n                                clientID: publisher,\n                                presence: attachment.doc.getPresence(publisher),\n                            },\n                        });\n                    }\n                    break;\n                case resources_pb.DocEventType.DOCUMENT_UNWATCHED: {\n                    const presence = attachment.doc.getPresence(publisher);\n                    attachment.doc.removeOnlineClient(publisher);\n                    // NOTE(chacha912): There is no presence, when PresenceChange(clear) is applied before unwatching.\n                    // In that case, the 'unwatched' event is triggered while handling the PresenceChange.\n                    if (presence) {\n                        attachment.doc.publish({\n                            type: DocEventType.Unwatched,\n                            value: { clientID: publisher, presence },\n                        });\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    detachInternal(docKey) {\n        // NOTE(hackerwins): If attachment is not found, it means that the document\n        // has been already detached by another routine.\n        // This can happen when detach or remove is called while the watch loop is\n        // running.\n        const attachment = this.attachmentMap.get(docKey);\n        if (!attachment) {\n            return;\n        }\n        attachment.cancelWatchStream();\n        logger.debug(`[WD] c:\"${this.getKey()}\" unwatches`);\n        this.eventStreamObserver.next({\n            type: ClientEventType.StreamConnectionStatusChanged,\n            value: StreamConnectionStatus.Disconnected,\n        });\n        this.attachmentMap.delete(docKey);\n    }\n    syncInternal(attachment, syncMode) {\n        const { doc, docID } = attachment;\n        const reqPack = doc.createChangePack();\n        return this.rpcClient\n            .pushPullChanges({\n            clientId: this.id,\n            documentId: docID,\n            changePack: converter.toChangePack(reqPack),\n            pushOnly: syncMode === SyncMode.PushOnly,\n        }, {\n            headers: { 'x-shard-key': `${this.apiKey}/${doc.getKey()}` },\n        })\n            .then((res) => {\n            const respPack = converter.fromChangePack(res.changePack);\n            // (chacha912, hackerwins): If syncLoop already executed with\n            // PushPull, ignore the response when the syncMode is PushOnly.\n            if (respPack.hasChanges() && syncMode === SyncMode.PushOnly) {\n                return doc;\n            }\n            doc.applyChangePack(respPack);\n            this.eventStreamObserver.next({\n                type: ClientEventType.DocumentSynced,\n                value: DocumentSyncResultType.Synced,\n            });\n            // (chacha912): If a document has been removed, watchStream should\n            // be disconnected to not receive an event for that document.\n            if (doc.getStatus() === DocumentStatus.Removed) {\n                this.detachInternal(doc.getKey());\n            }\n            const docKey = doc.getKey();\n            const remoteSize = respPack.getChangeSize();\n            logger.info(`[PP] c:\"${this.getKey()}\" sync d:\"${docKey}\", push:${reqPack.getChangeSize()} pull:${remoteSize} cp:${respPack\n                .getCheckpoint()\n                .toTestString()}`);\n            return doc;\n        })\n            .catch((err) => {\n            logger.error(`[PP] c:\"${this.getKey()}\" err :`, err);\n            throw err;\n        });\n    }\n}\n\n;// CONCATENATED MODULE: ./src/yorkie.ts\n/*\n * Copyright 2020 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * The top-level yorkie namespace with additional properties.\n *\n * In production, this will be called exactly once and the result\n * assigned to the `yorkie` global.\n *\n * e.g) `new yorkie.Client(...);`\n *\n * @public\n */\nconst yorkie = {\n    Client: Client,\n    Document: Document,\n    Primitive: Primitive,\n    Text: Text,\n    Counter: Counter,\n    Tree: Tree,\n    IntType: CounterType.IntegerCnt,\n    LongType: CounterType.LongCnt,\n};\n/* harmony default export */ const src_yorkie = (yorkie);\n\n})();\n\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});\n//# sourceMappingURL=yorkie-js-sdk.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveW9ya2llLWpzLXNkay9kaXN0L3lvcmtpZS1qcy1zZGsuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBeUQ7QUFDN0Q7QUFDQSxNQUFNLEVBS3VCO0FBQzdCLENBQUM7QUFDRCx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQywrQkFBbUI7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLGdEQUFnRCxhQUFhOztBQUU3RCxRQUFRLGlDQUFpQyxFQUFFLCtCQUFtQjs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxrREFBa0Q7QUFDdkQsS0FBSyx3REFBd0Q7QUFDN0QsS0FBSyx3REFBd0Q7QUFDN0QsS0FBSyxrREFBa0Q7QUFDdkQsS0FBSyxzREFBc0Q7QUFDM0QsS0FBSyxzREFBc0Q7QUFDM0QsS0FBSyxvREFBb0Q7QUFDekQsS0FBSyxrREFBa0Q7QUFDdkQsS0FBSyxnRUFBZ0U7QUFDckUsS0FBSyw4REFBOEQ7QUFDbkUsS0FBSyxtREFBbUQ7QUFDeEQsS0FBSyxpRUFBaUU7QUFDdEUsS0FBSywyREFBMkQ7QUFDaEUsS0FBSyxtREFBbUQ7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDhFQUE4RTtBQUNuRixLQUFLLDhFQUE4RTtBQUNuRixLQUFLLGtGQUFrRjtBQUN2RixLQUFLLGtGQUFrRjtBQUN2RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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TSx3RUFBd0U7QUFDOUUsTUFBTSx3RUFBd0U7QUFDOUUsTUFBTSx1REFBdUQ7QUFDN0Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsK0JBQStCLGFBQWE7O0FBRTVDLFFBQVEsbVhBQW1YLEVBQUUsZ0NBQW1CO0FBQ2haLFFBQVEsYUFBYSxFQUFFLGdDQUFtQjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9DQUFvQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGO0FBQy9GO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDZDQUE2QywwQkFBbUIsRUFBRSxnQ0FBbUI7O0FBRXJGLHFCQUFxQixnQ0FBbUIsR0FBRywwQkFBbUI7QUFDOUQ7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qiw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDLDRDQUE0QztBQUM1QztB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsY0FBYyxnQ0FBbUI7QUFDakMsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtGQUFrRjtBQUNwRyxrQkFBa0Isa0ZBQWtGO0FBQ3BHLG1CQUFtQixtRkFBbUY7QUFDdEcsMEJBQTBCLGtGQUFrRjtBQUM1Ryx3QkFBd0Isa0ZBQWtGO0FBQzFHLHFCQUFxQixxRkFBcUY7QUFDMUcsdUJBQXVCLHVGQUF1RjtBQUM5Ryw2QkFBNkIsd0ZBQXdGO0FBQ3JILDhCQUE4Qix3RkFBd0Y7QUFDdEgsMkJBQTJCLHNGQUFzRjtBQUNqSCw0QkFBNEIsc0ZBQXNGO0FBQ2xILHFCQUFxQixzRkFBc0Y7QUFDM0csc0JBQXNCLHNGQUFzRjtBQUM1Ryx1QkFBdUIsd0ZBQXdGO0FBQy9HLHNCQUFzQix1RkFBdUY7QUFDN0csc0JBQXNCLGlGQUFpRjtBQUN2RyxvQkFBb0IsaUZBQWlGO0FBQ3JHLHNCQUFzQix3RkFBd0Y7QUFDOUcsNkJBQTZCLHdGQUF3RjtBQUNySCxnQ0FBZ0Msd0ZBQXdGO0FBQ3hILEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsZ0NBQW1CO0FBQ3JDO0FBQ0EsbUJBQW1CLGdDQUFtQjtBQUN0QyxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEI7QUFDM0I7QUFDQTtBQUNBLE1BQU0sZ0NBQWdDO0FBQ3RDLE1BQU0saUNBQWlDO0FBQ3ZDLE1BQU0saUNBQWlDO0FBQ3ZDLE1BQU0sZ0NBQWdDO0FBQ3RDLE1BQU0sb0NBQW9DO0FBQzFDLE1BQU0sb0NBQW9DO0FBQzFDLE1BQU0sNENBQTRDO0FBQ2xELE1BQU0sNENBQTRDO0FBQ2xELE1BQU0sNENBQTRDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDhFQUE4RTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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RjtBQUN0RixNQUFNLGdGQUFnRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDhFQUE4RTtBQUNwRixNQUFNLCtFQUErRTtBQUNyRixNQUFNLGtHQUFrRztBQUN4RyxNQUFNLGdHQUFnRztBQUN0RyxNQUFNLG1GQUFtRjtBQUN6RixNQUFNLGtGQUFrRjtBQUN4RixNQUFNLHVGQUF1RjtBQUM3RixNQUFNLG9GQUFvRjtBQUMxRixNQUFNLG9GQUFvRjtBQUMxRixNQUFNLHFFQUFxRTtBQUMzRSxNQUFNLHdGQUF3RjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4REFBOEQ7QUFDL0Q7QUFDQTtBQUNBLE1BQU0sNEJB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsWUFBWSxhQUFhLHlEQUF5RDtBQUNuSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdCQUF3QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFFQUFxRTtBQUMzRSxNQUFNLG1FQUFtRTtBQUN6RTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixzQ0FBc0M7QUFDdkg7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLHNDQUFzQztBQUN2SDtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsc0NBQXNDO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0scUVBQXFFO0FBQzNFLE1BQU0sbUVBQW1FO0FBQ3pFOztBQUVBO0FBQ0EsYUFBYSxnQ0FBbUI7QUFDaEMsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG9GQUFvRjtBQUMxRjs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBLE1BQU0sMkJBQTJCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG9FQUFvRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sb0VBQW9FO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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dEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxtRUFBbUU7QUFDekUsTUFBTSxrRUFBa0U7QUFDeEUsTUFBTSxxRkFBcUY7QUFDM0YsTUFBTSxvRUFBb0U7QUFDMUUsTUFBTSxrRUFBa0U7QUFDeEUsTUFBTSxrRkFBa0Y7QUFDeEYsTUFBTSxzRUFBc0U7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFB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QXNFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sbUVBQW1FO0FBQ3pFLE1BQU0sb0VBQW9FO0FBQzFFLE1BQU0sb0VBQW9FO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxtRUFBbUU7QUFDekUsTUFBTSw2REFBNkQ7QUFDbkU7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sbUVBQW1FO0FBQ3pFLE1BQU0sb0VBQW9FO0FBQzFFLE1BQU0sb0VBQW9FO0FBQzFFLE1BQU0sc0VBQXNFO0FBQzVFLE1BQU0sa0VBQWtFO0FBQ3hFLE1BQU0sa0VBQWtFO0FBQ3hFLE1BQU0sa0ZBQWtGO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sbUVBQW1FO0FBQ3pFLE1BQU0sK0VBQStFO0FBQ3JGLE1BQU0sOEVBQThFO0FBQ3BGLE1BQU0sZ0ZBQWdGO0FBQ3RGLE1BQU0sK0VBQStFO0FBQ3JGLE1BQU0sb0VBQW9FO0FBQzFFLE1BQU0sa0ZBQWtGO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYyxHQUFHLFlBQVk7QUFDMUUsK0NBQStDLGVBQWU7QUFDOUQ7QUFDQSx5REFBeUQsRUFBRTtBQUMzRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELDRCQUE0QjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsZUFBZSxhQUFhLHFCQUFxQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkdBQTZHO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSw2Q0FBNkMsMEJBQW1CLEVBQUUsaUNBQW1COztBQUVyRixxQkFBcUIsaUNBQW1CLEdBQUcsMEJBQW1CO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhLGFBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUM3QyxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsaUNBQW1CO0FBQ3RDLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGlCQUFpQjtBQUNuRixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCOztBQUUvQjtBQUNBLGtCQUFrQixpQ0FBbUI7QUFDckMsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CLElBQUksUUFBUTtBQUM3QyxjQUFjLG1CQUFtQjtBQUNqQzs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsTUFBb0M7QUFDekQ7QUFDQTtBQUNBLDJHQUEyRyx1RkFBdUYsY0FBYztBQUNoTix1QkFBdUIsOEJBQThCLGdEQUFnRCx3REFBd0Q7QUFDN0osNkNBQTZDLHNDQUFzQyxVQUFVLG1CQUFtQixJQUFJO0FBQ3BIO0FBQ0EsZUFBZSxNQUE4QixvQkFBb0I7QUFDakUsd0JBQXdCLE1BQXVDO0FBQy9EO0FBQ0E7QUFDQSxpQkFBaUIsdUZBQXVGLGNBQWM7QUFDdEgsdUJBQXVCLGdDQUFnQyxxQ0FBcUMsMkNBQTJDO0FBQ3ZJLDRCQUE0QixNQUFNLGlCQUFpQixZQUFZO0FBQy9ELHVCQUF1QjtBQUN2Qiw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1QjtBQUNBLHdCQUF3QixNQUF1QztBQUMvRDtBQUNBLGlCQUFpQiw2Q0FBNkMsVUFBVSxzREFBc0QsY0FBYztBQUM1SSwwQkFBMEIsNkJBQTZCLG9CQUFvQix1Q0FBdUMsa0JBQWtCO0FBQ3BJOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxpQ0FBaUM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLHFFQUFxRTtBQUN6SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsOEVBQThFO0FBQ3RLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLEVBQUU7QUFDeEU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLEVBQUU7QUFDNUU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWMsK0RBQStEO0FBQzNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWMsdUVBQXVFO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0hBQXdIO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxVQUFVO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsaUNBQW1CO0FBQ2hDO0FBQ0EsYUFBYSxpQ0FBbUI7QUFDaEMsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGtFQUFrRTtBQUN4RSxNQUFNLHNFQUFzRTtBQUM1RSxNQUFNLCtFQUErRTtBQUNyRjs7QUFFQTtBQUNBLG1CQUFtQixpQ0FBbUI7QUFDdEMsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNB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LFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QUNBLGlDQUFpQyxVQUFVLFVBQVUsVUFBVSxLQUFLLGFBQWE7QUFDakY7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCLE9BQU8sZUFBZTtBQUNwRTtBQUNBLGtCQUFrQix3QkFBd0IsR0FBRyxhQUFhLEdBQUcsZUFBZTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QixPQUFPLGVBQWU7QUFDcEU7QUFDQSxrQkFBa0Isd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcsZUFBZTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsdUJBQXVCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxvQ0FBb0M7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtCQUFrQixJQUFJLGVBQWU7QUFDL0Q7QUFDQSxpQkFBaUIsRUFBRSxnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCLElBQUksb0JBQW9CO0FBQ3BFO0FBQ0EsaUJBQWlCLEVBQUUsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWSxFQUFFLFdBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsS0FBSyxpQkFBaUIsaUJBQWlCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWMsR0FBRyxjQUFjLEdBQUcsbUJBQW1CO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixjQUFjO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLGVBQWU7QUFDdEc7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsdUJBQXVCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELDJCQUEyQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsdUJBQXVCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlDQUFpQyxHQUFHO0FBQ2hFO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsNEJBQTRCLEVBQUUsTUFBTTtBQUNwQztBQUNBO0FBQ0EsOEJBQThCLEtBQUs7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE1BQU0sSUFBSSxHQUFHO0FBQ2pFO0FBQ0E7QUFDQSxpREFBaUQsTUFBTSxJQUFJLFVBQVU7QUFDckU7QUFDQTtBQUNBLCtDQUErQyxJQUFJLElBQUksVUFBVTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE9BQU8sSUFBSSxVQUFVO0FBQ3ZFO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELEtBQUs7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0QkFBNEIsR0FBRyxZQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFVBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxVQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVSxFQUFFLDBFQUEwRSxHQUFHO0FBQ3hHO0FBQ0Esa0JBQWtCLElBQUksVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrQkFBK0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPLElBQUksT0FBTyxJQUFJLE9BQU87QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMEJBQTBCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWUsY0FBYyxlQUFlO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOEJBQThCLEdBQUcsWUFBWTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRCQUE0QixHQUFHLFlBQVk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUIsR0FBRyxvQkFBb0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QixFQUFFLDZCQUE2QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLDBCQUEwQjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEVBQUUscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGtCQUFrQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLFVBQVU7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLFlBQVk7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLGVBQWU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSx5QkFBeUI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLEtBQUs7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsWUFBWTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLFlBQVk7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLElBQUk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx1QkFBdUI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSSxJQUFJLHNCQUFzQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDBDQUEwQyxZQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsMENBQTBDLElBQUk7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsZUFBZTtBQUM3RTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsNENBQTRDLElBQUk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRLElBQUksd0JBQXdCLE1BQU0sTUFBTSxJQUFJLHlCQUF5QixJQUFJLFFBQVE7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVEsSUFBSSx3QkFBd0IsTUFBTSxNQUFNLElBQUkseUJBQXlCLElBQUksMkJBQTJCO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsd0JBQXdCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQyxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQyxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFlBQVk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsYUFBYTtBQUN2RTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7Ozs7Ozs7Ozs7OztBQWVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFVBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSwySEFBMkg7QUFDM0g7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxjQUFjO0FBQ2pGO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsK0RBQStELGNBQWM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2QkFBNkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDRCQUE0QixLQUFLO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtQkFBbUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdEQUF3RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdEQUF3RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVELGlCQUFpQiwwQkFBbUI7QUFDcEMsVUFBVTtBQUNWO0FBQ0EsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3luYy1jb2RlLWNsaW5ldC8uL25vZGVfbW9kdWxlcy95b3JraWUtanMtc2RrL2Rpc3QveW9ya2llLWpzLXNkay5qcz9mMjJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogXG4gKiB5b3JraWUtanMtc2RrIGZvciBidWlsZGluZyBjb2xsYWJvcmF0aXZlIGVkaXRpbmcgYXBwbGljYXRpb25zLlxuICogIC0gVmVyc2lvbjogdjAuNC4xMVxuICogIC0gRGF0ZTogMjAyMy0xMi0xOFQwMjoxOVpcbiAqICAtIEhvbWVwYWdlOiBodHRwczovL3lvcmtpZS5kZXZcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wieW9ya2llXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInlvcmtpZVwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsICgpID0+IHtcbnJldHVybiAvKioqKioqLyAoKCkgPT4geyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdFwidXNlIHN0cmljdFwiO1xuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIDY0Njpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy9cbi8vIENvcHlyaWdodCAyMDIyIFRoZSBZb3JraWUgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbi8vIEBnZW5lcmF0ZWQgYnkgcHJvdG9jLWdlbi1lcyB2MS42LjAgd2l0aCBwYXJhbWV0ZXIgXCJ0YXJnZXQ9anMrZHRzLGpzX2ltcG9ydF9zdHlsZT1sZWdhY3lfY29tbW9uanNcIlxuLy8gQGdlbmVyYXRlZCBmcm9tIGZpbGUgc3JjL2FwaS95b3JraWUvdjEvcmVzb3VyY2VzLnByb3RvIChwYWNrYWdlIHlvcmtpZS52MSwgc3ludGF4IHByb3RvMylcbi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBAdHMtbm9jaGVja1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuXG5jb25zdCB7IHByb3RvMywgU3RyaW5nVmFsdWUsIFRpbWVzdGFtcCB9ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MzIpO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHlvcmtpZS52MS5WYWx1ZVR5cGVcbiAqL1xuY29uc3QgVmFsdWVUeXBlID0gcHJvdG8zLm1ha2VFbnVtKFxuICBcInlvcmtpZS52MS5WYWx1ZVR5cGVcIixcbiAgW1xuICAgIHtubzogMCwgbmFtZTogXCJWQUxVRV9UWVBFX05VTExcIiwgbG9jYWxOYW1lOiBcIk5VTExcIn0sXG4gICAge25vOiAxLCBuYW1lOiBcIlZBTFVFX1RZUEVfQk9PTEVBTlwiLCBsb2NhbE5hbWU6IFwiQk9PTEVBTlwifSxcbiAgICB7bm86IDIsIG5hbWU6IFwiVkFMVUVfVFlQRV9JTlRFR0VSXCIsIGxvY2FsTmFtZTogXCJJTlRFR0VSXCJ9LFxuICAgIHtubzogMywgbmFtZTogXCJWQUxVRV9UWVBFX0xPTkdcIiwgbG9jYWxOYW1lOiBcIkxPTkdcIn0sXG4gICAge25vOiA0LCBuYW1lOiBcIlZBTFVFX1RZUEVfRE9VQkxFXCIsIGxvY2FsTmFtZTogXCJET1VCTEVcIn0sXG4gICAge25vOiA1LCBuYW1lOiBcIlZBTFVFX1RZUEVfU1RSSU5HXCIsIGxvY2FsTmFtZTogXCJTVFJJTkdcIn0sXG4gICAge25vOiA2LCBuYW1lOiBcIlZBTFVFX1RZUEVfQllURVNcIiwgbG9jYWxOYW1lOiBcIkJZVEVTXCJ9LFxuICAgIHtubzogNywgbmFtZTogXCJWQUxVRV9UWVBFX0RBVEVcIiwgbG9jYWxOYW1lOiBcIkRBVEVcIn0sXG4gICAge25vOiA4LCBuYW1lOiBcIlZBTFVFX1RZUEVfSlNPTl9PQkpFQ1RcIiwgbG9jYWxOYW1lOiBcIkpTT05fT0JKRUNUXCJ9LFxuICAgIHtubzogOSwgbmFtZTogXCJWQUxVRV9UWVBFX0pTT05fQVJSQVlcIiwgbG9jYWxOYW1lOiBcIkpTT05fQVJSQVlcIn0sXG4gICAge25vOiAxMCwgbmFtZTogXCJWQUxVRV9UWVBFX1RFWFRcIiwgbG9jYWxOYW1lOiBcIlRFWFRcIn0sXG4gICAge25vOiAxMSwgbmFtZTogXCJWQUxVRV9UWVBFX0lOVEVHRVJfQ05UXCIsIGxvY2FsTmFtZTogXCJJTlRFR0VSX0NOVFwifSxcbiAgICB7bm86IDEyLCBuYW1lOiBcIlZBTFVFX1RZUEVfTE9OR19DTlRcIiwgbG9jYWxOYW1lOiBcIkxPTkdfQ05UXCJ9LFxuICAgIHtubzogMTMsIG5hbWU6IFwiVkFMVUVfVFlQRV9UUkVFXCIsIGxvY2FsTmFtZTogXCJUUkVFXCJ9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB5b3JraWUudjEuRG9jRXZlbnRUeXBlXG4gKi9cbmNvbnN0IERvY0V2ZW50VHlwZSA9IHByb3RvMy5tYWtlRW51bShcbiAgXCJ5b3JraWUudjEuRG9jRXZlbnRUeXBlXCIsXG4gIFtcbiAgICB7bm86IDAsIG5hbWU6IFwiRE9DX0VWRU5UX1RZUEVfRE9DVU1FTlRfQ0hBTkdFRFwiLCBsb2NhbE5hbWU6IFwiRE9DVU1FTlRfQ0hBTkdFRFwifSxcbiAgICB7bm86IDEsIG5hbWU6IFwiRE9DX0VWRU5UX1RZUEVfRE9DVU1FTlRfV0FUQ0hFRFwiLCBsb2NhbE5hbWU6IFwiRE9DVU1FTlRfV0FUQ0hFRFwifSxcbiAgICB7bm86IDIsIG5hbWU6IFwiRE9DX0VWRU5UX1RZUEVfRE9DVU1FTlRfVU5XQVRDSEVEXCIsIGxvY2FsTmFtZTogXCJET0NVTUVOVF9VTldBVENIRURcIn0sXG4gICAge25vOiAzLCBuYW1lOiBcIkRPQ19FVkVOVF9UWVBFX0RPQ1VNRU5UX0JST0FEQ0FTVFwiLCBsb2NhbE5hbWU6IFwiRE9DVU1FTlRfQlJPQURDQVNUXCJ9LFxuICBdLFxuKTtcblxuLyoqXG4gKiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAqIE1lc3NhZ2VzIGZvciBTbmFwc2hvdCAgICAgICAgICAgICAgIC8vXG4gKiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSB5b3JraWUudjEuU25hcHNob3RcbiAqL1xuY29uc3QgU25hcHNob3QgPSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcInlvcmtpZS52MS5TbmFwc2hvdFwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJyb290XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBKU09ORWxlbWVudCB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwicHJlc2VuY2VzXCIsIGtpbmQ6IFwibWFwXCIsIEs6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIFY6IHtraW5kOiBcIm1lc3NhZ2VcIiwgVDogUHJlc2VuY2V9IH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIENoYW5nZVBhY2sgaXMgYSBtZXNzYWdlIHRoYXQgY29udGFpbnMgYWxsIGNoYW5nZXMgdGhhdCBvY2N1cnJlZCBpbiBhIGRvY3VtZW50LlxuICogSXQgaXMgdXNlZCB0byBzeW5jaHJvbml6ZSBjaGFuZ2VzIGJldHdlZW4gY2xpZW50cyBhbmQgc2VydmVycy5cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSB5b3JraWUudjEuQ2hhbmdlUGFja1xuICovXG5jb25zdCBDaGFuZ2VQYWNrID0gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJ5b3JraWUudjEuQ2hhbmdlUGFja1wiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJkb2N1bWVudF9rZXlcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiY2hlY2twb2ludFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogQ2hlY2twb2ludCB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwic25hcHNob3RcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTIgLyogU2NhbGFyVHlwZS5CWVRFUyAqLyB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwiY2hhbmdlc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogQ2hhbmdlLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwibWluX3N5bmNlZF90aWNrZXRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVUaWNrZXQgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcImlzX3JlbW92ZWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgeW9ya2llLnYxLkNoYW5nZVxuICovXG5jb25zdCBDaGFuZ2UgPSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcInlvcmtpZS52MS5DaGFuZ2VcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiaWRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IENoYW5nZUlEIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJtZXNzYWdlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcIm9wZXJhdGlvbnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IE9wZXJhdGlvbiwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcInByZXNlbmNlX2NoYW5nZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUHJlc2VuY2VDaGFuZ2UgfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgeW9ya2llLnYxLkNoYW5nZUlEXG4gKi9cbmNvbnN0IENoYW5nZUlEID0gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJ5b3JraWUudjEuQ2hhbmdlSURcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiY2xpZW50X3NlcVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwic2VydmVyX3NlcVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAzIC8qIFNjYWxhclR5cGUuSU5UNjQgKi8sIEw6IDEgLyogTG9uZ1R5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJsYW1wb3J0XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqLywgTDogMSAvKiBMb25nVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcImFjdG9yX2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEyIC8qIFNjYWxhclR5cGUuQllURVMgKi8gfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgeW9ya2llLnYxLk9wZXJhdGlvblxuICovXG5jb25zdCBPcGVyYXRpb24gPSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcInlvcmtpZS52MS5PcGVyYXRpb25cIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwic2V0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBPcGVyYXRpb25fU2V0LCBvbmVvZjogXCJib2R5XCIgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImFkZFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogT3BlcmF0aW9uX0FkZCwgb25lb2Y6IFwiYm9keVwiIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJtb3ZlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBPcGVyYXRpb25fTW92ZSwgb25lb2Y6IFwiYm9keVwiIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJyZW1vdmVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IE9wZXJhdGlvbl9SZW1vdmUsIG9uZW9mOiBcImJvZHlcIiB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwiZWRpdFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogT3BlcmF0aW9uX0VkaXQsIG9uZW9mOiBcImJvZHlcIiB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwic2VsZWN0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBPcGVyYXRpb25fU2VsZWN0LCBvbmVvZjogXCJib2R5XCIgfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcInN0eWxlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBPcGVyYXRpb25fU3R5bGUsIG9uZW9mOiBcImJvZHlcIiB9LFxuICAgIHsgbm86IDgsIG5hbWU6IFwiaW5jcmVhc2VcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IE9wZXJhdGlvbl9JbmNyZWFzZSwgb25lb2Y6IFwiYm9keVwiIH0sXG4gICAgeyBubzogOSwgbmFtZTogXCJ0cmVlX2VkaXRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IE9wZXJhdGlvbl9UcmVlRWRpdCwgb25lb2Y6IFwiYm9keVwiIH0sXG4gICAgeyBubzogMTAsIG5hbWU6IFwidHJlZV9zdHlsZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogT3BlcmF0aW9uX1RyZWVTdHlsZSwgb25lb2Y6IFwiYm9keVwiIH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIHlvcmtpZS52MS5PcGVyYXRpb24uU2V0XG4gKi9cbmNvbnN0IE9wZXJhdGlvbl9TZXQgPSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcInlvcmtpZS52MS5PcGVyYXRpb24uU2V0XCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInBhcmVudF9jcmVhdGVkX2F0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lVGlja2V0IH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJrZXlcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwidmFsdWVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEpTT05FbGVtZW50U2ltcGxlIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJleGVjdXRlZF9hdFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZVRpY2tldCB9LFxuICBdLFxuICB7bG9jYWxOYW1lOiBcIk9wZXJhdGlvbl9TZXRcIn0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIHlvcmtpZS52MS5PcGVyYXRpb24uQWRkXG4gKi9cbmNvbnN0IE9wZXJhdGlvbl9BZGQgPSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcInlvcmtpZS52MS5PcGVyYXRpb24uQWRkXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInBhcmVudF9jcmVhdGVkX2F0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lVGlja2V0IH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJwcmV2X2NyZWF0ZWRfYXRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVUaWNrZXQgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInZhbHVlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBKU09ORWxlbWVudFNpbXBsZSB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwiZXhlY3V0ZWRfYXRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVUaWNrZXQgfSxcbiAgXSxcbiAge2xvY2FsTmFtZTogXCJPcGVyYXRpb25fQWRkXCJ9LFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSB5b3JraWUudjEuT3BlcmF0aW9uLk1vdmVcbiAqL1xuY29uc3QgT3BlcmF0aW9uX01vdmUgPSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcInlvcmtpZS52MS5PcGVyYXRpb24uTW92ZVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJwYXJlbnRfY3JlYXRlZF9hdFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZVRpY2tldCB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwicHJldl9jcmVhdGVkX2F0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lVGlja2V0IH0sXG4gICAgeyBubzogMywgbmFtZTogXCJjcmVhdGVkX2F0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lVGlja2V0IH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJleGVjdXRlZF9hdFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZVRpY2tldCB9LFxuICBdLFxuICB7bG9jYWxOYW1lOiBcIk9wZXJhdGlvbl9Nb3ZlXCJ9LFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSB5b3JraWUudjEuT3BlcmF0aW9uLlJlbW92ZVxuICovXG5jb25zdCBPcGVyYXRpb25fUmVtb3ZlID0gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJ5b3JraWUudjEuT3BlcmF0aW9uLlJlbW92ZVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJwYXJlbnRfY3JlYXRlZF9hdFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZVRpY2tldCB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiY3JlYXRlZF9hdFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZVRpY2tldCB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiZXhlY3V0ZWRfYXRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVUaWNrZXQgfSxcbiAgXSxcbiAge2xvY2FsTmFtZTogXCJPcGVyYXRpb25fUmVtb3ZlXCJ9LFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSB5b3JraWUudjEuT3BlcmF0aW9uLkVkaXRcbiAqL1xuY29uc3QgT3BlcmF0aW9uX0VkaXQgPSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcInlvcmtpZS52MS5PcGVyYXRpb24uRWRpdFwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJwYXJlbnRfY3JlYXRlZF9hdFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZVRpY2tldCB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiZnJvbVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGV4dE5vZGVQb3MgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInRvXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUZXh0Tm9kZVBvcyB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwiY3JlYXRlZF9hdF9tYXBfYnlfYWN0b3JcIiwga2luZDogXCJtYXBcIiwgSzogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgVjoge2tpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lVGlja2V0fSB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwiY29udGVudFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJleGVjdXRlZF9hdFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZVRpY2tldCB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwiYXR0cmlidXRlc1wiLCBraW5kOiBcIm1hcFwiLCBLOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLCBWOiB7a2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL30gfSxcbiAgXSxcbiAge2xvY2FsTmFtZTogXCJPcGVyYXRpb25fRWRpdFwifSxcbik7XG5cbi8qKlxuICogTk9URShoYWNrZXJ3aW5zKTogU2VsZWN0IE9wZXJhdGlvbiBpcyBub3QgdXNlZCBpbiB0aGUgY3VycmVudCB2ZXJzaW9uLlxuICogSW4gdGhlIHByZXZpb3VzIHZlcnNpb24sIGl0IHdhcyB1c2VkIHRvIHJlcHJlc2VudCBzZWxlY3Rpb24gb2YgVGV4dC5cbiAqIEhvd2V2ZXIsIGl0IGhhcyBiZWVuIHJlcGxhY2VkIGJ5IFByZXNlbmNlIG5vdy4gSXQgaXMgcmV0YWluZWQgZm9yIGJhY2t3YXJkXG4gKiBjb21wYXRpYmlsaXR5IHB1cnBvc2VzLlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIHlvcmtpZS52MS5PcGVyYXRpb24uU2VsZWN0XG4gKi9cbmNvbnN0IE9wZXJhdGlvbl9TZWxlY3QgPSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcInlvcmtpZS52MS5PcGVyYXRpb24uU2VsZWN0XCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInBhcmVudF9jcmVhdGVkX2F0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lVGlja2V0IH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJmcm9tXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUZXh0Tm9kZVBvcyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwidG9cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRleHROb2RlUG9zIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJleGVjdXRlZF9hdFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZVRpY2tldCB9LFxuICBdLFxuICB7bG9jYWxOYW1lOiBcIk9wZXJhdGlvbl9TZWxlY3RcIn0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIHlvcmtpZS52MS5PcGVyYXRpb24uU3R5bGVcbiAqL1xuY29uc3QgT3BlcmF0aW9uX1N0eWxlID0gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJ5b3JraWUudjEuT3BlcmF0aW9uLlN0eWxlXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInBhcmVudF9jcmVhdGVkX2F0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lVGlja2V0IH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJmcm9tXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUZXh0Tm9kZVBvcyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwidG9cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRleHROb2RlUG9zIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJhdHRyaWJ1dGVzXCIsIGtpbmQ6IFwibWFwXCIsIEs6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIFY6IHtraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovfSB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwiZXhlY3V0ZWRfYXRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVUaWNrZXQgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcImNyZWF0ZWRfYXRfbWFwX2J5X2FjdG9yXCIsIGtpbmQ6IFwibWFwXCIsIEs6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIFY6IHtraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZVRpY2tldH0gfSxcbiAgXSxcbiAge2xvY2FsTmFtZTogXCJPcGVyYXRpb25fU3R5bGVcIn0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIHlvcmtpZS52MS5PcGVyYXRpb24uSW5jcmVhc2VcbiAqL1xuY29uc3QgT3BlcmF0aW9uX0luY3JlYXNlID0gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJ5b3JraWUudjEuT3BlcmF0aW9uLkluY3JlYXNlXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInBhcmVudF9jcmVhdGVkX2F0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lVGlja2V0IH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJ2YWx1ZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogSlNPTkVsZW1lbnRTaW1wbGUgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImV4ZWN1dGVkX2F0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lVGlja2V0IH0sXG4gIF0sXG4gIHtsb2NhbE5hbWU6IFwiT3BlcmF0aW9uX0luY3JlYXNlXCJ9LFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSB5b3JraWUudjEuT3BlcmF0aW9uLlRyZWVFZGl0XG4gKi9cbmNvbnN0IE9wZXJhdGlvbl9UcmVlRWRpdCA9IHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwieW9ya2llLnYxLk9wZXJhdGlvbi5UcmVlRWRpdFwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJwYXJlbnRfY3JlYXRlZF9hdFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZVRpY2tldCB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiZnJvbVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVHJlZVBvcyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwidG9cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRyZWVQb3MgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcImNyZWF0ZWRfYXRfbWFwX2J5X2FjdG9yXCIsIGtpbmQ6IFwibWFwXCIsIEs6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIFY6IHtraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZVRpY2tldH0gfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcImNvbnRlbnRzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUcmVlTm9kZXMsIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJzcGxpdF9sZXZlbFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8gfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcImV4ZWN1dGVkX2F0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lVGlja2V0IH0sXG4gIF0sXG4gIHtsb2NhbE5hbWU6IFwiT3BlcmF0aW9uX1RyZWVFZGl0XCJ9LFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSB5b3JraWUudjEuT3BlcmF0aW9uLlRyZWVTdHlsZVxuICovXG5jb25zdCBPcGVyYXRpb25fVHJlZVN0eWxlID0gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJ5b3JraWUudjEuT3BlcmF0aW9uLlRyZWVTdHlsZVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJwYXJlbnRfY3JlYXRlZF9hdFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZVRpY2tldCB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiZnJvbVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVHJlZVBvcyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwidG9cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRyZWVQb3MgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcImF0dHJpYnV0ZXNcIiwga2luZDogXCJtYXBcIiwgSzogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgVjoge2tpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi99IH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJleGVjdXRlZF9hdFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZVRpY2tldCB9LFxuICBdLFxuICB7bG9jYWxOYW1lOiBcIk9wZXJhdGlvbl9UcmVlU3R5bGVcIn0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIHlvcmtpZS52MS5KU09ORWxlbWVudFNpbXBsZVxuICovXG5jb25zdCBKU09ORWxlbWVudFNpbXBsZSA9IHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwieW9ya2llLnYxLkpTT05FbGVtZW50U2ltcGxlXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImNyZWF0ZWRfYXRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVUaWNrZXQgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIm1vdmVkX2F0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lVGlja2V0IH0sXG4gICAgeyBubzogMywgbmFtZTogXCJyZW1vdmVkX2F0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lVGlja2V0IH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVmFsdWVUeXBlKSB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwidmFsdWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTIgLyogU2NhbGFyVHlwZS5CWVRFUyAqLyB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSB5b3JraWUudjEuSlNPTkVsZW1lbnRcbiAqL1xuY29uc3QgSlNPTkVsZW1lbnQgPSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcInlvcmtpZS52MS5KU09ORWxlbWVudFwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJqc29uX29iamVjdFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogSlNPTkVsZW1lbnRfSlNPTk9iamVjdCwgb25lb2Y6IFwiYm9keVwiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJqc29uX2FycmF5XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBKU09ORWxlbWVudF9KU09OQXJyYXksIG9uZW9mOiBcImJvZHlcIiB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwicHJpbWl0aXZlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBKU09ORWxlbWVudF9QcmltaXRpdmUsIG9uZW9mOiBcImJvZHlcIiB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwidGV4dFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogSlNPTkVsZW1lbnRfVGV4dCwgb25lb2Y6IFwiYm9keVwiIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJjb3VudGVyXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBKU09ORWxlbWVudF9Db3VudGVyLCBvbmVvZjogXCJib2R5XCIgfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcInRyZWVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEpTT05FbGVtZW50X1RyZWUsIG9uZW9mOiBcImJvZHlcIiB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSB5b3JraWUudjEuSlNPTkVsZW1lbnQuSlNPTk9iamVjdFxuICovXG5jb25zdCBKU09ORWxlbWVudF9KU09OT2JqZWN0ID0gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJ5b3JraWUudjEuSlNPTkVsZW1lbnQuSlNPTk9iamVjdFwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJub2Rlc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUkhUTm9kZSwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImNyZWF0ZWRfYXRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVUaWNrZXQgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcIm1vdmVkX2F0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lVGlja2V0IH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJyZW1vdmVkX2F0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lVGlja2V0IH0sXG4gIF0sXG4gIHtsb2NhbE5hbWU6IFwiSlNPTkVsZW1lbnRfSlNPTk9iamVjdFwifSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgeW9ya2llLnYxLkpTT05FbGVtZW50LkpTT05BcnJheVxuICovXG5jb25zdCBKU09ORWxlbWVudF9KU09OQXJyYXkgPSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcInlvcmtpZS52MS5KU09ORWxlbWVudC5KU09OQXJyYXlcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwibm9kZXNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFJHQU5vZGUsIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJjcmVhdGVkX2F0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lVGlja2V0IH0sXG4gICAgeyBubzogMywgbmFtZTogXCJtb3ZlZF9hdFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZVRpY2tldCB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwicmVtb3ZlZF9hdFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZVRpY2tldCB9LFxuICBdLFxuICB7bG9jYWxOYW1lOiBcIkpTT05FbGVtZW50X0pTT05BcnJheVwifSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgeW9ya2llLnYxLkpTT05FbGVtZW50LlByaW1pdGl2ZVxuICovXG5jb25zdCBKU09ORWxlbWVudF9QcmltaXRpdmUgPSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcInlvcmtpZS52MS5KU09ORWxlbWVudC5QcmltaXRpdmVcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFZhbHVlVHlwZSkgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInZhbHVlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEyIC8qIFNjYWxhclR5cGUuQllURVMgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImNyZWF0ZWRfYXRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVUaWNrZXQgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcIm1vdmVkX2F0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lVGlja2V0IH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJyZW1vdmVkX2F0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lVGlja2V0IH0sXG4gIF0sXG4gIHtsb2NhbE5hbWU6IFwiSlNPTkVsZW1lbnRfUHJpbWl0aXZlXCJ9LFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSB5b3JraWUudjEuSlNPTkVsZW1lbnQuVGV4dFxuICovXG5jb25zdCBKU09ORWxlbWVudF9UZXh0ID0gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJ5b3JraWUudjEuSlNPTkVsZW1lbnQuVGV4dFwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJub2Rlc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGV4dE5vZGUsIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJjcmVhdGVkX2F0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lVGlja2V0IH0sXG4gICAgeyBubzogMywgbmFtZTogXCJtb3ZlZF9hdFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZVRpY2tldCB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwicmVtb3ZlZF9hdFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZVRpY2tldCB9LFxuICBdLFxuICB7bG9jYWxOYW1lOiBcIkpTT05FbGVtZW50X1RleHRcIn0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIHlvcmtpZS52MS5KU09ORWxlbWVudC5Db3VudGVyXG4gKi9cbmNvbnN0IEpTT05FbGVtZW50X0NvdW50ZXIgPSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcInlvcmtpZS52MS5KU09ORWxlbWVudC5Db3VudGVyXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShWYWx1ZVR5cGUpIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJ2YWx1ZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMiAvKiBTY2FsYXJUeXBlLkJZVEVTICovIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJjcmVhdGVkX2F0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lVGlja2V0IH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJtb3ZlZF9hdFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZVRpY2tldCB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwicmVtb3ZlZF9hdFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZVRpY2tldCB9LFxuICBdLFxuICB7bG9jYWxOYW1lOiBcIkpTT05FbGVtZW50X0NvdW50ZXJcIn0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIHlvcmtpZS52MS5KU09ORWxlbWVudC5UcmVlXG4gKi9cbmNvbnN0IEpTT05FbGVtZW50X1RyZWUgPSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcInlvcmtpZS52MS5KU09ORWxlbWVudC5UcmVlXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcIm5vZGVzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUcmVlTm9kZSwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImNyZWF0ZWRfYXRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVUaWNrZXQgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcIm1vdmVkX2F0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lVGlja2V0IH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJyZW1vdmVkX2F0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lVGlja2V0IH0sXG4gIF0sXG4gIHtsb2NhbE5hbWU6IFwiSlNPTkVsZW1lbnRfVHJlZVwifSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgeW9ya2llLnYxLlJIVE5vZGVcbiAqL1xuY29uc3QgUkhUTm9kZSA9IHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwieW9ya2llLnYxLlJIVE5vZGVcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwia2V5XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImVsZW1lbnRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEpTT05FbGVtZW50IH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIHlvcmtpZS52MS5SR0FOb2RlXG4gKi9cbmNvbnN0IFJHQU5vZGUgPSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcInlvcmtpZS52MS5SR0FOb2RlXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcIm5leHRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFJHQU5vZGUgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImVsZW1lbnRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEpTT05FbGVtZW50IH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIHlvcmtpZS52MS5Ob2RlQXR0clxuICovXG5jb25zdCBOb2RlQXR0ciA9IHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwieW9ya2llLnYxLk5vZGVBdHRyXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInZhbHVlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInVwZGF0ZWRfYXRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVUaWNrZXQgfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgeW9ya2llLnYxLlRleHROb2RlXG4gKi9cbmNvbnN0IFRleHROb2RlID0gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJ5b3JraWUudjEuVGV4dE5vZGVcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiaWRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRleHROb2RlSUQgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInZhbHVlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInJlbW92ZWRfYXRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVUaWNrZXQgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcImluc19wcmV2X2lkXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUZXh0Tm9kZUlEIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJhdHRyaWJ1dGVzXCIsIGtpbmQ6IFwibWFwXCIsIEs6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIFY6IHtraW5kOiBcIm1lc3NhZ2VcIiwgVDogTm9kZUF0dHJ9IH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIHlvcmtpZS52MS5UZXh0Tm9kZUlEXG4gKi9cbmNvbnN0IFRleHROb2RlSUQgPSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcInlvcmtpZS52MS5UZXh0Tm9kZUlEXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImNyZWF0ZWRfYXRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVUaWNrZXQgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIm9mZnNldFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8gfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgeW9ya2llLnYxLlRyZWVOb2RlXG4gKi9cbmNvbnN0IFRyZWVOb2RlID0gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJ5b3JraWUudjEuVHJlZU5vZGVcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiaWRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRyZWVOb2RlSUQgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwidmFsdWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwicmVtb3ZlZF9hdFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZVRpY2tldCB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwiaW5zX3ByZXZfaWRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRyZWVOb2RlSUQgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcImluc19uZXh0X2lkXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUcmVlTm9kZUlEIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJkZXB0aFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8gfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcImF0dHJpYnV0ZXNcIiwga2luZDogXCJtYXBcIiwgSzogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgVjoge2tpbmQ6IFwibWVzc2FnZVwiLCBUOiBOb2RlQXR0cn0gfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgeW9ya2llLnYxLlRyZWVOb2Rlc1xuICovXG5jb25zdCBUcmVlTm9kZXMgPSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcInlvcmtpZS52MS5UcmVlTm9kZXNcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiY29udGVudFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVHJlZU5vZGUsIHJlcGVhdGVkOiB0cnVlIH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIHlvcmtpZS52MS5UcmVlTm9kZUlEXG4gKi9cbmNvbnN0IFRyZWVOb2RlSUQgPSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcInlvcmtpZS52MS5UcmVlTm9kZUlEXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImNyZWF0ZWRfYXRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVUaWNrZXQgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIm9mZnNldFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8gfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgeW9ya2llLnYxLlRyZWVQb3NcbiAqL1xuY29uc3QgVHJlZVBvcyA9IHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwieW9ya2llLnYxLlRyZWVQb3NcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwicGFyZW50X2lkXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUcmVlTm9kZUlEIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJsZWZ0X3NpYmxpbmdfaWRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRyZWVOb2RlSUQgfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgeW9ya2llLnYxLlVzZXJcbiAqL1xuY29uc3QgVXNlciA9IHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwieW9ya2llLnYxLlVzZXJcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwidXNlcm5hbWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiY3JlYXRlZF9hdFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZXN0YW1wIH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIHlvcmtpZS52MS5Qcm9qZWN0XG4gKi9cbmNvbnN0IFByb2plY3QgPSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcInlvcmtpZS52MS5Qcm9qZWN0XCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImlkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIm5hbWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwicHVibGljX2tleVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJzZWNyZXRfa2V5XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcImF1dGhfd2ViaG9va191cmxcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwiYXV0aF93ZWJob29rX21ldGhvZHNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcImNsaWVudF9kZWFjdGl2YXRlX3RocmVzaG9sZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogOCwgbmFtZTogXCJjcmVhdGVkX2F0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lc3RhbXAgfSxcbiAgICB7IG5vOiA5LCBuYW1lOiBcInVwZGF0ZWRfYXRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVzdGFtcCB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSB5b3JraWUudjEuVXBkYXRhYmxlUHJvamVjdEZpZWxkc1xuICovXG5jb25zdCBVcGRhdGFibGVQcm9qZWN0RmllbGRzID0gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJ5b3JraWUudjEuVXBkYXRhYmxlUHJvamVjdEZpZWxkc1wiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJuYW1lXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTdHJpbmdWYWx1ZSB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiYXV0aF93ZWJob29rX3VybFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU3RyaW5nVmFsdWUgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImF1dGhfd2ViaG9va19tZXRob2RzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBVcGRhdGFibGVQcm9qZWN0RmllbGRzX0F1dGhXZWJob29rTWV0aG9kcyB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwiY2xpZW50X2RlYWN0aXZhdGVfdGhyZXNob2xkXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTdHJpbmdWYWx1ZSB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSB5b3JraWUudjEuVXBkYXRhYmxlUHJvamVjdEZpZWxkcy5BdXRoV2ViaG9va01ldGhvZHNcbiAqL1xuY29uc3QgVXBkYXRhYmxlUHJvamVjdEZpZWxkc19BdXRoV2ViaG9va01ldGhvZHMgPSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcInlvcmtpZS52MS5VcGRhdGFibGVQcm9qZWN0RmllbGRzLkF1dGhXZWJob29rTWV0aG9kc1wiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJtZXRob2RzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gIF0sXG4gIHtsb2NhbE5hbWU6IFwiVXBkYXRhYmxlUHJvamVjdEZpZWxkc19BdXRoV2ViaG9va01ldGhvZHNcIn0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIHlvcmtpZS52MS5Eb2N1bWVudFN1bW1hcnlcbiAqL1xuY29uc3QgRG9jdW1lbnRTdW1tYXJ5ID0gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJ5b3JraWUudjEuRG9jdW1lbnRTdW1tYXJ5XCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImlkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImtleVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJzbmFwc2hvdFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJjcmVhdGVkX2F0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lc3RhbXAgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcImFjY2Vzc2VkX2F0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lc3RhbXAgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcInVwZGF0ZWRfYXRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVzdGFtcCB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSB5b3JraWUudjEuUHJlc2VuY2VDaGFuZ2VcbiAqL1xuY29uc3QgUHJlc2VuY2VDaGFuZ2UgPSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcInlvcmtpZS52MS5QcmVzZW5jZUNoYW5nZVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoUHJlc2VuY2VDaGFuZ2VfQ2hhbmdlVHlwZSkgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInByZXNlbmNlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBQcmVzZW5jZSB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB5b3JraWUudjEuUHJlc2VuY2VDaGFuZ2UuQ2hhbmdlVHlwZVxuICovXG5jb25zdCBQcmVzZW5jZUNoYW5nZV9DaGFuZ2VUeXBlID0gcHJvdG8zLm1ha2VFbnVtKFxuICBcInlvcmtpZS52MS5QcmVzZW5jZUNoYW5nZS5DaGFuZ2VUeXBlXCIsXG4gIFtcbiAgICB7bm86IDAsIG5hbWU6IFwiQ0hBTkdFX1RZUEVfVU5TUEVDSUZJRURcIiwgbG9jYWxOYW1lOiBcIlVOU1BFQ0lGSUVEXCJ9LFxuICAgIHtubzogMSwgbmFtZTogXCJDSEFOR0VfVFlQRV9QVVRcIiwgbG9jYWxOYW1lOiBcIlBVVFwifSxcbiAgICB7bm86IDIsIG5hbWU6IFwiQ0hBTkdFX1RZUEVfREVMRVRFXCIsIGxvY2FsTmFtZTogXCJERUxFVEVcIn0sXG4gICAge25vOiAzLCBuYW1lOiBcIkNIQU5HRV9UWVBFX0NMRUFSXCIsIGxvY2FsTmFtZTogXCJDTEVBUlwifSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgeW9ya2llLnYxLlByZXNlbmNlXG4gKi9cbmNvbnN0IFByZXNlbmNlID0gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJ5b3JraWUudjEuUHJlc2VuY2VcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiZGF0YVwiLCBraW5kOiBcIm1hcFwiLCBLOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLCBWOiB7a2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL30gfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgeW9ya2llLnYxLkNoZWNrcG9pbnRcbiAqL1xuY29uc3QgQ2hlY2twb2ludCA9IHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwieW9ya2llLnYxLkNoZWNrcG9pbnRcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwic2VydmVyX3NlcVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAzIC8qIFNjYWxhclR5cGUuSU5UNjQgKi8sIEw6IDEgLyogTG9uZ1R5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJjbGllbnRfc2VxXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIHlvcmtpZS52MS5UZXh0Tm9kZVBvc1xuICovXG5jb25zdCBUZXh0Tm9kZVBvcyA9IHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwieW9ya2llLnYxLlRleHROb2RlUG9zXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImNyZWF0ZWRfYXRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVUaWNrZXQgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIm9mZnNldFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInJlbGF0aXZlX29mZnNldFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8gfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgeW9ya2llLnYxLlRpbWVUaWNrZXRcbiAqL1xuY29uc3QgVGltZVRpY2tldCA9IHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwieW9ya2llLnYxLlRpbWVUaWNrZXRcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwibGFtcG9ydFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAzIC8qIFNjYWxhclR5cGUuSU5UNjQgKi8sIEw6IDEgLyogTG9uZ1R5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJkZWxpbWl0ZXJcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImFjdG9yX2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEyIC8qIFNjYWxhclR5cGUuQllURVMgKi8gfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgeW9ya2llLnYxLkRvY0V2ZW50Qm9keVxuICovXG5jb25zdCBEb2NFdmVudEJvZHkgPSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcInlvcmtpZS52MS5Eb2NFdmVudEJvZHlcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidG9waWNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwicGF5bG9hZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMiAvKiBTY2FsYXJUeXBlLkJZVEVTICovIH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIHlvcmtpZS52MS5Eb2NFdmVudFxuICovXG5jb25zdCBEb2NFdmVudCA9IHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwieW9ya2llLnYxLkRvY0V2ZW50XCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShEb2NFdmVudFR5cGUpIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJwdWJsaXNoZXJcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiYm9keVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogRG9jRXZlbnRCb2R5IH0sXG4gIF0sXG4pO1xuXG5cbmV4cG9ydHMuVmFsdWVUeXBlID0gVmFsdWVUeXBlO1xuZXhwb3J0cy5Eb2NFdmVudFR5cGUgPSBEb2NFdmVudFR5cGU7XG5leHBvcnRzLlNuYXBzaG90ID0gU25hcHNob3Q7XG5leHBvcnRzLkNoYW5nZVBhY2sgPSBDaGFuZ2VQYWNrO1xuZXhwb3J0cy5DaGFuZ2UgPSBDaGFuZ2U7XG5leHBvcnRzLkNoYW5nZUlEID0gQ2hhbmdlSUQ7XG5leHBvcnRzLk9wZXJhdGlvbiA9IE9wZXJhdGlvbjtcbmV4cG9ydHMuT3BlcmF0aW9uX1NldCA9IE9wZXJhdGlvbl9TZXQ7XG5leHBvcnRzLk9wZXJhdGlvbl9BZGQgPSBPcGVyYXRpb25fQWRkO1xuZXhwb3J0cy5PcGVyYXRpb25fTW92ZSA9IE9wZXJhdGlvbl9Nb3ZlO1xuZXhwb3J0cy5PcGVyYXRpb25fUmVtb3ZlID0gT3BlcmF0aW9uX1JlbW92ZTtcbmV4cG9ydHMuT3BlcmF0aW9uX0VkaXQgPSBPcGVyYXRpb25fRWRpdDtcbmV4cG9ydHMuT3BlcmF0aW9uX1NlbGVjdCA9IE9wZXJhdGlvbl9TZWxlY3Q7XG5leHBvcnRzLk9wZXJhdGlvbl9TdHlsZSA9IE9wZXJhdGlvbl9TdHlsZTtcbmV4cG9ydHMuT3BlcmF0aW9uX0luY3JlYXNlID0gT3BlcmF0aW9uX0luY3JlYXNlO1xuZXhwb3J0cy5PcGVyYXRpb25fVHJlZUVkaXQgPSBPcGVyYXRpb25fVHJlZUVkaXQ7XG5leHBvcnRzLk9wZXJhdGlvbl9UcmVlU3R5bGUgPSBPcGVyYXRpb25fVHJlZVN0eWxlO1xuZXhwb3J0cy5KU09ORWxlbWVudFNpbXBsZSA9IEpTT05FbGVtZW50U2ltcGxlO1xuZXhwb3J0cy5KU09ORWxlbWVudCA9IEpTT05FbGVtZW50O1xuZXhwb3J0cy5KU09ORWxlbWVudF9KU09OT2JqZWN0ID0gSlNPTkVsZW1lbnRfSlNPTk9iamVjdDtcbmV4cG9ydHMuSlNPTkVsZW1lbnRfSlNPTkFycmF5ID0gSlNPTkVsZW1lbnRfSlNPTkFycmF5O1xuZXhwb3J0cy5KU09ORWxlbWVudF9QcmltaXRpdmUgPSBKU09ORWxlbWVudF9QcmltaXRpdmU7XG5leHBvcnRzLkpTT05FbGVtZW50X1RleHQgPSBKU09ORWxlbWVudF9UZXh0O1xuZXhwb3J0cy5KU09ORWxlbWVudF9Db3VudGVyID0gSlNPTkVsZW1lbnRfQ291bnRlcjtcbmV4cG9ydHMuSlNPTkVsZW1lbnRfVHJlZSA9IEpTT05FbGVtZW50X1RyZWU7XG5leHBvcnRzLlJIVE5vZGUgPSBSSFROb2RlO1xuZXhwb3J0cy5SR0FOb2RlID0gUkdBTm9kZTtcbmV4cG9ydHMuTm9kZUF0dHIgPSBOb2RlQXR0cjtcbmV4cG9ydHMuVGV4dE5vZGUgPSBUZXh0Tm9kZTtcbmV4cG9ydHMuVGV4dE5vZGVJRCA9IFRleHROb2RlSUQ7XG5leHBvcnRzLlRyZWVOb2RlID0gVHJlZU5vZGU7XG5leHBvcnRzLlRyZWVOb2RlcyA9IFRyZWVOb2RlcztcbmV4cG9ydHMuVHJlZU5vZGVJRCA9IFRyZWVOb2RlSUQ7XG5leHBvcnRzLlRyZWVQb3MgPSBUcmVlUG9zO1xuZXhwb3J0cy5Vc2VyID0gVXNlcjtcbmV4cG9ydHMuUHJvamVjdCA9IFByb2plY3Q7XG5leHBvcnRzLlVwZGF0YWJsZVByb2plY3RGaWVsZHMgPSBVcGRhdGFibGVQcm9qZWN0RmllbGRzO1xuZXhwb3J0cy5VcGRhdGFibGVQcm9qZWN0RmllbGRzX0F1dGhXZWJob29rTWV0aG9kcyA9IFVwZGF0YWJsZVByb2plY3RGaWVsZHNfQXV0aFdlYmhvb2tNZXRob2RzO1xuZXhwb3J0cy5Eb2N1bWVudFN1bW1hcnkgPSBEb2N1bWVudFN1bW1hcnk7XG5leHBvcnRzLlByZXNlbmNlQ2hhbmdlID0gUHJlc2VuY2VDaGFuZ2U7XG5leHBvcnRzLlByZXNlbmNlQ2hhbmdlX0NoYW5nZVR5cGUgPSBQcmVzZW5jZUNoYW5nZV9DaGFuZ2VUeXBlO1xuZXhwb3J0cy5QcmVzZW5jZSA9IFByZXNlbmNlO1xuZXhwb3J0cy5DaGVja3BvaW50ID0gQ2hlY2twb2ludDtcbmV4cG9ydHMuVGV4dE5vZGVQb3MgPSBUZXh0Tm9kZVBvcztcbmV4cG9ydHMuVGltZVRpY2tldCA9IFRpbWVUaWNrZXQ7XG5leHBvcnRzLkRvY0V2ZW50Qm9keSA9IERvY0V2ZW50Qm9keTtcbmV4cG9ydHMuRG9jRXZlbnQgPSBEb2NFdmVudDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjk1OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgX193ZWJwYWNrX3VudXNlZF9leHBvcnRfXztcbi8vXG4vLyBDb3B5cmlnaHQgMjAyMCBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vLyBAZ2VuZXJhdGVkIGJ5IHByb3RvYy1nZW4tY29ubmVjdC1lcyB2MS4yLjAgd2l0aCBwYXJhbWV0ZXIgXCJ0YXJnZXQ9anMrZHRzLGpzX2ltcG9ydF9zdHlsZT1sZWdhY3lfY29tbW9uanNcIlxuLy8gQGdlbmVyYXRlZCBmcm9tIGZpbGUgc3JjL2FwaS95b3JraWUvdjEveW9ya2llLnByb3RvIChwYWNrYWdlIHlvcmtpZS52MSwgc3ludGF4IHByb3RvMylcbi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBAdHMtbm9jaGVja1xuXG5cbl9fd2VicGFja191bnVzZWRfZXhwb3J0X18gPSAoeyB2YWx1ZTogdHJ1ZSB9KTtcblxuY29uc3QgeyBBY3RpdmF0ZUNsaWVudFJlcXVlc3QsIEFjdGl2YXRlQ2xpZW50UmVzcG9uc2UsIEF0dGFjaERvY3VtZW50UmVxdWVzdCwgQXR0YWNoRG9jdW1lbnRSZXNwb25zZSwgQnJvYWRjYXN0UmVxdWVzdCwgQnJvYWRjYXN0UmVzcG9uc2UsIERlYWN0aXZhdGVDbGllbnRSZXF1ZXN0LCBEZWFjdGl2YXRlQ2xpZW50UmVzcG9uc2UsIERldGFjaERvY3VtZW50UmVxdWVzdCwgRGV0YWNoRG9jdW1lbnRSZXNwb25zZSwgUHVzaFB1bGxDaGFuZ2VzUmVxdWVzdCwgUHVzaFB1bGxDaGFuZ2VzUmVzcG9uc2UsIFJlbW92ZURvY3VtZW50UmVxdWVzdCwgUmVtb3ZlRG9jdW1lbnRSZXNwb25zZSwgV2F0Y2hEb2N1bWVudFJlcXVlc3QsIFdhdGNoRG9jdW1lbnRSZXNwb25zZSB9ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzYpO1xuY29uc3QgeyBNZXRob2RLaW5kIH0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzMik7XG5cbi8qKlxuICogWW9ya2llIGlzIGEgc2VydmljZSB0aGF0IHByb3ZpZGVzIGEgQVBJIGZvciBTREtzLlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBzZXJ2aWNlIHlvcmtpZS52MS5Zb3JraWVTZXJ2aWNlXG4gKi9cbmNvbnN0IFlvcmtpZVNlcnZpY2UgPSB7XG4gIHR5cGVOYW1lOiBcInlvcmtpZS52MS5Zb3JraWVTZXJ2aWNlXCIsXG4gIG1ldGhvZHM6IHtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcnBjIHlvcmtpZS52MS5Zb3JraWVTZXJ2aWNlLkFjdGl2YXRlQ2xpZW50XG4gICAgICovXG4gICAgYWN0aXZhdGVDbGllbnQ6IHtcbiAgICAgIG5hbWU6IFwiQWN0aXZhdGVDbGllbnRcIixcbiAgICAgIEk6IEFjdGl2YXRlQ2xpZW50UmVxdWVzdCxcbiAgICAgIE86IEFjdGl2YXRlQ2xpZW50UmVzcG9uc2UsXG4gICAgICBraW5kOiBNZXRob2RLaW5kLlVuYXJ5LFxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHJwYyB5b3JraWUudjEuWW9ya2llU2VydmljZS5EZWFjdGl2YXRlQ2xpZW50XG4gICAgICovXG4gICAgZGVhY3RpdmF0ZUNsaWVudDoge1xuICAgICAgbmFtZTogXCJEZWFjdGl2YXRlQ2xpZW50XCIsXG4gICAgICBJOiBEZWFjdGl2YXRlQ2xpZW50UmVxdWVzdCxcbiAgICAgIE86IERlYWN0aXZhdGVDbGllbnRSZXNwb25zZSxcbiAgICAgIGtpbmQ6IE1ldGhvZEtpbmQuVW5hcnksXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcnBjIHlvcmtpZS52MS5Zb3JraWVTZXJ2aWNlLkF0dGFjaERvY3VtZW50XG4gICAgICovXG4gICAgYXR0YWNoRG9jdW1lbnQ6IHtcbiAgICAgIG5hbWU6IFwiQXR0YWNoRG9jdW1lbnRcIixcbiAgICAgIEk6IEF0dGFjaERvY3VtZW50UmVxdWVzdCxcbiAgICAgIE86IEF0dGFjaERvY3VtZW50UmVzcG9uc2UsXG4gICAgICBraW5kOiBNZXRob2RLaW5kLlVuYXJ5LFxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHJwYyB5b3JraWUudjEuWW9ya2llU2VydmljZS5EZXRhY2hEb2N1bWVudFxuICAgICAqL1xuICAgIGRldGFjaERvY3VtZW50OiB7XG4gICAgICBuYW1lOiBcIkRldGFjaERvY3VtZW50XCIsXG4gICAgICBJOiBEZXRhY2hEb2N1bWVudFJlcXVlc3QsXG4gICAgICBPOiBEZXRhY2hEb2N1bWVudFJlc3BvbnNlLFxuICAgICAga2luZDogTWV0aG9kS2luZC5VbmFyeSxcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBycGMgeW9ya2llLnYxLllvcmtpZVNlcnZpY2UuUmVtb3ZlRG9jdW1lbnRcbiAgICAgKi9cbiAgICByZW1vdmVEb2N1bWVudDoge1xuICAgICAgbmFtZTogXCJSZW1vdmVEb2N1bWVudFwiLFxuICAgICAgSTogUmVtb3ZlRG9jdW1lbnRSZXF1ZXN0LFxuICAgICAgTzogUmVtb3ZlRG9jdW1lbnRSZXNwb25zZSxcbiAgICAgIGtpbmQ6IE1ldGhvZEtpbmQuVW5hcnksXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcnBjIHlvcmtpZS52MS5Zb3JraWVTZXJ2aWNlLlB1c2hQdWxsQ2hhbmdlc1xuICAgICAqL1xuICAgIHB1c2hQdWxsQ2hhbmdlczoge1xuICAgICAgbmFtZTogXCJQdXNoUHVsbENoYW5nZXNcIixcbiAgICAgIEk6IFB1c2hQdWxsQ2hhbmdlc1JlcXVlc3QsXG4gICAgICBPOiBQdXNoUHVsbENoYW5nZXNSZXNwb25zZSxcbiAgICAgIGtpbmQ6IE1ldGhvZEtpbmQuVW5hcnksXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcnBjIHlvcmtpZS52MS5Zb3JraWVTZXJ2aWNlLldhdGNoRG9jdW1lbnRcbiAgICAgKi9cbiAgICB3YXRjaERvY3VtZW50OiB7XG4gICAgICBuYW1lOiBcIldhdGNoRG9jdW1lbnRcIixcbiAgICAgIEk6IFdhdGNoRG9jdW1lbnRSZXF1ZXN0LFxuICAgICAgTzogV2F0Y2hEb2N1bWVudFJlc3BvbnNlLFxuICAgICAga2luZDogTWV0aG9kS2luZC5TZXJ2ZXJTdHJlYW1pbmcsXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcnBjIHlvcmtpZS52MS5Zb3JraWVTZXJ2aWNlLkJyb2FkY2FzdFxuICAgICAqL1xuICAgIGJyb2FkY2FzdDoge1xuICAgICAgbmFtZTogXCJCcm9hZGNhc3RcIixcbiAgICAgIEk6IEJyb2FkY2FzdFJlcXVlc3QsXG4gICAgICBPOiBCcm9hZGNhc3RSZXNwb25zZSxcbiAgICAgIGtpbmQ6IE1ldGhvZEtpbmQuVW5hcnksXG4gICAgfSxcbiAgfVxufTtcblxuXG5leHBvcnRzLlYgPSBZb3JraWVTZXJ2aWNlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNzY6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vXG4vLyBDb3B5cmlnaHQgMjAyMCBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vLyBAZ2VuZXJhdGVkIGJ5IHByb3RvYy1nZW4tZXMgdjEuNi4wIHdpdGggcGFyYW1ldGVyIFwidGFyZ2V0PWpzK2R0cyxqc19pbXBvcnRfc3R5bGU9bGVnYWN5X2NvbW1vbmpzXCJcbi8vIEBnZW5lcmF0ZWQgZnJvbSBmaWxlIHNyYy9hcGkveW9ya2llL3YxL3lvcmtpZS5wcm90byAocGFja2FnZSB5b3JraWUudjEsIHN5bnRheCBwcm90bzMpXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gQHRzLW5vY2hlY2tcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcblxuY29uc3QgeyBwcm90bzMgfSA9IF9fd2VicGFja19yZXF1aXJlX18oNTMyKTtcbmNvbnN0IHsgQ2hhbmdlUGFjaywgRG9jRXZlbnQgfSA9IF9fd2VicGFja19yZXF1aXJlX18oNjQ2KTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSB5b3JraWUudjEuQWN0aXZhdGVDbGllbnRSZXF1ZXN0XG4gKi9cbmNvbnN0IEFjdGl2YXRlQ2xpZW50UmVxdWVzdCA9IHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwieW9ya2llLnYxLkFjdGl2YXRlQ2xpZW50UmVxdWVzdFwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJjbGllbnRfa2V5XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgeW9ya2llLnYxLkFjdGl2YXRlQ2xpZW50UmVzcG9uc2VcbiAqL1xuY29uc3QgQWN0aXZhdGVDbGllbnRSZXNwb25zZSA9IHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwieW9ya2llLnYxLkFjdGl2YXRlQ2xpZW50UmVzcG9uc2VcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiY2xpZW50X2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgeW9ya2llLnYxLkRlYWN0aXZhdGVDbGllbnRSZXF1ZXN0XG4gKi9cbmNvbnN0IERlYWN0aXZhdGVDbGllbnRSZXF1ZXN0ID0gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJ5b3JraWUudjEuRGVhY3RpdmF0ZUNsaWVudFJlcXVlc3RcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiY2xpZW50X2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgeW9ya2llLnYxLkRlYWN0aXZhdGVDbGllbnRSZXNwb25zZVxuICovXG5jb25zdCBEZWFjdGl2YXRlQ2xpZW50UmVzcG9uc2UgPSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcInlvcmtpZS52MS5EZWFjdGl2YXRlQ2xpZW50UmVzcG9uc2VcIixcbiAgW10sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIHlvcmtpZS52MS5BdHRhY2hEb2N1bWVudFJlcXVlc3RcbiAqL1xuY29uc3QgQXR0YWNoRG9jdW1lbnRSZXF1ZXN0ID0gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJ5b3JraWUudjEuQXR0YWNoRG9jdW1lbnRSZXF1ZXN0XCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImNsaWVudF9pZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJjaGFuZ2VfcGFja1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogQ2hhbmdlUGFjayB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSB5b3JraWUudjEuQXR0YWNoRG9jdW1lbnRSZXNwb25zZVxuICovXG5jb25zdCBBdHRhY2hEb2N1bWVudFJlc3BvbnNlID0gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJ5b3JraWUudjEuQXR0YWNoRG9jdW1lbnRSZXNwb25zZVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJkb2N1bWVudF9pZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJjaGFuZ2VfcGFja1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogQ2hhbmdlUGFjayB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSB5b3JraWUudjEuRGV0YWNoRG9jdW1lbnRSZXF1ZXN0XG4gKi9cbmNvbnN0IERldGFjaERvY3VtZW50UmVxdWVzdCA9IHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwieW9ya2llLnYxLkRldGFjaERvY3VtZW50UmVxdWVzdFwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJjbGllbnRfaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiZG9jdW1lbnRfaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiY2hhbmdlX3BhY2tcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IENoYW5nZVBhY2sgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcInJlbW92ZV9pZl9ub3RfYXR0YWNoZWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgeW9ya2llLnYxLkRldGFjaERvY3VtZW50UmVzcG9uc2VcbiAqL1xuY29uc3QgRGV0YWNoRG9jdW1lbnRSZXNwb25zZSA9IHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwieW9ya2llLnYxLkRldGFjaERvY3VtZW50UmVzcG9uc2VcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDIsIG5hbWU6IFwiY2hhbmdlX3BhY2tcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IENoYW5nZVBhY2sgfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgeW9ya2llLnYxLldhdGNoRG9jdW1lbnRSZXF1ZXN0XG4gKi9cbmNvbnN0IFdhdGNoRG9jdW1lbnRSZXF1ZXN0ID0gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJ5b3JraWUudjEuV2F0Y2hEb2N1bWVudFJlcXVlc3RcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiY2xpZW50X2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImRvY3VtZW50X2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgeW9ya2llLnYxLldhdGNoRG9jdW1lbnRSZXNwb25zZVxuICovXG5jb25zdCBXYXRjaERvY3VtZW50UmVzcG9uc2UgPSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcInlvcmtpZS52MS5XYXRjaERvY3VtZW50UmVzcG9uc2VcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiaW5pdGlhbGl6YXRpb25cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFdhdGNoRG9jdW1lbnRSZXNwb25zZV9Jbml0aWFsaXphdGlvbiwgb25lb2Y6IFwiYm9keVwiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJldmVudFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogRG9jRXZlbnQsIG9uZW9mOiBcImJvZHlcIiB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSB5b3JraWUudjEuV2F0Y2hEb2N1bWVudFJlc3BvbnNlLkluaXRpYWxpemF0aW9uXG4gKi9cbmNvbnN0IFdhdGNoRG9jdW1lbnRSZXNwb25zZV9Jbml0aWFsaXphdGlvbiA9IHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwieW9ya2llLnYxLldhdGNoRG9jdW1lbnRSZXNwb25zZS5Jbml0aWFsaXphdGlvblwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJjbGllbnRfaWRzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gIF0sXG4gIHtsb2NhbE5hbWU6IFwiV2F0Y2hEb2N1bWVudFJlc3BvbnNlX0luaXRpYWxpemF0aW9uXCJ9LFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSB5b3JraWUudjEuUmVtb3ZlRG9jdW1lbnRSZXF1ZXN0XG4gKi9cbmNvbnN0IFJlbW92ZURvY3VtZW50UmVxdWVzdCA9IHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwieW9ya2llLnYxLlJlbW92ZURvY3VtZW50UmVxdWVzdFwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJjbGllbnRfaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiZG9jdW1lbnRfaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiY2hhbmdlX3BhY2tcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IENoYW5nZVBhY2sgfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgeW9ya2llLnYxLlJlbW92ZURvY3VtZW50UmVzcG9uc2VcbiAqL1xuY29uc3QgUmVtb3ZlRG9jdW1lbnRSZXNwb25zZSA9IHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwieW9ya2llLnYxLlJlbW92ZURvY3VtZW50UmVzcG9uc2VcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiY2hhbmdlX3BhY2tcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IENoYW5nZVBhY2sgfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgeW9ya2llLnYxLlB1c2hQdWxsQ2hhbmdlc1JlcXVlc3RcbiAqL1xuY29uc3QgUHVzaFB1bGxDaGFuZ2VzUmVxdWVzdCA9IHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwieW9ya2llLnYxLlB1c2hQdWxsQ2hhbmdlc1JlcXVlc3RcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiY2xpZW50X2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImRvY3VtZW50X2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImNoYW5nZV9wYWNrXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBDaGFuZ2VQYWNrIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJwdXNoX29ubHlcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgeW9ya2llLnYxLlB1c2hQdWxsQ2hhbmdlc1Jlc3BvbnNlXG4gKi9cbmNvbnN0IFB1c2hQdWxsQ2hhbmdlc1Jlc3BvbnNlID0gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJ5b3JraWUudjEuUHVzaFB1bGxDaGFuZ2VzUmVzcG9uc2VcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiY2hhbmdlX3BhY2tcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IENoYW5nZVBhY2sgfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgeW9ya2llLnYxLkJyb2FkY2FzdFJlcXVlc3RcbiAqL1xuY29uc3QgQnJvYWRjYXN0UmVxdWVzdCA9IHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwieW9ya2llLnYxLkJyb2FkY2FzdFJlcXVlc3RcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiY2xpZW50X2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImRvY3VtZW50X2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInRvcGljXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcInBheWxvYWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTIgLyogU2NhbGFyVHlwZS5CWVRFUyAqLyB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSB5b3JraWUudjEuQnJvYWRjYXN0UmVzcG9uc2VcbiAqL1xuY29uc3QgQnJvYWRjYXN0UmVzcG9uc2UgPSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcInlvcmtpZS52MS5Ccm9hZGNhc3RSZXNwb25zZVwiLFxuICBbXSxcbik7XG5cblxuZXhwb3J0cy5BY3RpdmF0ZUNsaWVudFJlcXVlc3QgPSBBY3RpdmF0ZUNsaWVudFJlcXVlc3Q7XG5leHBvcnRzLkFjdGl2YXRlQ2xpZW50UmVzcG9uc2UgPSBBY3RpdmF0ZUNsaWVudFJlc3BvbnNlO1xuZXhwb3J0cy5EZWFjdGl2YXRlQ2xpZW50UmVxdWVzdCA9IERlYWN0aXZhdGVDbGllbnRSZXF1ZXN0O1xuZXhwb3J0cy5EZWFjdGl2YXRlQ2xpZW50UmVzcG9uc2UgPSBEZWFjdGl2YXRlQ2xpZW50UmVzcG9uc2U7XG5leHBvcnRzLkF0dGFjaERvY3VtZW50UmVxdWVzdCA9IEF0dGFjaERvY3VtZW50UmVxdWVzdDtcbmV4cG9ydHMuQXR0YWNoRG9jdW1lbnRSZXNwb25zZSA9IEF0dGFjaERvY3VtZW50UmVzcG9uc2U7XG5leHBvcnRzLkRldGFjaERvY3VtZW50UmVxdWVzdCA9IERldGFjaERvY3VtZW50UmVxdWVzdDtcbmV4cG9ydHMuRGV0YWNoRG9jdW1lbnRSZXNwb25zZSA9IERldGFjaERvY3VtZW50UmVzcG9uc2U7XG5leHBvcnRzLldhdGNoRG9jdW1lbnRSZXF1ZXN0ID0gV2F0Y2hEb2N1bWVudFJlcXVlc3Q7XG5leHBvcnRzLldhdGNoRG9jdW1lbnRSZXNwb25zZSA9IFdhdGNoRG9jdW1lbnRSZXNwb25zZTtcbmV4cG9ydHMuV2F0Y2hEb2N1bWVudFJlc3BvbnNlX0luaXRpYWxpemF0aW9uID0gV2F0Y2hEb2N1bWVudFJlc3BvbnNlX0luaXRpYWxpemF0aW9uO1xuZXhwb3J0cy5SZW1vdmVEb2N1bWVudFJlcXVlc3QgPSBSZW1vdmVEb2N1bWVudFJlcXVlc3Q7XG5leHBvcnRzLlJlbW92ZURvY3VtZW50UmVzcG9uc2UgPSBSZW1vdmVEb2N1bWVudFJlc3BvbnNlO1xuZXhwb3J0cy5QdXNoUHVsbENoYW5nZXNSZXF1ZXN0ID0gUHVzaFB1bGxDaGFuZ2VzUmVxdWVzdDtcbmV4cG9ydHMuUHVzaFB1bGxDaGFuZ2VzUmVzcG9uc2UgPSBQdXNoUHVsbENoYW5nZXNSZXNwb25zZTtcbmV4cG9ydHMuQnJvYWRjYXN0UmVxdWVzdCA9IEJyb2FkY2FzdFJlcXVlc3Q7XG5leHBvcnRzLkJyb2FkY2FzdFJlc3BvbnNlID0gQnJvYWRjYXN0UmVzcG9uc2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc5OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBMdDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQmluYXJ5V3JpdGVyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVEQ6ICgpID0+ICgvKiBiaW5kaW5nICovIFdpcmVUeXBlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgb1A6ICgpID0+ICgvKiBiaW5kaW5nICovIEJpbmFyeVJlYWRlcilcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nb29nbGVfdmFyaW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxOCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3ByaXZhdGVfYXNzZXJ0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3Byb3RvX2ludDY0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxMCk7XG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5cblxuLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLWNvbnN0LG5vLWNhc2UtZGVjbGFyYXRpb25zLEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzICovXG4vKipcbiAqIFByb3RvYnVmIGJpbmFyeSBmb3JtYXQgd2lyZSB0eXBlcy5cbiAqXG4gKiBBIHdpcmUgdHlwZSBwcm92aWRlcyBqdXN0IGVub3VnaCBpbmZvcm1hdGlvbiB0byBmaW5kIHRoZSBsZW5ndGggb2YgdGhlXG4gKiBmb2xsb3dpbmcgdmFsdWUuXG4gKlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvZG9jcy9lbmNvZGluZyNzdHJ1Y3R1cmVcbiAqL1xudmFyIFdpcmVUeXBlO1xuKGZ1bmN0aW9uIChXaXJlVHlwZSkge1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGludDMyLCBpbnQ2NCwgdWludDMyLCB1aW50NjQsIHNpbnQzMiwgc2ludDY0LCBib29sLCBlbnVtXG4gICAgICovXG4gICAgV2lyZVR5cGVbV2lyZVR5cGVbXCJWYXJpbnRcIl0gPSAwXSA9IFwiVmFyaW50XCI7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgZml4ZWQ2NCwgc2ZpeGVkNjQsIGRvdWJsZS5cbiAgICAgKiBBbHdheXMgOCBieXRlcyB3aXRoIGxpdHRsZS1lbmRpYW4gYnl0ZSBvcmRlci5cbiAgICAgKi9cbiAgICBXaXJlVHlwZVtXaXJlVHlwZVtcIkJpdDY0XCJdID0gMV0gPSBcIkJpdDY0XCI7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3Igc3RyaW5nLCBieXRlcywgZW1iZWRkZWQgbWVzc2FnZXMsIHBhY2tlZCByZXBlYXRlZCBmaWVsZHNcbiAgICAgKlxuICAgICAqIE9ubHkgcmVwZWF0ZWQgbnVtZXJpYyB0eXBlcyAodHlwZXMgd2hpY2ggdXNlIHRoZSB2YXJpbnQsIDMyLWJpdCxcbiAgICAgKiBvciA2NC1iaXQgd2lyZSB0eXBlcykgY2FuIGJlIHBhY2tlZC4gSW4gcHJvdG8zLCBzdWNoIGZpZWxkcyBhcmVcbiAgICAgKiBwYWNrZWQgYnkgZGVmYXVsdC5cbiAgICAgKi9cbiAgICBXaXJlVHlwZVtXaXJlVHlwZVtcIkxlbmd0aERlbGltaXRlZFwiXSA9IDJdID0gXCJMZW5ndGhEZWxpbWl0ZWRcIjtcbiAgICAvKipcbiAgICAgKiBTdGFydCBvZiBhIHRhZy1kZWxpbWl0ZWQgYWdncmVnYXRlLCBzdWNoIGFzIGEgcHJvdG8yIGdyb3VwLCBvciBhIG1lc3NhZ2VcbiAgICAgKiBpbiBlZGl0aW9ucyB3aXRoIG1lc3NhZ2VfZW5jb2RpbmcgPSBERUxJTUlURUQuXG4gICAgICovXG4gICAgV2lyZVR5cGVbV2lyZVR5cGVbXCJTdGFydEdyb3VwXCJdID0gM10gPSBcIlN0YXJ0R3JvdXBcIjtcbiAgICAvKipcbiAgICAgKiBFbmQgb2YgYSB0YWctZGVsaW1pdGVkIGFnZ3JlZ2F0ZS5cbiAgICAgKi9cbiAgICBXaXJlVHlwZVtXaXJlVHlwZVtcIkVuZEdyb3VwXCJdID0gNF0gPSBcIkVuZEdyb3VwXCI7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgZml4ZWQzMiwgc2ZpeGVkMzIsIGZsb2F0LlxuICAgICAqIEFsd2F5cyA0IGJ5dGVzIHdpdGggbGl0dGxlLWVuZGlhbiBieXRlIG9yZGVyLlxuICAgICAqL1xuICAgIFdpcmVUeXBlW1dpcmVUeXBlW1wiQml0MzJcIl0gPSA1XSA9IFwiQml0MzJcIjtcbn0pKFdpcmVUeXBlIHx8IChXaXJlVHlwZSA9IHt9KSk7XG5jbGFzcyBCaW5hcnlXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHRleHRFbmNvZGVyKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcmV2aW91cyBmb3JrIHN0YXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy50ZXh0RW5jb2RlciA9IHRleHRFbmNvZGVyICE9PSBudWxsICYmIHRleHRFbmNvZGVyICE9PSB2b2lkIDAgPyB0ZXh0RW5jb2RlciA6IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICB0aGlzLmJ1ZiA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYWxsIGJ5dGVzIHdyaXR0ZW4gYW5kIHJlc2V0IHRoaXMgd3JpdGVyLlxuICAgICAqL1xuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgdGhpcy5jaHVua3MucHVzaChuZXcgVWludDhBcnJheSh0aGlzLmJ1ZikpOyAvLyBmbHVzaCB0aGUgYnVmZmVyXG4gICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgbGVuICs9IHRoaXMuY2h1bmtzW2ldLmxlbmd0aDtcbiAgICAgICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJ5dGVzLnNldCh0aGlzLmNodW5rc1tpXSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCArPSB0aGlzLmNodW5rc1tpXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBhIG5ldyBmb3JrIGZvciBsZW5ndGgtZGVsaW1pdGVkIGRhdGEgbGlrZSBhIG1lc3NhZ2VcbiAgICAgKiBvciBhIHBhY2tlZCByZXBlYXRlZCBmaWVsZC5cbiAgICAgKlxuICAgICAqIE11c3QgYmUgam9pbmVkIGxhdGVyIHdpdGggYGpvaW4oKWAuXG4gICAgICovXG4gICAgZm9yaygpIHtcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKHsgY2h1bmtzOiB0aGlzLmNodW5rcywgYnVmOiB0aGlzLmJ1ZiB9KTtcbiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICAgICAgdGhpcy5idWYgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEpvaW4gdGhlIGxhc3QgZm9yay4gV3JpdGUgaXRzIGxlbmd0aCBhbmQgYnl0ZXMsIHRoZW5cbiAgICAgKiByZXR1cm4gdG8gdGhlIHByZXZpb3VzIHN0YXRlLlxuICAgICAqL1xuICAgIGpvaW4oKSB7XG4gICAgICAgIC8vIGdldCBjaHVuayBvZiBmb3JrXG4gICAgICAgIGxldCBjaHVuayA9IHRoaXMuZmluaXNoKCk7XG4gICAgICAgIC8vIHJlc3RvcmUgcHJldmlvdXMgc3RhdGVcbiAgICAgICAgbGV0IHByZXYgPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAoIXByZXYpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHN0YXRlLCBmb3JrIHN0YWNrIGVtcHR5XCIpO1xuICAgICAgICB0aGlzLmNodW5rcyA9IHByZXYuY2h1bmtzO1xuICAgICAgICB0aGlzLmJ1ZiA9IHByZXYuYnVmO1xuICAgICAgICAvLyB3cml0ZSBsZW5ndGggb2YgY2h1bmsgYXMgdmFyaW50XG4gICAgICAgIHRoaXMudWludDMyKGNodW5rLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSB0YWcgKGZpZWxkIG51bWJlciBhbmQgd2lyZSB0eXBlKS5cbiAgICAgKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gYHVpbnQzMiggKGZpZWxkTm8gPDwgMyB8IHR5cGUpID4+PiAwIClgLlxuICAgICAqXG4gICAgICogR2VuZXJhdGVkIGNvZGUgc2hvdWxkIGNvbXB1dGUgdGhlIHRhZyBhaGVhZCBvZiB0aW1lIGFuZCBjYWxsIGB1aW50MzIoKWAuXG4gICAgICovXG4gICAgdGFnKGZpZWxkTm8sIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudWludDMyKCgoZmllbGRObyA8PCAzKSB8IHR5cGUpID4+PiAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBjaHVuayBvZiByYXcgYnl0ZXMuXG4gICAgICovXG4gICAgcmF3KGNodW5rKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtzLnB1c2gobmV3IFVpbnQ4QXJyYXkodGhpcy5idWYpKTtcbiAgICAgICAgICAgIHRoaXMuYnVmID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGB1aW50MzJgIHZhbHVlLCBhbiB1bnNpZ25lZCAzMiBiaXQgdmFyaW50LlxuICAgICAqL1xuICAgIHVpbnQzMih2YWx1ZSkge1xuICAgICAgICAoMCxfcHJpdmF0ZV9hc3NlcnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5hc3NlcnRVSW50MzIgKi8gLmZwKSh2YWx1ZSk7XG4gICAgICAgIC8vIHdyaXRlIHZhbHVlIGFzIHZhcmludCAzMiwgaW5saW5lZCBmb3Igc3BlZWRcbiAgICAgICAgd2hpbGUgKHZhbHVlID4gMHg3Zikge1xuICAgICAgICAgICAgdGhpcy5idWYucHVzaCgodmFsdWUgJiAweDdmKSB8IDB4ODApO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA+Pj4gNztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1Zi5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYGludDMyYCB2YWx1ZSwgYSBzaWduZWQgMzIgYml0IHZhcmludC5cbiAgICAgKi9cbiAgICBpbnQzMih2YWx1ZSkge1xuICAgICAgICAoMCxfcHJpdmF0ZV9hc3NlcnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5hc3NlcnRJbnQzMiAqLyAudWcpKHZhbHVlKTtcbiAgICAgICAgKDAsX2dvb2dsZV92YXJpbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC52YXJpbnQzMndyaXRlICovIC5mQykodmFsdWUsIHRoaXMuYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYGJvb2xgIHZhbHVlLCBhIHZhcmlhbnQuXG4gICAgICovXG4gICAgYm9vbCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmJ1Zi5wdXNoKHZhbHVlID8gMSA6IDApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgYnl0ZXNgIHZhbHVlLCBsZW5ndGgtZGVsaW1pdGVkIGFyYml0cmFyeSBkYXRhLlxuICAgICAqL1xuICAgIGJ5dGVzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudWludDMyKHZhbHVlLmJ5dGVMZW5ndGgpOyAvLyB3cml0ZSBsZW5ndGggb2YgY2h1bmsgYXMgdmFyaW50XG4gICAgICAgIHJldHVybiB0aGlzLnJhdyh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYHN0cmluZ2AgdmFsdWUsIGxlbmd0aC1kZWxpbWl0ZWQgZGF0YSBjb252ZXJ0ZWQgdG8gVVRGLTggdGV4dC5cbiAgICAgKi9cbiAgICBzdHJpbmcodmFsdWUpIHtcbiAgICAgICAgbGV0IGNodW5rID0gdGhpcy50ZXh0RW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgICAgICB0aGlzLnVpbnQzMihjaHVuay5ieXRlTGVuZ3RoKTsgLy8gd3JpdGUgbGVuZ3RoIG9mIGNodW5rIGFzIHZhcmludFxuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBmbG9hdGAgdmFsdWUsIDMyLWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gICAgICovXG4gICAgZmxvYXQodmFsdWUpIHtcbiAgICAgICAgKDAsX3ByaXZhdGVfYXNzZXJ0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAuYXNzZXJ0RmxvYXQzMiAqLyAuRV8pKHZhbHVlKTtcbiAgICAgICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgIG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLnNldEZsb2F0MzIoMCwgdmFsdWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBkb3VibGVgIHZhbHVlLCBhIDY0LWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gICAgICovXG4gICAgZG91YmxlKHZhbHVlKSB7XG4gICAgICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgICAgICBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKS5zZXRGbG9hdDY0KDAsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgZml4ZWQzMmAgdmFsdWUsIGFuIHVuc2lnbmVkLCBmaXhlZC1sZW5ndGggMzItYml0IGludGVnZXIuXG4gICAgICovXG4gICAgZml4ZWQzMih2YWx1ZSkge1xuICAgICAgICAoMCxfcHJpdmF0ZV9hc3NlcnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5hc3NlcnRVSW50MzIgKi8gLmZwKSh2YWx1ZSk7XG4gICAgICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgICBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKS5zZXRVaW50MzIoMCwgdmFsdWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBzZml4ZWQzMmAgdmFsdWUsIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggMzItYml0IGludGVnZXIuXG4gICAgICovXG4gICAgc2ZpeGVkMzIodmFsdWUpIHtcbiAgICAgICAgKDAsX3ByaXZhdGVfYXNzZXJ0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAuYXNzZXJ0SW50MzIgKi8gLnVnKSh2YWx1ZSk7XG4gICAgICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgICBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKS5zZXRJbnQzMigwLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYHNpbnQzMmAgdmFsdWUsIGEgc2lnbmVkLCB6aWd6YWctZW5jb2RlZCAzMi1iaXQgdmFyaW50LlxuICAgICAqL1xuICAgIHNpbnQzMih2YWx1ZSkge1xuICAgICAgICAoMCxfcHJpdmF0ZV9hc3NlcnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5hc3NlcnRJbnQzMiAqLyAudWcpKHZhbHVlKTtcbiAgICAgICAgLy8gemlnemFnIGVuY29kZVxuICAgICAgICB2YWx1ZSA9ICgodmFsdWUgPDwgMSkgXiAodmFsdWUgPj4gMzEpKSA+Pj4gMDtcbiAgICAgICAgKDAsX2dvb2dsZV92YXJpbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC52YXJpbnQzMndyaXRlICovIC5mQykodmFsdWUsIHRoaXMuYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYGZpeGVkNjRgIHZhbHVlLCBhIHNpZ25lZCwgZml4ZWQtbGVuZ3RoIDY0LWJpdCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIHNmaXhlZDY0KHZhbHVlKSB7XG4gICAgICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDgpLCB2aWV3ID0gbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlciksIHRjID0gX3Byb3RvX2ludDY0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18vKiAucHJvdG9JbnQ2NCAqLyAucS5lbmModmFsdWUpO1xuICAgICAgICB2aWV3LnNldEludDMyKDAsIHRjLmxvLCB0cnVlKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMig0LCB0Yy5oaSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYGZpeGVkNjRgIHZhbHVlLCBhbiB1bnNpZ25lZCwgZml4ZWQtbGVuZ3RoIDY0IGJpdCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIGZpeGVkNjQodmFsdWUpIHtcbiAgICAgICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoOCksIHZpZXcgPSBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKSwgdGMgPSBfcHJvdG9faW50NjRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy8qIC5wcm90b0ludDY0ICovIC5xLnVFbmModmFsdWUpO1xuICAgICAgICB2aWV3LnNldEludDMyKDAsIHRjLmxvLCB0cnVlKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMig0LCB0Yy5oaSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYGludDY0YCB2YWx1ZSwgYSBzaWduZWQgNjQtYml0IHZhcmludC5cbiAgICAgKi9cbiAgICBpbnQ2NCh2YWx1ZSkge1xuICAgICAgICBsZXQgdGMgPSBfcHJvdG9faW50NjRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy8qIC5wcm90b0ludDY0ICovIC5xLmVuYyh2YWx1ZSk7XG4gICAgICAgICgwLF9nb29nbGVfdmFyaW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18vKiAudmFyaW50NjR3cml0ZSAqLyAuX3kpKHRjLmxvLCB0Yy5oaSwgdGhpcy5idWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgc2ludDY0YCB2YWx1ZSwgYSBzaWduZWQsIHppZy16YWctZW5jb2RlZCA2NC1iaXQgdmFyaW50LlxuICAgICAqL1xuICAgIHNpbnQ2NCh2YWx1ZSkge1xuICAgICAgICBsZXQgdGMgPSBfcHJvdG9faW50NjRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy8qIC5wcm90b0ludDY0ICovIC5xLmVuYyh2YWx1ZSksIFxuICAgICAgICAvLyB6aWd6YWcgZW5jb2RlXG4gICAgICAgIHNpZ24gPSB0Yy5oaSA+PiAzMSwgbG8gPSAodGMubG8gPDwgMSkgXiBzaWduLCBoaSA9ICgodGMuaGkgPDwgMSkgfCAodGMubG8gPj4+IDMxKSkgXiBzaWduO1xuICAgICAgICAoMCxfZ29vZ2xlX3ZhcmludF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLnZhcmludDY0d3JpdGUgKi8gLl95KShsbywgaGksIHRoaXMuYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYHVpbnQ2NGAgdmFsdWUsIGFuIHVuc2lnbmVkIDY0LWJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgdWludDY0KHZhbHVlKSB7XG4gICAgICAgIGxldCB0YyA9IF9wcm90b19pbnQ2NF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLyogLnByb3RvSW50NjQgKi8gLnEudUVuYyh2YWx1ZSk7XG4gICAgICAgICgwLF9nb29nbGVfdmFyaW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18vKiAudmFyaW50NjR3cml0ZSAqLyAuX3kpKHRjLmxvLCB0Yy5oaSwgdGhpcy5idWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5jbGFzcyBCaW5hcnlSZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKGJ1ZiwgdGV4dERlY29kZXIpIHtcbiAgICAgICAgdGhpcy52YXJpbnQ2NCA9IF9nb29nbGVfdmFyaW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18vKiAudmFyaW50NjRyZWFkICovIC5zZzsgLy8gZGlydHkgY2FzdCBmb3IgYHRoaXNgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkIGEgYHVpbnQzMmAgZmllbGQsIGFuIHVuc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVpbnQzMiA9IF9nb29nbGVfdmFyaW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18vKiAudmFyaW50MzJyZWFkICovIC5qSTsgLy8gZGlydHkgY2FzdCBmb3IgYHRoaXNgIGFuZCBhY2Nlc3MgdG8gcHJvdGVjdGVkIGBidWZgXG4gICAgICAgIHRoaXMuYnVmID0gYnVmO1xuICAgICAgICB0aGlzLmxlbiA9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IERhdGFWaWV3KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHRoaXMudGV4dERlY29kZXIgPSB0ZXh0RGVjb2RlciAhPT0gbnVsbCAmJiB0ZXh0RGVjb2RlciAhPT0gdm9pZCAwID8gdGV4dERlY29kZXIgOiBuZXcgVGV4dERlY29kZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYSB0YWcgLSBmaWVsZCBudW1iZXIgYW5kIHdpcmUgdHlwZS5cbiAgICAgKi9cbiAgICB0YWcoKSB7XG4gICAgICAgIGxldCB0YWcgPSB0aGlzLnVpbnQzMigpLCBmaWVsZE5vID0gdGFnID4+PiAzLCB3aXJlVHlwZSA9IHRhZyAmIDc7XG4gICAgICAgIGlmIChmaWVsZE5vIDw9IDAgfHwgd2lyZVR5cGUgPCAwIHx8IHdpcmVUeXBlID4gNSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgdGFnOiBmaWVsZCBubyBcIiArIGZpZWxkTm8gKyBcIiB3aXJlIHR5cGUgXCIgKyB3aXJlVHlwZSk7XG4gICAgICAgIHJldHVybiBbZmllbGRObywgd2lyZVR5cGVdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTa2lwIG9uZSBlbGVtZW50IG9uIHRoZSB3aXJlIGFuZCByZXR1cm4gdGhlIHNraXBwZWQgZGF0YS5cbiAgICAgKiBTdXBwb3J0cyBXaXJlVHlwZS5TdGFydEdyb3VwIHNpbmNlIHYyLjAuMC1hbHBoYS4yMy5cbiAgICAgKi9cbiAgICBza2lwKHdpcmVUeXBlKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICBzd2l0Y2ggKHdpcmVUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFdpcmVUeXBlLlZhcmludDpcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBUUzcwMjk6IEZhbGx0aHJvdWdoIGNhc2UgaW4gc3dpdGNoXG4gICAgICAgICAgICBjYXNlIFdpcmVUeXBlLkJpdDY0OlxuICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgVFM3MDI5OiBGYWxsdGhyb3VnaCBjYXNlIGluIHN3aXRjaFxuICAgICAgICAgICAgY2FzZSBXaXJlVHlwZS5CaXQzMjpcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQ6XG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMudWludDMyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gbGVuO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBXaXJlVHlwZS5TdGFydEdyb3VwOlxuICAgICAgICAgICAgICAgIC8vIEZyb20gZGVzY3JpcHRvci5wcm90bzogR3JvdXAgdHlwZSBpcyBkZXByZWNhdGVkLCBub3Qgc3VwcG9ydGVkIGluIHByb3RvMy5cbiAgICAgICAgICAgICAgICAvLyBCdXQgd2UgbXVzdCBzdGlsbCBiZSBhYmxlIHRvIHBhcnNlIGFuZCB0cmVhdCBhcyB1bmtub3duLlxuICAgICAgICAgICAgICAgIGxldCB0O1xuICAgICAgICAgICAgICAgIHdoaWxlICgodCA9IHRoaXMudGFnKClbMV0pICE9PSBXaXJlVHlwZS5FbmRHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNraXAodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW50IHNraXAgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Zi5zdWJhcnJheShzdGFydCwgdGhpcy5wb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaHJvd3MgZXJyb3IgaWYgcG9zaXRpb24gaW4gYnl0ZSBhcnJheSBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgICovXG4gICAgYXNzZXJ0Qm91bmRzKCkge1xuICAgICAgICBpZiAodGhpcy5wb3MgPiB0aGlzLmxlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwicHJlbWF0dXJlIEVPRlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBpbnQzMmAgZmllbGQsIGEgc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgaW50MzIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVpbnQzMigpIHwgMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBzaW50MzJgIGZpZWxkLCBhIHNpZ25lZCwgemlnemFnLWVuY29kZWQgMzItYml0IHZhcmludC5cbiAgICAgKi9cbiAgICBzaW50MzIoKSB7XG4gICAgICAgIGxldCB6emUgPSB0aGlzLnVpbnQzMigpO1xuICAgICAgICAvLyBkZWNvZGUgemlnemFnXG4gICAgICAgIHJldHVybiAoenplID4+PiAxKSBeIC0oenplICYgMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgaW50NjRgIGZpZWxkLCBhIHNpZ25lZCA2NC1iaXQgdmFyaW50LlxuICAgICAqL1xuICAgIGludDY0KCkge1xuICAgICAgICByZXR1cm4gX3Byb3RvX2ludDY0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18vKiAucHJvdG9JbnQ2NCAqLyAucS5kZWMoLi4udGhpcy52YXJpbnQ2NCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGB1aW50NjRgIGZpZWxkLCBhbiB1bnNpZ25lZCA2NC1iaXQgdmFyaW50LlxuICAgICAqL1xuICAgIHVpbnQ2NCgpIHtcbiAgICAgICAgcmV0dXJuIF9wcm90b19pbnQ2NF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLyogLnByb3RvSW50NjQgKi8gLnEudURlYyguLi50aGlzLnZhcmludDY0KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYHNpbnQ2NGAgZmllbGQsIGEgc2lnbmVkLCB6aWctemFnLWVuY29kZWQgNjQtYml0IHZhcmludC5cbiAgICAgKi9cbiAgICBzaW50NjQoKSB7XG4gICAgICAgIGxldCBbbG8sIGhpXSA9IHRoaXMudmFyaW50NjQoKTtcbiAgICAgICAgLy8gZGVjb2RlIHppZyB6YWdcbiAgICAgICAgbGV0IHMgPSAtKGxvICYgMSk7XG4gICAgICAgIGxvID0gKChsbyA+Pj4gMSkgfCAoKGhpICYgMSkgPDwgMzEpKSBeIHM7XG4gICAgICAgIGhpID0gKGhpID4+PiAxKSBeIHM7XG4gICAgICAgIHJldHVybiBfcHJvdG9faW50NjRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy8qIC5wcm90b0ludDY0ICovIC5xLmRlYyhsbywgaGkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGJvb2xgIGZpZWxkLCBhIHZhcmlhbnQuXG4gICAgICovXG4gICAgYm9vbCgpIHtcbiAgICAgICAgbGV0IFtsbywgaGldID0gdGhpcy52YXJpbnQ2NCgpO1xuICAgICAgICByZXR1cm4gbG8gIT09IDAgfHwgaGkgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgZml4ZWQzMmAgZmllbGQsIGFuIHVuc2lnbmVkLCBmaXhlZC1sZW5ndGggMzItYml0IGludGVnZXIuXG4gICAgICovXG4gICAgZml4ZWQzMigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5nZXRVaW50MzIoKHRoaXMucG9zICs9IDQpIC0gNCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgc2ZpeGVkMzJgIGZpZWxkLCBhIHNpZ25lZCwgZml4ZWQtbGVuZ3RoIDMyLWJpdCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIHNmaXhlZDMyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmdldEludDMyKCh0aGlzLnBvcyArPSA0KSAtIDQsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGZpeGVkNjRgIGZpZWxkLCBhbiB1bnNpZ25lZCwgZml4ZWQtbGVuZ3RoIDY0IGJpdCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIGZpeGVkNjQoKSB7XG4gICAgICAgIHJldHVybiBfcHJvdG9faW50NjRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy8qIC5wcm90b0ludDY0ICovIC5xLnVEZWModGhpcy5zZml4ZWQzMigpLCB0aGlzLnNmaXhlZDMyKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGZpeGVkNjRgIGZpZWxkLCBhIHNpZ25lZCwgZml4ZWQtbGVuZ3RoIDY0LWJpdCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIHNmaXhlZDY0KCkge1xuICAgICAgICByZXR1cm4gX3Byb3RvX2ludDY0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18vKiAucHJvdG9JbnQ2NCAqLyAucS5kZWModGhpcy5zZml4ZWQzMigpLCB0aGlzLnNmaXhlZDMyKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGZsb2F0YCBmaWVsZCwgMzItYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICAgKi9cbiAgICBmbG9hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5nZXRGbG9hdDMyKCh0aGlzLnBvcyArPSA0KSAtIDQsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGRvdWJsZWAgZmllbGQsIGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICAgKi9cbiAgICBkb3VibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0RmxvYXQ2NCgodGhpcy5wb3MgKz0gOCkgLSA4LCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBieXRlc2AgZmllbGQsIGxlbmd0aC1kZWxpbWl0ZWQgYXJiaXRyYXJ5IGRhdGEuXG4gICAgICovXG4gICAgYnl0ZXMoKSB7XG4gICAgICAgIGxldCBsZW4gPSB0aGlzLnVpbnQzMigpLCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLnBvcyArPSBsZW47XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Zi5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYHN0cmluZ2AgZmllbGQsIGxlbmd0aC1kZWxpbWl0ZWQgZGF0YSBjb252ZXJ0ZWQgdG8gVVRGLTggdGV4dC5cbiAgICAgKi9cbiAgICBzdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHREZWNvZGVyLmRlY29kZSh0aGlzLmJ5dGVzKCkpO1xuICAgIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDY1OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBwOiAoKSA9PiAoLyogYmluZGluZyAqLyBMb25nVHlwZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHc6ICgpID0+ICgvKiBiaW5kaW5nICovIFNjYWxhclR5cGUpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIFNjYWxhciB2YWx1ZSB0eXBlcy4gVGhpcyBpcyBhIHN1YnNldCBvZiBmaWVsZCB0eXBlcyBkZWNsYXJlZCBieSBwcm90b2J1ZlxuICogZW51bSBnb29nbGUucHJvdG9idWYuRmllbGREZXNjcmlwdG9yUHJvdG8uVHlwZSBUaGUgdHlwZXMgR1JPVVAgYW5kIE1FU1NBR0VcbiAqIGFyZSBvbWl0dGVkLCBidXQgdGhlIG51bWVyaWNhbCB2YWx1ZXMgYXJlIGlkZW50aWNhbC5cbiAqL1xudmFyIFNjYWxhclR5cGU7XG4oZnVuY3Rpb24gKFNjYWxhclR5cGUpIHtcbiAgICAvLyAwIGlzIHJlc2VydmVkIGZvciBlcnJvcnMuXG4gICAgLy8gT3JkZXIgaXMgd2VpcmQgZm9yIGhpc3RvcmljYWwgcmVhc29ucy5cbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJET1VCTEVcIl0gPSAxXSA9IFwiRE9VQkxFXCI7XG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiRkxPQVRcIl0gPSAyXSA9IFwiRkxPQVRcIjtcbiAgICAvLyBOb3QgWmlnWmFnIGVuY29kZWQuICBOZWdhdGl2ZSBudW1iZXJzIHRha2UgMTAgYnl0ZXMuICBVc2UgVFlQRV9TSU5UNjQgaWZcbiAgICAvLyBuZWdhdGl2ZSB2YWx1ZXMgYXJlIGxpa2VseS5cbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJJTlQ2NFwiXSA9IDNdID0gXCJJTlQ2NFwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlVJTlQ2NFwiXSA9IDRdID0gXCJVSU5UNjRcIjtcbiAgICAvLyBOb3QgWmlnWmFnIGVuY29kZWQuICBOZWdhdGl2ZSBudW1iZXJzIHRha2UgMTAgYnl0ZXMuICBVc2UgVFlQRV9TSU5UMzIgaWZcbiAgICAvLyBuZWdhdGl2ZSB2YWx1ZXMgYXJlIGxpa2VseS5cbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJJTlQzMlwiXSA9IDVdID0gXCJJTlQzMlwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkZJWEVENjRcIl0gPSA2XSA9IFwiRklYRUQ2NFwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkZJWEVEMzJcIl0gPSA3XSA9IFwiRklYRUQzMlwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkJPT0xcIl0gPSA4XSA9IFwiQk9PTFwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNUUklOR1wiXSA9IDldID0gXCJTVFJJTkdcIjtcbiAgICAvLyBUYWctZGVsaW1pdGVkIGFnZ3JlZ2F0ZS5cbiAgICAvLyBHcm91cCB0eXBlIGlzIGRlcHJlY2F0ZWQgYW5kIG5vdCBzdXBwb3J0ZWQgaW4gcHJvdG8zLiBIb3dldmVyLCBQcm90bzNcbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIHN0aWxsIGJlIGFibGUgdG8gcGFyc2UgdGhlIGdyb3VwIHdpcmUgZm9ybWF0IGFuZFxuICAgIC8vIHRyZWF0IGdyb3VwIGZpZWxkcyBhcyB1bmtub3duIGZpZWxkcy5cbiAgICAvLyBUWVBFX0dST1VQID0gMTAsXG4gICAgLy8gVFlQRV9NRVNTQUdFID0gMTEsICAvLyBMZW5ndGgtZGVsaW1pdGVkIGFnZ3JlZ2F0ZS5cbiAgICAvLyBOZXcgaW4gdmVyc2lvbiAyLlxuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkJZVEVTXCJdID0gMTJdID0gXCJCWVRFU1wiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlVJTlQzMlwiXSA9IDEzXSA9IFwiVUlOVDMyXCI7XG4gICAgLy8gVFlQRV9FTlVNID0gMTQsXG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0ZJWEVEMzJcIl0gPSAxNV0gPSBcIlNGSVhFRDMyXCI7XG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0ZJWEVENjRcIl0gPSAxNl0gPSBcIlNGSVhFRDY0XCI7XG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0lOVDMyXCJdID0gMTddID0gXCJTSU5UMzJcIjtcbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJTSU5UNjRcIl0gPSAxOF0gPSBcIlNJTlQ2NFwiO1xufSkoU2NhbGFyVHlwZSB8fCAoU2NhbGFyVHlwZSA9IHt9KSk7XG4vKipcbiAqIEphdmFTY3JpcHQgcmVwcmVzZW50YXRpb24gb2YgZmllbGRzIHdpdGggNjQgYml0IGludGVncmFsIHR5cGVzIChpbnQ2NCwgdWludDY0LFxuICogc2ludDY0LCBmaXhlZDY0LCBzZml4ZWQ2NCkuXG4gKlxuICogVGhpcyBpcyBhIHN1YnNldCBvZiBnb29nbGUucHJvdG9idWYuRmllbGRPcHRpb25zLkpTVHlwZSwgd2hpY2ggZGVmaW5lcyBKU19OT1JNQUwsXG4gKiBKU19TVFJJTkcsIGFuZCBKU19OVU1CRVIuIFByb3RvYnVmLUVTIHVzZXMgQmlnSW50IGJ5IGRlZmF1bHQsIGJ1dCB3aWxsIHVzZVxuICogU3RyaW5nIGlmIGBbanN0eXBlID0gSlNfU1RSSU5HXWAgaXMgc3BlY2lmaWVkLlxuICpcbiAqIGBgYHByb3RvYnVmXG4gKiB1aW50NjQgZmllbGRfYSA9IDE7IC8vIEJpZ0ludFxuICogdWludDY0IGZpZWxkX2IgPSAyIFtqc3R5cGUgPSBKU19OT1JNQUxdOyAvLyBCaWdJbnRcbiAqIHVpbnQ2NCBmaWVsZF9iID0gMiBbanN0eXBlID0gSlNfTlVNQkVSXTsgLy8gQmlnSW50XG4gKiB1aW50NjQgZmllbGRfYiA9IDIgW2pzdHlwZSA9IEpTX1NUUklOR107IC8vIFN0cmluZ1xuICogYGBgXG4gKi9cbnZhciBMb25nVHlwZTtcbihmdW5jdGlvbiAoTG9uZ1R5cGUpIHtcbiAgICAvKipcbiAgICAgKiBVc2UgSmF2YVNjcmlwdCBCaWdJbnQuXG4gICAgICovXG4gICAgTG9uZ1R5cGVbTG9uZ1R5cGVbXCJCSUdJTlRcIl0gPSAwXSA9IFwiQklHSU5UXCI7XG4gICAgLyoqXG4gICAgICogVXNlIEphdmFTY3JpcHQgU3RyaW5nLlxuICAgICAqXG4gICAgICogRmllbGQgb3B0aW9uIGBbanN0eXBlID0gSlNfU1RSSU5HXWAuXG4gICAgICovXG4gICAgTG9uZ1R5cGVbTG9uZ1R5cGVbXCJTVFJJTkdcIl0gPSAxXSA9IFwiU1RSSU5HXCI7XG59KShMb25nVHlwZSB8fCAoTG9uZ1R5cGUgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3MzM6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEk6ICgpID0+ICgvKiBiaW5kaW5nICovIEFueSlcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tZXNzYWdlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2MSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3Byb3RvM19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTApO1xuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuXG4vKipcbiAqIGBBbnlgIGNvbnRhaW5zIGFuIGFyYml0cmFyeSBzZXJpYWxpemVkIHByb3RvY29sIGJ1ZmZlciBtZXNzYWdlIGFsb25nIHdpdGggYVxuICogVVJMIHRoYXQgZGVzY3JpYmVzIHRoZSB0eXBlIG9mIHRoZSBzZXJpYWxpemVkIG1lc3NhZ2UuXG4gKlxuICogUHJvdG9idWYgbGlicmFyeSBwcm92aWRlcyBzdXBwb3J0IHRvIHBhY2svdW5wYWNrIEFueSB2YWx1ZXMgaW4gdGhlIGZvcm1cbiAqIG9mIHV0aWxpdHkgZnVuY3Rpb25zIG9yIGFkZGl0aW9uYWwgZ2VuZXJhdGVkIG1ldGhvZHMgb2YgdGhlIEFueSB0eXBlLlxuICpcbiAqIEV4YW1wbGUgMTogUGFjayBhbmQgdW5wYWNrIGEgbWVzc2FnZSBpbiBDKysuXG4gKlxuICogICAgIEZvbyBmb28gPSAuLi47XG4gKiAgICAgQW55IGFueTtcbiAqICAgICBhbnkuUGFja0Zyb20oZm9vKTtcbiAqICAgICAuLi5cbiAqICAgICBpZiAoYW55LlVucGFja1RvKCZmb28pKSB7XG4gKiAgICAgICAuLi5cbiAqICAgICB9XG4gKlxuICogRXhhbXBsZSAyOiBQYWNrIGFuZCB1bnBhY2sgYSBtZXNzYWdlIGluIEphdmEuXG4gKlxuICogICAgIEZvbyBmb28gPSAuLi47XG4gKiAgICAgQW55IGFueSA9IEFueS5wYWNrKGZvbyk7XG4gKiAgICAgLi4uXG4gKiAgICAgaWYgKGFueS5pcyhGb28uY2xhc3MpKSB7XG4gKiAgICAgICBmb28gPSBhbnkudW5wYWNrKEZvby5jbGFzcyk7XG4gKiAgICAgfVxuICogICAgIC8vIG9yIC4uLlxuICogICAgIGlmIChhbnkuaXNTYW1lVHlwZUFzKEZvby5nZXREZWZhdWx0SW5zdGFuY2UoKSkpIHtcbiAqICAgICAgIGZvbyA9IGFueS51bnBhY2soRm9vLmdldERlZmF1bHRJbnN0YW5jZSgpKTtcbiAqICAgICB9XG4gKlxuICogIEV4YW1wbGUgMzogUGFjayBhbmQgdW5wYWNrIGEgbWVzc2FnZSBpbiBQeXRob24uXG4gKlxuICogICAgIGZvbyA9IEZvbyguLi4pXG4gKiAgICAgYW55ID0gQW55KClcbiAqICAgICBhbnkuUGFjayhmb28pXG4gKiAgICAgLi4uXG4gKiAgICAgaWYgYW55LklzKEZvby5ERVNDUklQVE9SKTpcbiAqICAgICAgIGFueS5VbnBhY2soZm9vKVxuICogICAgICAgLi4uXG4gKlxuICogIEV4YW1wbGUgNDogUGFjayBhbmQgdW5wYWNrIGEgbWVzc2FnZSBpbiBHb1xuICpcbiAqICAgICAgZm9vIDo9ICZwYi5Gb297Li4ufVxuICogICAgICBhbnksIGVyciA6PSBhbnlwYi5OZXcoZm9vKVxuICogICAgICBpZiBlcnIgIT0gbmlsIHtcbiAqICAgICAgICAuLi5cbiAqICAgICAgfVxuICogICAgICAuLi5cbiAqICAgICAgZm9vIDo9ICZwYi5Gb297fVxuICogICAgICBpZiBlcnIgOj0gYW55LlVubWFyc2hhbFRvKGZvbyk7IGVyciAhPSBuaWwge1xuICogICAgICAgIC4uLlxuICogICAgICB9XG4gKlxuICogVGhlIHBhY2sgbWV0aG9kcyBwcm92aWRlZCBieSBwcm90b2J1ZiBsaWJyYXJ5IHdpbGwgYnkgZGVmYXVsdCB1c2VcbiAqICd0eXBlLmdvb2dsZWFwaXMuY29tL2Z1bGwudHlwZS5uYW1lJyBhcyB0aGUgdHlwZSBVUkwgYW5kIHRoZSB1bnBhY2tcbiAqIG1ldGhvZHMgb25seSB1c2UgdGhlIGZ1bGx5IHF1YWxpZmllZCB0eXBlIG5hbWUgYWZ0ZXIgdGhlIGxhc3QgJy8nXG4gKiBpbiB0aGUgdHlwZSBVUkwsIGZvciBleGFtcGxlIFwiZm9vLmJhci5jb20veC95LnpcIiB3aWxsIHlpZWxkIHR5cGVcbiAqIG5hbWUgXCJ5LnpcIi5cbiAqXG4gKiBKU09OXG4gKiA9PT09XG4gKiBUaGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhbiBgQW55YCB2YWx1ZSB1c2VzIHRoZSByZWd1bGFyXG4gKiByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGVzZXJpYWxpemVkLCBlbWJlZGRlZCBtZXNzYWdlLCB3aXRoIGFuXG4gKiBhZGRpdGlvbmFsIGZpZWxkIGBAdHlwZWAgd2hpY2ggY29udGFpbnMgdGhlIHR5cGUgVVJMLiBFeGFtcGxlOlxuICpcbiAqICAgICBwYWNrYWdlIGdvb2dsZS5wcm9maWxlO1xuICogICAgIG1lc3NhZ2UgUGVyc29uIHtcbiAqICAgICAgIHN0cmluZyBmaXJzdF9uYW1lID0gMTtcbiAqICAgICAgIHN0cmluZyBsYXN0X25hbWUgPSAyO1xuICogICAgIH1cbiAqXG4gKiAgICAge1xuICogICAgICAgXCJAdHlwZVwiOiBcInR5cGUuZ29vZ2xlYXBpcy5jb20vZ29vZ2xlLnByb2ZpbGUuUGVyc29uXCIsXG4gKiAgICAgICBcImZpcnN0TmFtZVwiOiA8c3RyaW5nPixcbiAqICAgICAgIFwibGFzdE5hbWVcIjogPHN0cmluZz5cbiAqICAgICB9XG4gKlxuICogSWYgdGhlIGVtYmVkZGVkIG1lc3NhZ2UgdHlwZSBpcyB3ZWxsLWtub3duIGFuZCBoYXMgYSBjdXN0b20gSlNPTlxuICogcmVwcmVzZW50YXRpb24sIHRoYXQgcmVwcmVzZW50YXRpb24gd2lsbCBiZSBlbWJlZGRlZCBhZGRpbmcgYSBmaWVsZFxuICogYHZhbHVlYCB3aGljaCBob2xkcyB0aGUgY3VzdG9tIEpTT04gaW4gYWRkaXRpb24gdG8gdGhlIGBAdHlwZWBcbiAqIGZpZWxkLiBFeGFtcGxlIChmb3IgbWVzc2FnZSBbZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uXVtdKTpcbiAqXG4gKiAgICAge1xuICogICAgICAgXCJAdHlwZVwiOiBcInR5cGUuZ29vZ2xlYXBpcy5jb20vZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uXCIsXG4gKiAgICAgICBcInZhbHVlXCI6IFwiMS4yMTJzXCJcbiAqICAgICB9XG4gKlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5BbnlcbiAqL1xuY2xhc3MgQW55IGV4dGVuZHMgX21lc3NhZ2VfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5NZXNzYWdlICovIC52IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIFVSTC9yZXNvdXJjZSBuYW1lIHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyB0aGUgdHlwZSBvZiB0aGUgc2VyaWFsaXplZFxuICAgICAgICAgKiBwcm90b2NvbCBidWZmZXIgbWVzc2FnZS4gVGhpcyBzdHJpbmcgbXVzdCBjb250YWluIGF0IGxlYXN0XG4gICAgICAgICAqIG9uZSBcIi9cIiBjaGFyYWN0ZXIuIFRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIFVSTCdzIHBhdGggbXVzdCByZXByZXNlbnRcbiAgICAgICAgICogdGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lIG9mIHRoZSB0eXBlIChhcyBpblxuICAgICAgICAgKiBgcGF0aC9nb29nbGUucHJvdG9idWYuRHVyYXRpb25gKS4gVGhlIG5hbWUgc2hvdWxkIGJlIGluIGEgY2Fub25pY2FsIGZvcm1cbiAgICAgICAgICogKGUuZy4sIGxlYWRpbmcgXCIuXCIgaXMgbm90IGFjY2VwdGVkKS5cbiAgICAgICAgICpcbiAgICAgICAgICogSW4gcHJhY3RpY2UsIHRlYW1zIHVzdWFsbHkgcHJlY29tcGlsZSBpbnRvIHRoZSBiaW5hcnkgYWxsIHR5cGVzIHRoYXQgdGhleVxuICAgICAgICAgKiBleHBlY3QgaXQgdG8gdXNlIGluIHRoZSBjb250ZXh0IG9mIEFueS4gSG93ZXZlciwgZm9yIFVSTHMgd2hpY2ggdXNlIHRoZVxuICAgICAgICAgKiBzY2hlbWUgYGh0dHBgLCBgaHR0cHNgLCBvciBubyBzY2hlbWUsIG9uZSBjYW4gb3B0aW9uYWxseSBzZXQgdXAgYSB0eXBlXG4gICAgICAgICAqIHNlcnZlciB0aGF0IG1hcHMgdHlwZSBVUkxzIHRvIG1lc3NhZ2UgZGVmaW5pdGlvbnMgYXMgZm9sbG93czpcbiAgICAgICAgICpcbiAgICAgICAgICogKiBJZiBubyBzY2hlbWUgaXMgcHJvdmlkZWQsIGBodHRwc2AgaXMgYXNzdW1lZC5cbiAgICAgICAgICogKiBBbiBIVFRQIEdFVCBvbiB0aGUgVVJMIG11c3QgeWllbGQgYSBbZ29vZ2xlLnByb3RvYnVmLlR5cGVdW11cbiAgICAgICAgICogICB2YWx1ZSBpbiBiaW5hcnkgZm9ybWF0LCBvciBwcm9kdWNlIGFuIGVycm9yLlxuICAgICAgICAgKiAqIEFwcGxpY2F0aW9ucyBhcmUgYWxsb3dlZCB0byBjYWNoZSBsb29rdXAgcmVzdWx0cyBiYXNlZCBvbiB0aGVcbiAgICAgICAgICogICBVUkwsIG9yIGhhdmUgdGhlbSBwcmVjb21waWxlZCBpbnRvIGEgYmluYXJ5IHRvIGF2b2lkIGFueVxuICAgICAgICAgKiAgIGxvb2t1cC4gVGhlcmVmb3JlLCBiaW5hcnkgY29tcGF0aWJpbGl0eSBuZWVkcyB0byBiZSBwcmVzZXJ2ZWRcbiAgICAgICAgICogICBvbiBjaGFuZ2VzIHRvIHR5cGVzLiAoVXNlIHZlcnNpb25lZCB0eXBlIG5hbWVzIHRvIG1hbmFnZVxuICAgICAgICAgKiAgIGJyZWFraW5nIGNoYW5nZXMuKVxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlOiB0aGlzIGZ1bmN0aW9uYWxpdHkgaXMgbm90IGN1cnJlbnRseSBhdmFpbGFibGUgaW4gdGhlIG9mZmljaWFsXG4gICAgICAgICAqIHByb3RvYnVmIHJlbGVhc2UsIGFuZCBpdCBpcyBub3QgdXNlZCBmb3IgdHlwZSBVUkxzIGJlZ2lubmluZyB3aXRoXG4gICAgICAgICAqIHR5cGUuZ29vZ2xlYXBpcy5jb20uIEFzIG9mIE1heSAyMDIzLCB0aGVyZSBhcmUgbm8gd2lkZWx5IHVzZWQgdHlwZSBzZXJ2ZXJcbiAgICAgICAgICogaW1wbGVtZW50YXRpb25zIGFuZCBubyBwbGFucyB0byBpbXBsZW1lbnQgb25lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTY2hlbWVzIG90aGVyIHRoYW4gYGh0dHBgLCBgaHR0cHNgIChvciB0aGUgZW1wdHkgc2NoZW1lKSBtaWdodCBiZVxuICAgICAgICAgKiB1c2VkIHdpdGggaW1wbGVtZW50YXRpb24gc3BlY2lmaWMgc2VtYW50aWNzLlxuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyB0eXBlX3VybCA9IDE7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGVVcmwgPSBcIlwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogTXVzdCBiZSBhIHZhbGlkIHNlcmlhbGl6ZWQgcHJvdG9jb2wgYnVmZmVyIG9mIHRoZSBhYm92ZSBzcGVjaWZpZWQgdHlwZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBieXRlcyB2YWx1ZSA9IDI7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIF9wcm90bzNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5wcm90bzMgKi8gLncudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgdG9Kc29uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy50eXBlVXJsID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZU5hbWUgPSB0aGlzLnR5cGVVcmxUb05hbWUodGhpcy50eXBlVXJsKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHlwZVJlZ2lzdHJ5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmluZE1lc3NhZ2UodHlwZU5hbWUpO1xuICAgICAgICBpZiAoIW1lc3NhZ2VUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBlbmNvZGUgbWVzc2FnZSBnb29nbGUucHJvdG9idWYuQW55IHRvIEpTT046IFwiJHt0aGlzLnR5cGVVcmx9XCIgaXMgbm90IGluIHRoZSB0eXBlIHJlZ2lzdHJ5YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VUeXBlLmZyb21CaW5hcnkodGhpcy52YWx1ZSk7XG4gICAgICAgIGxldCBqc29uID0gbWVzc2FnZS50b0pzb24ob3B0aW9ucyk7XG4gICAgICAgIGlmICh0eXBlTmFtZS5zdGFydHNXaXRoKFwiZ29vZ2xlLnByb3RvYnVmLlwiKSB8fCAoanNvbiA9PT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGpzb24pIHx8IHR5cGVvZiBqc29uICE9PSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAganNvbiA9IHsgdmFsdWU6IGpzb24gfTtcbiAgICAgICAgfVxuICAgICAgICBqc29uW1wiQHR5cGVcIl0gPSB0aGlzLnR5cGVVcmw7XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgICBmcm9tSnNvbihqc29uLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGpzb24gPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheShqc29uKSB8fCB0eXBlb2YganNvbiAhPSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBkZWNvZGUgbWVzc2FnZSBnb29nbGUucHJvdG9idWYuQW55IGZyb20gSlNPTjogZXhwZWN0ZWQgb2JqZWN0IGJ1dCBnb3QgJHtqc29uID09PSBudWxsID8gXCJudWxsXCIgOiBBcnJheS5pc0FycmF5KGpzb24pID8gXCJhcnJheVwiIDogdHlwZW9mIGpzb259YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGpzb24pLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlVXJsID0ganNvbltcIkB0eXBlXCJdO1xuICAgICAgICBpZiAodHlwZW9mIHR5cGVVcmwgIT0gXCJzdHJpbmdcIiB8fCB0eXBlVXJsID09IFwiXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5BbnkgZnJvbSBKU09OOiBcIkB0eXBlXCIgaXMgZW1wdHlgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlTmFtZSA9IHRoaXMudHlwZVVybFRvTmFtZSh0eXBlVXJsKSwgbWVzc2FnZVR5cGUgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHlwZVJlZ2lzdHJ5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmluZE1lc3NhZ2UodHlwZU5hbWUpO1xuICAgICAgICBpZiAoIW1lc3NhZ2VUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBkZWNvZGUgbWVzc2FnZSBnb29nbGUucHJvdG9idWYuQW55IGZyb20gSlNPTjogJHt0eXBlVXJsfSBpcyBub3QgaW4gdGhlIHR5cGUgcmVnaXN0cnlgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWVzc2FnZTtcbiAgICAgICAgaWYgKHR5cGVOYW1lLnN0YXJ0c1dpdGgoXCJnb29nbGUucHJvdG9idWYuXCIpICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChqc29uLCBcInZhbHVlXCIpKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZVR5cGUuZnJvbUpzb24oanNvbltcInZhbHVlXCJdLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuYXNzaWduKHt9LCBqc29uKTtcbiAgICAgICAgICAgIGRlbGV0ZSBjb3B5W1wiQHR5cGVcIl07XG4gICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZVR5cGUuZnJvbUpzb24oY29weSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYWNrRnJvbShtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHBhY2tGcm9tKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG1lc3NhZ2UudG9CaW5hcnkoKTtcbiAgICAgICAgdGhpcy50eXBlVXJsID0gdGhpcy50eXBlTmFtZVRvVXJsKG1lc3NhZ2UuZ2V0VHlwZSgpLnR5cGVOYW1lKTtcbiAgICB9XG4gICAgdW5wYWNrVG8odGFyZ2V0KSB7XG4gICAgICAgIGlmICghdGhpcy5pcyh0YXJnZXQuZ2V0VHlwZSgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5mcm9tQmluYXJ5KHRoaXMudmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdW5wYWNrKHJlZ2lzdHJ5KSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGVVcmwgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSByZWdpc3RyeS5maW5kTWVzc2FnZSh0aGlzLnR5cGVVcmxUb05hbWUodGhpcy50eXBlVXJsKSk7XG4gICAgICAgIGlmICghbWVzc2FnZVR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VUeXBlLmZyb21CaW5hcnkodGhpcy52YWx1ZSk7XG4gICAgfVxuICAgIGlzKHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZVVybCA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy50eXBlVXJsVG9OYW1lKHRoaXMudHlwZVVybCk7XG4gICAgICAgIGxldCB0eXBlTmFtZSA9ICcnO1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0eXBlTmFtZSA9IHR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0eXBlTmFtZSA9IHR5cGUudHlwZU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWUgPT09IHR5cGVOYW1lO1xuICAgIH1cbiAgICB0eXBlTmFtZVRvVXJsKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGB0eXBlLmdvb2dsZWFwaXMuY29tLyR7bmFtZX1gO1xuICAgIH1cbiAgICB0eXBlVXJsVG9OYW1lKHVybCkge1xuICAgICAgICBpZiAoIXVybC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB0eXBlIHVybDogJHt1cmx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2xhc2ggPSB1cmwubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgICAgICBjb25zdCBuYW1lID0gc2xhc2ggPj0gMCA/IHVybC5zdWJzdHJpbmcoc2xhc2ggKyAxKSA6IHVybDtcbiAgICAgICAgaWYgKCFuYW1lLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHR5cGUgdXJsOiAke3VybH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgc3RhdGljIHBhY2sobWVzc2FnZSkge1xuICAgICAgICBjb25zdCBhbnkgPSBuZXcgQW55KCk7XG4gICAgICAgIGFueS5wYWNrRnJvbShtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGFueTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbnkoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEFueSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgQW55KCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gX3Byb3RvM19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLnByb3RvMyAqLyAudy51dGlsLmVxdWFscyhBbnksIGEsIGIpO1xuICAgIH1cbn1cbkFueS5ydW50aW1lID0gX3Byb3RvM19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLnByb3RvMyAqLyAudztcbkFueS50eXBlTmFtZSA9IFwiZ29vZ2xlLnByb3RvYnVmLkFueVwiO1xuQW55LmZpZWxkcyA9IF9wcm90bzNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5wcm90bzMgKi8gLncudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZV91cmxcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwidmFsdWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTIgLyogU2NhbGFyVHlwZS5CWVRFUyAqLyB9LFxuXSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDgxODpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19fX3dlYnBhY2tfbW9kdWxlX18sIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQWs6ICgpID0+ICgvKiBiaW5kaW5nICovIGludDY0VG9TdHJpbmcpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDWjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gaW50NjRGcm9tU3RyaW5nKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRmQ6ICgpID0+ICgvKiBiaW5kaW5nICovIHVJbnQ2NFRvU3RyaW5nKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgX3k6ICgpID0+ICgvKiBiaW5kaW5nICovIHZhcmludDY0d3JpdGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBmQzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gdmFyaW50MzJ3cml0ZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGpJOiAoKSA9PiAoLyogYmluZGluZyAqLyB2YXJpbnQzMnJlYWQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBzZzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gdmFyaW50NjRyZWFkKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vLyBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbi8vIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbi8vIG1ldDpcbi8vXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbi8vIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXJcbi8vIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbi8vIGRpc3RyaWJ1dGlvbi5cbi8vICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuLy8gY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbi8vIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4vL1xuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuLy8gXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4vLyBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuLy8gT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4vLyBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbi8vIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuLy8gVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuLy8gKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4vLyBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuLy9cbi8vIENvZGUgZ2VuZXJhdGVkIGJ5IHRoZSBQcm90b2NvbCBCdWZmZXIgY29tcGlsZXIgaXMgb3duZWQgYnkgdGhlIG93bmVyXG4vLyBvZiB0aGUgaW5wdXQgZmlsZSB1c2VkIHdoZW4gZ2VuZXJhdGluZyBpdC4gIFRoaXMgY29kZSBpcyBub3Rcbi8vIHN0YW5kYWxvbmUgYW5kIHJlcXVpcmVzIGEgc3VwcG9ydCBsaWJyYXJ5IHRvIGJlIGxpbmtlZCB3aXRoIGl0LiAgVGhpc1xuLy8gc3VwcG9ydCBsaWJyYXJ5IGlzIGl0c2VsZiBjb3ZlcmVkIGJ5IHRoZSBhYm92ZSBsaWNlbnNlLlxuLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLWNvbnN0LEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzICovXG4vKipcbiAqIFJlYWQgYSA2NCBiaXQgdmFyaW50IGFzIHR3byBKUyBudW1iZXJzLlxuICpcbiAqIFJldHVybnMgdHVwbGU6XG4gKiBbMF06IGxvdyBiaXRzXG4gKiBbMV06IGhpZ2ggYml0c1xuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvOGE3MTkyN2Q3NGE0Y2UzNGVmZTJkODc2OWZkYTE5OGY1MmQyMGQxMi9qcy9leHBlcmltZW50YWwvcnVudGltZS9rZXJuZWwvYnVmZmVyX2RlY29kZXIuanMjTDE3NVxuICovXG5mdW5jdGlvbiB2YXJpbnQ2NHJlYWQoKSB7XG4gICAgbGV0IGxvd0JpdHMgPSAwO1xuICAgIGxldCBoaWdoQml0cyA9IDA7XG4gICAgZm9yIChsZXQgc2hpZnQgPSAwOyBzaGlmdCA8IDI4OyBzaGlmdCArPSA3KSB7XG4gICAgICAgIGxldCBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgICAgIGxvd0JpdHMgfD0gKGIgJiAweDdmKSA8PCBzaGlmdDtcbiAgICAgICAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgICAgIHJldHVybiBbbG93Qml0cywgaGlnaEJpdHNdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBtaWRkbGVCeXRlID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgLy8gbGFzdCBmb3VyIGJpdHMgb2YgdGhlIGZpcnN0IDMyIGJpdCBudW1iZXJcbiAgICBsb3dCaXRzIHw9IChtaWRkbGVCeXRlICYgMHgwZikgPDwgMjg7XG4gICAgLy8gMyB1cHBlciBiaXRzIGFyZSBwYXJ0IG9mIHRoZSBuZXh0IDMyIGJpdCBudW1iZXJcbiAgICBoaWdoQml0cyA9IChtaWRkbGVCeXRlICYgMHg3MCkgPj4gNDtcbiAgICBpZiAoKG1pZGRsZUJ5dGUgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiBbbG93Qml0cywgaGlnaEJpdHNdO1xuICAgIH1cbiAgICBmb3IgKGxldCBzaGlmdCA9IDM7IHNoaWZ0IDw9IDMxOyBzaGlmdCArPSA3KSB7XG4gICAgICAgIGxldCBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgICAgIGhpZ2hCaXRzIHw9IChiICYgMHg3ZikgPDwgc2hpZnQ7XG4gICAgICAgIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgICAgICByZXR1cm4gW2xvd0JpdHMsIGhpZ2hCaXRzXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHZhcmludFwiKTtcbn1cbi8qKlxuICogV3JpdGUgYSA2NCBiaXQgdmFyaW50LCBnaXZlbiBhcyB0d28gSlMgbnVtYmVycywgdG8gdGhlIGdpdmVuIGJ5dGVzIGFycmF5LlxuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvOGE3MTkyN2Q3NGE0Y2UzNGVmZTJkODc2OWZkYTE5OGY1MmQyMGQxMi9qcy9leHBlcmltZW50YWwvcnVudGltZS9rZXJuZWwvd3JpdGVyLmpzI0wzNDRcbiAqL1xuZnVuY3Rpb24gdmFyaW50NjR3cml0ZShsbywgaGksIGJ5dGVzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyODsgaSA9IGkgKyA3KSB7XG4gICAgICAgIGNvbnN0IHNoaWZ0ID0gbG8gPj4+IGk7XG4gICAgICAgIGNvbnN0IGhhc05leHQgPSAhKHNoaWZ0ID4+PiA3ID09IDAgJiYgaGkgPT0gMCk7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSAoaGFzTmV4dCA/IHNoaWZ0IHwgMHg4MCA6IHNoaWZ0KSAmIDB4ZmY7XG4gICAgICAgIGJ5dGVzLnB1c2goYnl0ZSk7XG4gICAgICAgIGlmICghaGFzTmV4dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNwbGl0Qml0cyA9ICgobG8gPj4+IDI4KSAmIDB4MGYpIHwgKChoaSAmIDB4MDcpIDw8IDQpO1xuICAgIGNvbnN0IGhhc01vcmVCaXRzID0gIShoaSA+PiAzID09IDApO1xuICAgIGJ5dGVzLnB1c2goKGhhc01vcmVCaXRzID8gc3BsaXRCaXRzIHwgMHg4MCA6IHNwbGl0Qml0cykgJiAweGZmKTtcbiAgICBpZiAoIWhhc01vcmVCaXRzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDM7IGkgPCAzMTsgaSA9IGkgKyA3KSB7XG4gICAgICAgIGNvbnN0IHNoaWZ0ID0gaGkgPj4+IGk7XG4gICAgICAgIGNvbnN0IGhhc05leHQgPSAhKHNoaWZ0ID4+PiA3ID09IDApO1xuICAgICAgICBjb25zdCBieXRlID0gKGhhc05leHQgPyBzaGlmdCB8IDB4ODAgOiBzaGlmdCkgJiAweGZmO1xuICAgICAgICBieXRlcy5wdXNoKGJ5dGUpO1xuICAgICAgICBpZiAoIWhhc05leHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBieXRlcy5wdXNoKChoaSA+Pj4gMzEpICYgMHgwMSk7XG59XG4vLyBjb25zdGFudHMgZm9yIGJpbmFyeSBtYXRoXG5jb25zdCBUV09fUFdSXzMyX0RCTCA9IDB4MTAwMDAwMDAwO1xuLyoqXG4gKiBQYXJzZSBkZWNpbWFsIHN0cmluZyBvZiA2NCBiaXQgaW50ZWdlciB2YWx1ZSBhcyB0d28gSlMgbnVtYmVycy5cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi1qYXZhc2NyaXB0L2Jsb2IvYTQyOGM1ODI3M2FiYWQwN2M2NjA3MWQ5NzUzYmM0ZDEyODlkZTQyNi9leHBlcmltZW50YWwvcnVudGltZS9pbnQ2NC5qcyNMMTBcbiAqL1xuZnVuY3Rpb24gaW50NjRGcm9tU3RyaW5nKGRlYykge1xuICAgIC8vIENoZWNrIGZvciBtaW51cyBzaWduLlxuICAgIGNvbnN0IG1pbnVzID0gZGVjWzBdID09PSBcIi1cIjtcbiAgICBpZiAobWludXMpIHtcbiAgICAgICAgZGVjID0gZGVjLnNsaWNlKDEpO1xuICAgIH1cbiAgICAvLyBXb3JrIDYgZGVjaW1hbCBkaWdpdHMgYXQgYSB0aW1lLCBhY3RpbmcgbGlrZSB3ZSdyZSBjb252ZXJ0aW5nIGJhc2UgMWU2XG4gICAgLy8gZGlnaXRzIHRvIGJpbmFyeS4gVGhpcyBpcyBzYWZlIHRvIGRvIHdpdGggZmxvYXRpbmcgcG9pbnQgbWF0aCBiZWNhdXNlXG4gICAgLy8gTnVtYmVyLmlzU2FmZUludGVnZXIoQUxMXzMyX0JJVFMgKiAxZTYpID09IHRydWUuXG4gICAgY29uc3QgYmFzZSA9IDFlNjtcbiAgICBsZXQgbG93Qml0cyA9IDA7XG4gICAgbGV0IGhpZ2hCaXRzID0gMDtcbiAgICBmdW5jdGlvbiBhZGQxZTZkaWdpdChiZWdpbiwgZW5kKSB7XG4gICAgICAgIC8vIE5vdGU6IE51bWJlcignJykgaXMgMC5cbiAgICAgICAgY29uc3QgZGlnaXQxZTYgPSBOdW1iZXIoZGVjLnNsaWNlKGJlZ2luLCBlbmQpKTtcbiAgICAgICAgaGlnaEJpdHMgKj0gYmFzZTtcbiAgICAgICAgbG93Qml0cyA9IGxvd0JpdHMgKiBiYXNlICsgZGlnaXQxZTY7XG4gICAgICAgIC8vIENhcnJ5IGJpdHMgZnJvbSBsb3dCaXRzIHRvXG4gICAgICAgIGlmIChsb3dCaXRzID49IFRXT19QV1JfMzJfREJMKSB7XG4gICAgICAgICAgICBoaWdoQml0cyA9IGhpZ2hCaXRzICsgKChsb3dCaXRzIC8gVFdPX1BXUl8zMl9EQkwpIHwgMCk7XG4gICAgICAgICAgICBsb3dCaXRzID0gbG93Qml0cyAlIFRXT19QV1JfMzJfREJMO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZDFlNmRpZ2l0KC0yNCwgLTE4KTtcbiAgICBhZGQxZTZkaWdpdCgtMTgsIC0xMik7XG4gICAgYWRkMWU2ZGlnaXQoLTEyLCAtNik7XG4gICAgYWRkMWU2ZGlnaXQoLTYpO1xuICAgIHJldHVybiBtaW51cyA/IG5lZ2F0ZShsb3dCaXRzLCBoaWdoQml0cykgOiBuZXdCaXRzKGxvd0JpdHMsIGhpZ2hCaXRzKTtcbn1cbi8qKlxuICogTG9zc2xlc3NseSBjb252ZXJ0cyBhIDY0LWJpdCBzaWduZWQgaW50ZWdlciBpbiAzMjozMiBzcGxpdCByZXByZXNlbnRhdGlvblxuICogaW50byBhIGRlY2ltYWwgc3RyaW5nLlxuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmLWphdmFzY3JpcHQvYmxvYi9hNDI4YzU4MjczYWJhZDA3YzY2MDcxZDk3NTNiYzRkMTI4OWRlNDI2L2V4cGVyaW1lbnRhbC9ydW50aW1lL2ludDY0LmpzI0wxMFxuICovXG5mdW5jdGlvbiBpbnQ2NFRvU3RyaW5nKGxvLCBoaSkge1xuICAgIGxldCBiaXRzID0gbmV3Qml0cyhsbywgaGkpO1xuICAgIC8vIElmIHdlJ3JlIHRyZWF0aW5nIHRoZSBpbnB1dCBhcyBhIHNpZ25lZCB2YWx1ZSBhbmQgdGhlIGhpZ2ggYml0IGlzIHNldCwgZG9cbiAgICAvLyBhIG1hbnVhbCB0d28ncyBjb21wbGVtZW50IGNvbnZlcnNpb24gYmVmb3JlIHRoZSBkZWNpbWFsIGNvbnZlcnNpb24uXG4gICAgY29uc3QgbmVnYXRpdmUgPSAoYml0cy5oaSAmIDB4ODAwMDAwMDApO1xuICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICBiaXRzID0gbmVnYXRlKGJpdHMubG8sIGJpdHMuaGkpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB1SW50NjRUb1N0cmluZyhiaXRzLmxvLCBiaXRzLmhpKTtcbiAgICByZXR1cm4gbmVnYXRpdmUgPyBcIi1cIiArIHJlc3VsdCA6IHJlc3VsdDtcbn1cbi8qKlxuICogTG9zc2xlc3NseSBjb252ZXJ0cyBhIDY0LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIGluIDMyOjMyIHNwbGl0IHJlcHJlc2VudGF0aW9uXG4gKiBpbnRvIGEgZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYtamF2YXNjcmlwdC9ibG9iL2E0MjhjNTgyNzNhYmFkMDdjNjYwNzFkOTc1M2JjNGQxMjg5ZGU0MjYvZXhwZXJpbWVudGFsL3J1bnRpbWUvaW50NjQuanMjTDEwXG4gKi9cbmZ1bmN0aW9uIHVJbnQ2NFRvU3RyaW5nKGxvLCBoaSkge1xuICAgICh7IGxvLCBoaSB9ID0gdG9VbnNpZ25lZChsbywgaGkpKTtcbiAgICAvLyBTa2lwIHRoZSBleHBlbnNpdmUgY29udmVyc2lvbiBpZiB0aGUgbnVtYmVyIGlzIHNtYWxsIGVub3VnaCB0byB1c2UgdGhlXG4gICAgLy8gYnVpbHQtaW4gY29udmVyc2lvbnMuXG4gICAgLy8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgPSAweDAwMUZGRkZGIEZGRkZGRkZGLCB0aHVzIGFueSBudW1iZXIgd2l0aFxuICAgIC8vIGhpZ2hCaXRzIDw9IDB4MUZGRkZGIGNhbiBiZSBzYWZlbHkgZXhwcmVzc2VkIHdpdGggYSBkb3VibGUgYW5kIHJldGFpblxuICAgIC8vIGludGVnZXIgcHJlY2lzaW9uLlxuICAgIC8vIFByb3ZlbiBieTogTnVtYmVyLmlzU2FmZUludGVnZXIoMHgxRkZGRkYgKiAyKiozMiArIDB4RkZGRkZGRkYpID09IHRydWUuXG4gICAgaWYgKGhpIDw9IDB4MUZGRkZGKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoVFdPX1BXUl8zMl9EQkwgKiBoaSArIGxvKTtcbiAgICB9XG4gICAgLy8gV2hhdCB0aGlzIGNvZGUgaXMgZG9pbmcgaXMgZXNzZW50aWFsbHkgY29udmVydGluZyB0aGUgaW5wdXQgbnVtYmVyIGZyb21cbiAgICAvLyBiYXNlLTIgdG8gYmFzZS0xZTcsIHdoaWNoIGFsbG93cyB1cyB0byByZXByZXNlbnQgdGhlIDY0LWJpdCByYW5nZSB3aXRoXG4gICAgLy8gb25seSAzICh2ZXJ5IGxhcmdlKSBkaWdpdHMuIFRob3NlIGRpZ2l0cyBhcmUgdGhlbiB0cml2aWFsIHRvIGNvbnZlcnQgdG9cbiAgICAvLyBhIGJhc2UtMTAgc3RyaW5nLlxuICAgIC8vIFRoZSBtYWdpYyBudW1iZXJzIHVzZWQgaGVyZSBhcmUgLVxuICAgIC8vIDJeMjQgPSAxNjc3NzIxNiA9ICgxLDY3NzcyMTYpIGluIGJhc2UtMWU3LlxuICAgIC8vIDJeNDggPSAyODE0NzQ5NzY3MTA2NTYgPSAoMiw4MTQ3NDk3LDY3MTA2NTYpIGluIGJhc2UtMWU3LlxuICAgIC8vIFNwbGl0IDMyOjMyIHJlcHJlc2VudGF0aW9uIGludG8gMTY6MjQ6MjQgcmVwcmVzZW50YXRpb24gc28gb3VyXG4gICAgLy8gaW50ZXJtZWRpYXRlIGRpZ2l0cyBkb24ndCBvdmVyZmxvdy5cbiAgICBjb25zdCBsb3cgPSBsbyAmIDB4RkZGRkZGO1xuICAgIGNvbnN0IG1pZCA9ICgobG8gPj4+IDI0KSB8IChoaSA8PCA4KSkgJiAweEZGRkZGRjtcbiAgICBjb25zdCBoaWdoID0gKGhpID4+IDE2KSAmIDB4RkZGRjtcbiAgICAvLyBBc3NlbWJsZSBvdXIgdGhyZWUgYmFzZS0xZTcgZGlnaXRzLCBpZ25vcmluZyBjYXJyaWVzLiBUaGUgbWF4aW11bVxuICAgIC8vIHZhbHVlIGluIGEgZGlnaXQgYXQgdGhpcyBzdGVwIGlzIHJlcHJlc2VudGFibGUgYXMgYSA0OC1iaXQgaW50ZWdlciwgd2hpY2hcbiAgICAvLyBjYW4gYmUgc3RvcmVkIGluIGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICBsZXQgZGlnaXRBID0gbG93ICsgKG1pZCAqIDY3NzcyMTYpICsgKGhpZ2ggKiA2NzEwNjU2KTtcbiAgICBsZXQgZGlnaXRCID0gbWlkICsgKGhpZ2ggKiA4MTQ3NDk3KTtcbiAgICBsZXQgZGlnaXRDID0gKGhpZ2ggKiAyKTtcbiAgICAvLyBBcHBseSBjYXJyaWVzIGZyb20gQSB0byBCIGFuZCBmcm9tIEIgdG8gQy5cbiAgICBjb25zdCBiYXNlID0gMTAwMDAwMDA7XG4gICAgaWYgKGRpZ2l0QSA+PSBiYXNlKSB7XG4gICAgICAgIGRpZ2l0QiArPSBNYXRoLmZsb29yKGRpZ2l0QSAvIGJhc2UpO1xuICAgICAgICBkaWdpdEEgJT0gYmFzZTtcbiAgICB9XG4gICAgaWYgKGRpZ2l0QiA+PSBiYXNlKSB7XG4gICAgICAgIGRpZ2l0QyArPSBNYXRoLmZsb29yKGRpZ2l0QiAvIGJhc2UpO1xuICAgICAgICBkaWdpdEIgJT0gYmFzZTtcbiAgICB9XG4gICAgLy8gSWYgZGlnaXRDIGlzIDAsIHRoZW4gd2Ugc2hvdWxkIGhhdmUgcmV0dXJuZWQgaW4gdGhlIHRyaXZpYWwgY29kZSBwYXRoXG4gICAgLy8gYXQgdGhlIHRvcCBmb3Igbm9uLXNhZmUgaW50ZWdlcnMuIEdpdmVuIHRoaXMsIHdlIGNhbiBhc3N1bWUgYm90aCBkaWdpdEJcbiAgICAvLyBhbmQgZGlnaXRBIG5lZWQgbGVhZGluZyB6ZXJvcy5cbiAgICByZXR1cm4gZGlnaXRDLnRvU3RyaW5nKCkgKyBkZWNpbWFsRnJvbTFlN1dpdGhMZWFkaW5nWmVyb3MoZGlnaXRCKSArXG4gICAgICAgIGRlY2ltYWxGcm9tMWU3V2l0aExlYWRpbmdaZXJvcyhkaWdpdEEpO1xufVxuZnVuY3Rpb24gdG9VbnNpZ25lZChsbywgaGkpIHtcbiAgICByZXR1cm4geyBsbzogbG8gPj4+IDAsIGhpOiBoaSA+Pj4gMCB9O1xufVxuZnVuY3Rpb24gbmV3Qml0cyhsbywgaGkpIHtcbiAgICByZXR1cm4geyBsbzogbG8gfCAwLCBoaTogaGkgfCAwIH07XG59XG4vKipcbiAqIFJldHVybnMgdHdvJ3MgY29tcGxpbWVudCBuZWdhdGlvbiBvZiBpbnB1dC5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL0JpdHdpc2VfT3BlcmF0b3JzI1NpZ25lZF8zMi1iaXRfaW50ZWdlcnNcbiAqL1xuZnVuY3Rpb24gbmVnYXRlKGxvd0JpdHMsIGhpZ2hCaXRzKSB7XG4gICAgaGlnaEJpdHMgPSB+aGlnaEJpdHM7XG4gICAgaWYgKGxvd0JpdHMpIHtcbiAgICAgICAgbG93Qml0cyA9IH5sb3dCaXRzICsgMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElmIGxvd0JpdHMgaXMgMCwgdGhlbiBiaXR3aXNlLW5vdCBpcyAweEZGRkZGRkZGLFxuICAgICAgICAvLyBhZGRpbmcgMSB0byB0aGF0LCByZXN1bHRzIGluIDB4MTAwMDAwMDAwLCB3aGljaCBsZWF2ZXNcbiAgICAgICAgLy8gdGhlIGxvdyBiaXRzIDB4MCBhbmQgc2ltcGx5IGFkZHMgb25lIHRvIHRoZSBoaWdoIGJpdHMuXG4gICAgICAgIGhpZ2hCaXRzICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBuZXdCaXRzKGxvd0JpdHMsIGhpZ2hCaXRzKTtcbn1cbi8qKlxuICogUmV0dXJucyBkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIGRpZ2l0MWU3IHdpdGggbGVhZGluZyB6ZXJvcy5cbiAqL1xuY29uc3QgZGVjaW1hbEZyb20xZTdXaXRoTGVhZGluZ1plcm9zID0gKGRpZ2l0MWU3KSA9PiB7XG4gICAgY29uc3QgcGFydGlhbCA9IFN0cmluZyhkaWdpdDFlNyk7XG4gICAgcmV0dXJuIFwiMDAwMDAwMFwiLnNsaWNlKHBhcnRpYWwubGVuZ3RoKSArIHBhcnRpYWw7XG59O1xuLyoqXG4gKiBXcml0ZSBhIDMyIGJpdCB2YXJpbnQsIHNpZ25lZCBvciB1bnNpZ25lZC4gU2FtZSBhcyBgdmFyaW50NjR3cml0ZSgwLCB2YWx1ZSwgYnl0ZXMpYFxuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvMWIxODgzM2Y0ZjJhMmY2ODFmNGU0YTI1Y2RmM2IwYTQzMTE1ZWMyNi9qcy9iaW5hcnkvZW5jb2Rlci5qcyNMMTQ0XG4gKi9cbmZ1bmN0aW9uIHZhcmludDMyd3JpdGUodmFsdWUsIGJ5dGVzKSB7XG4gICAgaWYgKHZhbHVlID49IDApIHtcbiAgICAgICAgLy8gd3JpdGUgdmFsdWUgYXMgdmFyaW50IDMyXG4gICAgICAgIHdoaWxlICh2YWx1ZSA+IDB4N2YpIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goKHZhbHVlICYgMHg3ZikgfCAweDgwKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPj4+IDc7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZXMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xuICAgICAgICAgICAgYnl0ZXMucHVzaCgodmFsdWUgJiAxMjcpIHwgMTI4KTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPj4gNztcbiAgICAgICAgfVxuICAgICAgICBieXRlcy5wdXNoKDEpO1xuICAgIH1cbn1cbi8qKlxuICogUmVhZCBhbiB1bnNpZ25lZCAzMiBiaXQgdmFyaW50LlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvOGE3MTkyN2Q3NGE0Y2UzNGVmZTJkODc2OWZkYTE5OGY1MmQyMGQxMi9qcy9leHBlcmltZW50YWwvcnVudGltZS9rZXJuZWwvYnVmZmVyX2RlY29kZXIuanMjTDIyMFxuICovXG5mdW5jdGlvbiB2YXJpbnQzMnJlYWQoKSB7XG4gICAgbGV0IGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICBsZXQgcmVzdWx0ID0gYiAmIDB4N2Y7XG4gICAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgICAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgcmVzdWx0IHw9IChiICYgMHg3ZikgPDwgNztcbiAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICByZXN1bHQgfD0gKGIgJiAweDdmKSA8PCAxNDtcbiAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICByZXN1bHQgfD0gKGIgJiAweDdmKSA8PCAyMTtcbiAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEV4dHJhY3Qgb25seSBsYXN0IDQgYml0c1xuICAgIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICByZXN1bHQgfD0gKGIgJiAweDBmKSA8PCAyODtcbiAgICBmb3IgKGxldCByZWFkQnl0ZXMgPSA1OyAoYiAmIDB4ODApICE9PSAwICYmIHJlYWRCeXRlcyA8IDEwOyByZWFkQnl0ZXMrKylcbiAgICAgICAgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgIGlmICgoYiAmIDB4ODApICE9IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdmFyaW50XCIpO1xuICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgLy8gUmVzdWx0IGNhbiBoYXZlIDMyIGJpdHMsIGNvbnZlcnQgaXQgdG8gdW5zaWduZWRcbiAgICByZXR1cm4gcmVzdWx0ID4+PiAwO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MzI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIEVTTSBDT01QQVQgRkxBR1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuXG4vLyBFWFBPUlRTXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuICBBbnk6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBhbnlfcGIvKiBBbnkgKi8uSSksXG4gIEFwaTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEFwaSksXG4gIEJpbmFyeVJlYWRlcjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGJpbmFyeV9lbmNvZGluZy8qIEJpbmFyeVJlYWRlciAqLy5vUCksXG4gIEJpbmFyeVdyaXRlcjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGJpbmFyeV9lbmNvZGluZy8qIEJpbmFyeVdyaXRlciAqLy5MdCksXG4gIEJvb2xWYWx1ZTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEJvb2xWYWx1ZSksXG4gIEJ5dGVzVmFsdWU6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBCeXRlc1ZhbHVlKSxcbiAgQ29kZUdlbmVyYXRvclJlcXVlc3Q6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb2RlR2VuZXJhdG9yUmVxdWVzdCksXG4gIENvZGVHZW5lcmF0b3JSZXNwb25zZTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvZGVHZW5lcmF0b3JSZXNwb25zZSksXG4gIENvZGVHZW5lcmF0b3JSZXNwb25zZV9GZWF0dXJlOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29kZUdlbmVyYXRvclJlc3BvbnNlX0ZlYXR1cmUpLFxuICBDb2RlR2VuZXJhdG9yUmVzcG9uc2VfRmlsZTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvZGVHZW5lcmF0b3JSZXNwb25zZV9GaWxlKSxcbiAgRGVzY3JpcHRvclByb3RvOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRGVzY3JpcHRvclByb3RvKSxcbiAgRGVzY3JpcHRvclByb3RvX0V4dGVuc2lvblJhbmdlOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRGVzY3JpcHRvclByb3RvX0V4dGVuc2lvblJhbmdlKSxcbiAgRGVzY3JpcHRvclByb3RvX1Jlc2VydmVkUmFuZ2U6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBEZXNjcmlwdG9yUHJvdG9fUmVzZXJ2ZWRSYW5nZSksXG4gIERvdWJsZVZhbHVlOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRG91YmxlVmFsdWUpLFxuICBEdXJhdGlvbjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIER1cmF0aW9uKSxcbiAgRWRpdGlvbjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEVkaXRpb24pLFxuICBFbXB0eTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEVtcHR5KSxcbiAgRW51bTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEVudW0pLFxuICBFbnVtRGVzY3JpcHRvclByb3RvOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRW51bURlc2NyaXB0b3JQcm90byksXG4gIEVudW1EZXNjcmlwdG9yUHJvdG9fRW51bVJlc2VydmVkUmFuZ2U6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFbnVtRGVzY3JpcHRvclByb3RvX0VudW1SZXNlcnZlZFJhbmdlKSxcbiAgRW51bU9wdGlvbnM6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFbnVtT3B0aW9ucyksXG4gIEVudW1WYWx1ZTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEVudW1WYWx1ZSksXG4gIEVudW1WYWx1ZURlc2NyaXB0b3JQcm90bzogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEVudW1WYWx1ZURlc2NyaXB0b3JQcm90byksXG4gIEVudW1WYWx1ZU9wdGlvbnM6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFbnVtVmFsdWVPcHRpb25zKSxcbiAgRXh0ZW5zaW9uUmFuZ2VPcHRpb25zOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRXh0ZW5zaW9uUmFuZ2VPcHRpb25zKSxcbiAgRXh0ZW5zaW9uUmFuZ2VPcHRpb25zX0RlY2xhcmF0aW9uOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRXh0ZW5zaW9uUmFuZ2VPcHRpb25zX0RlY2xhcmF0aW9uKSxcbiAgRXh0ZW5zaW9uUmFuZ2VPcHRpb25zX1ZlcmlmaWNhdGlvblN0YXRlOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRXh0ZW5zaW9uUmFuZ2VPcHRpb25zX1ZlcmlmaWNhdGlvblN0YXRlKSxcbiAgRmVhdHVyZVNldDogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEZlYXR1cmVTZXQpLFxuICBGZWF0dXJlU2V0RGVmYXVsdHM6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBGZWF0dXJlU2V0RGVmYXVsdHMpLFxuICBGZWF0dXJlU2V0RGVmYXVsdHNfRmVhdHVyZVNldEVkaXRpb25EZWZhdWx0OiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRmVhdHVyZVNldERlZmF1bHRzX0ZlYXR1cmVTZXRFZGl0aW9uRGVmYXVsdCksXG4gIEZlYXR1cmVTZXRfRW51bVR5cGU6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBGZWF0dXJlU2V0X0VudW1UeXBlKSxcbiAgRmVhdHVyZVNldF9GaWVsZFByZXNlbmNlOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRmVhdHVyZVNldF9GaWVsZFByZXNlbmNlKSxcbiAgRmVhdHVyZVNldF9Kc29uRm9ybWF0OiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRmVhdHVyZVNldF9Kc29uRm9ybWF0KSxcbiAgRmVhdHVyZVNldF9NZXNzYWdlRW5jb2Rpbmc6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBGZWF0dXJlU2V0X01lc3NhZ2VFbmNvZGluZyksXG4gIEZlYXR1cmVTZXRfUmVwZWF0ZWRGaWVsZEVuY29kaW5nOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRmVhdHVyZVNldF9SZXBlYXRlZEZpZWxkRW5jb2RpbmcpLFxuICBGZWF0dXJlU2V0X1V0ZjhWYWxpZGF0aW9uOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRmVhdHVyZVNldF9VdGY4VmFsaWRhdGlvbiksXG4gIEZpZWxkOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRmllbGQpLFxuICBGaWVsZERlc2NyaXB0b3JQcm90bzogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEZpZWxkRGVzY3JpcHRvclByb3RvKSxcbiAgRmllbGREZXNjcmlwdG9yUHJvdG9fTGFiZWw6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBGaWVsZERlc2NyaXB0b3JQcm90b19MYWJlbCksXG4gIEZpZWxkRGVzY3JpcHRvclByb3RvX1R5cGU6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBGaWVsZERlc2NyaXB0b3JQcm90b19UeXBlKSxcbiAgRmllbGRNYXNrOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRmllbGRNYXNrKSxcbiAgRmllbGRPcHRpb25zOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRmllbGRPcHRpb25zKSxcbiAgRmllbGRPcHRpb25zX0NUeXBlOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRmllbGRPcHRpb25zX0NUeXBlKSxcbiAgRmllbGRPcHRpb25zX0VkaXRpb25EZWZhdWx0OiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRmllbGRPcHRpb25zX0VkaXRpb25EZWZhdWx0KSxcbiAgRmllbGRPcHRpb25zX0pTVHlwZTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEZpZWxkT3B0aW9uc19KU1R5cGUpLFxuICBGaWVsZE9wdGlvbnNfT3B0aW9uUmV0ZW50aW9uOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRmllbGRPcHRpb25zX09wdGlvblJldGVudGlvbiksXG4gIEZpZWxkT3B0aW9uc19PcHRpb25UYXJnZXRUeXBlOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRmllbGRPcHRpb25zX09wdGlvblRhcmdldFR5cGUpLFxuICBGaWVsZF9DYXJkaW5hbGl0eTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEZpZWxkX0NhcmRpbmFsaXR5KSxcbiAgRmllbGRfS2luZDogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEZpZWxkX0tpbmQpLFxuICBGaWxlRGVzY3JpcHRvclByb3RvOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRmlsZURlc2NyaXB0b3JQcm90byksXG4gIEZpbGVEZXNjcmlwdG9yU2V0OiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRmlsZURlc2NyaXB0b3JTZXQpLFxuICBGaWxlT3B0aW9uczogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEZpbGVPcHRpb25zKSxcbiAgRmlsZU9wdGlvbnNfT3B0aW1pemVNb2RlOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRmlsZU9wdGlvbnNfT3B0aW1pemVNb2RlKSxcbiAgRmxvYXRWYWx1ZTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEZsb2F0VmFsdWUpLFxuICBHZW5lcmF0ZWRDb2RlSW5mbzogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEdlbmVyYXRlZENvZGVJbmZvKSxcbiAgR2VuZXJhdGVkQ29kZUluZm9fQW5ub3RhdGlvbjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEdlbmVyYXRlZENvZGVJbmZvX0Fubm90YXRpb24pLFxuICBHZW5lcmF0ZWRDb2RlSW5mb19Bbm5vdGF0aW9uX1NlbWFudGljOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gR2VuZXJhdGVkQ29kZUluZm9fQW5ub3RhdGlvbl9TZW1hbnRpYyksXG4gIEludDMyVmFsdWU6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBJbnQzMlZhbHVlKSxcbiAgSW50NjRWYWx1ZTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEludDY0VmFsdWUpLFxuICBMaXN0VmFsdWU6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBMaXN0VmFsdWUpLFxuICBMb25nVHlwZTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGVzbV9maWVsZC8qIExvbmdUeXBlICovLnApLFxuICBNZXNzYWdlOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYpLFxuICBNZXNzYWdlT3B0aW9uczogKCkgPT4gKC8qIHJlZXhwb3J0ICovIE1lc3NhZ2VPcHRpb25zKSxcbiAgTWV0aG9kOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTWV0aG9kKSxcbiAgTWV0aG9kRGVzY3JpcHRvclByb3RvOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTWV0aG9kRGVzY3JpcHRvclByb3RvKSxcbiAgTWV0aG9kSWRlbXBvdGVuY3k6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBzZXJ2aWNlX3R5cGUvKiBNZXRob2RJZGVtcG90ZW5jeSAqLy53KSxcbiAgTWV0aG9kS2luZDogKCkgPT4gKC8qIHJlZXhwb3J0ICovIHNlcnZpY2VfdHlwZS8qIE1ldGhvZEtpbmQgKi8udCksXG4gIE1ldGhvZE9wdGlvbnM6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBNZXRob2RPcHRpb25zKSxcbiAgTWV0aG9kT3B0aW9uc19JZGVtcG90ZW5jeUxldmVsOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTWV0aG9kT3B0aW9uc19JZGVtcG90ZW5jeUxldmVsKSxcbiAgTWl4aW46ICgpID0+ICgvKiByZWV4cG9ydCAqLyBNaXhpbiksXG4gIE51bGxWYWx1ZTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIE51bGxWYWx1ZSksXG4gIE9uZW9mRGVzY3JpcHRvclByb3RvOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gT25lb2ZEZXNjcmlwdG9yUHJvdG8pLFxuICBPbmVvZk9wdGlvbnM6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBPbmVvZk9wdGlvbnMpLFxuICBPcHRpb246ICgpID0+ICgvKiByZWV4cG9ydCAqLyBPcHRpb24pLFxuICBTY2FsYXJUeXBlOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gZXNtX2ZpZWxkLyogU2NhbGFyVHlwZSAqLy53KSxcbiAgU2VydmljZURlc2NyaXB0b3JQcm90bzogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFNlcnZpY2VEZXNjcmlwdG9yUHJvdG8pLFxuICBTZXJ2aWNlT3B0aW9uczogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFNlcnZpY2VPcHRpb25zKSxcbiAgU291cmNlQ29kZUluZm86ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTb3VyY2VDb2RlSW5mbyksXG4gIFNvdXJjZUNvZGVJbmZvX0xvY2F0aW9uOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU291cmNlQ29kZUluZm9fTG9jYXRpb24pLFxuICBTb3VyY2VDb250ZXh0OiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU291cmNlQ29udGV4dCksXG4gIFN0cmluZ1ZhbHVlOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU3RyaW5nVmFsdWUpLFxuICBTdHJ1Y3Q6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTdHJ1Y3QpLFxuICBTeW50YXg6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTeW50YXgpLFxuICBUaW1lc3RhbXA6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBUaW1lc3RhbXApLFxuICBUeXBlOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gVHlwZSksXG4gIFVJbnQzMlZhbHVlOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gVUludDMyVmFsdWUpLFxuICBVSW50NjRWYWx1ZTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFVJbnQ2NFZhbHVlKSxcbiAgVW5pbnRlcnByZXRlZE9wdGlvbjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFVuaW50ZXJwcmV0ZWRPcHRpb24pLFxuICBVbmludGVycHJldGVkT3B0aW9uX05hbWVQYXJ0OiAoKSA9PiAoLyogcmVleHBvcnQgKi8gVW5pbnRlcnByZXRlZE9wdGlvbl9OYW1lUGFydCksXG4gIFZhbHVlOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gVmFsdWUpLFxuICBWZXJzaW9uOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gVmVyc2lvbiksXG4gIFdpcmVUeXBlOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gYmluYXJ5X2VuY29kaW5nLyogV2lyZVR5cGUgKi8uVEQpLFxuICBjb2RlZ2VuSW5mbzogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGNvZGVnZW5JbmZvKSxcbiAgY3JlYXRlRGVzY3JpcHRvclNldDogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGNyZWF0ZURlc2NyaXB0b3JTZXQpLFxuICBjcmVhdGVSZWdpc3RyeTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGNyZWF0ZVJlZ2lzdHJ5KSxcbiAgY3JlYXRlUmVnaXN0cnlGcm9tRGVzY3JpcHRvcnM6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBjcmVhdGVSZWdpc3RyeUZyb21EZXNjcmlwdG9ycyksXG4gIHByb3RvMjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIHByb3RvMiksXG4gIHByb3RvMzogKCkgPT4gKC8qIHJlZXhwb3J0ICovIHByb3RvMy8qIHByb3RvMyAqLy53KSxcbiAgcHJvdG9CYXNlNjQ6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBwcm90b19iYXNlNjQvKiBwcm90b0Jhc2U2NCAqLy5XKSxcbiAgcHJvdG9EZWxpbWl0ZWQ6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBwcm90b0RlbGltaXRlZCksXG4gIHByb3RvRG91YmxlOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gcHJvdG9Eb3VibGUpLFxuICBwcm90b0ludDY0OiAoKSA9PiAoLyogcmVleHBvcnQgKi8gcHJvdG9faW50NjQvKiBwcm90b0ludDY0ICovLnEpLFxuICB0b1BsYWluTWVzc2FnZTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIHRvUGxhaW5NZXNzYWdlKVxufSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3Byb3RvMy5qcyArIDIgbW9kdWxlc1xudmFyIHByb3RvMyA9IF9fd2VicGFja19yZXF1aXJlX18oODUwKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3ByaXZhdGUvcHJvdG8tcnVudGltZS5qcyArIDEgbW9kdWxlc1xudmFyIHByb3RvX3J1bnRpbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5Myk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9maWVsZC5qc1xudmFyIGVzbV9maWVsZCA9IF9fd2VicGFja19yZXF1aXJlX18oNDY1KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3ByaXZhdGUvYmluYXJ5LWZvcm1hdC1jb21tb24uanNcbnZhciBiaW5hcnlfZm9ybWF0X2NvbW1vbiA9IF9fd2VicGFja19yZXF1aXJlX18oNzQ0KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9iaW5hcnktZm9ybWF0LXByb3RvMi5qc1xuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvbiwgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zLCBuby1jYXNlLWRlY2xhcmF0aW9ucywgcHJlZmVyLWNvbnN0ICovXG5mdW5jdGlvbiBtYWtlQmluYXJ5Rm9ybWF0UHJvdG8yKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICgwLGJpbmFyeV9mb3JtYXRfY29tbW9uLyogbWFrZUJpbmFyeUZvcm1hdENvbW1vbiAqLy5nWSkoKSksIHsgd3JpdGVNZXNzYWdlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UuZ2V0VHlwZSgpO1xuICAgICAgICAgICAgbGV0IGZpZWxkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKGZpZWxkIG9mIHR5cGUuZmllbGRzLmJ5TnVtYmVyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlLCAvLyB0aGlzIHdpbGwgYmUgb3VyIGZpZWxkIHZhbHVlLCB3aGV0aGVyIGl0IGlzIG1lbWJlciBvZiBhIG9uZW9mIG9yIG5vdFxuICAgICAgICAgICAgICAgICAgICByZXBlYXRlZCA9IGZpZWxkLnJlcGVhdGVkLCBsb2NhbE5hbWUgPSBmaWVsZC5sb2NhbE5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5vbmVvZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb25lb2YgPSBtZXNzYWdlW2ZpZWxkLm9uZW9mLmxvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25lb2YuY2FzZSAhPT0gbG9jYWxOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIGZpZWxkIGlzIG5vdCBzZWxlY3RlZCwgc2tpcFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvbmVvZi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbWVzc2FnZVtsb2NhbE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gY29udHJhc3QgdG8gcHJvdG8zLCB3ZSByYWlzZSBhbiBlcnJvciBpZiBhIG5vbi1vcHRpb25hbCAocHJvdG8yIHJlcXVpcmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmllbGQgaXMgbWlzc2luZyBhIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIWZpZWxkLm9uZW9mICYmICFmaWVsZC5vcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBlbmNvZGUgZmllbGQgJHt0eXBlLnR5cGVOYW1lfS4ke2ZpZWxkLm5hbWV9IHRvIGJpbmFyeTogcmVxdWlyZWQgZmllbGQgbm90IHNldGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2NhbGFyVHlwZSA9IGZpZWxkLmtpbmQgPT0gXCJlbnVtXCIgPyBlc21fZmllbGQvKiBTY2FsYXJUeXBlICovLncuSU5UMzIgOiBmaWVsZC5UO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQucGFja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCxiaW5hcnlfZm9ybWF0X2NvbW1vbi8qIHdyaXRlUGFja2VkICovLkpqKSh3cml0ZXIsIHNjYWxhclR5cGUsIGZpZWxkLm5vLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCxiaW5hcnlfZm9ybWF0X2NvbW1vbi8qIHdyaXRlU2NhbGFyICovLk5OKSh3cml0ZXIsIHNjYWxhclR5cGUsIGZpZWxkLm5vLCBpdGVtLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIGNvbnRyYXN0IHRvIHByb3RvMywgd2UgZG8gbm90IHNraXAgaW50cmluc2ljIGRlZmF1bHQgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXQgZGVmYXVsdCB2YWx1ZXMgYXJlIG5vdCBzcGVjaWFsIGNhc2VkIGVpdGhlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLGJpbmFyeV9mb3JtYXRfY29tbW9uLyogd3JpdGVTY2FsYXIgKi8uTk4pKHdyaXRlciwgc2NhbGFyVHlwZSwgZmllbGQubm8sIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsYmluYXJ5X2Zvcm1hdF9jb21tb24vKiB3cml0ZU1lc3NhZ2VGaWVsZCAqLy5vUSkod3JpdGVyLCBvcHRpb25zLCBmaWVsZCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLGJpbmFyeV9mb3JtYXRfY29tbW9uLyogd3JpdGVNZXNzYWdlRmllbGQgKi8ub1EpKHdyaXRlciwgb3B0aW9ucywgZmllbGQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCxiaW5hcnlfZm9ybWF0X2NvbW1vbi8qIHdyaXRlTWFwRW50cnkgKi8uZ1EpKHdyaXRlciwgb3B0aW9ucywgZmllbGQsIGtleSwgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxldCBtID0gZmllbGRcbiAgICAgICAgICAgICAgICAgICAgPyBgY2Fubm90IGVuY29kZSBmaWVsZCAke3R5cGUudHlwZU5hbWV9LiR7ZmllbGQgPT09IG51bGwgfHwgZmllbGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpZWxkLm5hbWV9IHRvIGJpbmFyeWBcbiAgICAgICAgICAgICAgICAgICAgOiBgY2Fubm90IGVuY29kZSBtZXNzYWdlICR7dHlwZS50eXBlTmFtZX0gdG8gYmluYXJ5YDtcbiAgICAgICAgICAgICAgICBsZXQgciA9IGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFN0cmluZyhlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSArIChyLmxlbmd0aCA+IDAgPyBgOiAke3J9YCA6IFwiXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcykge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVVbmtub3duRmllbGRzKG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9IH0pO1xufVxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL3V0aWwtY29tbW9uLmpzXG52YXIgdXRpbF9jb21tb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzMyk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL2ZpZWxkLWxpc3QuanNcbnZhciBmaWVsZF9saXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDEpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9maWVsZC5qc1xudmFyIHByaXZhdGVfZmllbGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxNSk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL25hbWVzLmpzXG52YXIgbmFtZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwNCk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL2ZpZWxkLXdyYXBwZXIuanNcbnZhciBmaWVsZF93cmFwcGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MzIpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9hc3NlcnQuanNcbnZhciBhc3NlcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMCk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL2pzb24tZm9ybWF0LWNvbW1vbi5qc1xudmFyIGpzb25fZm9ybWF0X2NvbW1vbiA9IF9fd2VicGFja19yZXF1aXJlX18oODE0KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9qc29uLWZvcm1hdC1wcm90bzIuanNcbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jYXNlLWRlY2xhcmF0aW9ucywgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMsQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVybixAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50ICovXG5mdW5jdGlvbiBtYWtlSnNvbkZvcm1hdFByb3RvMigpIHtcbiAgICByZXR1cm4gKDAsanNvbl9mb3JtYXRfY29tbW9uLyogbWFrZUpzb25Gb3JtYXRDb21tb24gKi8uYikoKHdyaXRlRW51bSwgd3JpdGVTY2FsYXIpID0+IHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHdyaXRlRmllbGQoZmllbGQsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoZmllbGQua2luZCA9PSBcIm1hcFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QganNvbk9iaiA9IHt9O1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2VudHJ5S2V5LCBlbnRyeVZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSB3cml0ZVNjYWxhcihmaWVsZC5WLlQsIGVudHJ5VmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLGFzc2VydC8qIGFzc2VydCAqLy5odSkodmFsICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25PYmpbZW50cnlLZXkudG9TdHJpbmcoKV0gPSB2YWw7IC8vIEpTT04gc3RhbmRhcmQgYWxsb3dzIG9ubHkgKGRvdWJsZSBxdW90ZWQpIHN0cmluZyBhcyBwcm9wZXJ0eSBrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbZW50cnlLZXksIGVudHJ5VmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEpTT04gc3RhbmRhcmQgYWxsb3dzIG9ubHkgKGRvdWJsZSBxdW90ZWQpIHN0cmluZyBhcyBwcm9wZXJ0eSBrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uT2JqW2VudHJ5S2V5LnRvU3RyaW5nKCldID0gZW50cnlWYWx1ZS50b0pzb24ob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudW1UeXBlID0gZmllbGQuVi5UO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbZW50cnlLZXksIGVudHJ5VmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLGFzc2VydC8qIGFzc2VydCAqLy5odSkoZW50cnlWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBlbnRyeVZhbHVlID09IFwibnVtYmVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHdyaXRlRW51bShlbnVtVHlwZSwgZW50cnlWYWx1ZSwgdHJ1ZSwgb3B0aW9ucy5lbnVtQXNJbnRlZ2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCxhc3NlcnQvKiBhc3NlcnQgKi8uaHUpKHZhbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uT2JqW2VudHJ5S2V5LnRvU3RyaW5nKCldID0gdmFsOyAvLyBKU09OIHN0YW5kYXJkIGFsbG93cyBvbmx5IChkb3VibGUgcXVvdGVkKSBzdHJpbmcgYXMgcHJvcGVydHkga2V5XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZW1pdERlZmF1bHRWYWx1ZXMgfHwgT2JqZWN0LmtleXMoanNvbk9iaikubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICA/IGpzb25PYmpcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGpzb25BcnIgPSBbXTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25BcnIucHVzaCh3cml0ZVNjYWxhcihmaWVsZC5ULCB2YWx1ZVtpXSwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbkFyci5wdXNoKHdyaXRlRW51bShmaWVsZC5ULCB2YWx1ZVtpXSwgdHJ1ZSwgb3B0aW9ucy5lbnVtQXNJbnRlZ2VyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uQXJyLnB1c2godmFsdWVbaV0udG9Kc29uKG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5lbWl0RGVmYXVsdFZhbHVlcyB8fCBqc29uQXJyLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyBqc29uQXJyXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gY29udHJhc3QgdG8gcHJvdG8zLCB3ZSByYWlzZSBhbiBlcnJvciBpZiBhIG5vbi1vcHRpb25hbCAocHJvdG8yIHJlcXVpcmVkKVxuICAgICAgICAgICAgICAgIC8vIGZpZWxkIGlzIG1pc3NpbmcgYSB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpZWxkLm9uZW9mICYmICFmaWVsZC5vcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGByZXF1aXJlZCBmaWVsZCBub3Qgc2V0YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gY29udHJhc3QgdG8gcHJvdG8zLCB3ZSBkbyBub3Qgc2tpcCBpbnRyaW5zaWMgZGVmYXVsdCB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdCBkZWZhdWx0IHZhbHVlcyBhcmUgbm90IHNwZWNpYWwgY2FzZWQgZWl0aGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlU2NhbGFyKGZpZWxkLlQsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIGNvbnRyYXN0IHRvIHByb3RvMywgd2UgZG8gbm90IHNraXAgaW50cmluc2ljIGRlZmF1bHQgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXQgZGVmYXVsdCB2YWx1ZXMgYXJlIG5vdCBzcGVjaWFsIGNhc2VkIGVpdGhlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZUVudW0oZmllbGQuVCwgdmFsdWUsIHRydWUsIG9wdGlvbnMuZW51bUFzSW50ZWdlcik7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsZmllbGRfd3JhcHBlci8qIHdyYXBGaWVsZCAqLy5FKShmaWVsZC5ULCB2YWx1ZSkudG9Kc29uKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcm90bzIuanNcbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cblxuXG5cblxuXG5cblxuLyoqXG4gKiBQcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBtZXNzYWdlcyBkZWZpbmVkIHdpdGggdGhlIHByb3RvMiBzeW50YXguXG4gKi9cbmNvbnN0IHByb3RvMiA9ICgwLHByb3RvX3J1bnRpbWUvKiBtYWtlUHJvdG9SdW50aW1lICovLkYpKFwicHJvdG8yXCIsIG1ha2VKc29uRm9ybWF0UHJvdG8yKCksIG1ha2VCaW5hcnlGb3JtYXRQcm90bzIoKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoMCx1dGlsX2NvbW1vbi8qIG1ha2VVdGlsQ29tbW9uICovLmYpKCkpLCB7IG5ld0ZpZWxkTGlzdChmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBmaWVsZF9saXN0LyogSW50ZXJuYWxGaWVsZExpc3QgKi8uaShmaWVsZHMsIG5vcm1hbGl6ZUZpZWxkSW5mb3NQcm90bzIpO1xuICAgIH0sXG4gICAgaW5pdEZpZWxkcyh0YXJnZXQpIHtcbiAgICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdGFyZ2V0LmdldFR5cGUoKS5maWVsZHMuYnlNZW1iZXIoKSkge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG1lbWJlci5sb2NhbE5hbWUsIHQgPSB0YXJnZXQ7XG4gICAgICAgICAgICBpZiAobWVtYmVyLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgdFtuYW1lXSA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChtZW1iZXIua2luZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJvbmVvZlwiOlxuICAgICAgICAgICAgICAgICAgICB0W25hbWVdID0geyBjYXNlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgICAgICAgICB0W25hbWVdID0ge307XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIGNvbnRyYXN0IHRvIHByb3RvMywgZW51bSBhbmQgc2NhbGFyIGZpZWxkcyBoYXZlIG5vIGludHJpbnNpYyBkZWZhdWx0IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGFuIG9wdGlvbmFsIGV4cGxpY2l0IGRlZmF1bHQgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVubGlrZSBwcm90bzMgaW50cmluc2ljIGRlZmF1bHQgdmFsdWVzLCBwcm90bzIgZXhwbGljaXQgZGVmYXVsdCB2YWx1ZXMgYXJlIG5vdFxuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgb24gY29uc3RydWN0aW9uLCBiZWNhdXNlIHRoZXkgYXJlIG5vdCBvbWl0dGVkIG9uIHRoZSB3aXJlLiBJZiB3ZSBkaWQgc2V0XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdmFsdWVzIG9uIGNvbnN0cnVjdGlvbiwgYSBkZXNlcmlhbGl6ZS1zZXJpYWxpemUgcm91bmQtdHJpcCB3b3VsZCBhZGRcbiAgICAgICAgICAgICAgICAgICAgLy8gZmllbGRzIHRvIGEgbWVzc2FnZS5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IH0pKTtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50ICovXG5mdW5jdGlvbiBub3JtYWxpemVGaWVsZEluZm9zUHJvdG8yKGZpZWxkSW5mb3MpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIGNvbnN0IHIgPSBbXTtcbiAgICBsZXQgbztcbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVvZiBmaWVsZEluZm9zID09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IGZpZWxkSW5mb3MoKVxuICAgICAgICA6IGZpZWxkSW5mb3MpIHtcbiAgICAgICAgY29uc3QgZiA9IGZpZWxkO1xuICAgICAgICBmLmxvY2FsTmFtZSA9ICgwLG5hbWVzLyogbG9jYWxGaWVsZE5hbWUgKi8uUnopKGZpZWxkLm5hbWUsIGZpZWxkLm9uZW9mICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBmLmpzb25OYW1lID0gKF9hID0gZmllbGQuanNvbk5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICgwLG5hbWVzLyogZmllbGRKc29uTmFtZSAqLy54MSkoZmllbGQubmFtZSk7XG4gICAgICAgIGYucmVwZWF0ZWQgPSAoX2IgPSBmaWVsZC5yZXBlYXRlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgICAgIGlmIChmaWVsZC5raW5kID09IFwic2NhbGFyXCIpIHtcbiAgICAgICAgICAgIGYuTCA9IChfYyA9IGZpZWxkLkwpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGVzbV9maWVsZC8qIExvbmdUeXBlICovLnAuQklHSU5UO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGRvIG5vdCBzdXJmYWNlIG9wdGlvbnMgYXQgdGhpcyB0aW1lXG4gICAgICAgIC8vIGYub3B0aW9ucyA9IGZpZWxkLm9wdGlvbnMgPz8gZW1wdHlSZWFkb25seU9iamVjdDtcbiAgICAgICAgaWYgKGZpZWxkLm9uZW9mICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9vbmFtZSA9IHR5cGVvZiBmaWVsZC5vbmVvZiA9PSBcInN0cmluZ1wiID8gZmllbGQub25lb2YgOiBmaWVsZC5vbmVvZi5uYW1lO1xuICAgICAgICAgICAgaWYgKCFvIHx8IG8ubmFtZSAhPSBvb25hbWUpIHtcbiAgICAgICAgICAgICAgICBvID0gbmV3IHByaXZhdGVfZmllbGQvKiBJbnRlcm5hbE9uZW9mSW5mbyAqLy5vKG9vbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmLm9uZW9mID0gbztcbiAgICAgICAgICAgIG8uYWRkRmllbGQoZik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJvdG8yIHNwZWNpZmljOlxuICAgICAgICBpZiAoZmllbGQua2luZCA9PSBcIm1lc3NhZ2VcIikge1xuICAgICAgICAgICAgZi5kZWxpbWl0ZWQgPSAoX2QgPSBmaWVsZC5kZWxpbWl0ZWQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluIGNvbnRyYXN0IHRvIHByb3RvMywgcmVwZWF0ZWQgZmllbGRzIGFyZSB1bnBhY2tlZCBleGNlcHQgd2hlbiBleHBsaWNpdGx5IHNwZWNpZmllZC5cbiAgICAgICAgZi5wYWNrZWQgPSAoX2UgPSBmaWVsZC5wYWNrZWQpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IGZhbHNlO1xuICAgICAgICByLnB1c2goZik7XG4gICAgfVxuICAgIHJldHVybiByO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3Byb3RvLWRvdWJsZS5qc1xuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8vIEV4cG9ydCBnbG9iYWwgTnVtYmVyIGNvbnN0YW50cy4gVGhpcyBpcyBkb25lIHNvIHRoYXQgd2UgY2FuIHNhZmVseSB1c2Vcbi8vIHRoZXNlIGdsb2JhbCBjb25zdGFudHMgd2hlbiBnZW5lcmF0aW5nIGNvZGUgYW5kIGJlIGFzc3VyZWQgd2UncmUgdXNpbmdcbi8vIHRoZSBjb3JyZWN0IHZhbHVlcy4gV2UgY2Fubm90IHJlbHkgb24gZ2xvYmFsVGhpcyBzaW5jZSB3ZSBzdXBwb3J0IEVTMjAxN1xuLy8gYW5kIGdsb2JhbFRoaXMgd2FzIGludHJvZHVjZWQgaW4gRVMyMDIwLiBXZSBhbHNvIGRvbid0IHdhbnQgdG8gZXhwbGljaXRseVxuLy8gZ2VuZXJhdGUgY29kZSB1c2luZywgZm9yIGV4YW1wbGUsIE51bWJlci5OYU4sIHNpbmNlIHRoaXMgY291bGQgY2xhc2ggd2l0aFxuLy8gYSBtZXNzYWdlIG5hbWUgb2YgTnVtYmVyLiBJbnN0ZWFkIHdlIGNhbiBleHBvcnQgdGhlbSBoZXJlIHNpbmNlIHRoaXMgd2lsbFxuLy8gYmUgaW4gYSBkaWZmZXJlbnQgc2NvcGUgYXMgdGhlIGdlbmVyYXRlZCBjb2RlIGFuZCB3ZSBhcmUgZ3VhcmFudGVlZCB0byB1c2Vcbi8vIHRoZSBpbnRlbmRlZCBnbG9iYWwgdmFsdWVzLlxuY29uc3QgcHJvdG9Eb3VibGUgPSB7XG4gICAgTmFOOiBOdW1iZXIuTmFOLFxuICAgIFBPU0lUSVZFX0lORklOSVRZOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgTkVHQVRJVkVfSU5GSU5JVFk6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcbn07XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3Byb3RvLWludDY0LmpzXG52YXIgcHJvdG9faW50NjQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxMCk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcm90by1iYXNlNjQuanNcbnZhciBwcm90b19iYXNlNjQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzNik7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9iaW5hcnktZW5jb2RpbmcuanNcbnZhciBiaW5hcnlfZW5jb2RpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc5KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJvdG8tZGVsaW1pdGVkLmpzXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIF9fYXN5bmNWYWx1ZXMgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2FzeW5jVmFsdWVzKSB8fCBmdW5jdGlvbiAobykge1xuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cbn07XG52YXIgX19hd2FpdCA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXdhaXQpIHx8IGZ1bmN0aW9uICh2KSB7IHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpOyB9XG52YXIgX19hc3luY0dlbmVyYXRvciA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXN5bmNHZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiLCBhd2FpdFJldHVybiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgICBmdW5jdGlvbiBhd2FpdFJldHVybihmKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZiwgcmVqZWN0KTsgfTsgfVxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpZiAoZ1tuXSkgeyBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyBpZiAoZikgaVtuXSA9IGYoaVtuXSk7IH0gfVxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cbn07XG5cblxuLyoqXG4gKiBwcm90b0RlbGltaXRlZCBwcm92aWRlcyBmdW5jdGlvbnMgdG8gc2VyaWFsaXplIGFuZCBwYXJzZSBzaXplLWRlbGltaXRlZFxuICogbWVzc2FnZXMuXG4gKlxuICogQSBzaXplLWRlbGltaXRlZCBtZXNzYWdlIGlzIGEgdmFyaW50IHNpemUgaW4gYnl0ZXMsIGZvbGxvd2VkIGJ5IGV4YWN0bHlcbiAqIHRoYXQgbWFueSBieXRlcyBvZiBhIG1lc3NhZ2Ugc2VyaWFsaXplZCB3aXRoIHRoZSBiaW5hcnkgZm9ybWF0LlxuICpcbiAqIFRoaXMgc2l6ZS1kZWxpbWl0ZWQgZm9ybWF0IGlzIGNvbXBhdGlibGUgd2l0aCBvdGhlciBpbXBsZW1lbnRhdGlvbnMuXG4gKiBGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYvaXNzdWVzLzEwMjI5XG4gKi9cbmNvbnN0IHByb3RvRGVsaW1pdGVkID0ge1xuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSBhIG1lc3NhZ2UsIHByZWZpeGluZyBpdCB3aXRoIGl0cyBzaXplLlxuICAgICAqL1xuICAgIGVuYyhtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG9wdCA9ICgwLGJpbmFyeV9mb3JtYXRfY29tbW9uLyogbWFrZUJpbmFyeUZvcm1hdENvbW1vbiAqLy5nWSkoKS5tYWtlV3JpdGVPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gb3B0LndyaXRlckZhY3RvcnkoKS5ieXRlcyhtZXNzYWdlLnRvQmluYXJ5KG9wdCkpLmZpbmlzaCgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUGFyc2UgYSBzaXplLWRlbGltaXRlZCBtZXNzYWdlLCBpZ25vcmluZyBleHRyYSBieXRlcy5cbiAgICAgKi9cbiAgICBkZWModHlwZSwgYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgb3B0ID0gKDAsYmluYXJ5X2Zvcm1hdF9jb21tb24vKiBtYWtlQmluYXJ5Rm9ybWF0Q29tbW9uICovLmdZKSgpLm1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHR5cGUuZnJvbUJpbmFyeShvcHQucmVhZGVyRmFjdG9yeShieXRlcykuYnl0ZXMoKSwgb3B0KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFBhcnNlIGEgc3RyZWFtIG9mIHNpemUtZGVsaW1pdGVkIG1lc3NhZ2VzLlxuICAgICAqL1xuICAgIGRlY1N0cmVhbSh0eXBlLCBpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBkZWNTdHJlYW1fMSgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgZV8xLCBfYiwgX2M7XG4gICAgICAgICAgICAvLyBhcHBlbmQgY2h1bmsgdG8gYnVmZmVyLCByZXR1cm5pbmcgdXBkYXRlZCBidWZmZXJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFwcGVuZChidWZmZXIsIGNodW5rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbiA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlci5ieXRlTGVuZ3RoICsgY2h1bmsuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbi5zZXQoYnVmZmVyKTtcbiAgICAgICAgICAgICAgICBuLnNldChjaHVuaywgYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgaXRlcmFibGVfMSA9IF9fYXN5bmNWYWx1ZXMoaXRlcmFibGUpLCBpdGVyYWJsZV8xXzE7IGl0ZXJhYmxlXzFfMSA9IHlpZWxkIF9fYXdhaXQoaXRlcmFibGVfMS5uZXh0KCkpLCBfYSA9IGl0ZXJhYmxlXzFfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfYyA9IGl0ZXJhYmxlXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gYXBwZW5kKGJ1ZmZlciwgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gcHJvdG9EZWxpbWl0ZWQucGVla1NpemUoYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaXplLmVvZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpemUgaXMgaW5jb21wbGV0ZSwgYnVmZmVyIG1vcmUgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpemUub2Zmc2V0ICsgc2l6ZS5zaXplID4gYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtZXNzYWdlIGlzIGluY29tcGxldGUsIGJ1ZmZlciBtb3JlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQocHJvdG9EZWxpbWl0ZWQuZGVjKHR5cGUsIGJ1ZmZlcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnN1YmFycmF5KHNpemUub2Zmc2V0ICsgc2l6ZS5zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBpdGVyYWJsZV8xLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChpdGVyYWJsZV8xKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChidWZmZXIuYnl0ZUxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbmNvbXBsZXRlIGRhdGFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyB0aGUgc2l6ZSBmcm9tIHRoZSBnaXZlbiBzaXplLWRlbGltaXRlZCBtZXNzYWdlLCB3aGljaCBtYXkgYmVcbiAgICAgKiBpbmNvbXBsZXRlLlxuICAgICAqXG4gICAgICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICogLSBzaXplOiBUaGUgc2l6ZSBvZiB0aGUgZGVsaW1pdGVkIG1lc3NhZ2UgaW4gYnl0ZXNcbiAgICAgKiAtIG9mZnNldDogVGhlIG9mZnNldCBpbiB0aGUgZ2l2ZW4gYnl0ZSBhcnJheSB3aGVyZSB0aGUgbWVzc2FnZSBzdGFydHNcbiAgICAgKiAtIGVvZjogdHJ1ZVxuICAgICAqXG4gICAgICogSWYgdGhlIHNpemUtZGVsaW1pdGVkIGRhdGEgZG9lcyBub3QgaW5jbHVkZSBhbGwgYnl0ZXMgb2YgdGhlIHZhcmludCBzaXplLFxuICAgICAqIHRoZSBmb2xsb3dpbmcgb2JqZWN0IGlzIHJldHVybmVkOlxuICAgICAqIC0gc2l6ZTogbnVsbFxuICAgICAqIC0gb2Zmc2V0OiBudWxsXG4gICAgICogLSBlb2Y6IGZhbHNlXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGltcGxlbWVudCBwYXJzaW5nIG9mIHNpemUtZGVsaW1pdGVkIG1lc3NhZ2VzXG4gICAgICogZnJvbSBhIHN0cmVhbS5cbiAgICAgKi9cbiAgICBwZWVrU2l6ZShkYXRhKSB7XG4gICAgICAgIGNvbnN0IHNpemVFb2YgPSB7IGVvZjogdHJ1ZSwgc2l6ZTogbnVsbCwgb2Zmc2V0OiBudWxsIH07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPiBkYXRhLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2l6ZUVvZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZGF0YVtpXSAmIDB4ODApID09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgYmluYXJ5X2VuY29kaW5nLyogQmluYXJ5UmVhZGVyICovLm9QKGRhdGEpO1xuICAgICAgICAgICAgICAgIGxldCBzaXplO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUmFuZ2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpemVFb2Y7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZW9mOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiByZWFkZXIucG9zLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB2YXJpbnRcIik7XG4gICAgfSxcbn07XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3ByaXZhdGUvc2NhbGFycy5qc1xudmFyIHNjYWxhcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4MSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3ByaXZhdGUvcmVpZnktd2t0LmpzXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKipcbiAqIEBkZXByZWNhdGVkIHBsZWFzZSB1c2UgcmVpZnlXa3QgZnJvbSBAYnVmYnVpbGQvcHJvdG9wbHVnaW4vZWNtYXNjcmlwdCBpbnN0ZWFkXG4gKlxuICogUmVpZmllcyBhIGdpdmVuIERlc2NNZXNzYWdlIGludG8gYSBtb3JlIGNvbmNyZXRlIG9iamVjdCByZXByZXNlbnRpbmcgaXRzXG4gKiByZXNwZWN0aXZlIHdlbGwta25vd24gdHlwZS4gIFRoZSByZXR1cm5lZCBvYmplY3Qgd2lsbCBjb250YWluIHByb3BlcnRpZXNcbiAqIHJlcHJlc2VudGluZyB0aGUgV0tUJ3MgZGVmaW5lZCBmaWVsZHMuXG4gKlxuICogVXNlZnVsIGR1cmluZyBjb2RlIGdlbmVyYXRpb24gd2hlbiBpbW1lZGlhdGUgYWNjZXNzIHRvIGEgcGFydGljdWxhciBmaWVsZFxuICogaXMgbmVlZGVkIHdpdGhvdXQgaGF2aW5nIHRvIHNlYXJjaCB0aGUgb2JqZWN0J3MgdHlwZW5hbWUgYW5kIERlc2NGaWVsZCBsaXN0LlxuICpcbiAqIFJldHVybnMgdW5kZWZpbmVkIGlmIHRoZSBXS1QgY2Fubm90IGJlIGNvbXBsZXRlbHkgY29uc3RydWN0ZWQgdmlhIHRoZVxuICogRGVzY01lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIHJlaWZ5V2t0KG1lc3NhZ2UpIHtcbiAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZU5hbWUpIHtcbiAgICAgICAgY2FzZSBcImdvb2dsZS5wcm90b2J1Zi5BbnlcIjoge1xuICAgICAgICAgICAgY29uc3QgdHlwZVVybCA9IG1lc3NhZ2UuZmllbGRzLmZpbmQoKGYpID0+IGYubnVtYmVyID09IDEgJiZcbiAgICAgICAgICAgICAgICBmLmZpZWxkS2luZCA9PSBcInNjYWxhclwiICYmXG4gICAgICAgICAgICAgICAgZi5zY2FsYXIgPT09IGVzbV9maWVsZC8qIFNjYWxhclR5cGUgKi8udy5TVFJJTkcpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBtZXNzYWdlLmZpZWxkcy5maW5kKChmKSA9PiBmLm51bWJlciA9PSAyICYmXG4gICAgICAgICAgICAgICAgZi5maWVsZEtpbmQgPT0gXCJzY2FsYXJcIiAmJlxuICAgICAgICAgICAgICAgIGYuc2NhbGFyID09PSBlc21fZmllbGQvKiBTY2FsYXJUeXBlICovLncuQllURVMpO1xuICAgICAgICAgICAgaWYgKHR5cGVVcmwgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlTmFtZTogbWVzc2FnZS50eXBlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZVVybCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IHNlY29uZHMgPSBtZXNzYWdlLmZpZWxkcy5maW5kKChmKSA9PiBmLm51bWJlciA9PSAxICYmXG4gICAgICAgICAgICAgICAgZi5maWVsZEtpbmQgPT0gXCJzY2FsYXJcIiAmJlxuICAgICAgICAgICAgICAgIGYuc2NhbGFyID09PSBlc21fZmllbGQvKiBTY2FsYXJUeXBlICovLncuSU5UNjQpO1xuICAgICAgICAgICAgY29uc3QgbmFub3MgPSBtZXNzYWdlLmZpZWxkcy5maW5kKChmKSA9PiBmLm51bWJlciA9PSAyICYmXG4gICAgICAgICAgICAgICAgZi5maWVsZEtpbmQgPT0gXCJzY2FsYXJcIiAmJlxuICAgICAgICAgICAgICAgIGYuc2NhbGFyID09PSBlc21fZmllbGQvKiBTY2FsYXJUeXBlICovLncuSU5UMzIpO1xuICAgICAgICAgICAgaWYgKHNlY29uZHMgJiYgbmFub3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlTmFtZTogbWVzc2FnZS50eXBlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyxcbiAgICAgICAgICAgICAgICAgICAgbmFub3MsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJnb29nbGUucHJvdG9idWYuRHVyYXRpb25cIjoge1xuICAgICAgICAgICAgY29uc3Qgc2Vjb25kcyA9IG1lc3NhZ2UuZmllbGRzLmZpbmQoKGYpID0+IGYubnVtYmVyID09IDEgJiZcbiAgICAgICAgICAgICAgICBmLmZpZWxkS2luZCA9PSBcInNjYWxhclwiICYmXG4gICAgICAgICAgICAgICAgZi5zY2FsYXIgPT09IGVzbV9maWVsZC8qIFNjYWxhclR5cGUgKi8udy5JTlQ2NCk7XG4gICAgICAgICAgICBjb25zdCBuYW5vcyA9IG1lc3NhZ2UuZmllbGRzLmZpbmQoKGYpID0+IGYubnVtYmVyID09IDIgJiZcbiAgICAgICAgICAgICAgICBmLmZpZWxkS2luZCA9PSBcInNjYWxhclwiICYmXG4gICAgICAgICAgICAgICAgZi5zY2FsYXIgPT09IGVzbV9maWVsZC8qIFNjYWxhclR5cGUgKi8udy5JTlQzMik7XG4gICAgICAgICAgICBpZiAoc2Vjb25kcyAmJiBuYW5vcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVOYW1lOiBtZXNzYWdlLnR5cGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRzLFxuICAgICAgICAgICAgICAgICAgICBuYW5vcyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3RcIjoge1xuICAgICAgICAgICAgY29uc3QgZmllbGRzID0gbWVzc2FnZS5maWVsZHMuZmluZCgoZikgPT4gZi5udW1iZXIgPT0gMSAmJiAhZi5yZXBlYXRlZCk7XG4gICAgICAgICAgICBpZiAoKGZpZWxkcyA9PT0gbnVsbCB8fCBmaWVsZHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpZWxkcy5maWVsZEtpbmQpICE9PSBcIm1hcFwiIHx8XG4gICAgICAgICAgICAgICAgZmllbGRzLm1hcFZhbHVlLmtpbmQgIT09IFwibWVzc2FnZVwiIHx8XG4gICAgICAgICAgICAgICAgZmllbGRzLm1hcFZhbHVlLm1lc3NhZ2UudHlwZU5hbWUgIT09IFwiZ29vZ2xlLnByb3RvYnVmLlZhbHVlXCIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHR5cGVOYW1lOiBtZXNzYWdlLnR5cGVOYW1lLCBmaWVsZHMgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZ29vZ2xlLnByb3RvYnVmLlZhbHVlXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IGtpbmQgPSBtZXNzYWdlLm9uZW9mcy5maW5kKChvKSA9PiBvLm5hbWUgPT09IFwia2luZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IG51bGxWYWx1ZSA9IG1lc3NhZ2UuZmllbGRzLmZpbmQoKGYpID0+IGYubnVtYmVyID09IDEgJiYgZi5vbmVvZiA9PT0ga2luZCk7XG4gICAgICAgICAgICBpZiAoKG51bGxWYWx1ZSA9PT0gbnVsbCB8fCBudWxsVmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG51bGxWYWx1ZS5maWVsZEtpbmQpICE9PSBcImVudW1cIiB8fFxuICAgICAgICAgICAgICAgIG51bGxWYWx1ZS5lbnVtLnR5cGVOYW1lICE9PSBcImdvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWVcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBudW1iZXJWYWx1ZSA9IG1lc3NhZ2UuZmllbGRzLmZpbmQoKGYpID0+IGYubnVtYmVyID09IDIgJiZcbiAgICAgICAgICAgICAgICBmLmZpZWxkS2luZCA9PSBcInNjYWxhclwiICYmXG4gICAgICAgICAgICAgICAgZi5zY2FsYXIgPT09IGVzbV9maWVsZC8qIFNjYWxhclR5cGUgKi8udy5ET1VCTEUgJiZcbiAgICAgICAgICAgICAgICBmLm9uZW9mID09PSBraW5kKTtcbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ1ZhbHVlID0gbWVzc2FnZS5maWVsZHMuZmluZCgoZikgPT4gZi5udW1iZXIgPT0gMyAmJlxuICAgICAgICAgICAgICAgIGYuZmllbGRLaW5kID09IFwic2NhbGFyXCIgJiZcbiAgICAgICAgICAgICAgICBmLnNjYWxhciA9PT0gZXNtX2ZpZWxkLyogU2NhbGFyVHlwZSAqLy53LlNUUklORyAmJlxuICAgICAgICAgICAgICAgIGYub25lb2YgPT09IGtpbmQpO1xuICAgICAgICAgICAgY29uc3QgYm9vbFZhbHVlID0gbWVzc2FnZS5maWVsZHMuZmluZCgoZikgPT4gZi5udW1iZXIgPT0gNCAmJlxuICAgICAgICAgICAgICAgIGYuZmllbGRLaW5kID09IFwic2NhbGFyXCIgJiZcbiAgICAgICAgICAgICAgICBmLnNjYWxhciA9PT0gZXNtX2ZpZWxkLyogU2NhbGFyVHlwZSAqLy53LkJPT0wgJiZcbiAgICAgICAgICAgICAgICBmLm9uZW9mID09PSBraW5kKTtcbiAgICAgICAgICAgIGNvbnN0IHN0cnVjdFZhbHVlID0gbWVzc2FnZS5maWVsZHMuZmluZCgoZikgPT4gZi5udW1iZXIgPT0gNSAmJiBmLm9uZW9mID09PSBraW5kKTtcbiAgICAgICAgICAgIGlmICgoc3RydWN0VmFsdWUgPT09IG51bGwgfHwgc3RydWN0VmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0cnVjdFZhbHVlLmZpZWxkS2luZCkgIT09IFwibWVzc2FnZVwiIHx8XG4gICAgICAgICAgICAgICAgc3RydWN0VmFsdWUubWVzc2FnZS50eXBlTmFtZSAhPT0gXCJnb29nbGUucHJvdG9idWYuU3RydWN0XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGlzdFZhbHVlID0gbWVzc2FnZS5maWVsZHMuZmluZCgoZikgPT4gZi5udW1iZXIgPT0gNiAmJiBmLm9uZW9mID09PSBraW5kKTtcbiAgICAgICAgICAgIGlmICgobGlzdFZhbHVlID09PSBudWxsIHx8IGxpc3RWYWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGlzdFZhbHVlLmZpZWxkS2luZCkgIT09IFwibWVzc2FnZVwiIHx8XG4gICAgICAgICAgICAgICAgbGlzdFZhbHVlLm1lc3NhZ2UudHlwZU5hbWUgIT09IFwiZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChraW5kICYmIG51bWJlclZhbHVlICYmIHN0cmluZ1ZhbHVlICYmIGJvb2xWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVOYW1lOiBtZXNzYWdlLnR5cGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgICAgICBudWxsVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG51bWJlclZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBzdHJpbmdWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgYm9vbFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBzdHJ1Y3RWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbGlzdFZhbHVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZVwiOiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBtZXNzYWdlLmZpZWxkcy5maW5kKChmKSA9PiBmLm51bWJlciA9PSAxICYmIGYucmVwZWF0ZWQpO1xuICAgICAgICAgICAgaWYgKCh2YWx1ZXMgPT09IG51bGwgfHwgdmFsdWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZXMuZmllbGRLaW5kKSAhPSBcIm1lc3NhZ2VcIiB8fFxuICAgICAgICAgICAgICAgIHZhbHVlcy5tZXNzYWdlLnR5cGVOYW1lICE9PSBcImdvb2dsZS5wcm90b2J1Zi5WYWx1ZVwiKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlTmFtZTogbWVzc2FnZS50eXBlTmFtZSwgdmFsdWVzIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImdvb2dsZS5wcm90b2J1Zi5GaWVsZE1hc2tcIjoge1xuICAgICAgICAgICAgY29uc3QgcGF0aHMgPSBtZXNzYWdlLmZpZWxkcy5maW5kKChmKSA9PiBmLm51bWJlciA9PSAxICYmXG4gICAgICAgICAgICAgICAgZi5maWVsZEtpbmQgPT0gXCJzY2FsYXJcIiAmJlxuICAgICAgICAgICAgICAgIGYuc2NhbGFyID09PSBlc21fZmllbGQvKiBTY2FsYXJUeXBlICovLncuU1RSSU5HICYmXG4gICAgICAgICAgICAgICAgZi5yZXBlYXRlZCk7XG4gICAgICAgICAgICBpZiAocGF0aHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlTmFtZTogbWVzc2FnZS50eXBlTmFtZSwgcGF0aHMgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJnb29nbGUucHJvdG9idWYuRG91YmxlVmFsdWVcIjpcbiAgICAgICAgY2FzZSBcImdvb2dsZS5wcm90b2J1Zi5GbG9hdFZhbHVlXCI6XG4gICAgICAgIGNhc2UgXCJnb29nbGUucHJvdG9idWYuSW50NjRWYWx1ZVwiOlxuICAgICAgICBjYXNlIFwiZ29vZ2xlLnByb3RvYnVmLlVJbnQ2NFZhbHVlXCI6XG4gICAgICAgIGNhc2UgXCJnb29nbGUucHJvdG9idWYuSW50MzJWYWx1ZVwiOlxuICAgICAgICBjYXNlIFwiZ29vZ2xlLnByb3RvYnVmLlVJbnQzMlZhbHVlXCI6XG4gICAgICAgIGNhc2UgXCJnb29nbGUucHJvdG9idWYuQm9vbFZhbHVlXCI6XG4gICAgICAgIGNhc2UgXCJnb29nbGUucHJvdG9idWYuU3RyaW5nVmFsdWVcIjpcbiAgICAgICAgY2FzZSBcImdvb2dsZS5wcm90b2J1Zi5CeXRlc1ZhbHVlXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbWVzc2FnZS5maWVsZHMuZmluZCgoZikgPT4gZi5udW1iZXIgPT0gMSAmJiBmLm5hbWUgPT0gXCJ2YWx1ZVwiKTtcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS5maWVsZEtpbmQgIT09IFwic2NhbGFyXCIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHR5cGVOYW1lOiBtZXNzYWdlLnR5cGVOYW1lLCB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vY29kZWdlbi1pbmZvLmpzXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5cblxuXG5cbmNvbnN0IHBhY2thZ2VOYW1lID0gXCJAYnVmYnVpbGQvcHJvdG9idWZcIjtcbmNvbnN0IGNvZGVnZW5JbmZvID0ge1xuICAgIHBhY2thZ2VOYW1lOiBcIkBidWZidWlsZC9wcm90b2J1ZlwiLFxuICAgIGxvY2FsTmFtZTogbmFtZXMvKiBsb2NhbE5hbWUgKi8ucjEsXG4gICAgcmVpZnlXa3Q6IHJlaWZ5V2t0LFxuICAgIGdldFVud3JhcHBlZEZpZWxkVHlwZTogZmllbGRfd3JhcHBlci8qIGdldFVud3JhcHBlZEZpZWxkVHlwZSAqLy53LFxuICAgIHNjYWxhckRlZmF1bHRWYWx1ZTogc2NhbGFycy8qIHNjYWxhckRlZmF1bHRWYWx1ZSAqLy5rWSxcbiAgICBzYWZlSWRlbnRpZmllcjogbmFtZXMvKiBzYWZlSWRlbnRpZmllciAqLy5HRCxcbiAgICBzYWZlT2JqZWN0UHJvcGVydHk6IG5hbWVzLyogc2FmZU9iamVjdFByb3BlcnR5ICovLmxsLFxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHN5bWJvbHM6IHtcbiAgICAgICAgcHJvdG8yOiB7IHR5cGVPbmx5OiBmYWxzZSwgcHJpdmF0ZUltcG9ydFBhdGg6IFwiLi9wcm90bzIuanNcIiwgcHVibGljSW1wb3J0UGF0aDogcGFja2FnZU5hbWUgfSxcbiAgICAgICAgcHJvdG8zOiB7IHR5cGVPbmx5OiBmYWxzZSwgcHJpdmF0ZUltcG9ydFBhdGg6IFwiLi9wcm90bzMuanNcIiwgcHVibGljSW1wb3J0UGF0aDogcGFja2FnZU5hbWUgfSxcbiAgICAgICAgTWVzc2FnZTogeyB0eXBlT25seTogZmFsc2UsIHByaXZhdGVJbXBvcnRQYXRoOiBcIi4vbWVzc2FnZS5qc1wiLCBwdWJsaWNJbXBvcnRQYXRoOiBwYWNrYWdlTmFtZSB9LFxuICAgICAgICBQYXJ0aWFsTWVzc2FnZTogeyB0eXBlT25seTogdHJ1ZSwgcHJpdmF0ZUltcG9ydFBhdGg6IFwiLi9tZXNzYWdlLmpzXCIsIHB1YmxpY0ltcG9ydFBhdGg6IHBhY2thZ2VOYW1lIH0sXG4gICAgICAgIFBsYWluTWVzc2FnZTogeyB0eXBlT25seTogdHJ1ZSwgcHJpdmF0ZUltcG9ydFBhdGg6IFwiLi9tZXNzYWdlLmpzXCIsIHB1YmxpY0ltcG9ydFBhdGg6IHBhY2thZ2VOYW1lIH0sXG4gICAgICAgIEZpZWxkTGlzdDogeyB0eXBlT25seTogdHJ1ZSwgcHJpdmF0ZUltcG9ydFBhdGg6IFwiLi9maWVsZC1saXN0LmpzXCIsIHB1YmxpY0ltcG9ydFBhdGg6IHBhY2thZ2VOYW1lIH0sXG4gICAgICAgIE1lc3NhZ2VUeXBlOiB7IHR5cGVPbmx5OiB0cnVlLCBwcml2YXRlSW1wb3J0UGF0aDogXCIuL21lc3NhZ2UtdHlwZS5qc1wiLCBwdWJsaWNJbXBvcnRQYXRoOiBwYWNrYWdlTmFtZSB9LFxuICAgICAgICBCaW5hcnlSZWFkT3B0aW9uczogeyB0eXBlT25seTogdHJ1ZSwgcHJpdmF0ZUltcG9ydFBhdGg6IFwiLi9iaW5hcnktZm9ybWF0LmpzXCIsIHB1YmxpY0ltcG9ydFBhdGg6IHBhY2thZ2VOYW1lIH0sXG4gICAgICAgIEJpbmFyeVdyaXRlT3B0aW9uczogeyB0eXBlT25seTogdHJ1ZSwgcHJpdmF0ZUltcG9ydFBhdGg6IFwiLi9iaW5hcnktZm9ybWF0LmpzXCIsIHB1YmxpY0ltcG9ydFBhdGg6IHBhY2thZ2VOYW1lIH0sXG4gICAgICAgIEpzb25SZWFkT3B0aW9uczogeyB0eXBlT25seTogdHJ1ZSwgcHJpdmF0ZUltcG9ydFBhdGg6IFwiLi9qc29uLWZvcm1hdC5qc1wiLCBwdWJsaWNJbXBvcnRQYXRoOiBwYWNrYWdlTmFtZSB9LFxuICAgICAgICBKc29uV3JpdGVPcHRpb25zOiB7IHR5cGVPbmx5OiB0cnVlLCBwcml2YXRlSW1wb3J0UGF0aDogXCIuL2pzb24tZm9ybWF0LmpzXCIsIHB1YmxpY0ltcG9ydFBhdGg6IHBhY2thZ2VOYW1lIH0sXG4gICAgICAgIEpzb25WYWx1ZTogeyB0eXBlT25seTogdHJ1ZSwgcHJpdmF0ZUltcG9ydFBhdGg6IFwiLi9qc29uLWZvcm1hdC5qc1wiLCBwdWJsaWNJbXBvcnRQYXRoOiBwYWNrYWdlTmFtZSB9LFxuICAgICAgICBKc29uT2JqZWN0OiB7IHR5cGVPbmx5OiB0cnVlLCBwcml2YXRlSW1wb3J0UGF0aDogXCIuL2pzb24tZm9ybWF0LmpzXCIsIHB1YmxpY0ltcG9ydFBhdGg6IHBhY2thZ2VOYW1lIH0sXG4gICAgICAgIHByb3RvRG91YmxlOiB7IHR5cGVPbmx5OiBmYWxzZSwgcHJpdmF0ZUltcG9ydFBhdGg6IFwiLi9wcm90by1kb3VibGUuanNcIiwgcHVibGljSW1wb3J0UGF0aDogcGFja2FnZU5hbWUgfSxcbiAgICAgICAgcHJvdG9JbnQ2NDogeyB0eXBlT25seTogZmFsc2UsIHByaXZhdGVJbXBvcnRQYXRoOiBcIi4vcHJvdG8taW50NjQuanNcIiwgcHVibGljSW1wb3J0UGF0aDogcGFja2FnZU5hbWUgfSxcbiAgICAgICAgU2NhbGFyVHlwZTogeyB0eXBlT25seTogZmFsc2UsIHByaXZhdGVJbXBvcnRQYXRoOiBcIi4vZmllbGQuanNcIiwgcHVibGljSW1wb3J0UGF0aDogcGFja2FnZU5hbWUgfSxcbiAgICAgICAgTG9uZ1R5cGU6IHsgdHlwZU9ubHk6IGZhbHNlLCBwcml2YXRlSW1wb3J0UGF0aDogXCIuL2ZpZWxkLmpzXCIsIHB1YmxpY0ltcG9ydFBhdGg6IHBhY2thZ2VOYW1lIH0sXG4gICAgICAgIE1ldGhvZEtpbmQ6IHsgdHlwZU9ubHk6IGZhbHNlLCBwcml2YXRlSW1wb3J0UGF0aDogXCIuL3NlcnZpY2UtdHlwZS5qc1wiLCBwdWJsaWNJbXBvcnRQYXRoOiBwYWNrYWdlTmFtZSB9LFxuICAgICAgICBNZXRob2RJZGVtcG90ZW5jeTogeyB0eXBlT25seTogZmFsc2UsIHByaXZhdGVJbXBvcnRQYXRoOiBcIi4vc2VydmljZS10eXBlLmpzXCIsIHB1YmxpY0ltcG9ydFBhdGg6IHBhY2thZ2VOYW1lIH0sXG4gICAgICAgIElNZXNzYWdlVHlwZVJlZ2lzdHJ5OiB7IHR5cGVPbmx5OiB0cnVlLCBwcml2YXRlSW1wb3J0UGF0aDogXCIuL3R5cGUtcmVnaXN0cnkuanNcIiwgcHVibGljSW1wb3J0UGF0aDogcGFja2FnZU5hbWUgfSxcbiAgICB9LFxuICAgIHdrdFNvdXJjZUZpbGVzOiBbXG4gICAgICAgIFwiZ29vZ2xlL3Byb3RvYnVmL2NvbXBpbGVyL3BsdWdpbi5wcm90b1wiLFxuICAgICAgICBcImdvb2dsZS9wcm90b2J1Zi9hbnkucHJvdG9cIixcbiAgICAgICAgXCJnb29nbGUvcHJvdG9idWYvYXBpLnByb3RvXCIsXG4gICAgICAgIFwiZ29vZ2xlL3Byb3RvYnVmL2Rlc2NyaXB0b3IucHJvdG9cIixcbiAgICAgICAgXCJnb29nbGUvcHJvdG9idWYvZHVyYXRpb24ucHJvdG9cIixcbiAgICAgICAgXCJnb29nbGUvcHJvdG9idWYvZW1wdHkucHJvdG9cIixcbiAgICAgICAgXCJnb29nbGUvcHJvdG9idWYvZmllbGRfbWFzay5wcm90b1wiLFxuICAgICAgICBcImdvb2dsZS9wcm90b2J1Zi9zb3VyY2VfY29udGV4dC5wcm90b1wiLFxuICAgICAgICBcImdvb2dsZS9wcm90b2J1Zi9zdHJ1Y3QucHJvdG9cIixcbiAgICAgICAgXCJnb29nbGUvcHJvdG9idWYvdGltZXN0YW1wLnByb3RvXCIsXG4gICAgICAgIFwiZ29vZ2xlL3Byb3RvYnVmL3R5cGUucHJvdG9cIixcbiAgICAgICAgXCJnb29nbGUvcHJvdG9idWYvd3JhcHBlcnMucHJvdG9cIixcbiAgICBdLFxufTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vbWVzc2FnZS5qc1xudmFyIGVzbV9tZXNzYWdlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NjEpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vc2VydmljZS10eXBlLmpzXG52YXIgc2VydmljZV90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMjgpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9nb29nbGUvcHJvdG9idWYvZGVzY3JpcHRvcl9wYi5qc1xuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8vIEF1dGhvcjoga2VudG9uQGdvb2dsZS5jb20gKEtlbnRvbiBWYXJkYSlcbi8vICBCYXNlZCBvbiBvcmlnaW5hbCBQcm90b2NvbCBCdWZmZXJzIGRlc2lnbiBieVxuLy8gIFNhbmpheSBHaGVtYXdhdCwgSmVmZiBEZWFuLCBhbmQgb3RoZXJzLlxuLy9cbi8vIFRoZSBtZXNzYWdlcyBpbiB0aGlzIGZpbGUgZGVzY3JpYmUgdGhlIGRlZmluaXRpb25zIGZvdW5kIGluIC5wcm90byBmaWxlcy5cbi8vIEEgdmFsaWQgLnByb3RvIGZpbGUgY2FuIGJlIHRyYW5zbGF0ZWQgZGlyZWN0bHkgdG8gYSBGaWxlRGVzY3JpcHRvclByb3RvXG4vLyB3aXRob3V0IGFueSBvdGhlciBpbmZvcm1hdGlvbiAoZS5nLiB3aXRob3V0IHJlYWRpbmcgaXRzIGltcG9ydHMpLlxuLy8gQGdlbmVyYXRlZCBieSBwcm90b2MtZ2VuLWVzIHYxLjYuMCB3aXRoIHBhcmFtZXRlciBcImJvb3RzdHJhcF93a3Q9dHJ1ZSx0c19ub2NoZWNrPWZhbHNlLHRhcmdldD10c1wiXG4vLyBAZ2VuZXJhdGVkIGZyb20gZmlsZSBnb29nbGUvcHJvdG9idWYvZGVzY3JpcHRvci5wcm90byAocGFja2FnZSBnb29nbGUucHJvdG9idWYsIHN5bnRheCBwcm90bzIpXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG5cbi8qKlxuICogVGhlIGZ1bGwgc2V0IG9mIGtub3duIGVkaXRpb25zLlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGdvb2dsZS5wcm90b2J1Zi5FZGl0aW9uXG4gKi9cbnZhciBFZGl0aW9uO1xuKGZ1bmN0aW9uIChFZGl0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQSBwbGFjZWhvbGRlciBmb3IgYW4gdW5rbm93biBlZGl0aW9uIHZhbHVlLlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEVESVRJT05fVU5LTk9XTiA9IDA7XG4gICAgICovXG4gICAgRWRpdGlvbltFZGl0aW9uW1wiRURJVElPTl9VTktOT1dOXCJdID0gMF0gPSBcIkVESVRJT05fVU5LTk9XTlwiO1xuICAgIC8qKlxuICAgICAqIExlZ2FjeSBzeW50YXggXCJlZGl0aW9uc1wiLiAgVGhlc2UgcHJlLWRhdGUgZWRpdGlvbnMsIGJ1dCBiZWhhdmUgbXVjaCBsaWtlXG4gICAgICogZGlzdGluY3QgZWRpdGlvbnMuICBUaGVzZSBjYW4ndCBiZSB1c2VkIHRvIHNwZWNpZnkgdGhlIGVkaXRpb24gb2YgcHJvdG9cbiAgICAgKiBmaWxlcywgYnV0IGZlYXR1cmUgZGVmaW5pdGlvbnMgbXVzdCBzdXBwbHkgcHJvdG8yL3Byb3RvMyBkZWZhdWx0cyBmb3JcbiAgICAgKiBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBFRElUSU9OX1BST1RPMiA9IDk5ODtcbiAgICAgKi9cbiAgICBFZGl0aW9uW0VkaXRpb25bXCJFRElUSU9OX1BST1RPMlwiXSA9IDk5OF0gPSBcIkVESVRJT05fUFJPVE8yXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEVESVRJT05fUFJPVE8zID0gOTk5O1xuICAgICAqL1xuICAgIEVkaXRpb25bRWRpdGlvbltcIkVESVRJT05fUFJPVE8zXCJdID0gOTk5XSA9IFwiRURJVElPTl9QUk9UTzNcIjtcbiAgICAvKipcbiAgICAgKiBFZGl0aW9ucyB0aGF0IGhhdmUgYmVlbiByZWxlYXNlZC4gIFRoZSBzcGVjaWZpYyB2YWx1ZXMgYXJlIGFyYml0cmFyeSBhbmRcbiAgICAgKiBzaG91bGQgbm90IGJlIGRlcGVuZGVkIG9uLCBidXQgdGhleSB3aWxsIGFsd2F5cyBiZSB0aW1lLW9yZGVyZWQgZm9yIGVhc3lcbiAgICAgKiBjb21wYXJpc29uLlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEVESVRJT05fMjAyMyA9IDEwMDA7XG4gICAgICovXG4gICAgRWRpdGlvbltFZGl0aW9uW1wiRURJVElPTl8yMDIzXCJdID0gMTAwMF0gPSBcIkVESVRJT05fMjAyM1wiO1xuICAgIC8qKlxuICAgICAqIFBsYWNlaG9sZGVyIGVkaXRpb25zIGZvciB0ZXN0aW5nIGZlYXR1cmUgcmVzb2x1dGlvbi4gIFRoZXNlIHNob3VsZCBub3QgYmVcbiAgICAgKiB1c2VkIG9yIHJlbHllZCBvbiBvdXRzaWRlIG9mIHRlc3RzLlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEVESVRJT05fMV9URVNUX09OTFkgPSAxO1xuICAgICAqL1xuICAgIEVkaXRpb25bRWRpdGlvbltcIkVESVRJT05fMV9URVNUX09OTFlcIl0gPSAxXSA9IFwiRURJVElPTl8xX1RFU1RfT05MWVwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBFRElUSU9OXzJfVEVTVF9PTkxZID0gMjtcbiAgICAgKi9cbiAgICBFZGl0aW9uW0VkaXRpb25bXCJFRElUSU9OXzJfVEVTVF9PTkxZXCJdID0gMl0gPSBcIkVESVRJT05fMl9URVNUX09OTFlcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogRURJVElPTl85OTk5N19URVNUX09OTFkgPSA5OTk5NztcbiAgICAgKi9cbiAgICBFZGl0aW9uW0VkaXRpb25bXCJFRElUSU9OXzk5OTk3X1RFU1RfT05MWVwiXSA9IDk5OTk3XSA9IFwiRURJVElPTl85OTk5N19URVNUX09OTFlcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogRURJVElPTl85OTk5OF9URVNUX09OTFkgPSA5OTk5ODtcbiAgICAgKi9cbiAgICBFZGl0aW9uW0VkaXRpb25bXCJFRElUSU9OXzk5OTk4X1RFU1RfT05MWVwiXSA9IDk5OTk4XSA9IFwiRURJVElPTl85OTk5OF9URVNUX09OTFlcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogRURJVElPTl85OTk5OV9URVNUX09OTFkgPSA5OTk5OTtcbiAgICAgKi9cbiAgICBFZGl0aW9uW0VkaXRpb25bXCJFRElUSU9OXzk5OTk5X1RFU1RfT05MWVwiXSA9IDk5OTk5XSA9IFwiRURJVElPTl85OTk5OV9URVNUX09OTFlcIjtcbn0pKEVkaXRpb24gfHwgKEVkaXRpb24gPSB7fSkpO1xuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzIuZ2V0RW51bVR5cGUoRWRpdGlvbilcbnByb3RvMi51dGlsLnNldEVudW1UeXBlKEVkaXRpb24sIFwiZ29vZ2xlLnByb3RvYnVmLkVkaXRpb25cIiwgW1xuICAgIHsgbm86IDAsIG5hbWU6IFwiRURJVElPTl9VTktOT1dOXCIgfSxcbiAgICB7IG5vOiA5OTgsIG5hbWU6IFwiRURJVElPTl9QUk9UTzJcIiB9LFxuICAgIHsgbm86IDk5OSwgbmFtZTogXCJFRElUSU9OX1BST1RPM1wiIH0sXG4gICAgeyBubzogMTAwMCwgbmFtZTogXCJFRElUSU9OXzIwMjNcIiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiRURJVElPTl8xX1RFU1RfT05MWVwiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJFRElUSU9OXzJfVEVTVF9PTkxZXCIgfSxcbiAgICB7IG5vOiA5OTk5NywgbmFtZTogXCJFRElUSU9OXzk5OTk3X1RFU1RfT05MWVwiIH0sXG4gICAgeyBubzogOTk5OTgsIG5hbWU6IFwiRURJVElPTl85OTk5OF9URVNUX09OTFlcIiB9LFxuICAgIHsgbm86IDk5OTk5LCBuYW1lOiBcIkVESVRJT05fOTk5OTlfVEVTVF9PTkxZXCIgfSxcbl0pO1xuLyoqXG4gKiBUaGUgcHJvdG9jb2wgY29tcGlsZXIgY2FuIG91dHB1dCBhIEZpbGVEZXNjcmlwdG9yU2V0IGNvbnRhaW5pbmcgdGhlIC5wcm90b1xuICogZmlsZXMgaXQgcGFyc2VzLlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5GaWxlRGVzY3JpcHRvclNldFxuICovXG5jbGFzcyBGaWxlRGVzY3JpcHRvclNldCBleHRlbmRzIGVzbV9tZXNzYWdlLyogTWVzc2FnZSAqLy52IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGdvb2dsZS5wcm90b2J1Zi5GaWxlRGVzY3JpcHRvclByb3RvIGZpbGUgPSAxO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWxlID0gW107XG4gICAgICAgIHByb3RvMi51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEZpbGVEZXNjcmlwdG9yU2V0KCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWxlRGVzY3JpcHRvclNldCgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmlsZURlc2NyaXB0b3JTZXQoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBwcm90bzIudXRpbC5lcXVhbHMoRmlsZURlc2NyaXB0b3JTZXQsIGEsIGIpO1xuICAgIH1cbn1cbkZpbGVEZXNjcmlwdG9yU2V0LnJ1bnRpbWUgPSBwcm90bzI7XG5GaWxlRGVzY3JpcHRvclNldC50eXBlTmFtZSA9IFwiZ29vZ2xlLnByb3RvYnVmLkZpbGVEZXNjcmlwdG9yU2V0XCI7XG5GaWxlRGVzY3JpcHRvclNldC5maWVsZHMgPSBwcm90bzIudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiZmlsZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogRmlsZURlc2NyaXB0b3JQcm90bywgcmVwZWF0ZWQ6IHRydWUgfSxcbl0pO1xuLyoqXG4gKiBEZXNjcmliZXMgYSBjb21wbGV0ZSAucHJvdG8gZmlsZS5cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuRmlsZURlc2NyaXB0b3JQcm90b1xuICovXG5jbGFzcyBGaWxlRGVzY3JpcHRvclByb3RvIGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWVzIG9mIGZpbGVzIGltcG9ydGVkIGJ5IHRoaXMgZmlsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBzdHJpbmcgZGVwZW5kZW5jeSA9IDM7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlcGVuZGVuY3kgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGV4ZXMgb2YgdGhlIHB1YmxpYyBpbXBvcnRlZCBmaWxlcyBpbiB0aGUgZGVwZW5kZW5jeSBsaXN0IGFib3ZlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGludDMyIHB1YmxpY19kZXBlbmRlbmN5ID0gMTA7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnB1YmxpY0RlcGVuZGVuY3kgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGV4ZXMgb2YgdGhlIHdlYWsgaW1wb3J0ZWQgZmlsZXMgaW4gdGhlIGRlcGVuZGVuY3kgbGlzdC5cbiAgICAgICAgICogRm9yIEdvb2dsZS1pbnRlcm5hbCBtaWdyYXRpb24gb25seS4gRG8gbm90IHVzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBpbnQzMiB3ZWFrX2RlcGVuZGVuY3kgPSAxMTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud2Vha0RlcGVuZGVuY3kgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCB0b3AtbGV2ZWwgZGVmaW5pdGlvbnMgaW4gdGhpcyBmaWxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGdvb2dsZS5wcm90b2J1Zi5EZXNjcmlwdG9yUHJvdG8gbWVzc2FnZV90eXBlID0gNDtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWVzc2FnZVR5cGUgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgZ29vZ2xlLnByb3RvYnVmLkVudW1EZXNjcmlwdG9yUHJvdG8gZW51bV90eXBlID0gNTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW51bVR5cGUgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgZ29vZ2xlLnByb3RvYnVmLlNlcnZpY2VEZXNjcmlwdG9yUHJvdG8gc2VydmljZSA9IDY7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgZ29vZ2xlLnByb3RvYnVmLkZpZWxkRGVzY3JpcHRvclByb3RvIGV4dGVuc2lvbiA9IDc7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4dGVuc2lvbiA9IFtdO1xuICAgICAgICBwcm90bzIudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWxlRGVzY3JpcHRvclByb3RvKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWxlRGVzY3JpcHRvclByb3RvKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWxlRGVzY3JpcHRvclByb3RvKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gcHJvdG8yLnV0aWwuZXF1YWxzKEZpbGVEZXNjcmlwdG9yUHJvdG8sIGEsIGIpO1xuICAgIH1cbn1cbkZpbGVEZXNjcmlwdG9yUHJvdG8ucnVudGltZSA9IHByb3RvMjtcbkZpbGVEZXNjcmlwdG9yUHJvdG8udHlwZU5hbWUgPSBcImdvb2dsZS5wcm90b2J1Zi5GaWxlRGVzY3JpcHRvclByb3RvXCI7XG5GaWxlRGVzY3JpcHRvclByb3RvLmZpZWxkcyA9IHByb3RvMi51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJuYW1lXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwicGFja2FnZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImRlcGVuZGVuY3lcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiAxMCwgbmFtZTogXCJwdWJsaWNfZGVwZW5kZW5jeVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogMTEsIG5hbWU6IFwid2Vha19kZXBlbmRlbmN5XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDUgLyogU2NhbGFyVHlwZS5JTlQzMiAqLywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcIm1lc3NhZ2VfdHlwZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogRGVzY3JpcHRvclByb3RvLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwiZW51bV90eXBlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBFbnVtRGVzY3JpcHRvclByb3RvLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwic2VydmljZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU2VydmljZURlc2NyaXB0b3JQcm90bywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcImV4dGVuc2lvblwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogRmllbGREZXNjcmlwdG9yUHJvdG8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogOCwgbmFtZTogXCJvcHRpb25zXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBGaWxlT3B0aW9ucywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogOSwgbmFtZTogXCJzb3VyY2VfY29kZV9pbmZvXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTb3VyY2VDb2RlSW5mbywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogMTIsIG5hbWU6IFwic3ludGF4XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDE0LCBuYW1lOiBcImVkaXRpb25cIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMi5nZXRFbnVtVHlwZShFZGl0aW9uKSwgb3B0OiB0cnVlIH0sXG5dKTtcbi8qKlxuICogRGVzY3JpYmVzIGEgbWVzc2FnZSB0eXBlLlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5EZXNjcmlwdG9yUHJvdG9cbiAqL1xuY2xhc3MgRGVzY3JpcHRvclByb3RvIGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgZ29vZ2xlLnByb3RvYnVmLkZpZWxkRGVzY3JpcHRvclByb3RvIGZpZWxkID0gMjtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmllbGQgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgZ29vZ2xlLnByb3RvYnVmLkZpZWxkRGVzY3JpcHRvclByb3RvIGV4dGVuc2lvbiA9IDY7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4dGVuc2lvbiA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBnb29nbGUucHJvdG9idWYuRGVzY3JpcHRvclByb3RvIG5lc3RlZF90eXBlID0gMztcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmVzdGVkVHlwZSA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBnb29nbGUucHJvdG9idWYuRW51bURlc2NyaXB0b3JQcm90byBlbnVtX3R5cGUgPSA0O1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbnVtVHlwZSA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBnb29nbGUucHJvdG9idWYuRGVzY3JpcHRvclByb3RvLkV4dGVuc2lvblJhbmdlIGV4dGVuc2lvbl9yYW5nZSA9IDU7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4dGVuc2lvblJhbmdlID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGdvb2dsZS5wcm90b2J1Zi5PbmVvZkRlc2NyaXB0b3JQcm90byBvbmVvZl9kZWNsID0gODtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25lb2ZEZWNsID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGdvb2dsZS5wcm90b2J1Zi5EZXNjcmlwdG9yUHJvdG8uUmVzZXJ2ZWRSYW5nZSByZXNlcnZlZF9yYW5nZSA9IDk7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc2VydmVkUmFuZ2UgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2VydmVkIGZpZWxkIG5hbWVzLCB3aGljaCBtYXkgbm90IGJlIHVzZWQgYnkgZmllbGRzIGluIHRoZSBzYW1lIG1lc3NhZ2UuXG4gICAgICAgICAqIEEgZ2l2ZW4gbmFtZSBtYXkgb25seSBiZSByZXNlcnZlZCBvbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIHN0cmluZyByZXNlcnZlZF9uYW1lID0gMTA7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc2VydmVkTmFtZSA9IFtdO1xuICAgICAgICBwcm90bzIudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXNjcmlwdG9yUHJvdG8oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IERlc2NyaXB0b3JQcm90bygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVzY3JpcHRvclByb3RvKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gcHJvdG8yLnV0aWwuZXF1YWxzKERlc2NyaXB0b3JQcm90bywgYSwgYik7XG4gICAgfVxufVxuRGVzY3JpcHRvclByb3RvLnJ1bnRpbWUgPSBwcm90bzI7XG5EZXNjcmlwdG9yUHJvdG8udHlwZU5hbWUgPSBcImdvb2dsZS5wcm90b2J1Zi5EZXNjcmlwdG9yUHJvdG9cIjtcbkRlc2NyaXB0b3JQcm90by5maWVsZHMgPSBwcm90bzIudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwibmFtZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImZpZWxkXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBGaWVsZERlc2NyaXB0b3JQcm90bywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcImV4dGVuc2lvblwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogRmllbGREZXNjcmlwdG9yUHJvdG8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJuZXN0ZWRfdHlwZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogRGVzY3JpcHRvclByb3RvLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwiZW51bV90eXBlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBFbnVtRGVzY3JpcHRvclByb3RvLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwiZXh0ZW5zaW9uX3JhbmdlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBEZXNjcmlwdG9yUHJvdG9fRXh0ZW5zaW9uUmFuZ2UsIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogOCwgbmFtZTogXCJvbmVvZl9kZWNsXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBPbmVvZkRlc2NyaXB0b3JQcm90bywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcIm9wdGlvbnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IE1lc3NhZ2VPcHRpb25zLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiA5LCBuYW1lOiBcInJlc2VydmVkX3JhbmdlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBEZXNjcmlwdG9yUHJvdG9fUmVzZXJ2ZWRSYW5nZSwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiAxMCwgbmFtZTogXCJyZXNlcnZlZF9uYW1lXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIHJlcGVhdGVkOiB0cnVlIH0sXG5dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLkRlc2NyaXB0b3JQcm90by5FeHRlbnNpb25SYW5nZVxuICovXG5jbGFzcyBEZXNjcmlwdG9yUHJvdG9fRXh0ZW5zaW9uUmFuZ2UgZXh0ZW5kcyBlc21fbWVzc2FnZS8qIE1lc3NhZ2UgKi8udiB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBwcm90bzIudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXNjcmlwdG9yUHJvdG9fRXh0ZW5zaW9uUmFuZ2UoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IERlc2NyaXB0b3JQcm90b19FeHRlbnNpb25SYW5nZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVzY3JpcHRvclByb3RvX0V4dGVuc2lvblJhbmdlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gcHJvdG8yLnV0aWwuZXF1YWxzKERlc2NyaXB0b3JQcm90b19FeHRlbnNpb25SYW5nZSwgYSwgYik7XG4gICAgfVxufVxuRGVzY3JpcHRvclByb3RvX0V4dGVuc2lvblJhbmdlLnJ1bnRpbWUgPSBwcm90bzI7XG5EZXNjcmlwdG9yUHJvdG9fRXh0ZW5zaW9uUmFuZ2UudHlwZU5hbWUgPSBcImdvb2dsZS5wcm90b2J1Zi5EZXNjcmlwdG9yUHJvdG8uRXh0ZW5zaW9uUmFuZ2VcIjtcbkRlc2NyaXB0b3JQcm90b19FeHRlbnNpb25SYW5nZS5maWVsZHMgPSBwcm90bzIudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwic3RhcnRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNSAvKiBTY2FsYXJUeXBlLklOVDMyICovLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImVuZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8sIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwib3B0aW9uc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogRXh0ZW5zaW9uUmFuZ2VPcHRpb25zLCBvcHQ6IHRydWUgfSxcbl0pO1xuLyoqXG4gKiBSYW5nZSBvZiByZXNlcnZlZCB0YWcgbnVtYmVycy4gUmVzZXJ2ZWQgdGFnIG51bWJlcnMgbWF5IG5vdCBiZSB1c2VkIGJ5XG4gKiBmaWVsZHMgb3IgZXh0ZW5zaW9uIHJhbmdlcyBpbiB0aGUgc2FtZSBtZXNzYWdlLiBSZXNlcnZlZCByYW5nZXMgbWF5XG4gKiBub3Qgb3ZlcmxhcC5cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuRGVzY3JpcHRvclByb3RvLlJlc2VydmVkUmFuZ2VcbiAqL1xuY2xhc3MgRGVzY3JpcHRvclByb3RvX1Jlc2VydmVkUmFuZ2UgZXh0ZW5kcyBlc21fbWVzc2FnZS8qIE1lc3NhZ2UgKi8udiB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBwcm90bzIudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXNjcmlwdG9yUHJvdG9fUmVzZXJ2ZWRSYW5nZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVzY3JpcHRvclByb3RvX1Jlc2VydmVkUmFuZ2UoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IERlc2NyaXB0b3JQcm90b19SZXNlcnZlZFJhbmdlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gcHJvdG8yLnV0aWwuZXF1YWxzKERlc2NyaXB0b3JQcm90b19SZXNlcnZlZFJhbmdlLCBhLCBiKTtcbiAgICB9XG59XG5EZXNjcmlwdG9yUHJvdG9fUmVzZXJ2ZWRSYW5nZS5ydW50aW1lID0gcHJvdG8yO1xuRGVzY3JpcHRvclByb3RvX1Jlc2VydmVkUmFuZ2UudHlwZU5hbWUgPSBcImdvb2dsZS5wcm90b2J1Zi5EZXNjcmlwdG9yUHJvdG8uUmVzZXJ2ZWRSYW5nZVwiO1xuRGVzY3JpcHRvclByb3RvX1Jlc2VydmVkUmFuZ2UuZmllbGRzID0gcHJvdG8yLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInN0YXJ0XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDUgLyogU2NhbGFyVHlwZS5JTlQzMiAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJlbmRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNSAvKiBTY2FsYXJUeXBlLklOVDMyICovLCBvcHQ6IHRydWUgfSxcbl0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuRXh0ZW5zaW9uUmFuZ2VPcHRpb25zXG4gKi9cbmNsYXNzIEV4dGVuc2lvblJhbmdlT3B0aW9ucyBleHRlbmRzIGVzbV9tZXNzYWdlLyogTWVzc2FnZSAqLy52IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGFyc2VyIHN0b3JlcyBvcHRpb25zIGl0IGRvZXNuJ3QgcmVjb2duaXplIGhlcmUuIFNlZSBhYm92ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBnb29nbGUucHJvdG9idWYuVW5pbnRlcnByZXRlZE9wdGlvbiB1bmludGVycHJldGVkX29wdGlvbiA9IDk5OTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudW5pbnRlcnByZXRlZE9wdGlvbiA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogRm9yIGV4dGVybmFsIHVzZXJzOiBETyBOT1QgVVNFLiBXZSBhcmUgaW4gdGhlIHByb2Nlc3Mgb2Ygb3BlbiBzb3VyY2luZ1xuICAgICAgICAgKiBleHRlbnNpb24gZGVjbGFyYXRpb24gYW5kIGV4ZWN1dGluZyBpbnRlcm5hbCBjbGVhbnVwcyBiZWZvcmUgaXQgY2FuIGJlXG4gICAgICAgICAqIHVzZWQgZXh0ZXJuYWxseS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBnb29nbGUucHJvdG9idWYuRXh0ZW5zaW9uUmFuZ2VPcHRpb25zLkRlY2xhcmF0aW9uIGRlY2xhcmF0aW9uID0gMjtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb24gPSBbXTtcbiAgICAgICAgcHJvdG8yLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXh0ZW5zaW9uUmFuZ2VPcHRpb25zKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFeHRlbnNpb25SYW5nZU9wdGlvbnMoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEV4dGVuc2lvblJhbmdlT3B0aW9ucygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvMi51dGlsLmVxdWFscyhFeHRlbnNpb25SYW5nZU9wdGlvbnMsIGEsIGIpO1xuICAgIH1cbn1cbkV4dGVuc2lvblJhbmdlT3B0aW9ucy5ydW50aW1lID0gcHJvdG8yO1xuRXh0ZW5zaW9uUmFuZ2VPcHRpb25zLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuRXh0ZW5zaW9uUmFuZ2VPcHRpb25zXCI7XG5FeHRlbnNpb25SYW5nZU9wdGlvbnMuZmllbGRzID0gcHJvdG8yLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiA5OTksIG5hbWU6IFwidW5pbnRlcnByZXRlZF9vcHRpb25cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFVuaW50ZXJwcmV0ZWRPcHRpb24sIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJkZWNsYXJhdGlvblwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogRXh0ZW5zaW9uUmFuZ2VPcHRpb25zX0RlY2xhcmF0aW9uLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDUwLCBuYW1lOiBcImZlYXR1cmVzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBGZWF0dXJlU2V0LCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInZlcmlmaWNhdGlvblwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8yLmdldEVudW1UeXBlKEV4dGVuc2lvblJhbmdlT3B0aW9uc19WZXJpZmljYXRpb25TdGF0ZSksIG9wdDogdHJ1ZSwgZGVmYXVsdDogRXh0ZW5zaW9uUmFuZ2VPcHRpb25zX1ZlcmlmaWNhdGlvblN0YXRlLlVOVkVSSUZJRUQgfSxcbl0pO1xuLyoqXG4gKiBUaGUgdmVyaWZpY2F0aW9uIHN0YXRlIG9mIHRoZSBleHRlbnNpb24gcmFuZ2UuXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gZ29vZ2xlLnByb3RvYnVmLkV4dGVuc2lvblJhbmdlT3B0aW9ucy5WZXJpZmljYXRpb25TdGF0ZVxuICovXG52YXIgRXh0ZW5zaW9uUmFuZ2VPcHRpb25zX1ZlcmlmaWNhdGlvblN0YXRlO1xuKGZ1bmN0aW9uIChFeHRlbnNpb25SYW5nZU9wdGlvbnNfVmVyaWZpY2F0aW9uU3RhdGUpIHtcbiAgICAvKipcbiAgICAgKiBBbGwgdGhlIGV4dGVuc2lvbnMgb2YgdGhlIHJhbmdlIG11c3QgYmUgZGVjbGFyZWQuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogREVDTEFSQVRJT04gPSAwO1xuICAgICAqL1xuICAgIEV4dGVuc2lvblJhbmdlT3B0aW9uc19WZXJpZmljYXRpb25TdGF0ZVtFeHRlbnNpb25SYW5nZU9wdGlvbnNfVmVyaWZpY2F0aW9uU3RhdGVbXCJERUNMQVJBVElPTlwiXSA9IDBdID0gXCJERUNMQVJBVElPTlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBVTlZFUklGSUVEID0gMTtcbiAgICAgKi9cbiAgICBFeHRlbnNpb25SYW5nZU9wdGlvbnNfVmVyaWZpY2F0aW9uU3RhdGVbRXh0ZW5zaW9uUmFuZ2VPcHRpb25zX1ZlcmlmaWNhdGlvblN0YXRlW1wiVU5WRVJJRklFRFwiXSA9IDFdID0gXCJVTlZFUklGSUVEXCI7XG59KShFeHRlbnNpb25SYW5nZU9wdGlvbnNfVmVyaWZpY2F0aW9uU3RhdGUgfHwgKEV4dGVuc2lvblJhbmdlT3B0aW9uc19WZXJpZmljYXRpb25TdGF0ZSA9IHt9KSk7XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMi5nZXRFbnVtVHlwZShFeHRlbnNpb25SYW5nZU9wdGlvbnNfVmVyaWZpY2F0aW9uU3RhdGUpXG5wcm90bzIudXRpbC5zZXRFbnVtVHlwZShFeHRlbnNpb25SYW5nZU9wdGlvbnNfVmVyaWZpY2F0aW9uU3RhdGUsIFwiZ29vZ2xlLnByb3RvYnVmLkV4dGVuc2lvblJhbmdlT3B0aW9ucy5WZXJpZmljYXRpb25TdGF0ZVwiLCBbXG4gICAgeyBubzogMCwgbmFtZTogXCJERUNMQVJBVElPTlwiIH0sXG4gICAgeyBubzogMSwgbmFtZTogXCJVTlZFUklGSUVEXCIgfSxcbl0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuRXh0ZW5zaW9uUmFuZ2VPcHRpb25zLkRlY2xhcmF0aW9uXG4gKi9cbmNsYXNzIEV4dGVuc2lvblJhbmdlT3B0aW9uc19EZWNsYXJhdGlvbiBleHRlbmRzIGVzbV9tZXNzYWdlLyogTWVzc2FnZSAqLy52IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHByb3RvMi51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEV4dGVuc2lvblJhbmdlT3B0aW9uc19EZWNsYXJhdGlvbigpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXh0ZW5zaW9uUmFuZ2VPcHRpb25zX0RlY2xhcmF0aW9uKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFeHRlbnNpb25SYW5nZU9wdGlvbnNfRGVjbGFyYXRpb24oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBwcm90bzIudXRpbC5lcXVhbHMoRXh0ZW5zaW9uUmFuZ2VPcHRpb25zX0RlY2xhcmF0aW9uLCBhLCBiKTtcbiAgICB9XG59XG5FeHRlbnNpb25SYW5nZU9wdGlvbnNfRGVjbGFyYXRpb24ucnVudGltZSA9IHByb3RvMjtcbkV4dGVuc2lvblJhbmdlT3B0aW9uc19EZWNsYXJhdGlvbi50eXBlTmFtZSA9IFwiZ29vZ2xlLnByb3RvYnVmLkV4dGVuc2lvblJhbmdlT3B0aW9ucy5EZWNsYXJhdGlvblwiO1xuRXh0ZW5zaW9uUmFuZ2VPcHRpb25zX0RlY2xhcmF0aW9uLmZpZWxkcyA9IHByb3RvMi51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJudW1iZXJcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNSAvKiBTY2FsYXJUeXBlLklOVDMyICovLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImZ1bGxfbmFtZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJyZXNlcnZlZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJyZXBlYXRlZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLywgb3B0OiB0cnVlIH0sXG5dKTtcbi8qKlxuICogRGVzY3JpYmVzIGEgZmllbGQgd2l0aGluIGEgbWVzc2FnZS5cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuRmllbGREZXNjcmlwdG9yUHJvdG9cbiAqL1xuY2xhc3MgRmllbGREZXNjcmlwdG9yUHJvdG8gZXh0ZW5kcyBlc21fbWVzc2FnZS8qIE1lc3NhZ2UgKi8udiB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBwcm90bzIudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZERlc2NyaXB0b3JQcm90bygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGREZXNjcmlwdG9yUHJvdG8oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEZpZWxkRGVzY3JpcHRvclByb3RvKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gcHJvdG8yLnV0aWwuZXF1YWxzKEZpZWxkRGVzY3JpcHRvclByb3RvLCBhLCBiKTtcbiAgICB9XG59XG5GaWVsZERlc2NyaXB0b3JQcm90by5ydW50aW1lID0gcHJvdG8yO1xuRmllbGREZXNjcmlwdG9yUHJvdG8udHlwZU5hbWUgPSBcImdvb2dsZS5wcm90b2J1Zi5GaWVsZERlc2NyaXB0b3JQcm90b1wiO1xuRmllbGREZXNjcmlwdG9yUHJvdG8uZmllbGRzID0gcHJvdG8yLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcIm5hbWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJudW1iZXJcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNSAvKiBTY2FsYXJUeXBlLklOVDMyICovLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcImxhYmVsXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzIuZ2V0RW51bVR5cGUoRmllbGREZXNjcmlwdG9yUHJvdG9fTGFiZWwpLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMi5nZXRFbnVtVHlwZShGaWVsZERlc2NyaXB0b3JQcm90b19UeXBlKSwgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJ0eXBlX25hbWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJleHRlbmRlZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcImRlZmF1bHRfdmFsdWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogOSwgbmFtZTogXCJvbmVvZl9pbmRleFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8sIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDEwLCBuYW1lOiBcImpzb25fbmFtZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcIm9wdGlvbnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEZpZWxkT3B0aW9ucywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogMTcsIG5hbWU6IFwicHJvdG8zX29wdGlvbmFsXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovLCBvcHQ6IHRydWUgfSxcbl0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBnb29nbGUucHJvdG9idWYuRmllbGREZXNjcmlwdG9yUHJvdG8uVHlwZVxuICovXG52YXIgRmllbGREZXNjcmlwdG9yUHJvdG9fVHlwZTtcbihmdW5jdGlvbiAoRmllbGREZXNjcmlwdG9yUHJvdG9fVHlwZSkge1xuICAgIC8qKlxuICAgICAqIDAgaXMgcmVzZXJ2ZWQgZm9yIGVycm9ycy5cbiAgICAgKiBPcmRlciBpcyB3ZWlyZCBmb3IgaGlzdG9yaWNhbCByZWFzb25zLlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFRZUEVfRE9VQkxFID0gMTtcbiAgICAgKi9cbiAgICBGaWVsZERlc2NyaXB0b3JQcm90b19UeXBlW0ZpZWxkRGVzY3JpcHRvclByb3RvX1R5cGVbXCJET1VCTEVcIl0gPSAxXSA9IFwiRE9VQkxFXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFRZUEVfRkxPQVQgPSAyO1xuICAgICAqL1xuICAgIEZpZWxkRGVzY3JpcHRvclByb3RvX1R5cGVbRmllbGREZXNjcmlwdG9yUHJvdG9fVHlwZVtcIkZMT0FUXCJdID0gMl0gPSBcIkZMT0FUXCI7XG4gICAgLyoqXG4gICAgICogTm90IFppZ1phZyBlbmNvZGVkLiAgTmVnYXRpdmUgbnVtYmVycyB0YWtlIDEwIGJ5dGVzLiAgVXNlIFRZUEVfU0lOVDY0IGlmXG4gICAgICogbmVnYXRpdmUgdmFsdWVzIGFyZSBsaWtlbHkuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVFlQRV9JTlQ2NCA9IDM7XG4gICAgICovXG4gICAgRmllbGREZXNjcmlwdG9yUHJvdG9fVHlwZVtGaWVsZERlc2NyaXB0b3JQcm90b19UeXBlW1wiSU5UNjRcIl0gPSAzXSA9IFwiSU5UNjRcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVFlQRV9VSU5UNjQgPSA0O1xuICAgICAqL1xuICAgIEZpZWxkRGVzY3JpcHRvclByb3RvX1R5cGVbRmllbGREZXNjcmlwdG9yUHJvdG9fVHlwZVtcIlVJTlQ2NFwiXSA9IDRdID0gXCJVSU5UNjRcIjtcbiAgICAvKipcbiAgICAgKiBOb3QgWmlnWmFnIGVuY29kZWQuICBOZWdhdGl2ZSBudW1iZXJzIHRha2UgMTAgYnl0ZXMuICBVc2UgVFlQRV9TSU5UMzIgaWZcbiAgICAgKiBuZWdhdGl2ZSB2YWx1ZXMgYXJlIGxpa2VseS5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBUWVBFX0lOVDMyID0gNTtcbiAgICAgKi9cbiAgICBGaWVsZERlc2NyaXB0b3JQcm90b19UeXBlW0ZpZWxkRGVzY3JpcHRvclByb3RvX1R5cGVbXCJJTlQzMlwiXSA9IDVdID0gXCJJTlQzMlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBUWVBFX0ZJWEVENjQgPSA2O1xuICAgICAqL1xuICAgIEZpZWxkRGVzY3JpcHRvclByb3RvX1R5cGVbRmllbGREZXNjcmlwdG9yUHJvdG9fVHlwZVtcIkZJWEVENjRcIl0gPSA2XSA9IFwiRklYRUQ2NFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBUWVBFX0ZJWEVEMzIgPSA3O1xuICAgICAqL1xuICAgIEZpZWxkRGVzY3JpcHRvclByb3RvX1R5cGVbRmllbGREZXNjcmlwdG9yUHJvdG9fVHlwZVtcIkZJWEVEMzJcIl0gPSA3XSA9IFwiRklYRUQzMlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBUWVBFX0JPT0wgPSA4O1xuICAgICAqL1xuICAgIEZpZWxkRGVzY3JpcHRvclByb3RvX1R5cGVbRmllbGREZXNjcmlwdG9yUHJvdG9fVHlwZVtcIkJPT0xcIl0gPSA4XSA9IFwiQk9PTFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBUWVBFX1NUUklORyA9IDk7XG4gICAgICovXG4gICAgRmllbGREZXNjcmlwdG9yUHJvdG9fVHlwZVtGaWVsZERlc2NyaXB0b3JQcm90b19UeXBlW1wiU1RSSU5HXCJdID0gOV0gPSBcIlNUUklOR1wiO1xuICAgIC8qKlxuICAgICAqIFRhZy1kZWxpbWl0ZWQgYWdncmVnYXRlLlxuICAgICAqIEdyb3VwIHR5cGUgaXMgZGVwcmVjYXRlZCBhbmQgbm90IHN1cHBvcnRlZCBhZnRlciBnb29nbGUucHJvdG9idWYuIEhvd2V2ZXIsIFByb3RvM1xuICAgICAqIGltcGxlbWVudGF0aW9ucyBzaG91bGQgc3RpbGwgYmUgYWJsZSB0byBwYXJzZSB0aGUgZ3JvdXAgd2lyZSBmb3JtYXQgYW5kXG4gICAgICogdHJlYXQgZ3JvdXAgZmllbGRzIGFzIHVua25vd24gZmllbGRzLiAgSW4gRWRpdGlvbnMsIHRoZSBncm91cCB3aXJlIGZvcm1hdFxuICAgICAqIGNhbiBiZSBlbmFibGVkIHZpYSB0aGUgYG1lc3NhZ2VfZW5jb2RpbmdgIGZlYXR1cmUuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVFlQRV9HUk9VUCA9IDEwO1xuICAgICAqL1xuICAgIEZpZWxkRGVzY3JpcHRvclByb3RvX1R5cGVbRmllbGREZXNjcmlwdG9yUHJvdG9fVHlwZVtcIkdST1VQXCJdID0gMTBdID0gXCJHUk9VUFwiO1xuICAgIC8qKlxuICAgICAqIExlbmd0aC1kZWxpbWl0ZWQgYWdncmVnYXRlLlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFRZUEVfTUVTU0FHRSA9IDExO1xuICAgICAqL1xuICAgIEZpZWxkRGVzY3JpcHRvclByb3RvX1R5cGVbRmllbGREZXNjcmlwdG9yUHJvdG9fVHlwZVtcIk1FU1NBR0VcIl0gPSAxMV0gPSBcIk1FU1NBR0VcIjtcbiAgICAvKipcbiAgICAgKiBOZXcgaW4gdmVyc2lvbiAyLlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFRZUEVfQllURVMgPSAxMjtcbiAgICAgKi9cbiAgICBGaWVsZERlc2NyaXB0b3JQcm90b19UeXBlW0ZpZWxkRGVzY3JpcHRvclByb3RvX1R5cGVbXCJCWVRFU1wiXSA9IDEyXSA9IFwiQllURVNcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVFlQRV9VSU5UMzIgPSAxMztcbiAgICAgKi9cbiAgICBGaWVsZERlc2NyaXB0b3JQcm90b19UeXBlW0ZpZWxkRGVzY3JpcHRvclByb3RvX1R5cGVbXCJVSU5UMzJcIl0gPSAxM10gPSBcIlVJTlQzMlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBUWVBFX0VOVU0gPSAxNDtcbiAgICAgKi9cbiAgICBGaWVsZERlc2NyaXB0b3JQcm90b19UeXBlW0ZpZWxkRGVzY3JpcHRvclByb3RvX1R5cGVbXCJFTlVNXCJdID0gMTRdID0gXCJFTlVNXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFRZUEVfU0ZJWEVEMzIgPSAxNTtcbiAgICAgKi9cbiAgICBGaWVsZERlc2NyaXB0b3JQcm90b19UeXBlW0ZpZWxkRGVzY3JpcHRvclByb3RvX1R5cGVbXCJTRklYRUQzMlwiXSA9IDE1XSA9IFwiU0ZJWEVEMzJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVFlQRV9TRklYRUQ2NCA9IDE2O1xuICAgICAqL1xuICAgIEZpZWxkRGVzY3JpcHRvclByb3RvX1R5cGVbRmllbGREZXNjcmlwdG9yUHJvdG9fVHlwZVtcIlNGSVhFRDY0XCJdID0gMTZdID0gXCJTRklYRUQ2NFwiO1xuICAgIC8qKlxuICAgICAqIFVzZXMgWmlnWmFnIGVuY29kaW5nLlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFRZUEVfU0lOVDMyID0gMTc7XG4gICAgICovXG4gICAgRmllbGREZXNjcmlwdG9yUHJvdG9fVHlwZVtGaWVsZERlc2NyaXB0b3JQcm90b19UeXBlW1wiU0lOVDMyXCJdID0gMTddID0gXCJTSU5UMzJcIjtcbiAgICAvKipcbiAgICAgKiBVc2VzIFppZ1phZyBlbmNvZGluZy5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBUWVBFX1NJTlQ2NCA9IDE4O1xuICAgICAqL1xuICAgIEZpZWxkRGVzY3JpcHRvclByb3RvX1R5cGVbRmllbGREZXNjcmlwdG9yUHJvdG9fVHlwZVtcIlNJTlQ2NFwiXSA9IDE4XSA9IFwiU0lOVDY0XCI7XG59KShGaWVsZERlc2NyaXB0b3JQcm90b19UeXBlIHx8IChGaWVsZERlc2NyaXB0b3JQcm90b19UeXBlID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8yLmdldEVudW1UeXBlKEZpZWxkRGVzY3JpcHRvclByb3RvX1R5cGUpXG5wcm90bzIudXRpbC5zZXRFbnVtVHlwZShGaWVsZERlc2NyaXB0b3JQcm90b19UeXBlLCBcImdvb2dsZS5wcm90b2J1Zi5GaWVsZERlc2NyaXB0b3JQcm90by5UeXBlXCIsIFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcIlRZUEVfRE9VQkxFXCIgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIlRZUEVfRkxPQVRcIiB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiVFlQRV9JTlQ2NFwiIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJUWVBFX1VJTlQ2NFwiIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJUWVBFX0lOVDMyXCIgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcIlRZUEVfRklYRUQ2NFwiIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJUWVBFX0ZJWEVEMzJcIiB9LFxuICAgIHsgbm86IDgsIG5hbWU6IFwiVFlQRV9CT09MXCIgfSxcbiAgICB7IG5vOiA5LCBuYW1lOiBcIlRZUEVfU1RSSU5HXCIgfSxcbiAgICB7IG5vOiAxMCwgbmFtZTogXCJUWVBFX0dST1VQXCIgfSxcbiAgICB7IG5vOiAxMSwgbmFtZTogXCJUWVBFX01FU1NBR0VcIiB9LFxuICAgIHsgbm86IDEyLCBuYW1lOiBcIlRZUEVfQllURVNcIiB9LFxuICAgIHsgbm86IDEzLCBuYW1lOiBcIlRZUEVfVUlOVDMyXCIgfSxcbiAgICB7IG5vOiAxNCwgbmFtZTogXCJUWVBFX0VOVU1cIiB9LFxuICAgIHsgbm86IDE1LCBuYW1lOiBcIlRZUEVfU0ZJWEVEMzJcIiB9LFxuICAgIHsgbm86IDE2LCBuYW1lOiBcIlRZUEVfU0ZJWEVENjRcIiB9LFxuICAgIHsgbm86IDE3LCBuYW1lOiBcIlRZUEVfU0lOVDMyXCIgfSxcbiAgICB7IG5vOiAxOCwgbmFtZTogXCJUWVBFX1NJTlQ2NFwiIH0sXG5dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gZ29vZ2xlLnByb3RvYnVmLkZpZWxkRGVzY3JpcHRvclByb3RvLkxhYmVsXG4gKi9cbnZhciBGaWVsZERlc2NyaXB0b3JQcm90b19MYWJlbDtcbihmdW5jdGlvbiAoRmllbGREZXNjcmlwdG9yUHJvdG9fTGFiZWwpIHtcbiAgICAvKipcbiAgICAgKiAwIGlzIHJlc2VydmVkIGZvciBlcnJvcnNcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBMQUJFTF9PUFRJT05BTCA9IDE7XG4gICAgICovXG4gICAgRmllbGREZXNjcmlwdG9yUHJvdG9fTGFiZWxbRmllbGREZXNjcmlwdG9yUHJvdG9fTGFiZWxbXCJPUFRJT05BTFwiXSA9IDFdID0gXCJPUFRJT05BTFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBMQUJFTF9SRVBFQVRFRCA9IDM7XG4gICAgICovXG4gICAgRmllbGREZXNjcmlwdG9yUHJvdG9fTGFiZWxbRmllbGREZXNjcmlwdG9yUHJvdG9fTGFiZWxbXCJSRVBFQVRFRFwiXSA9IDNdID0gXCJSRVBFQVRFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSByZXF1aXJlZCBsYWJlbCBpcyBvbmx5IGFsbG93ZWQgaW4gZ29vZ2xlLnByb3RvYnVmLiAgSW4gcHJvdG8zIGFuZCBFZGl0aW9uc1xuICAgICAqIGl0J3MgZXhwbGljaXRseSBwcm9oaWJpdGVkLiAgSW4gRWRpdGlvbnMsIHRoZSBgZmllbGRfcHJlc2VuY2VgIGZlYXR1cmVcbiAgICAgKiBjYW4gYmUgdXNlZCB0byBnZXQgdGhpcyBiZWhhdmlvci5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBMQUJFTF9SRVFVSVJFRCA9IDI7XG4gICAgICovXG4gICAgRmllbGREZXNjcmlwdG9yUHJvdG9fTGFiZWxbRmllbGREZXNjcmlwdG9yUHJvdG9fTGFiZWxbXCJSRVFVSVJFRFwiXSA9IDJdID0gXCJSRVFVSVJFRFwiO1xufSkoRmllbGREZXNjcmlwdG9yUHJvdG9fTGFiZWwgfHwgKEZpZWxkRGVzY3JpcHRvclByb3RvX0xhYmVsID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8yLmdldEVudW1UeXBlKEZpZWxkRGVzY3JpcHRvclByb3RvX0xhYmVsKVxucHJvdG8yLnV0aWwuc2V0RW51bVR5cGUoRmllbGREZXNjcmlwdG9yUHJvdG9fTGFiZWwsIFwiZ29vZ2xlLnByb3RvYnVmLkZpZWxkRGVzY3JpcHRvclByb3RvLkxhYmVsXCIsIFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcIkxBQkVMX09QVElPTkFMXCIgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcIkxBQkVMX1JFUEVBVEVEXCIgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIkxBQkVMX1JFUVVJUkVEXCIgfSxcbl0pO1xuLyoqXG4gKiBEZXNjcmliZXMgYSBvbmVvZi5cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuT25lb2ZEZXNjcmlwdG9yUHJvdG9cbiAqL1xuY2xhc3MgT25lb2ZEZXNjcmlwdG9yUHJvdG8gZXh0ZW5kcyBlc21fbWVzc2FnZS8qIE1lc3NhZ2UgKi8udiB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBwcm90bzIudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPbmVvZkRlc2NyaXB0b3JQcm90bygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgT25lb2ZEZXNjcmlwdG9yUHJvdG8oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IE9uZW9mRGVzY3JpcHRvclByb3RvKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gcHJvdG8yLnV0aWwuZXF1YWxzKE9uZW9mRGVzY3JpcHRvclByb3RvLCBhLCBiKTtcbiAgICB9XG59XG5PbmVvZkRlc2NyaXB0b3JQcm90by5ydW50aW1lID0gcHJvdG8yO1xuT25lb2ZEZXNjcmlwdG9yUHJvdG8udHlwZU5hbWUgPSBcImdvb2dsZS5wcm90b2J1Zi5PbmVvZkRlc2NyaXB0b3JQcm90b1wiO1xuT25lb2ZEZXNjcmlwdG9yUHJvdG8uZmllbGRzID0gcHJvdG8yLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcIm5hbWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJvcHRpb25zXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBPbmVvZk9wdGlvbnMsIG9wdDogdHJ1ZSB9LFxuXSk7XG4vKipcbiAqIERlc2NyaWJlcyBhbiBlbnVtIHR5cGUuXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLkVudW1EZXNjcmlwdG9yUHJvdG9cbiAqL1xuY2xhc3MgRW51bURlc2NyaXB0b3JQcm90byBleHRlbmRzIGVzbV9tZXNzYWdlLyogTWVzc2FnZSAqLy52IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGdvb2dsZS5wcm90b2J1Zi5FbnVtVmFsdWVEZXNjcmlwdG9yUHJvdG8gdmFsdWUgPSAyO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZSA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmFuZ2Ugb2YgcmVzZXJ2ZWQgbnVtZXJpYyB2YWx1ZXMuIFJlc2VydmVkIG51bWVyaWMgdmFsdWVzIG1heSBub3QgYmUgdXNlZFxuICAgICAgICAgKiBieSBlbnVtIHZhbHVlcyBpbiB0aGUgc2FtZSBlbnVtIGRlY2xhcmF0aW9uLiBSZXNlcnZlZCByYW5nZXMgbWF5IG5vdFxuICAgICAgICAgKiBvdmVybGFwLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGdvb2dsZS5wcm90b2J1Zi5FbnVtRGVzY3JpcHRvclByb3RvLkVudW1SZXNlcnZlZFJhbmdlIHJlc2VydmVkX3JhbmdlID0gNDtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzZXJ2ZWRSYW5nZSA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXJ2ZWQgZW51bSB2YWx1ZSBuYW1lcywgd2hpY2ggbWF5IG5vdCBiZSByZXVzZWQuIEEgZ2l2ZW4gbmFtZSBtYXkgb25seVxuICAgICAgICAgKiBiZSByZXNlcnZlZCBvbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIHN0cmluZyByZXNlcnZlZF9uYW1lID0gNTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzZXJ2ZWROYW1lID0gW107XG4gICAgICAgIHByb3RvMi51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEVudW1EZXNjcmlwdG9yUHJvdG8oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEVudW1EZXNjcmlwdG9yUHJvdG8oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEVudW1EZXNjcmlwdG9yUHJvdG8oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBwcm90bzIudXRpbC5lcXVhbHMoRW51bURlc2NyaXB0b3JQcm90bywgYSwgYik7XG4gICAgfVxufVxuRW51bURlc2NyaXB0b3JQcm90by5ydW50aW1lID0gcHJvdG8yO1xuRW51bURlc2NyaXB0b3JQcm90by50eXBlTmFtZSA9IFwiZ29vZ2xlLnByb3RvYnVmLkVudW1EZXNjcmlwdG9yUHJvdG9cIjtcbkVudW1EZXNjcmlwdG9yUHJvdG8uZmllbGRzID0gcHJvdG8yLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcIm5hbWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJ2YWx1ZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogRW51bVZhbHVlRGVzY3JpcHRvclByb3RvLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwib3B0aW9uc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogRW51bU9wdGlvbnMsIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwicmVzZXJ2ZWRfcmFuZ2VcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEVudW1EZXNjcmlwdG9yUHJvdG9fRW51bVJlc2VydmVkUmFuZ2UsIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJyZXNlcnZlZF9uYW1lXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIHJlcGVhdGVkOiB0cnVlIH0sXG5dKTtcbi8qKlxuICogUmFuZ2Ugb2YgcmVzZXJ2ZWQgbnVtZXJpYyB2YWx1ZXMuIFJlc2VydmVkIHZhbHVlcyBtYXkgbm90IGJlIHVzZWQgYnlcbiAqIGVudHJpZXMgaW4gdGhlIHNhbWUgZW51bS4gUmVzZXJ2ZWQgcmFuZ2VzIG1heSBub3Qgb3ZlcmxhcC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBpcyBkaXN0aW5jdCBmcm9tIERlc2NyaXB0b3JQcm90by5SZXNlcnZlZFJhbmdlIGluIHRoYXQgaXRcbiAqIGlzIGluY2x1c2l2ZSBzdWNoIHRoYXQgaXQgY2FuIGFwcHJvcHJpYXRlbHkgcmVwcmVzZW50IHRoZSBlbnRpcmUgaW50MzJcbiAqIGRvbWFpbi5cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuRW51bURlc2NyaXB0b3JQcm90by5FbnVtUmVzZXJ2ZWRSYW5nZVxuICovXG5jbGFzcyBFbnVtRGVzY3JpcHRvclByb3RvX0VudW1SZXNlcnZlZFJhbmdlIGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgcHJvdG8yLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW51bURlc2NyaXB0b3JQcm90b19FbnVtUmVzZXJ2ZWRSYW5nZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW51bURlc2NyaXB0b3JQcm90b19FbnVtUmVzZXJ2ZWRSYW5nZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW51bURlc2NyaXB0b3JQcm90b19FbnVtUmVzZXJ2ZWRSYW5nZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvMi51dGlsLmVxdWFscyhFbnVtRGVzY3JpcHRvclByb3RvX0VudW1SZXNlcnZlZFJhbmdlLCBhLCBiKTtcbiAgICB9XG59XG5FbnVtRGVzY3JpcHRvclByb3RvX0VudW1SZXNlcnZlZFJhbmdlLnJ1bnRpbWUgPSBwcm90bzI7XG5FbnVtRGVzY3JpcHRvclByb3RvX0VudW1SZXNlcnZlZFJhbmdlLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuRW51bURlc2NyaXB0b3JQcm90by5FbnVtUmVzZXJ2ZWRSYW5nZVwiO1xuRW51bURlc2NyaXB0b3JQcm90b19FbnVtUmVzZXJ2ZWRSYW5nZS5maWVsZHMgPSBwcm90bzIudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwic3RhcnRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNSAvKiBTY2FsYXJUeXBlLklOVDMyICovLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImVuZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8sIG9wdDogdHJ1ZSB9LFxuXSk7XG4vKipcbiAqIERlc2NyaWJlcyBhIHZhbHVlIHdpdGhpbiBhbiBlbnVtLlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5FbnVtVmFsdWVEZXNjcmlwdG9yUHJvdG9cbiAqL1xuY2xhc3MgRW51bVZhbHVlRGVzY3JpcHRvclByb3RvIGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgcHJvdG8yLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW51bVZhbHVlRGVzY3JpcHRvclByb3RvKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbnVtVmFsdWVEZXNjcmlwdG9yUHJvdG8oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEVudW1WYWx1ZURlc2NyaXB0b3JQcm90bygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvMi51dGlsLmVxdWFscyhFbnVtVmFsdWVEZXNjcmlwdG9yUHJvdG8sIGEsIGIpO1xuICAgIH1cbn1cbkVudW1WYWx1ZURlc2NyaXB0b3JQcm90by5ydW50aW1lID0gcHJvdG8yO1xuRW51bVZhbHVlRGVzY3JpcHRvclByb3RvLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuRW51bVZhbHVlRGVzY3JpcHRvclByb3RvXCI7XG5FbnVtVmFsdWVEZXNjcmlwdG9yUHJvdG8uZmllbGRzID0gcHJvdG8yLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcIm5hbWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJudW1iZXJcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNSAvKiBTY2FsYXJUeXBlLklOVDMyICovLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcIm9wdGlvbnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEVudW1WYWx1ZU9wdGlvbnMsIG9wdDogdHJ1ZSB9LFxuXSk7XG4vKipcbiAqIERlc2NyaWJlcyBhIHNlcnZpY2UuXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLlNlcnZpY2VEZXNjcmlwdG9yUHJvdG9cbiAqL1xuY2xhc3MgU2VydmljZURlc2NyaXB0b3JQcm90byBleHRlbmRzIGVzbV9tZXNzYWdlLyogTWVzc2FnZSAqLy52IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGdvb2dsZS5wcm90b2J1Zi5NZXRob2REZXNjcmlwdG9yUHJvdG8gbWV0aG9kID0gMjtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWV0aG9kID0gW107XG4gICAgICAgIHByb3RvMi51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFNlcnZpY2VEZXNjcmlwdG9yUHJvdG8oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFNlcnZpY2VEZXNjcmlwdG9yUHJvdG8oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFNlcnZpY2VEZXNjcmlwdG9yUHJvdG8oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBwcm90bzIudXRpbC5lcXVhbHMoU2VydmljZURlc2NyaXB0b3JQcm90bywgYSwgYik7XG4gICAgfVxufVxuU2VydmljZURlc2NyaXB0b3JQcm90by5ydW50aW1lID0gcHJvdG8yO1xuU2VydmljZURlc2NyaXB0b3JQcm90by50eXBlTmFtZSA9IFwiZ29vZ2xlLnByb3RvYnVmLlNlcnZpY2VEZXNjcmlwdG9yUHJvdG9cIjtcblNlcnZpY2VEZXNjcmlwdG9yUHJvdG8uZmllbGRzID0gcHJvdG8yLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcIm5hbWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJtZXRob2RcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IE1ldGhvZERlc2NyaXB0b3JQcm90bywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcIm9wdGlvbnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNlcnZpY2VPcHRpb25zLCBvcHQ6IHRydWUgfSxcbl0pO1xuLyoqXG4gKiBEZXNjcmliZXMgYSBtZXRob2Qgb2YgYSBzZXJ2aWNlLlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5NZXRob2REZXNjcmlwdG9yUHJvdG9cbiAqL1xuY2xhc3MgTWV0aG9kRGVzY3JpcHRvclByb3RvIGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgcHJvdG8yLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWV0aG9kRGVzY3JpcHRvclByb3RvKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNZXRob2REZXNjcmlwdG9yUHJvdG8oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IE1ldGhvZERlc2NyaXB0b3JQcm90bygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvMi51dGlsLmVxdWFscyhNZXRob2REZXNjcmlwdG9yUHJvdG8sIGEsIGIpO1xuICAgIH1cbn1cbk1ldGhvZERlc2NyaXB0b3JQcm90by5ydW50aW1lID0gcHJvdG8yO1xuTWV0aG9kRGVzY3JpcHRvclByb3RvLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuTWV0aG9kRGVzY3JpcHRvclByb3RvXCI7XG5NZXRob2REZXNjcmlwdG9yUHJvdG8uZmllbGRzID0gcHJvdG8yLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcIm5hbWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJpbnB1dF90eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwib3V0cHV0X3R5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJvcHRpb25zXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBNZXRob2RPcHRpb25zLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcImNsaWVudF9zdHJlYW1pbmdcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8sIG9wdDogdHJ1ZSwgZGVmYXVsdDogZmFsc2UgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcInNlcnZlcl9zdHJlYW1pbmdcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8sIG9wdDogdHJ1ZSwgZGVmYXVsdDogZmFsc2UgfSxcbl0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuRmlsZU9wdGlvbnNcbiAqL1xuY2xhc3MgRmlsZU9wdGlvbnMgZXh0ZW5kcyBlc21fbWVzc2FnZS8qIE1lc3NhZ2UgKi8udiB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhcnNlciBzdG9yZXMgb3B0aW9ucyBpdCBkb2Vzbid0IHJlY29nbml6ZSBoZXJlLlxuICAgICAgICAgKiBTZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoZSBcIk9wdGlvbnNcIiBzZWN0aW9uIGFib3ZlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGdvb2dsZS5wcm90b2J1Zi5VbmludGVycHJldGVkT3B0aW9uIHVuaW50ZXJwcmV0ZWRfb3B0aW9uID0gOTk5O1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51bmludGVycHJldGVkT3B0aW9uID0gW107XG4gICAgICAgIHByb3RvMi51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEZpbGVPcHRpb25zKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWxlT3B0aW9ucygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmlsZU9wdGlvbnMoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBwcm90bzIudXRpbC5lcXVhbHMoRmlsZU9wdGlvbnMsIGEsIGIpO1xuICAgIH1cbn1cbkZpbGVPcHRpb25zLnJ1bnRpbWUgPSBwcm90bzI7XG5GaWxlT3B0aW9ucy50eXBlTmFtZSA9IFwiZ29vZ2xlLnByb3RvYnVmLkZpbGVPcHRpb25zXCI7XG5GaWxlT3B0aW9ucy5maWVsZHMgPSBwcm90bzIudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiamF2YV9wYWNrYWdlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDgsIG5hbWU6IFwiamF2YV9vdXRlcl9jbGFzc25hbWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogMTAsIG5hbWU6IFwiamF2YV9tdWx0aXBsZV9maWxlc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLywgb3B0OiB0cnVlLCBkZWZhdWx0OiBmYWxzZSB9LFxuICAgIHsgbm86IDIwLCBuYW1lOiBcImphdmFfZ2VuZXJhdGVfZXF1YWxzX2FuZF9oYXNoXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiAyNywgbmFtZTogXCJqYXZhX3N0cmluZ19jaGVja191dGY4XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovLCBvcHQ6IHRydWUsIGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgeyBubzogOSwgbmFtZTogXCJvcHRpbWl6ZV9mb3JcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMi5nZXRFbnVtVHlwZShGaWxlT3B0aW9uc19PcHRpbWl6ZU1vZGUpLCBvcHQ6IHRydWUsIGRlZmF1bHQ6IEZpbGVPcHRpb25zX09wdGltaXplTW9kZS5TUEVFRCB9LFxuICAgIHsgbm86IDExLCBuYW1lOiBcImdvX3BhY2thZ2VcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogMTYsIG5hbWU6IFwiY2NfZ2VuZXJpY19zZXJ2aWNlc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLywgb3B0OiB0cnVlLCBkZWZhdWx0OiBmYWxzZSB9LFxuICAgIHsgbm86IDE3LCBuYW1lOiBcImphdmFfZ2VuZXJpY19zZXJ2aWNlc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLywgb3B0OiB0cnVlLCBkZWZhdWx0OiBmYWxzZSB9LFxuICAgIHsgbm86IDE4LCBuYW1lOiBcInB5X2dlbmVyaWNfc2VydmljZXNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8sIG9wdDogdHJ1ZSwgZGVmYXVsdDogZmFsc2UgfSxcbiAgICB7IG5vOiA0MiwgbmFtZTogXCJwaHBfZ2VuZXJpY19zZXJ2aWNlc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLywgb3B0OiB0cnVlLCBkZWZhdWx0OiBmYWxzZSB9LFxuICAgIHsgbm86IDIzLCBuYW1lOiBcImRlcHJlY2F0ZWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8sIG9wdDogdHJ1ZSwgZGVmYXVsdDogZmFsc2UgfSxcbiAgICB7IG5vOiAzMSwgbmFtZTogXCJjY19lbmFibGVfYXJlbmFzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovLCBvcHQ6IHRydWUsIGRlZmF1bHQ6IHRydWUgfSxcbiAgICB7IG5vOiAzNiwgbmFtZTogXCJvYmpjX2NsYXNzX3ByZWZpeFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiAzNywgbmFtZTogXCJjc2hhcnBfbmFtZXNwYWNlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDM5LCBuYW1lOiBcInN3aWZ0X3ByZWZpeFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiA0MCwgbmFtZTogXCJwaHBfY2xhc3NfcHJlZml4XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDQxLCBuYW1lOiBcInBocF9uYW1lc3BhY2VcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogNDQsIG5hbWU6IFwicGhwX21ldGFkYXRhX25hbWVzcGFjZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiA0NSwgbmFtZTogXCJydWJ5X3BhY2thZ2VcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogNTAsIG5hbWU6IFwiZmVhdHVyZXNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEZlYXR1cmVTZXQsIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDk5OSwgbmFtZTogXCJ1bmludGVycHJldGVkX29wdGlvblwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVW5pbnRlcnByZXRlZE9wdGlvbiwgcmVwZWF0ZWQ6IHRydWUgfSxcbl0pO1xuLyoqXG4gKiBHZW5lcmF0ZWQgY2xhc3NlcyBjYW4gYmUgb3B0aW1pemVkIGZvciBzcGVlZCBvciBjb2RlIHNpemUuXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gZ29vZ2xlLnByb3RvYnVmLkZpbGVPcHRpb25zLk9wdGltaXplTW9kZVxuICovXG52YXIgRmlsZU9wdGlvbnNfT3B0aW1pemVNb2RlO1xuKGZ1bmN0aW9uIChGaWxlT3B0aW9uc19PcHRpbWl6ZU1vZGUpIHtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBjb21wbGV0ZSBjb2RlIGZvciBwYXJzaW5nLCBzZXJpYWxpemF0aW9uLFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFNQRUVEID0gMTtcbiAgICAgKi9cbiAgICBGaWxlT3B0aW9uc19PcHRpbWl6ZU1vZGVbRmlsZU9wdGlvbnNfT3B0aW1pemVNb2RlW1wiU1BFRURcIl0gPSAxXSA9IFwiU1BFRURcIjtcbiAgICAvKipcbiAgICAgKiBldGMuXG4gICAgICpcbiAgICAgKiBVc2UgUmVmbGVjdGlvbk9wcyB0byBpbXBsZW1lbnQgdGhlc2UgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBDT0RFX1NJWkUgPSAyO1xuICAgICAqL1xuICAgIEZpbGVPcHRpb25zX09wdGltaXplTW9kZVtGaWxlT3B0aW9uc19PcHRpbWl6ZU1vZGVbXCJDT0RFX1NJWkVcIl0gPSAyXSA9IFwiQ09ERV9TSVpFXCI7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgY29kZSB1c2luZyBNZXNzYWdlTGl0ZSBhbmQgdGhlIGxpdGUgcnVudGltZS5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBMSVRFX1JVTlRJTUUgPSAzO1xuICAgICAqL1xuICAgIEZpbGVPcHRpb25zX09wdGltaXplTW9kZVtGaWxlT3B0aW9uc19PcHRpbWl6ZU1vZGVbXCJMSVRFX1JVTlRJTUVcIl0gPSAzXSA9IFwiTElURV9SVU5USU1FXCI7XG59KShGaWxlT3B0aW9uc19PcHRpbWl6ZU1vZGUgfHwgKEZpbGVPcHRpb25zX09wdGltaXplTW9kZSA9IHt9KSk7XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMi5nZXRFbnVtVHlwZShGaWxlT3B0aW9uc19PcHRpbWl6ZU1vZGUpXG5wcm90bzIudXRpbC5zZXRFbnVtVHlwZShGaWxlT3B0aW9uc19PcHRpbWl6ZU1vZGUsIFwiZ29vZ2xlLnByb3RvYnVmLkZpbGVPcHRpb25zLk9wdGltaXplTW9kZVwiLCBbXG4gICAgeyBubzogMSwgbmFtZTogXCJTUEVFRFwiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJDT0RFX1NJWkVcIiB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiTElURV9SVU5USU1FXCIgfSxcbl0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuTWVzc2FnZU9wdGlvbnNcbiAqL1xuY2xhc3MgTWVzc2FnZU9wdGlvbnMgZXh0ZW5kcyBlc21fbWVzc2FnZS8qIE1lc3NhZ2UgKi8udiB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhcnNlciBzdG9yZXMgb3B0aW9ucyBpdCBkb2Vzbid0IHJlY29nbml6ZSBoZXJlLiBTZWUgYWJvdmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgZ29vZ2xlLnByb3RvYnVmLlVuaW50ZXJwcmV0ZWRPcHRpb24gdW5pbnRlcnByZXRlZF9vcHRpb24gPSA5OTk7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVuaW50ZXJwcmV0ZWRPcHRpb24gPSBbXTtcbiAgICAgICAgcHJvdG8yLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWVzc2FnZU9wdGlvbnMoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IE1lc3NhZ2VPcHRpb25zKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNZXNzYWdlT3B0aW9ucygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvMi51dGlsLmVxdWFscyhNZXNzYWdlT3B0aW9ucywgYSwgYik7XG4gICAgfVxufVxuTWVzc2FnZU9wdGlvbnMucnVudGltZSA9IHByb3RvMjtcbk1lc3NhZ2VPcHRpb25zLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuTWVzc2FnZU9wdGlvbnNcIjtcbk1lc3NhZ2VPcHRpb25zLmZpZWxkcyA9IHByb3RvMi51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJtZXNzYWdlX3NldF93aXJlX2Zvcm1hdFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLywgb3B0OiB0cnVlLCBkZWZhdWx0OiBmYWxzZSB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwibm9fc3RhbmRhcmRfZGVzY3JpcHRvcl9hY2Nlc3NvclwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLywgb3B0OiB0cnVlLCBkZWZhdWx0OiBmYWxzZSB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiZGVwcmVjYXRlZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLywgb3B0OiB0cnVlLCBkZWZhdWx0OiBmYWxzZSB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwibWFwX2VudHJ5XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiAxMSwgbmFtZTogXCJkZXByZWNhdGVkX2xlZ2FjeV9qc29uX2ZpZWxkX2NvbmZsaWN0c1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogMTIsIG5hbWU6IFwiZmVhdHVyZXNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEZlYXR1cmVTZXQsIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDk5OSwgbmFtZTogXCJ1bmludGVycHJldGVkX29wdGlvblwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVW5pbnRlcnByZXRlZE9wdGlvbiwgcmVwZWF0ZWQ6IHRydWUgfSxcbl0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuRmllbGRPcHRpb25zXG4gKi9cbmNsYXNzIEZpZWxkT3B0aW9ucyBleHRlbmRzIGVzbV9tZXNzYWdlLyogTWVzc2FnZSAqLy52IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGdvb2dsZS5wcm90b2J1Zi5GaWVsZE9wdGlvbnMuT3B0aW9uVGFyZ2V0VHlwZSB0YXJnZXRzID0gMTk7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhcmdldHMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgZ29vZ2xlLnByb3RvYnVmLkZpZWxkT3B0aW9ucy5FZGl0aW9uRGVmYXVsdCBlZGl0aW9uX2RlZmF1bHRzID0gMjA7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVkaXRpb25EZWZhdWx0cyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhcnNlciBzdG9yZXMgb3B0aW9ucyBpdCBkb2Vzbid0IHJlY29nbml6ZSBoZXJlLiBTZWUgYWJvdmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgZ29vZ2xlLnByb3RvYnVmLlVuaW50ZXJwcmV0ZWRPcHRpb24gdW5pbnRlcnByZXRlZF9vcHRpb24gPSA5OTk7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVuaW50ZXJwcmV0ZWRPcHRpb24gPSBbXTtcbiAgICAgICAgcHJvdG8yLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGRPcHRpb25zKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZE9wdGlvbnMoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEZpZWxkT3B0aW9ucygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvMi51dGlsLmVxdWFscyhGaWVsZE9wdGlvbnMsIGEsIGIpO1xuICAgIH1cbn1cbkZpZWxkT3B0aW9ucy5ydW50aW1lID0gcHJvdG8yO1xuRmllbGRPcHRpb25zLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuRmllbGRPcHRpb25zXCI7XG5GaWVsZE9wdGlvbnMuZmllbGRzID0gcHJvdG8yLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImN0eXBlXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzIuZ2V0RW51bVR5cGUoRmllbGRPcHRpb25zX0NUeXBlKSwgb3B0OiB0cnVlLCBkZWZhdWx0OiBGaWVsZE9wdGlvbnNfQ1R5cGUuU1RSSU5HIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJwYWNrZWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8sIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwianN0eXBlXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzIuZ2V0RW51bVR5cGUoRmllbGRPcHRpb25zX0pTVHlwZSksIG9wdDogdHJ1ZSwgZGVmYXVsdDogRmllbGRPcHRpb25zX0pTVHlwZS5KU19OT1JNQUwgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcImxhenlcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8sIG9wdDogdHJ1ZSwgZGVmYXVsdDogZmFsc2UgfSxcbiAgICB7IG5vOiAxNSwgbmFtZTogXCJ1bnZlcmlmaWVkX2xhenlcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8sIG9wdDogdHJ1ZSwgZGVmYXVsdDogZmFsc2UgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImRlcHJlY2F0ZWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8sIG9wdDogdHJ1ZSwgZGVmYXVsdDogZmFsc2UgfSxcbiAgICB7IG5vOiAxMCwgbmFtZTogXCJ3ZWFrXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovLCBvcHQ6IHRydWUsIGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgeyBubzogMTYsIG5hbWU6IFwiZGVidWdfcmVkYWN0XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovLCBvcHQ6IHRydWUsIGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgeyBubzogMTcsIG5hbWU6IFwicmV0ZW50aW9uXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzIuZ2V0RW51bVR5cGUoRmllbGRPcHRpb25zX09wdGlvblJldGVudGlvbiksIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDE5LCBuYW1lOiBcInRhcmdldHNcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMi5nZXRFbnVtVHlwZShGaWVsZE9wdGlvbnNfT3B0aW9uVGFyZ2V0VHlwZSksIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogMjAsIG5hbWU6IFwiZWRpdGlvbl9kZWZhdWx0c1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogRmllbGRPcHRpb25zX0VkaXRpb25EZWZhdWx0LCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDIxLCBuYW1lOiBcImZlYXR1cmVzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBGZWF0dXJlU2V0LCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiA5OTksIG5hbWU6IFwidW5pbnRlcnByZXRlZF9vcHRpb25cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFVuaW50ZXJwcmV0ZWRPcHRpb24sIHJlcGVhdGVkOiB0cnVlIH0sXG5dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gZ29vZ2xlLnByb3RvYnVmLkZpZWxkT3B0aW9ucy5DVHlwZVxuICovXG52YXIgRmllbGRPcHRpb25zX0NUeXBlO1xuKGZ1bmN0aW9uIChGaWVsZE9wdGlvbnNfQ1R5cGUpIHtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IG1vZGUuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogU1RSSU5HID0gMDtcbiAgICAgKi9cbiAgICBGaWVsZE9wdGlvbnNfQ1R5cGVbRmllbGRPcHRpb25zX0NUeXBlW1wiU1RSSU5HXCJdID0gMF0gPSBcIlNUUklOR1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBvcHRpb24gW2N0eXBlPUNPUkRdIG1heSBiZSBhcHBsaWVkIHRvIGEgbm9uLXJlcGVhdGVkIGZpZWxkIG9mIHR5cGVcbiAgICAgKiBcImJ5dGVzXCIuIEl0IGluZGljYXRlcyB0aGF0IGluIEMrKywgdGhlIGRhdGEgc2hvdWxkIGJlIHN0b3JlZCBpbiBhIENvcmRcbiAgICAgKiBpbnN0ZWFkIG9mIGEgc3RyaW5nLiAgRm9yIHZlcnkgbGFyZ2Ugc3RyaW5ncywgdGhpcyBtYXkgcmVkdWNlIG1lbW9yeVxuICAgICAqIGZyYWdtZW50YXRpb24uIEl0IG1heSBhbHNvIGFsbG93IGJldHRlciBwZXJmb3JtYW5jZSB3aGVuIHBhcnNpbmcgZnJvbSBhXG4gICAgICogQ29yZCwgb3Igd2hlbiBwYXJzaW5nIHdpdGggYWxpYXNpbmcgZW5hYmxlZCwgYXMgdGhlIHBhcnNlZCBDb3JkIG1heSB0aGVuXG4gICAgICogYWxpYXMgdGhlIG9yaWdpbmFsIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBDT1JEID0gMTtcbiAgICAgKi9cbiAgICBGaWVsZE9wdGlvbnNfQ1R5cGVbRmllbGRPcHRpb25zX0NUeXBlW1wiQ09SRFwiXSA9IDFdID0gXCJDT1JEXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFNUUklOR19QSUVDRSA9IDI7XG4gICAgICovXG4gICAgRmllbGRPcHRpb25zX0NUeXBlW0ZpZWxkT3B0aW9uc19DVHlwZVtcIlNUUklOR19QSUVDRVwiXSA9IDJdID0gXCJTVFJJTkdfUElFQ0VcIjtcbn0pKEZpZWxkT3B0aW9uc19DVHlwZSB8fCAoRmllbGRPcHRpb25zX0NUeXBlID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8yLmdldEVudW1UeXBlKEZpZWxkT3B0aW9uc19DVHlwZSlcbnByb3RvMi51dGlsLnNldEVudW1UeXBlKEZpZWxkT3B0aW9uc19DVHlwZSwgXCJnb29nbGUucHJvdG9idWYuRmllbGRPcHRpb25zLkNUeXBlXCIsIFtcbiAgICB7IG5vOiAwLCBuYW1lOiBcIlNUUklOR1wiIH0sXG4gICAgeyBubzogMSwgbmFtZTogXCJDT1JEXCIgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIlNUUklOR19QSUVDRVwiIH0sXG5dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gZ29vZ2xlLnByb3RvYnVmLkZpZWxkT3B0aW9ucy5KU1R5cGVcbiAqL1xudmFyIEZpZWxkT3B0aW9uc19KU1R5cGU7XG4oZnVuY3Rpb24gKEZpZWxkT3B0aW9uc19KU1R5cGUpIHtcbiAgICAvKipcbiAgICAgKiBVc2UgdGhlIGRlZmF1bHQgdHlwZS5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBKU19OT1JNQUwgPSAwO1xuICAgICAqL1xuICAgIEZpZWxkT3B0aW9uc19KU1R5cGVbRmllbGRPcHRpb25zX0pTVHlwZVtcIkpTX05PUk1BTFwiXSA9IDBdID0gXCJKU19OT1JNQUxcIjtcbiAgICAvKipcbiAgICAgKiBVc2UgSmF2YVNjcmlwdCBzdHJpbmdzLlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEpTX1NUUklORyA9IDE7XG4gICAgICovXG4gICAgRmllbGRPcHRpb25zX0pTVHlwZVtGaWVsZE9wdGlvbnNfSlNUeXBlW1wiSlNfU1RSSU5HXCJdID0gMV0gPSBcIkpTX1NUUklOR1wiO1xuICAgIC8qKlxuICAgICAqIFVzZSBKYXZhU2NyaXB0IG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogSlNfTlVNQkVSID0gMjtcbiAgICAgKi9cbiAgICBGaWVsZE9wdGlvbnNfSlNUeXBlW0ZpZWxkT3B0aW9uc19KU1R5cGVbXCJKU19OVU1CRVJcIl0gPSAyXSA9IFwiSlNfTlVNQkVSXCI7XG59KShGaWVsZE9wdGlvbnNfSlNUeXBlIHx8IChGaWVsZE9wdGlvbnNfSlNUeXBlID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8yLmdldEVudW1UeXBlKEZpZWxkT3B0aW9uc19KU1R5cGUpXG5wcm90bzIudXRpbC5zZXRFbnVtVHlwZShGaWVsZE9wdGlvbnNfSlNUeXBlLCBcImdvb2dsZS5wcm90b2J1Zi5GaWVsZE9wdGlvbnMuSlNUeXBlXCIsIFtcbiAgICB7IG5vOiAwLCBuYW1lOiBcIkpTX05PUk1BTFwiIH0sXG4gICAgeyBubzogMSwgbmFtZTogXCJKU19TVFJJTkdcIiB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiSlNfTlVNQkVSXCIgfSxcbl0pO1xuLyoqXG4gKiBJZiBzZXQgdG8gUkVURU5USU9OX1NPVVJDRSwgdGhlIG9wdGlvbiB3aWxsIGJlIG9taXR0ZWQgZnJvbSB0aGUgYmluYXJ5LlxuICogTm90ZTogYXMgb2YgSmFudWFyeSAyMDIzLCBzdXBwb3J0IGZvciB0aGlzIGlzIGluIHByb2dyZXNzIGFuZCBkb2VzIG5vdCB5ZXRcbiAqIGhhdmUgYW4gZWZmZWN0IChiLzI2NDU5MzQ4OSkuXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gZ29vZ2xlLnByb3RvYnVmLkZpZWxkT3B0aW9ucy5PcHRpb25SZXRlbnRpb25cbiAqL1xudmFyIEZpZWxkT3B0aW9uc19PcHRpb25SZXRlbnRpb247XG4oZnVuY3Rpb24gKEZpZWxkT3B0aW9uc19PcHRpb25SZXRlbnRpb24pIHtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogUkVURU5USU9OX1VOS05PV04gPSAwO1xuICAgICAqL1xuICAgIEZpZWxkT3B0aW9uc19PcHRpb25SZXRlbnRpb25bRmllbGRPcHRpb25zX09wdGlvblJldGVudGlvbltcIlJFVEVOVElPTl9VTktOT1dOXCJdID0gMF0gPSBcIlJFVEVOVElPTl9VTktOT1dOXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFJFVEVOVElPTl9SVU5USU1FID0gMTtcbiAgICAgKi9cbiAgICBGaWVsZE9wdGlvbnNfT3B0aW9uUmV0ZW50aW9uW0ZpZWxkT3B0aW9uc19PcHRpb25SZXRlbnRpb25bXCJSRVRFTlRJT05fUlVOVElNRVwiXSA9IDFdID0gXCJSRVRFTlRJT05fUlVOVElNRVwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBSRVRFTlRJT05fU09VUkNFID0gMjtcbiAgICAgKi9cbiAgICBGaWVsZE9wdGlvbnNfT3B0aW9uUmV0ZW50aW9uW0ZpZWxkT3B0aW9uc19PcHRpb25SZXRlbnRpb25bXCJSRVRFTlRJT05fU09VUkNFXCJdID0gMl0gPSBcIlJFVEVOVElPTl9TT1VSQ0VcIjtcbn0pKEZpZWxkT3B0aW9uc19PcHRpb25SZXRlbnRpb24gfHwgKEZpZWxkT3B0aW9uc19PcHRpb25SZXRlbnRpb24gPSB7fSkpO1xuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzIuZ2V0RW51bVR5cGUoRmllbGRPcHRpb25zX09wdGlvblJldGVudGlvbilcbnByb3RvMi51dGlsLnNldEVudW1UeXBlKEZpZWxkT3B0aW9uc19PcHRpb25SZXRlbnRpb24sIFwiZ29vZ2xlLnByb3RvYnVmLkZpZWxkT3B0aW9ucy5PcHRpb25SZXRlbnRpb25cIiwgW1xuICAgIHsgbm86IDAsIG5hbWU6IFwiUkVURU5USU9OX1VOS05PV05cIiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiUkVURU5USU9OX1JVTlRJTUVcIiB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiUkVURU5USU9OX1NPVVJDRVwiIH0sXG5dKTtcbi8qKlxuICogVGhpcyBpbmRpY2F0ZXMgdGhlIHR5cGVzIG9mIGVudGl0aWVzIHRoYXQgdGhlIGZpZWxkIG1heSBhcHBseSB0byB3aGVuIHVzZWRcbiAqIGFzIGFuIG9wdGlvbi4gSWYgaXQgaXMgdW5zZXQsIHRoZW4gdGhlIGZpZWxkIG1heSBiZSBmcmVlbHkgdXNlZCBhcyBhblxuICogb3B0aW9uIG9uIGFueSBraW5kIG9mIGVudGl0eS4gTm90ZTogYXMgb2YgSmFudWFyeSAyMDIzLCBzdXBwb3J0IGZvciB0aGlzIGlzXG4gKiBpbiBwcm9ncmVzcyBhbmQgZG9lcyBub3QgeWV0IGhhdmUgYW4gZWZmZWN0IChiLzI2NDU5MzQ4OSkuXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gZ29vZ2xlLnByb3RvYnVmLkZpZWxkT3B0aW9ucy5PcHRpb25UYXJnZXRUeXBlXG4gKi9cbnZhciBGaWVsZE9wdGlvbnNfT3B0aW9uVGFyZ2V0VHlwZTtcbihmdW5jdGlvbiAoRmllbGRPcHRpb25zX09wdGlvblRhcmdldFR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVEFSR0VUX1RZUEVfVU5LTk9XTiA9IDA7XG4gICAgICovXG4gICAgRmllbGRPcHRpb25zX09wdGlvblRhcmdldFR5cGVbRmllbGRPcHRpb25zX09wdGlvblRhcmdldFR5cGVbXCJUQVJHRVRfVFlQRV9VTktOT1dOXCJdID0gMF0gPSBcIlRBUkdFVF9UWVBFX1VOS05PV05cIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVEFSR0VUX1RZUEVfRklMRSA9IDE7XG4gICAgICovXG4gICAgRmllbGRPcHRpb25zX09wdGlvblRhcmdldFR5cGVbRmllbGRPcHRpb25zX09wdGlvblRhcmdldFR5cGVbXCJUQVJHRVRfVFlQRV9GSUxFXCJdID0gMV0gPSBcIlRBUkdFVF9UWVBFX0ZJTEVcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVEFSR0VUX1RZUEVfRVhURU5TSU9OX1JBTkdFID0gMjtcbiAgICAgKi9cbiAgICBGaWVsZE9wdGlvbnNfT3B0aW9uVGFyZ2V0VHlwZVtGaWVsZE9wdGlvbnNfT3B0aW9uVGFyZ2V0VHlwZVtcIlRBUkdFVF9UWVBFX0VYVEVOU0lPTl9SQU5HRVwiXSA9IDJdID0gXCJUQVJHRVRfVFlQRV9FWFRFTlNJT05fUkFOR0VcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVEFSR0VUX1RZUEVfTUVTU0FHRSA9IDM7XG4gICAgICovXG4gICAgRmllbGRPcHRpb25zX09wdGlvblRhcmdldFR5cGVbRmllbGRPcHRpb25zX09wdGlvblRhcmdldFR5cGVbXCJUQVJHRVRfVFlQRV9NRVNTQUdFXCJdID0gM10gPSBcIlRBUkdFVF9UWVBFX01FU1NBR0VcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVEFSR0VUX1RZUEVfRklFTEQgPSA0O1xuICAgICAqL1xuICAgIEZpZWxkT3B0aW9uc19PcHRpb25UYXJnZXRUeXBlW0ZpZWxkT3B0aW9uc19PcHRpb25UYXJnZXRUeXBlW1wiVEFSR0VUX1RZUEVfRklFTERcIl0gPSA0XSA9IFwiVEFSR0VUX1RZUEVfRklFTERcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVEFSR0VUX1RZUEVfT05FT0YgPSA1O1xuICAgICAqL1xuICAgIEZpZWxkT3B0aW9uc19PcHRpb25UYXJnZXRUeXBlW0ZpZWxkT3B0aW9uc19PcHRpb25UYXJnZXRUeXBlW1wiVEFSR0VUX1RZUEVfT05FT0ZcIl0gPSA1XSA9IFwiVEFSR0VUX1RZUEVfT05FT0ZcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVEFSR0VUX1RZUEVfRU5VTSA9IDY7XG4gICAgICovXG4gICAgRmllbGRPcHRpb25zX09wdGlvblRhcmdldFR5cGVbRmllbGRPcHRpb25zX09wdGlvblRhcmdldFR5cGVbXCJUQVJHRVRfVFlQRV9FTlVNXCJdID0gNl0gPSBcIlRBUkdFVF9UWVBFX0VOVU1cIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVEFSR0VUX1RZUEVfRU5VTV9FTlRSWSA9IDc7XG4gICAgICovXG4gICAgRmllbGRPcHRpb25zX09wdGlvblRhcmdldFR5cGVbRmllbGRPcHRpb25zX09wdGlvblRhcmdldFR5cGVbXCJUQVJHRVRfVFlQRV9FTlVNX0VOVFJZXCJdID0gN10gPSBcIlRBUkdFVF9UWVBFX0VOVU1fRU5UUllcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVEFSR0VUX1RZUEVfU0VSVklDRSA9IDg7XG4gICAgICovXG4gICAgRmllbGRPcHRpb25zX09wdGlvblRhcmdldFR5cGVbRmllbGRPcHRpb25zX09wdGlvblRhcmdldFR5cGVbXCJUQVJHRVRfVFlQRV9TRVJWSUNFXCJdID0gOF0gPSBcIlRBUkdFVF9UWVBFX1NFUlZJQ0VcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVEFSR0VUX1RZUEVfTUVUSE9EID0gOTtcbiAgICAgKi9cbiAgICBGaWVsZE9wdGlvbnNfT3B0aW9uVGFyZ2V0VHlwZVtGaWVsZE9wdGlvbnNfT3B0aW9uVGFyZ2V0VHlwZVtcIlRBUkdFVF9UWVBFX01FVEhPRFwiXSA9IDldID0gXCJUQVJHRVRfVFlQRV9NRVRIT0RcIjtcbn0pKEZpZWxkT3B0aW9uc19PcHRpb25UYXJnZXRUeXBlIHx8IChGaWVsZE9wdGlvbnNfT3B0aW9uVGFyZ2V0VHlwZSA9IHt9KSk7XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMi5nZXRFbnVtVHlwZShGaWVsZE9wdGlvbnNfT3B0aW9uVGFyZ2V0VHlwZSlcbnByb3RvMi51dGlsLnNldEVudW1UeXBlKEZpZWxkT3B0aW9uc19PcHRpb25UYXJnZXRUeXBlLCBcImdvb2dsZS5wcm90b2J1Zi5GaWVsZE9wdGlvbnMuT3B0aW9uVGFyZ2V0VHlwZVwiLCBbXG4gICAgeyBubzogMCwgbmFtZTogXCJUQVJHRVRfVFlQRV9VTktOT1dOXCIgfSxcbiAgICB7IG5vOiAxLCBuYW1lOiBcIlRBUkdFVF9UWVBFX0ZJTEVcIiB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiVEFSR0VUX1RZUEVfRVhURU5TSU9OX1JBTkdFXCIgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcIlRBUkdFVF9UWVBFX01FU1NBR0VcIiB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwiVEFSR0VUX1RZUEVfRklFTERcIiB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwiVEFSR0VUX1RZUEVfT05FT0ZcIiB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwiVEFSR0VUX1RZUEVfRU5VTVwiIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJUQVJHRVRfVFlQRV9FTlVNX0VOVFJZXCIgfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcIlRBUkdFVF9UWVBFX1NFUlZJQ0VcIiB9LFxuICAgIHsgbm86IDksIG5hbWU6IFwiVEFSR0VUX1RZUEVfTUVUSE9EXCIgfSxcbl0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuRmllbGRPcHRpb25zLkVkaXRpb25EZWZhdWx0XG4gKi9cbmNsYXNzIEZpZWxkT3B0aW9uc19FZGl0aW9uRGVmYXVsdCBleHRlbmRzIGVzbV9tZXNzYWdlLyogTWVzc2FnZSAqLy52IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHByb3RvMi51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEZpZWxkT3B0aW9uc19FZGl0aW9uRGVmYXVsdCgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGRPcHRpb25zX0VkaXRpb25EZWZhdWx0KCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZE9wdGlvbnNfRWRpdGlvbkRlZmF1bHQoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBwcm90bzIudXRpbC5lcXVhbHMoRmllbGRPcHRpb25zX0VkaXRpb25EZWZhdWx0LCBhLCBiKTtcbiAgICB9XG59XG5GaWVsZE9wdGlvbnNfRWRpdGlvbkRlZmF1bHQucnVudGltZSA9IHByb3RvMjtcbkZpZWxkT3B0aW9uc19FZGl0aW9uRGVmYXVsdC50eXBlTmFtZSA9IFwiZ29vZ2xlLnByb3RvYnVmLkZpZWxkT3B0aW9ucy5FZGl0aW9uRGVmYXVsdFwiO1xuRmllbGRPcHRpb25zX0VkaXRpb25EZWZhdWx0LmZpZWxkcyA9IHByb3RvMi51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMywgbmFtZTogXCJlZGl0aW9uXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzIuZ2V0RW51bVR5cGUoRWRpdGlvbiksIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwidmFsdWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgb3B0OiB0cnVlIH0sXG5dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLk9uZW9mT3B0aW9uc1xuICovXG5jbGFzcyBPbmVvZk9wdGlvbnMgZXh0ZW5kcyBlc21fbWVzc2FnZS8qIE1lc3NhZ2UgKi8udiB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhcnNlciBzdG9yZXMgb3B0aW9ucyBpdCBkb2Vzbid0IHJlY29nbml6ZSBoZXJlLiBTZWUgYWJvdmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgZ29vZ2xlLnByb3RvYnVmLlVuaW50ZXJwcmV0ZWRPcHRpb24gdW5pbnRlcnByZXRlZF9vcHRpb24gPSA5OTk7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVuaW50ZXJwcmV0ZWRPcHRpb24gPSBbXTtcbiAgICAgICAgcHJvdG8yLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgT25lb2ZPcHRpb25zKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPbmVvZk9wdGlvbnMoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IE9uZW9mT3B0aW9ucygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvMi51dGlsLmVxdWFscyhPbmVvZk9wdGlvbnMsIGEsIGIpO1xuICAgIH1cbn1cbk9uZW9mT3B0aW9ucy5ydW50aW1lID0gcHJvdG8yO1xuT25lb2ZPcHRpb25zLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuT25lb2ZPcHRpb25zXCI7XG5PbmVvZk9wdGlvbnMuZmllbGRzID0gcHJvdG8yLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImZlYXR1cmVzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBGZWF0dXJlU2V0LCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiA5OTksIG5hbWU6IFwidW5pbnRlcnByZXRlZF9vcHRpb25cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFVuaW50ZXJwcmV0ZWRPcHRpb24sIHJlcGVhdGVkOiB0cnVlIH0sXG5dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLkVudW1PcHRpb25zXG4gKi9cbmNsYXNzIEVudW1PcHRpb25zIGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYXJzZXIgc3RvcmVzIG9wdGlvbnMgaXQgZG9lc24ndCByZWNvZ25pemUgaGVyZS4gU2VlIGFib3ZlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGdvb2dsZS5wcm90b2J1Zi5VbmludGVycHJldGVkT3B0aW9uIHVuaW50ZXJwcmV0ZWRfb3B0aW9uID0gOTk5O1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51bmludGVycHJldGVkT3B0aW9uID0gW107XG4gICAgICAgIHByb3RvMi51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEVudW1PcHRpb25zKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbnVtT3B0aW9ucygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW51bU9wdGlvbnMoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBwcm90bzIudXRpbC5lcXVhbHMoRW51bU9wdGlvbnMsIGEsIGIpO1xuICAgIH1cbn1cbkVudW1PcHRpb25zLnJ1bnRpbWUgPSBwcm90bzI7XG5FbnVtT3B0aW9ucy50eXBlTmFtZSA9IFwiZ29vZ2xlLnByb3RvYnVmLkVudW1PcHRpb25zXCI7XG5FbnVtT3B0aW9ucy5maWVsZHMgPSBwcm90bzIudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDIsIG5hbWU6IFwiYWxsb3dfYWxpYXNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8sIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiZGVwcmVjYXRlZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLywgb3B0OiB0cnVlLCBkZWZhdWx0OiBmYWxzZSB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwiZGVwcmVjYXRlZF9sZWdhY3lfanNvbl9maWVsZF9jb25mbGljdHNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8sIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwiZmVhdHVyZXNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEZlYXR1cmVTZXQsIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDk5OSwgbmFtZTogXCJ1bmludGVycHJldGVkX29wdGlvblwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVW5pbnRlcnByZXRlZE9wdGlvbiwgcmVwZWF0ZWQ6IHRydWUgfSxcbl0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuRW51bVZhbHVlT3B0aW9uc1xuICovXG5jbGFzcyBFbnVtVmFsdWVPcHRpb25zIGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYXJzZXIgc3RvcmVzIG9wdGlvbnMgaXQgZG9lc24ndCByZWNvZ25pemUgaGVyZS4gU2VlIGFib3ZlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGdvb2dsZS5wcm90b2J1Zi5VbmludGVycHJldGVkT3B0aW9uIHVuaW50ZXJwcmV0ZWRfb3B0aW9uID0gOTk5O1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51bmludGVycHJldGVkT3B0aW9uID0gW107XG4gICAgICAgIHByb3RvMi51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEVudW1WYWx1ZU9wdGlvbnMoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEVudW1WYWx1ZU9wdGlvbnMoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEVudW1WYWx1ZU9wdGlvbnMoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBwcm90bzIudXRpbC5lcXVhbHMoRW51bVZhbHVlT3B0aW9ucywgYSwgYik7XG4gICAgfVxufVxuRW51bVZhbHVlT3B0aW9ucy5ydW50aW1lID0gcHJvdG8yO1xuRW51bVZhbHVlT3B0aW9ucy50eXBlTmFtZSA9IFwiZ29vZ2xlLnByb3RvYnVmLkVudW1WYWx1ZU9wdGlvbnNcIjtcbkVudW1WYWx1ZU9wdGlvbnMuZmllbGRzID0gcHJvdG8yLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImRlcHJlY2F0ZWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8sIG9wdDogdHJ1ZSwgZGVmYXVsdDogZmFsc2UgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImZlYXR1cmVzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBGZWF0dXJlU2V0LCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImRlYnVnX3JlZGFjdFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLywgb3B0OiB0cnVlLCBkZWZhdWx0OiBmYWxzZSB9LFxuICAgIHsgbm86IDk5OSwgbmFtZTogXCJ1bmludGVycHJldGVkX29wdGlvblwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVW5pbnRlcnByZXRlZE9wdGlvbiwgcmVwZWF0ZWQ6IHRydWUgfSxcbl0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuU2VydmljZU9wdGlvbnNcbiAqL1xuY2xhc3MgU2VydmljZU9wdGlvbnMgZXh0ZW5kcyBlc21fbWVzc2FnZS8qIE1lc3NhZ2UgKi8udiB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhcnNlciBzdG9yZXMgb3B0aW9ucyBpdCBkb2Vzbid0IHJlY29nbml6ZSBoZXJlLiBTZWUgYWJvdmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgZ29vZ2xlLnByb3RvYnVmLlVuaW50ZXJwcmV0ZWRPcHRpb24gdW5pbnRlcnByZXRlZF9vcHRpb24gPSA5OTk7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVuaW50ZXJwcmV0ZWRPcHRpb24gPSBbXTtcbiAgICAgICAgcHJvdG8yLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VydmljZU9wdGlvbnMoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFNlcnZpY2VPcHRpb25zKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXJ2aWNlT3B0aW9ucygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvMi51dGlsLmVxdWFscyhTZXJ2aWNlT3B0aW9ucywgYSwgYik7XG4gICAgfVxufVxuU2VydmljZU9wdGlvbnMucnVudGltZSA9IHByb3RvMjtcblNlcnZpY2VPcHRpb25zLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuU2VydmljZU9wdGlvbnNcIjtcblNlcnZpY2VPcHRpb25zLmZpZWxkcyA9IHByb3RvMi51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMzQsIG5hbWU6IFwiZmVhdHVyZXNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEZlYXR1cmVTZXQsIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDMzLCBuYW1lOiBcImRlcHJlY2F0ZWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8sIG9wdDogdHJ1ZSwgZGVmYXVsdDogZmFsc2UgfSxcbiAgICB7IG5vOiA5OTksIG5hbWU6IFwidW5pbnRlcnByZXRlZF9vcHRpb25cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFVuaW50ZXJwcmV0ZWRPcHRpb24sIHJlcGVhdGVkOiB0cnVlIH0sXG5dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLk1ldGhvZE9wdGlvbnNcbiAqL1xuY2xhc3MgTWV0aG9kT3B0aW9ucyBleHRlbmRzIGVzbV9tZXNzYWdlLyogTWVzc2FnZSAqLy52IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGFyc2VyIHN0b3JlcyBvcHRpb25zIGl0IGRvZXNuJ3QgcmVjb2duaXplIGhlcmUuIFNlZSBhYm92ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBnb29nbGUucHJvdG9idWYuVW5pbnRlcnByZXRlZE9wdGlvbiB1bmludGVycHJldGVkX29wdGlvbiA9IDk5OTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudW5pbnRlcnByZXRlZE9wdGlvbiA9IFtdO1xuICAgICAgICBwcm90bzIudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNZXRob2RPcHRpb25zKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNZXRob2RPcHRpb25zKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNZXRob2RPcHRpb25zKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gcHJvdG8yLnV0aWwuZXF1YWxzKE1ldGhvZE9wdGlvbnMsIGEsIGIpO1xuICAgIH1cbn1cbk1ldGhvZE9wdGlvbnMucnVudGltZSA9IHByb3RvMjtcbk1ldGhvZE9wdGlvbnMudHlwZU5hbWUgPSBcImdvb2dsZS5wcm90b2J1Zi5NZXRob2RPcHRpb25zXCI7XG5NZXRob2RPcHRpb25zLmZpZWxkcyA9IHByb3RvMi51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMzMsIG5hbWU6IFwiZGVwcmVjYXRlZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLywgb3B0OiB0cnVlLCBkZWZhdWx0OiBmYWxzZSB9LFxuICAgIHsgbm86IDM0LCBuYW1lOiBcImlkZW1wb3RlbmN5X2xldmVsXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzIuZ2V0RW51bVR5cGUoTWV0aG9kT3B0aW9uc19JZGVtcG90ZW5jeUxldmVsKSwgb3B0OiB0cnVlLCBkZWZhdWx0OiBNZXRob2RPcHRpb25zX0lkZW1wb3RlbmN5TGV2ZWwuSURFTVBPVEVOQ1lfVU5LTk9XTiB9LFxuICAgIHsgbm86IDM1LCBuYW1lOiBcImZlYXR1cmVzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBGZWF0dXJlU2V0LCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiA5OTksIG5hbWU6IFwidW5pbnRlcnByZXRlZF9vcHRpb25cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFVuaW50ZXJwcmV0ZWRPcHRpb24sIHJlcGVhdGVkOiB0cnVlIH0sXG5dKTtcbi8qKlxuICogSXMgdGhpcyBtZXRob2Qgc2lkZS1lZmZlY3QtZnJlZSAob3Igc2FmZSBpbiBIVFRQIHBhcmxhbmNlKSwgb3IgaWRlbXBvdGVudCxcbiAqIG9yIG5laXRoZXI/IEhUVFAgYmFzZWQgUlBDIGltcGxlbWVudGF0aW9uIG1heSBjaG9vc2UgR0VUIHZlcmIgZm9yIHNhZmVcbiAqIG1ldGhvZHMsIGFuZCBQVVQgdmVyYiBmb3IgaWRlbXBvdGVudCBtZXRob2RzIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgUE9TVC5cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBnb29nbGUucHJvdG9idWYuTWV0aG9kT3B0aW9ucy5JZGVtcG90ZW5jeUxldmVsXG4gKi9cbnZhciBNZXRob2RPcHRpb25zX0lkZW1wb3RlbmN5TGV2ZWw7XG4oZnVuY3Rpb24gKE1ldGhvZE9wdGlvbnNfSWRlbXBvdGVuY3lMZXZlbCkge1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBJREVNUE9URU5DWV9VTktOT1dOID0gMDtcbiAgICAgKi9cbiAgICBNZXRob2RPcHRpb25zX0lkZW1wb3RlbmN5TGV2ZWxbTWV0aG9kT3B0aW9uc19JZGVtcG90ZW5jeUxldmVsW1wiSURFTVBPVEVOQ1lfVU5LTk9XTlwiXSA9IDBdID0gXCJJREVNUE9URU5DWV9VTktOT1dOXCI7XG4gICAgLyoqXG4gICAgICogaW1wbGllcyBpZGVtcG90ZW50XG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogTk9fU0lERV9FRkZFQ1RTID0gMTtcbiAgICAgKi9cbiAgICBNZXRob2RPcHRpb25zX0lkZW1wb3RlbmN5TGV2ZWxbTWV0aG9kT3B0aW9uc19JZGVtcG90ZW5jeUxldmVsW1wiTk9fU0lERV9FRkZFQ1RTXCJdID0gMV0gPSBcIk5PX1NJREVfRUZGRUNUU1wiO1xuICAgIC8qKlxuICAgICAqIGlkZW1wb3RlbnQsIGJ1dCBtYXkgaGF2ZSBzaWRlIGVmZmVjdHNcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBJREVNUE9URU5UID0gMjtcbiAgICAgKi9cbiAgICBNZXRob2RPcHRpb25zX0lkZW1wb3RlbmN5TGV2ZWxbTWV0aG9kT3B0aW9uc19JZGVtcG90ZW5jeUxldmVsW1wiSURFTVBPVEVOVFwiXSA9IDJdID0gXCJJREVNUE9URU5UXCI7XG59KShNZXRob2RPcHRpb25zX0lkZW1wb3RlbmN5TGV2ZWwgfHwgKE1ldGhvZE9wdGlvbnNfSWRlbXBvdGVuY3lMZXZlbCA9IHt9KSk7XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMi5nZXRFbnVtVHlwZShNZXRob2RPcHRpb25zX0lkZW1wb3RlbmN5TGV2ZWwpXG5wcm90bzIudXRpbC5zZXRFbnVtVHlwZShNZXRob2RPcHRpb25zX0lkZW1wb3RlbmN5TGV2ZWwsIFwiZ29vZ2xlLnByb3RvYnVmLk1ldGhvZE9wdGlvbnMuSWRlbXBvdGVuY3lMZXZlbFwiLCBbXG4gICAgeyBubzogMCwgbmFtZTogXCJJREVNUE9URU5DWV9VTktOT1dOXCIgfSxcbiAgICB7IG5vOiAxLCBuYW1lOiBcIk5PX1NJREVfRUZGRUNUU1wiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJJREVNUE9URU5UXCIgfSxcbl0pO1xuLyoqXG4gKiBBIG1lc3NhZ2UgcmVwcmVzZW50aW5nIGEgb3B0aW9uIHRoZSBwYXJzZXIgZG9lcyBub3QgcmVjb2duaXplLiBUaGlzIG9ubHlcbiAqIGFwcGVhcnMgaW4gb3B0aW9ucyBwcm90b3MgY3JlYXRlZCBieSB0aGUgY29tcGlsZXI6OlBhcnNlciBjbGFzcy5cbiAqIERlc2NyaXB0b3JQb29sIHJlc29sdmVzIHRoZXNlIHdoZW4gYnVpbGRpbmcgRGVzY3JpcHRvciBvYmplY3RzLiBUaGVyZWZvcmUsXG4gKiBvcHRpb25zIHByb3RvcyBpbiBkZXNjcmlwdG9yIG9iamVjdHMgKGUuZy4gcmV0dXJuZWQgYnkgRGVzY3JpcHRvcjo6b3B0aW9ucygpLFxuICogb3IgcHJvZHVjZWQgYnkgRGVzY3JpcHRvcjo6Q29weVRvKCkpIHdpbGwgbmV2ZXIgaGF2ZSBVbmludGVycHJldGVkT3B0aW9uc1xuICogaW4gdGhlbS5cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuVW5pbnRlcnByZXRlZE9wdGlvblxuICovXG5jbGFzcyBVbmludGVycHJldGVkT3B0aW9uIGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgZ29vZ2xlLnByb3RvYnVmLlVuaW50ZXJwcmV0ZWRPcHRpb24uTmFtZVBhcnQgbmFtZSA9IDI7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSBbXTtcbiAgICAgICAgcHJvdG8yLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgVW5pbnRlcnByZXRlZE9wdGlvbigpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgVW5pbnRlcnByZXRlZE9wdGlvbigpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgVW5pbnRlcnByZXRlZE9wdGlvbigpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvMi51dGlsLmVxdWFscyhVbmludGVycHJldGVkT3B0aW9uLCBhLCBiKTtcbiAgICB9XG59XG5VbmludGVycHJldGVkT3B0aW9uLnJ1bnRpbWUgPSBwcm90bzI7XG5VbmludGVycHJldGVkT3B0aW9uLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuVW5pbnRlcnByZXRlZE9wdGlvblwiO1xuVW5pbnRlcnByZXRlZE9wdGlvbi5maWVsZHMgPSBwcm90bzIudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDIsIG5hbWU6IFwibmFtZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVW5pbnRlcnByZXRlZE9wdGlvbl9OYW1lUGFydCwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImlkZW50aWZpZXJfdmFsdWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJwb3NpdGl2ZV9pbnRfdmFsdWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNCAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJuZWdhdGl2ZV9pbnRfdmFsdWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcImRvdWJsZV92YWx1ZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcInN0cmluZ192YWx1ZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMiAvKiBTY2FsYXJUeXBlLkJZVEVTICovLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcImFnZ3JlZ2F0ZV92YWx1ZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLCBvcHQ6IHRydWUgfSxcbl0pO1xuLyoqXG4gKiBUaGUgbmFtZSBvZiB0aGUgdW5pbnRlcnByZXRlZCBvcHRpb24uICBFYWNoIHN0cmluZyByZXByZXNlbnRzIGEgc2VnbWVudCBpblxuICogYSBkb3Qtc2VwYXJhdGVkIG5hbWUuICBpc19leHRlbnNpb24gaXMgdHJ1ZSBpZmYgYSBzZWdtZW50IHJlcHJlc2VudHMgYW5cbiAqIGV4dGVuc2lvbiAoZGVub3RlZCB3aXRoIHBhcmVudGhlc2VzIGluIG9wdGlvbnMgc3BlY3MgaW4gLnByb3RvIGZpbGVzKS5cbiAqIEUuZy4seyBbXCJmb29cIiwgZmFsc2VdLCBbXCJiYXIuYmF6XCIsIHRydWVdLCBbXCJtb29cIiwgZmFsc2VdIH0gcmVwcmVzZW50c1xuICogXCJmb28uKGJhci5iYXopLm1vb1wiLlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5VbmludGVycHJldGVkT3B0aW9uLk5hbWVQYXJ0XG4gKi9cbmNsYXNzIFVuaW50ZXJwcmV0ZWRPcHRpb25fTmFtZVBhcnQgZXh0ZW5kcyBlc21fbWVzc2FnZS8qIE1lc3NhZ2UgKi8udiB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBwcm90bzIudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVbmludGVycHJldGVkT3B0aW9uX05hbWVQYXJ0KCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVbmludGVycHJldGVkT3B0aW9uX05hbWVQYXJ0KCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVbmludGVycHJldGVkT3B0aW9uX05hbWVQYXJ0KCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gcHJvdG8yLnV0aWwuZXF1YWxzKFVuaW50ZXJwcmV0ZWRPcHRpb25fTmFtZVBhcnQsIGEsIGIpO1xuICAgIH1cbn1cblVuaW50ZXJwcmV0ZWRPcHRpb25fTmFtZVBhcnQucnVudGltZSA9IHByb3RvMjtcblVuaW50ZXJwcmV0ZWRPcHRpb25fTmFtZVBhcnQudHlwZU5hbWUgPSBcImdvb2dsZS5wcm90b2J1Zi5VbmludGVycHJldGVkT3B0aW9uLk5hbWVQYXJ0XCI7XG5VbmludGVycHJldGVkT3B0aW9uX05hbWVQYXJ0LmZpZWxkcyA9IHByb3RvMi51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJuYW1lX3BhcnRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiaXNfZXh0ZW5zaW9uXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG5dKTtcbi8qKlxuICogVE9ETyBFbnVtcyBpbiBDKysgZ2VuY29kZSAoYW5kIHBvdGVudGlhbGx5IG90aGVyIGxhbmd1YWdlcykgYXJlXG4gKiBub3Qgd2VsbCBzY29wZWQuICBUaGlzIG1lYW5zIHRoYXQgZWFjaCBvZiB0aGUgZmVhdHVyZSBlbnVtcyBiZWxvdyBjYW4gY2xhc2hcbiAqIHdpdGggZWFjaCBvdGhlci4gIFRoZSBzaG9ydCBuYW1lcyB3ZSd2ZSBjaG9zZW4gbWF4aW1pemUgY2FsbC1zaXRlXG4gKiByZWFkYWJpbGl0eSwgYnV0IGxlYXZlIHVzIHZlcnkgb3BlbiB0byB0aGlzIHNjZW5hcmlvLiAgQSBmdXR1cmUgZmVhdHVyZSB3aWxsXG4gKiBiZSBkZXNpZ25lZCBhbmQgaW1wbGVtZW50ZWQgdG8gaGFuZGxlIHRoaXMsIGhvcGVmdWxseSBiZWZvcmUgd2UgZXZlciBoaXQgYVxuICogY29uZmxpY3QgaGVyZS5cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuRmVhdHVyZVNldFxuICovXG5jbGFzcyBGZWF0dXJlU2V0IGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgcHJvdG8yLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmVhdHVyZVNldCgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmVhdHVyZVNldCgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmVhdHVyZVNldCgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvMi51dGlsLmVxdWFscyhGZWF0dXJlU2V0LCBhLCBiKTtcbiAgICB9XG59XG5GZWF0dXJlU2V0LnJ1bnRpbWUgPSBwcm90bzI7XG5GZWF0dXJlU2V0LnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuRmVhdHVyZVNldFwiO1xuRmVhdHVyZVNldC5maWVsZHMgPSBwcm90bzIudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiZmllbGRfcHJlc2VuY2VcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMi5nZXRFbnVtVHlwZShGZWF0dXJlU2V0X0ZpZWxkUHJlc2VuY2UpLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImVudW1fdHlwZVwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8yLmdldEVudW1UeXBlKEZlYXR1cmVTZXRfRW51bVR5cGUpLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInJlcGVhdGVkX2ZpZWxkX2VuY29kaW5nXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzIuZ2V0RW51bVR5cGUoRmVhdHVyZVNldF9SZXBlYXRlZEZpZWxkRW5jb2RpbmcpLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcInV0ZjhfdmFsaWRhdGlvblwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8yLmdldEVudW1UeXBlKEZlYXR1cmVTZXRfVXRmOFZhbGlkYXRpb24pLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcIm1lc3NhZ2VfZW5jb2RpbmdcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMi5nZXRFbnVtVHlwZShGZWF0dXJlU2V0X01lc3NhZ2VFbmNvZGluZyksIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwianNvbl9mb3JtYXRcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMi5nZXRFbnVtVHlwZShGZWF0dXJlU2V0X0pzb25Gb3JtYXQpLCBvcHQ6IHRydWUgfSxcbl0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBnb29nbGUucHJvdG9idWYuRmVhdHVyZVNldC5GaWVsZFByZXNlbmNlXG4gKi9cbnZhciBGZWF0dXJlU2V0X0ZpZWxkUHJlc2VuY2U7XG4oZnVuY3Rpb24gKEZlYXR1cmVTZXRfRmllbGRQcmVzZW5jZSkge1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBGSUVMRF9QUkVTRU5DRV9VTktOT1dOID0gMDtcbiAgICAgKi9cbiAgICBGZWF0dXJlU2V0X0ZpZWxkUHJlc2VuY2VbRmVhdHVyZVNldF9GaWVsZFByZXNlbmNlW1wiRklFTERfUFJFU0VOQ0VfVU5LTk9XTlwiXSA9IDBdID0gXCJGSUVMRF9QUkVTRU5DRV9VTktOT1dOXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEVYUExJQ0lUID0gMTtcbiAgICAgKi9cbiAgICBGZWF0dXJlU2V0X0ZpZWxkUHJlc2VuY2VbRmVhdHVyZVNldF9GaWVsZFByZXNlbmNlW1wiRVhQTElDSVRcIl0gPSAxXSA9IFwiRVhQTElDSVRcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogSU1QTElDSVQgPSAyO1xuICAgICAqL1xuICAgIEZlYXR1cmVTZXRfRmllbGRQcmVzZW5jZVtGZWF0dXJlU2V0X0ZpZWxkUHJlc2VuY2VbXCJJTVBMSUNJVFwiXSA9IDJdID0gXCJJTVBMSUNJVFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBMRUdBQ1lfUkVRVUlSRUQgPSAzO1xuICAgICAqL1xuICAgIEZlYXR1cmVTZXRfRmllbGRQcmVzZW5jZVtGZWF0dXJlU2V0X0ZpZWxkUHJlc2VuY2VbXCJMRUdBQ1lfUkVRVUlSRURcIl0gPSAzXSA9IFwiTEVHQUNZX1JFUVVJUkVEXCI7XG59KShGZWF0dXJlU2V0X0ZpZWxkUHJlc2VuY2UgfHwgKEZlYXR1cmVTZXRfRmllbGRQcmVzZW5jZSA9IHt9KSk7XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMi5nZXRFbnVtVHlwZShGZWF0dXJlU2V0X0ZpZWxkUHJlc2VuY2UpXG5wcm90bzIudXRpbC5zZXRFbnVtVHlwZShGZWF0dXJlU2V0X0ZpZWxkUHJlc2VuY2UsIFwiZ29vZ2xlLnByb3RvYnVmLkZlYXR1cmVTZXQuRmllbGRQcmVzZW5jZVwiLCBbXG4gICAgeyBubzogMCwgbmFtZTogXCJGSUVMRF9QUkVTRU5DRV9VTktOT1dOXCIgfSxcbiAgICB7IG5vOiAxLCBuYW1lOiBcIkVYUExJQ0lUXCIgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIklNUExJQ0lUXCIgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcIkxFR0FDWV9SRVFVSVJFRFwiIH0sXG5dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gZ29vZ2xlLnByb3RvYnVmLkZlYXR1cmVTZXQuRW51bVR5cGVcbiAqL1xudmFyIEZlYXR1cmVTZXRfRW51bVR5cGU7XG4oZnVuY3Rpb24gKEZlYXR1cmVTZXRfRW51bVR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogRU5VTV9UWVBFX1VOS05PV04gPSAwO1xuICAgICAqL1xuICAgIEZlYXR1cmVTZXRfRW51bVR5cGVbRmVhdHVyZVNldF9FbnVtVHlwZVtcIkVOVU1fVFlQRV9VTktOT1dOXCJdID0gMF0gPSBcIkVOVU1fVFlQRV9VTktOT1dOXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IE9QRU4gPSAxO1xuICAgICAqL1xuICAgIEZlYXR1cmVTZXRfRW51bVR5cGVbRmVhdHVyZVNldF9FbnVtVHlwZVtcIk9QRU5cIl0gPSAxXSA9IFwiT1BFTlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBDTE9TRUQgPSAyO1xuICAgICAqL1xuICAgIEZlYXR1cmVTZXRfRW51bVR5cGVbRmVhdHVyZVNldF9FbnVtVHlwZVtcIkNMT1NFRFwiXSA9IDJdID0gXCJDTE9TRURcIjtcbn0pKEZlYXR1cmVTZXRfRW51bVR5cGUgfHwgKEZlYXR1cmVTZXRfRW51bVR5cGUgPSB7fSkpO1xuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzIuZ2V0RW51bVR5cGUoRmVhdHVyZVNldF9FbnVtVHlwZSlcbnByb3RvMi51dGlsLnNldEVudW1UeXBlKEZlYXR1cmVTZXRfRW51bVR5cGUsIFwiZ29vZ2xlLnByb3RvYnVmLkZlYXR1cmVTZXQuRW51bVR5cGVcIiwgW1xuICAgIHsgbm86IDAsIG5hbWU6IFwiRU5VTV9UWVBFX1VOS05PV05cIiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiT1BFTlwiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJDTE9TRURcIiB9LFxuXSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGdvb2dsZS5wcm90b2J1Zi5GZWF0dXJlU2V0LlJlcGVhdGVkRmllbGRFbmNvZGluZ1xuICovXG52YXIgRmVhdHVyZVNldF9SZXBlYXRlZEZpZWxkRW5jb2Rpbmc7XG4oZnVuY3Rpb24gKEZlYXR1cmVTZXRfUmVwZWF0ZWRGaWVsZEVuY29kaW5nKSB7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFJFUEVBVEVEX0ZJRUxEX0VOQ09ESU5HX1VOS05PV04gPSAwO1xuICAgICAqL1xuICAgIEZlYXR1cmVTZXRfUmVwZWF0ZWRGaWVsZEVuY29kaW5nW0ZlYXR1cmVTZXRfUmVwZWF0ZWRGaWVsZEVuY29kaW5nW1wiUkVQRUFURURfRklFTERfRU5DT0RJTkdfVU5LTk9XTlwiXSA9IDBdID0gXCJSRVBFQVRFRF9GSUVMRF9FTkNPRElOR19VTktOT1dOXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFBBQ0tFRCA9IDE7XG4gICAgICovXG4gICAgRmVhdHVyZVNldF9SZXBlYXRlZEZpZWxkRW5jb2RpbmdbRmVhdHVyZVNldF9SZXBlYXRlZEZpZWxkRW5jb2RpbmdbXCJQQUNLRURcIl0gPSAxXSA9IFwiUEFDS0VEXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEVYUEFOREVEID0gMjtcbiAgICAgKi9cbiAgICBGZWF0dXJlU2V0X1JlcGVhdGVkRmllbGRFbmNvZGluZ1tGZWF0dXJlU2V0X1JlcGVhdGVkRmllbGRFbmNvZGluZ1tcIkVYUEFOREVEXCJdID0gMl0gPSBcIkVYUEFOREVEXCI7XG59KShGZWF0dXJlU2V0X1JlcGVhdGVkRmllbGRFbmNvZGluZyB8fCAoRmVhdHVyZVNldF9SZXBlYXRlZEZpZWxkRW5jb2RpbmcgPSB7fSkpO1xuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzIuZ2V0RW51bVR5cGUoRmVhdHVyZVNldF9SZXBlYXRlZEZpZWxkRW5jb2RpbmcpXG5wcm90bzIudXRpbC5zZXRFbnVtVHlwZShGZWF0dXJlU2V0X1JlcGVhdGVkRmllbGRFbmNvZGluZywgXCJnb29nbGUucHJvdG9idWYuRmVhdHVyZVNldC5SZXBlYXRlZEZpZWxkRW5jb2RpbmdcIiwgW1xuICAgIHsgbm86IDAsIG5hbWU6IFwiUkVQRUFURURfRklFTERfRU5DT0RJTkdfVU5LTk9XTlwiIH0sXG4gICAgeyBubzogMSwgbmFtZTogXCJQQUNLRURcIiB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiRVhQQU5ERURcIiB9LFxuXSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGdvb2dsZS5wcm90b2J1Zi5GZWF0dXJlU2V0LlV0ZjhWYWxpZGF0aW9uXG4gKi9cbnZhciBGZWF0dXJlU2V0X1V0ZjhWYWxpZGF0aW9uO1xuKGZ1bmN0aW9uIChGZWF0dXJlU2V0X1V0ZjhWYWxpZGF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFVURjhfVkFMSURBVElPTl9VTktOT1dOID0gMDtcbiAgICAgKi9cbiAgICBGZWF0dXJlU2V0X1V0ZjhWYWxpZGF0aW9uW0ZlYXR1cmVTZXRfVXRmOFZhbGlkYXRpb25bXCJVVEY4X1ZBTElEQVRJT05fVU5LTk9XTlwiXSA9IDBdID0gXCJVVEY4X1ZBTElEQVRJT05fVU5LTk9XTlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBOT05FID0gMTtcbiAgICAgKi9cbiAgICBGZWF0dXJlU2V0X1V0ZjhWYWxpZGF0aW9uW0ZlYXR1cmVTZXRfVXRmOFZhbGlkYXRpb25bXCJOT05FXCJdID0gMV0gPSBcIk5PTkVcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVkVSSUZZID0gMjtcbiAgICAgKi9cbiAgICBGZWF0dXJlU2V0X1V0ZjhWYWxpZGF0aW9uW0ZlYXR1cmVTZXRfVXRmOFZhbGlkYXRpb25bXCJWRVJJRllcIl0gPSAyXSA9IFwiVkVSSUZZXCI7XG59KShGZWF0dXJlU2V0X1V0ZjhWYWxpZGF0aW9uIHx8IChGZWF0dXJlU2V0X1V0ZjhWYWxpZGF0aW9uID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8yLmdldEVudW1UeXBlKEZlYXR1cmVTZXRfVXRmOFZhbGlkYXRpb24pXG5wcm90bzIudXRpbC5zZXRFbnVtVHlwZShGZWF0dXJlU2V0X1V0ZjhWYWxpZGF0aW9uLCBcImdvb2dsZS5wcm90b2J1Zi5GZWF0dXJlU2V0LlV0ZjhWYWxpZGF0aW9uXCIsIFtcbiAgICB7IG5vOiAwLCBuYW1lOiBcIlVURjhfVkFMSURBVElPTl9VTktOT1dOXCIgfSxcbiAgICB7IG5vOiAxLCBuYW1lOiBcIk5PTkVcIiB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiVkVSSUZZXCIgfSxcbl0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBnb29nbGUucHJvdG9idWYuRmVhdHVyZVNldC5NZXNzYWdlRW5jb2RpbmdcbiAqL1xudmFyIEZlYXR1cmVTZXRfTWVzc2FnZUVuY29kaW5nO1xuKGZ1bmN0aW9uIChGZWF0dXJlU2V0X01lc3NhZ2VFbmNvZGluZykge1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBNRVNTQUdFX0VOQ09ESU5HX1VOS05PV04gPSAwO1xuICAgICAqL1xuICAgIEZlYXR1cmVTZXRfTWVzc2FnZUVuY29kaW5nW0ZlYXR1cmVTZXRfTWVzc2FnZUVuY29kaW5nW1wiTUVTU0FHRV9FTkNPRElOR19VTktOT1dOXCJdID0gMF0gPSBcIk1FU1NBR0VfRU5DT0RJTkdfVU5LTk9XTlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBMRU5HVEhfUFJFRklYRUQgPSAxO1xuICAgICAqL1xuICAgIEZlYXR1cmVTZXRfTWVzc2FnZUVuY29kaW5nW0ZlYXR1cmVTZXRfTWVzc2FnZUVuY29kaW5nW1wiTEVOR1RIX1BSRUZJWEVEXCJdID0gMV0gPSBcIkxFTkdUSF9QUkVGSVhFRFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBERUxJTUlURUQgPSAyO1xuICAgICAqL1xuICAgIEZlYXR1cmVTZXRfTWVzc2FnZUVuY29kaW5nW0ZlYXR1cmVTZXRfTWVzc2FnZUVuY29kaW5nW1wiREVMSU1JVEVEXCJdID0gMl0gPSBcIkRFTElNSVRFRFwiO1xufSkoRmVhdHVyZVNldF9NZXNzYWdlRW5jb2RpbmcgfHwgKEZlYXR1cmVTZXRfTWVzc2FnZUVuY29kaW5nID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8yLmdldEVudW1UeXBlKEZlYXR1cmVTZXRfTWVzc2FnZUVuY29kaW5nKVxucHJvdG8yLnV0aWwuc2V0RW51bVR5cGUoRmVhdHVyZVNldF9NZXNzYWdlRW5jb2RpbmcsIFwiZ29vZ2xlLnByb3RvYnVmLkZlYXR1cmVTZXQuTWVzc2FnZUVuY29kaW5nXCIsIFtcbiAgICB7IG5vOiAwLCBuYW1lOiBcIk1FU1NBR0VfRU5DT0RJTkdfVU5LTk9XTlwiIH0sXG4gICAgeyBubzogMSwgbmFtZTogXCJMRU5HVEhfUFJFRklYRURcIiB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiREVMSU1JVEVEXCIgfSxcbl0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBnb29nbGUucHJvdG9idWYuRmVhdHVyZVNldC5Kc29uRm9ybWF0XG4gKi9cbnZhciBGZWF0dXJlU2V0X0pzb25Gb3JtYXQ7XG4oZnVuY3Rpb24gKEZlYXR1cmVTZXRfSnNvbkZvcm1hdCkge1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBKU09OX0ZPUk1BVF9VTktOT1dOID0gMDtcbiAgICAgKi9cbiAgICBGZWF0dXJlU2V0X0pzb25Gb3JtYXRbRmVhdHVyZVNldF9Kc29uRm9ybWF0W1wiSlNPTl9GT1JNQVRfVU5LTk9XTlwiXSA9IDBdID0gXCJKU09OX0ZPUk1BVF9VTktOT1dOXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEFMTE9XID0gMTtcbiAgICAgKi9cbiAgICBGZWF0dXJlU2V0X0pzb25Gb3JtYXRbRmVhdHVyZVNldF9Kc29uRm9ybWF0W1wiQUxMT1dcIl0gPSAxXSA9IFwiQUxMT1dcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogTEVHQUNZX0JFU1RfRUZGT1JUID0gMjtcbiAgICAgKi9cbiAgICBGZWF0dXJlU2V0X0pzb25Gb3JtYXRbRmVhdHVyZVNldF9Kc29uRm9ybWF0W1wiTEVHQUNZX0JFU1RfRUZGT1JUXCJdID0gMl0gPSBcIkxFR0FDWV9CRVNUX0VGRk9SVFwiO1xufSkoRmVhdHVyZVNldF9Kc29uRm9ybWF0IHx8IChGZWF0dXJlU2V0X0pzb25Gb3JtYXQgPSB7fSkpO1xuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzIuZ2V0RW51bVR5cGUoRmVhdHVyZVNldF9Kc29uRm9ybWF0KVxucHJvdG8yLnV0aWwuc2V0RW51bVR5cGUoRmVhdHVyZVNldF9Kc29uRm9ybWF0LCBcImdvb2dsZS5wcm90b2J1Zi5GZWF0dXJlU2V0Lkpzb25Gb3JtYXRcIiwgW1xuICAgIHsgbm86IDAsIG5hbWU6IFwiSlNPTl9GT1JNQVRfVU5LTk9XTlwiIH0sXG4gICAgeyBubzogMSwgbmFtZTogXCJBTExPV1wiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJMRUdBQ1lfQkVTVF9FRkZPUlRcIiB9LFxuXSk7XG4vKipcbiAqIEEgY29tcGlsZWQgc3BlY2lmaWNhdGlvbiBmb3IgdGhlIGRlZmF1bHRzIG9mIGEgc2V0IG9mIGZlYXR1cmVzLiAgVGhlc2VcbiAqIG1lc3NhZ2VzIGFyZSBnZW5lcmF0ZWQgZnJvbSBGZWF0dXJlU2V0IGV4dGVuc2lvbnMgYW5kIGNhbiBiZSB1c2VkIHRvIHNlZWRcbiAqIGZlYXR1cmUgcmVzb2x1dGlvbi4gVGhlIHJlc29sdXRpb24gd2l0aCB0aGlzIG9iamVjdCBiZWNvbWVzIGEgc2ltcGxlIHNlYXJjaFxuICogZm9yIHRoZSBjbG9zZXN0IG1hdGNoaW5nIGVkaXRpb24sIGZvbGxvd2VkIGJ5IHByb3RvIG1lcmdlcy5cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuRmVhdHVyZVNldERlZmF1bHRzXG4gKi9cbmNsYXNzIEZlYXR1cmVTZXREZWZhdWx0cyBleHRlbmRzIGVzbV9tZXNzYWdlLyogTWVzc2FnZSAqLy52IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGdvb2dsZS5wcm90b2J1Zi5GZWF0dXJlU2V0RGVmYXVsdHMuRmVhdHVyZVNldEVkaXRpb25EZWZhdWx0IGRlZmF1bHRzID0gMTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVmYXVsdHMgPSBbXTtcbiAgICAgICAgcHJvdG8yLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmVhdHVyZVNldERlZmF1bHRzKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGZWF0dXJlU2V0RGVmYXVsdHMoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEZlYXR1cmVTZXREZWZhdWx0cygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvMi51dGlsLmVxdWFscyhGZWF0dXJlU2V0RGVmYXVsdHMsIGEsIGIpO1xuICAgIH1cbn1cbkZlYXR1cmVTZXREZWZhdWx0cy5ydW50aW1lID0gcHJvdG8yO1xuRmVhdHVyZVNldERlZmF1bHRzLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuRmVhdHVyZVNldERlZmF1bHRzXCI7XG5GZWF0dXJlU2V0RGVmYXVsdHMuZmllbGRzID0gcHJvdG8yLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImRlZmF1bHRzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBGZWF0dXJlU2V0RGVmYXVsdHNfRmVhdHVyZVNldEVkaXRpb25EZWZhdWx0LCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwibWluaW11bV9lZGl0aW9uXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzIuZ2V0RW51bVR5cGUoRWRpdGlvbiksIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwibWF4aW11bV9lZGl0aW9uXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzIuZ2V0RW51bVR5cGUoRWRpdGlvbiksIG9wdDogdHJ1ZSB9LFxuXSk7XG4vKipcbiAqIEEgbWFwIGZyb20gZXZlcnkga25vd24gZWRpdGlvbiB3aXRoIGEgdW5pcXVlIHNldCBvZiBkZWZhdWx0cyB0byBpdHNcbiAqIGRlZmF1bHRzLiBOb3QgYWxsIGVkaXRpb25zIG1heSBiZSBjb250YWluZWQgaGVyZS4gIEZvciBhIGdpdmVuIGVkaXRpb24sXG4gKiB0aGUgZGVmYXVsdHMgYXQgdGhlIGNsb3Nlc3QgbWF0Y2hpbmcgZWRpdGlvbiBvcmRlcmVkIGF0IG9yIGJlZm9yZSBpdCBzaG91bGRcbiAqIGJlIHVzZWQuICBUaGlzIGZpZWxkIG11c3QgYmUgaW4gc3RyaWN0IGFzY2VuZGluZyBvcmRlciBieSBlZGl0aW9uLlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5GZWF0dXJlU2V0RGVmYXVsdHMuRmVhdHVyZVNldEVkaXRpb25EZWZhdWx0XG4gKi9cbmNsYXNzIEZlYXR1cmVTZXREZWZhdWx0c19GZWF0dXJlU2V0RWRpdGlvbkRlZmF1bHQgZXh0ZW5kcyBlc21fbWVzc2FnZS8qIE1lc3NhZ2UgKi8udiB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBwcm90bzIudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGZWF0dXJlU2V0RGVmYXVsdHNfRmVhdHVyZVNldEVkaXRpb25EZWZhdWx0KCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGZWF0dXJlU2V0RGVmYXVsdHNfRmVhdHVyZVNldEVkaXRpb25EZWZhdWx0KCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGZWF0dXJlU2V0RGVmYXVsdHNfRmVhdHVyZVNldEVkaXRpb25EZWZhdWx0KCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gcHJvdG8yLnV0aWwuZXF1YWxzKEZlYXR1cmVTZXREZWZhdWx0c19GZWF0dXJlU2V0RWRpdGlvbkRlZmF1bHQsIGEsIGIpO1xuICAgIH1cbn1cbkZlYXR1cmVTZXREZWZhdWx0c19GZWF0dXJlU2V0RWRpdGlvbkRlZmF1bHQucnVudGltZSA9IHByb3RvMjtcbkZlYXR1cmVTZXREZWZhdWx0c19GZWF0dXJlU2V0RWRpdGlvbkRlZmF1bHQudHlwZU5hbWUgPSBcImdvb2dsZS5wcm90b2J1Zi5GZWF0dXJlU2V0RGVmYXVsdHMuRmVhdHVyZVNldEVkaXRpb25EZWZhdWx0XCI7XG5GZWF0dXJlU2V0RGVmYXVsdHNfRmVhdHVyZVNldEVkaXRpb25EZWZhdWx0LmZpZWxkcyA9IHByb3RvMi51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMywgbmFtZTogXCJlZGl0aW9uXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzIuZ2V0RW51bVR5cGUoRWRpdGlvbiksIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiZmVhdHVyZXNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEZlYXR1cmVTZXQsIG9wdDogdHJ1ZSB9LFxuXSk7XG4vKipcbiAqIEVuY2Fwc3VsYXRlcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgZnJvbSB3aGljaCBhXG4gKiBGaWxlRGVzY3JpcHRvclByb3RvIHdhcyBnZW5lcmF0ZWQuXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLlNvdXJjZUNvZGVJbmZvXG4gKi9cbmNsYXNzIFNvdXJjZUNvZGVJbmZvIGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgTG9jYXRpb24gaWRlbnRpZmllcyBhIHBpZWNlIG9mIHNvdXJjZSBjb2RlIGluIGEgLnByb3RvIGZpbGUgd2hpY2hcbiAgICAgICAgICogY29ycmVzcG9uZHMgdG8gYSBwYXJ0aWN1bGFyIGRlZmluaXRpb24uICBUaGlzIGluZm9ybWF0aW9uIGlzIGludGVuZGVkXG4gICAgICAgICAqIHRvIGJlIHVzZWZ1bCB0byBJREVzLCBjb2RlIGluZGV4ZXJzLCBkb2N1bWVudGF0aW9uIGdlbmVyYXRvcnMsIGFuZCBzaW1pbGFyXG4gICAgICAgICAqIHRvb2xzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgZXhhbXBsZSwgc2F5IHdlIGhhdmUgYSBmaWxlIGxpa2U6XG4gICAgICAgICAqICAgbWVzc2FnZSBGb28ge1xuICAgICAgICAgKiAgICAgb3B0aW9uYWwgc3RyaW5nIGZvbyA9IDE7XG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiBMZXQncyBsb29rIGF0IGp1c3QgdGhlIGZpZWxkIGRlZmluaXRpb246XG4gICAgICAgICAqICAgb3B0aW9uYWwgc3RyaW5nIGZvbyA9IDE7XG4gICAgICAgICAqICAgXiAgICAgICBeXiAgICAgXl4gIF4gIF5eXlxuICAgICAgICAgKiAgIGEgICAgICAgYmMgICAgIGRlICBmICBnaGlcbiAgICAgICAgICogV2UgaGF2ZSB0aGUgZm9sbG93aW5nIGxvY2F0aW9uczpcbiAgICAgICAgICogICBzcGFuICAgcGF0aCAgICAgICAgICAgICAgIHJlcHJlc2VudHNcbiAgICAgICAgICogICBbYSxpKSAgWyA0LCAwLCAyLCAwIF0gICAgIFRoZSB3aG9sZSBmaWVsZCBkZWZpbml0aW9uLlxuICAgICAgICAgKiAgIFthLGIpICBbIDQsIDAsIDIsIDAsIDQgXSAgVGhlIGxhYmVsIChvcHRpb25hbCkuXG4gICAgICAgICAqICAgW2MsZCkgIFsgNCwgMCwgMiwgMCwgNSBdICBUaGUgdHlwZSAoc3RyaW5nKS5cbiAgICAgICAgICogICBbZSxmKSAgWyA0LCAwLCAyLCAwLCAxIF0gIFRoZSBuYW1lIChmb28pLlxuICAgICAgICAgKiAgIFtnLGgpICBbIDQsIDAsIDIsIDAsIDMgXSAgVGhlIG51bWJlciAoMSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGVzOlxuICAgICAgICAgKiAtIEEgbG9jYXRpb24gbWF5IHJlZmVyIHRvIGEgcmVwZWF0ZWQgZmllbGQgaXRzZWxmIChpLmUuIG5vdCB0byBhbnlcbiAgICAgICAgICogICBwYXJ0aWN1bGFyIGluZGV4IHdpdGhpbiBpdCkuICBUaGlzIGlzIHVzZWQgd2hlbmV2ZXIgYSBzZXQgb2YgZWxlbWVudHMgYXJlXG4gICAgICAgICAqICAgbG9naWNhbGx5IGVuY2xvc2VkIGluIGEgc2luZ2xlIGNvZGUgc2VnbWVudC4gIEZvciBleGFtcGxlLCBhbiBlbnRpcmVcbiAgICAgICAgICogICBleHRlbmQgYmxvY2sgKHBvc3NpYmx5IGNvbnRhaW5pbmcgbXVsdGlwbGUgZXh0ZW5zaW9uIGRlZmluaXRpb25zKSB3aWxsXG4gICAgICAgICAqICAgaGF2ZSBhbiBvdXRlciBsb2NhdGlvbiB3aG9zZSBwYXRoIHJlZmVycyB0byB0aGUgXCJleHRlbnNpb25zXCIgcmVwZWF0ZWRcbiAgICAgICAgICogICBmaWVsZCB3aXRob3V0IGFuIGluZGV4LlxuICAgICAgICAgKiAtIE11bHRpcGxlIGxvY2F0aW9ucyBtYXkgaGF2ZSB0aGUgc2FtZSBwYXRoLiAgVGhpcyBoYXBwZW5zIHdoZW4gYSBzaW5nbGVcbiAgICAgICAgICogICBsb2dpY2FsIGRlY2xhcmF0aW9uIGlzIHNwcmVhZCBvdXQgYWNyb3NzIG11bHRpcGxlIHBsYWNlcy4gIFRoZSBtb3N0XG4gICAgICAgICAqICAgb2J2aW91cyBleGFtcGxlIGlzIHRoZSBcImV4dGVuZFwiIGJsb2NrIGFnYWluIC0tIHRoZXJlIG1heSBiZSBtdWx0aXBsZVxuICAgICAgICAgKiAgIGV4dGVuZCBibG9ja3MgaW4gdGhlIHNhbWUgc2NvcGUsIGVhY2ggb2Ygd2hpY2ggd2lsbCBoYXZlIHRoZSBzYW1lIHBhdGguXG4gICAgICAgICAqIC0gQSBsb2NhdGlvbidzIHNwYW4gaXMgbm90IGFsd2F5cyBhIHN1YnNldCBvZiBpdHMgcGFyZW50J3Mgc3Bhbi4gIEZvclxuICAgICAgICAgKiAgIGV4YW1wbGUsIHRoZSBcImV4dGVuZGVlXCIgb2YgYW4gZXh0ZW5zaW9uIGRlY2xhcmF0aW9uIGFwcGVhcnMgYXQgdGhlXG4gICAgICAgICAqICAgYmVnaW5uaW5nIG9mIHRoZSBcImV4dGVuZFwiIGJsb2NrIGFuZCBpcyBzaGFyZWQgYnkgYWxsIGV4dGVuc2lvbnMgd2l0aGluXG4gICAgICAgICAqICAgdGhlIGJsb2NrLlxuICAgICAgICAgKiAtIEp1c3QgYmVjYXVzZSBhIGxvY2F0aW9uJ3Mgc3BhbiBpcyBhIHN1YnNldCBvZiBzb21lIG90aGVyIGxvY2F0aW9uJ3Mgc3BhblxuICAgICAgICAgKiAgIGRvZXMgbm90IG1lYW4gdGhhdCBpdCBpcyBhIGRlc2NlbmRhbnQuICBGb3IgZXhhbXBsZSwgYSBcImdyb3VwXCIgZGVmaW5lc1xuICAgICAgICAgKiAgIGJvdGggYSB0eXBlIGFuZCBhIGZpZWxkIGluIGEgc2luZ2xlIGRlY2xhcmF0aW9uLiAgVGh1cywgdGhlIGxvY2F0aW9uc1xuICAgICAgICAgKiAgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHR5cGUgYW5kIGZpZWxkIGFuZCB0aGVpciBjb21wb25lbnRzIHdpbGwgb3ZlcmxhcC5cbiAgICAgICAgICogLSBDb2RlIHdoaWNoIHRyaWVzIHRvIGludGVycHJldCBsb2NhdGlvbnMgc2hvdWxkIHByb2JhYmx5IGJlIGRlc2lnbmVkIHRvXG4gICAgICAgICAqICAgaWdub3JlIHRob3NlIHRoYXQgaXQgZG9lc24ndCB1bmRlcnN0YW5kLCBhcyBtb3JlIHR5cGVzIG9mIGxvY2F0aW9ucyBjb3VsZFxuICAgICAgICAgKiAgIGJlIHJlY29yZGVkIGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgZ29vZ2xlLnByb3RvYnVmLlNvdXJjZUNvZGVJbmZvLkxvY2F0aW9uIGxvY2F0aW9uID0gMTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBbXTtcbiAgICAgICAgcHJvdG8yLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgU291cmNlQ29kZUluZm8oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFNvdXJjZUNvZGVJbmZvKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3VyY2VDb2RlSW5mbygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvMi51dGlsLmVxdWFscyhTb3VyY2VDb2RlSW5mbywgYSwgYik7XG4gICAgfVxufVxuU291cmNlQ29kZUluZm8ucnVudGltZSA9IHByb3RvMjtcblNvdXJjZUNvZGVJbmZvLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuU291cmNlQ29kZUluZm9cIjtcblNvdXJjZUNvZGVJbmZvLmZpZWxkcyA9IHByb3RvMi51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJsb2NhdGlvblwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU291cmNlQ29kZUluZm9fTG9jYXRpb24sIHJlcGVhdGVkOiB0cnVlIH0sXG5dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLlNvdXJjZUNvZGVJbmZvLkxvY2F0aW9uXG4gKi9cbmNsYXNzIFNvdXJjZUNvZGVJbmZvX0xvY2F0aW9uIGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElkZW50aWZpZXMgd2hpY2ggcGFydCBvZiB0aGUgRmlsZURlc2NyaXB0b3JQcm90byB3YXMgZGVmaW5lZCBhdCB0aGlzXG4gICAgICAgICAqIGxvY2F0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBFYWNoIGVsZW1lbnQgaXMgYSBmaWVsZCBudW1iZXIgb3IgYW4gaW5kZXguICBUaGV5IGZvcm0gYSBwYXRoIGZyb21cbiAgICAgICAgICogdGhlIHJvb3QgRmlsZURlc2NyaXB0b3JQcm90byB0byB0aGUgcGxhY2Ugd2hlcmUgdGhlIGRlZmluaXRpb24gb2NjdXJzLlxuICAgICAgICAgKiBGb3IgZXhhbXBsZSwgdGhpcyBwYXRoOlxuICAgICAgICAgKiAgIFsgNCwgMywgMiwgNywgMSBdXG4gICAgICAgICAqIHJlZmVycyB0bzpcbiAgICAgICAgICogICBmaWxlLm1lc3NhZ2VfdHlwZSgzKSAgLy8gNCwgM1xuICAgICAgICAgKiAgICAgICAuZmllbGQoNykgICAgICAgICAvLyAyLCA3XG4gICAgICAgICAqICAgICAgIC5uYW1lKCkgICAgICAgICAgIC8vIDFcbiAgICAgICAgICogVGhpcyBpcyBiZWNhdXNlIEZpbGVEZXNjcmlwdG9yUHJvdG8ubWVzc2FnZV90eXBlIGhhcyBmaWVsZCBudW1iZXIgNDpcbiAgICAgICAgICogICByZXBlYXRlZCBEZXNjcmlwdG9yUHJvdG8gbWVzc2FnZV90eXBlID0gNDtcbiAgICAgICAgICogYW5kIERlc2NyaXB0b3JQcm90by5maWVsZCBoYXMgZmllbGQgbnVtYmVyIDI6XG4gICAgICAgICAqICAgcmVwZWF0ZWQgRmllbGREZXNjcmlwdG9yUHJvdG8gZmllbGQgPSAyO1xuICAgICAgICAgKiBhbmQgRmllbGREZXNjcmlwdG9yUHJvdG8ubmFtZSBoYXMgZmllbGQgbnVtYmVyIDE6XG4gICAgICAgICAqICAgb3B0aW9uYWwgc3RyaW5nIG5hbWUgPSAxO1xuICAgICAgICAgKlxuICAgICAgICAgKiBUaHVzLCB0aGUgYWJvdmUgcGF0aCBnaXZlcyB0aGUgbG9jYXRpb24gb2YgYSBmaWVsZCBuYW1lLiAgSWYgd2UgcmVtb3ZlZFxuICAgICAgICAgKiB0aGUgbGFzdCBlbGVtZW50OlxuICAgICAgICAgKiAgIFsgNCwgMywgMiwgNyBdXG4gICAgICAgICAqIHRoaXMgcGF0aCByZWZlcnMgdG8gdGhlIHdob2xlIGZpZWxkIGRlY2xhcmF0aW9uIChmcm9tIHRoZSBiZWdpbm5pbmdcbiAgICAgICAgICogb2YgdGhlIGxhYmVsIHRvIHRoZSB0ZXJtaW5hdGluZyBzZW1pY29sb24pLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGludDMyIHBhdGggPSAxIFtwYWNrZWQgPSB0cnVlXTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGF0aCA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQWx3YXlzIGhhcyBleGFjdGx5IHRocmVlIG9yIGZvdXIgZWxlbWVudHM6IHN0YXJ0IGxpbmUsIHN0YXJ0IGNvbHVtbixcbiAgICAgICAgICogZW5kIGxpbmUgKG9wdGlvbmFsLCBvdGhlcndpc2UgYXNzdW1lZCBzYW1lIGFzIHN0YXJ0IGxpbmUpLCBlbmQgY29sdW1uLlxuICAgICAgICAgKiBUaGVzZSBhcmUgcGFja2VkIGludG8gYSBzaW5nbGUgZmllbGQgZm9yIGVmZmljaWVuY3kuICBOb3RlIHRoYXQgbGluZVxuICAgICAgICAgKiBhbmQgY29sdW1uIG51bWJlcnMgYXJlIHplcm8tYmFzZWQgLS0gdHlwaWNhbGx5IHlvdSB3aWxsIHdhbnQgdG8gYWRkXG4gICAgICAgICAqIDEgdG8gZWFjaCBiZWZvcmUgZGlzcGxheWluZyB0byBhIHVzZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgaW50MzIgc3BhbiA9IDIgW3BhY2tlZCA9IHRydWVdO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zcGFuID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIHN0cmluZyBsZWFkaW5nX2RldGFjaGVkX2NvbW1lbnRzID0gNjtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGVhZGluZ0RldGFjaGVkQ29tbWVudHMgPSBbXTtcbiAgICAgICAgcHJvdG8yLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgU291cmNlQ29kZUluZm9fTG9jYXRpb24oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFNvdXJjZUNvZGVJbmZvX0xvY2F0aW9uKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3VyY2VDb2RlSW5mb19Mb2NhdGlvbigpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvMi51dGlsLmVxdWFscyhTb3VyY2VDb2RlSW5mb19Mb2NhdGlvbiwgYSwgYik7XG4gICAgfVxufVxuU291cmNlQ29kZUluZm9fTG9jYXRpb24ucnVudGltZSA9IHByb3RvMjtcblNvdXJjZUNvZGVJbmZvX0xvY2F0aW9uLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuU291cmNlQ29kZUluZm8uTG9jYXRpb25cIjtcblNvdXJjZUNvZGVJbmZvX0xvY2F0aW9uLmZpZWxkcyA9IHByb3RvMi51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJwYXRoXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDUgLyogU2NhbGFyVHlwZS5JTlQzMiAqLywgcmVwZWF0ZWQ6IHRydWUsIHBhY2tlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwic3BhblwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8sIHJlcGVhdGVkOiB0cnVlLCBwYWNrZWQ6IHRydWUgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImxlYWRpbmdfY29tbWVudHNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJ0cmFpbGluZ19jb21tZW50c1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcImxlYWRpbmdfZGV0YWNoZWRfY29tbWVudHNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgcmVwZWF0ZWQ6IHRydWUgfSxcbl0pO1xuLyoqXG4gKiBEZXNjcmliZXMgdGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIGdlbmVyYXRlZCBjb2RlIGFuZCBpdHMgb3JpZ2luYWwgc291cmNlXG4gKiBmaWxlLiBBIEdlbmVyYXRlZENvZGVJbmZvIG1lc3NhZ2UgaXMgYXNzb2NpYXRlZCB3aXRoIG9ubHkgb25lIGdlbmVyYXRlZFxuICogc291cmNlIGZpbGUsIGJ1dCBtYXkgY29udGFpbiByZWZlcmVuY2VzIHRvIGRpZmZlcmVudCBzb3VyY2UgLnByb3RvIGZpbGVzLlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5HZW5lcmF0ZWRDb2RlSW5mb1xuICovXG5jbGFzcyBHZW5lcmF0ZWRDb2RlSW5mbyBleHRlbmRzIGVzbV9tZXNzYWdlLyogTWVzc2FnZSAqLy52IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBBbm5vdGF0aW9uIGNvbm5lY3RzIHNvbWUgc3BhbiBvZiB0ZXh0IGluIGdlbmVyYXRlZCBjb2RlIHRvIGFuIGVsZW1lbnRcbiAgICAgICAgICogb2YgaXRzIGdlbmVyYXRpbmcgLnByb3RvIGZpbGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgZ29vZ2xlLnByb3RvYnVmLkdlbmVyYXRlZENvZGVJbmZvLkFubm90YXRpb24gYW5ub3RhdGlvbiA9IDE7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFubm90YXRpb24gPSBbXTtcbiAgICAgICAgcHJvdG8yLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgR2VuZXJhdGVkQ29kZUluZm8oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEdlbmVyYXRlZENvZGVJbmZvKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmF0ZWRDb2RlSW5mbygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvMi51dGlsLmVxdWFscyhHZW5lcmF0ZWRDb2RlSW5mbywgYSwgYik7XG4gICAgfVxufVxuR2VuZXJhdGVkQ29kZUluZm8ucnVudGltZSA9IHByb3RvMjtcbkdlbmVyYXRlZENvZGVJbmZvLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuR2VuZXJhdGVkQ29kZUluZm9cIjtcbkdlbmVyYXRlZENvZGVJbmZvLmZpZWxkcyA9IHByb3RvMi51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJhbm5vdGF0aW9uXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBHZW5lcmF0ZWRDb2RlSW5mb19Bbm5vdGF0aW9uLCByZXBlYXRlZDogdHJ1ZSB9LFxuXSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5HZW5lcmF0ZWRDb2RlSW5mby5Bbm5vdGF0aW9uXG4gKi9cbmNsYXNzIEdlbmVyYXRlZENvZGVJbmZvX0Fubm90YXRpb24gZXh0ZW5kcyBlc21fbWVzc2FnZS8qIE1lc3NhZ2UgKi8udiB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWRlbnRpZmllcyB0aGUgZWxlbWVudCBpbiB0aGUgb3JpZ2luYWwgc291cmNlIC5wcm90byBmaWxlLiBUaGlzIGZpZWxkXG4gICAgICAgICAqIGlzIGZvcm1hdHRlZCB0aGUgc2FtZSBhcyBTb3VyY2VDb2RlSW5mby5Mb2NhdGlvbi5wYXRoLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGludDMyIHBhdGggPSAxIFtwYWNrZWQgPSB0cnVlXTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGF0aCA9IFtdO1xuICAgICAgICBwcm90bzIudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmF0ZWRDb2RlSW5mb19Bbm5vdGF0aW9uKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmF0ZWRDb2RlSW5mb19Bbm5vdGF0aW9uKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmF0ZWRDb2RlSW5mb19Bbm5vdGF0aW9uKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gcHJvdG8yLnV0aWwuZXF1YWxzKEdlbmVyYXRlZENvZGVJbmZvX0Fubm90YXRpb24sIGEsIGIpO1xuICAgIH1cbn1cbkdlbmVyYXRlZENvZGVJbmZvX0Fubm90YXRpb24ucnVudGltZSA9IHByb3RvMjtcbkdlbmVyYXRlZENvZGVJbmZvX0Fubm90YXRpb24udHlwZU5hbWUgPSBcImdvb2dsZS5wcm90b2J1Zi5HZW5lcmF0ZWRDb2RlSW5mby5Bbm5vdGF0aW9uXCI7XG5HZW5lcmF0ZWRDb2RlSW5mb19Bbm5vdGF0aW9uLmZpZWxkcyA9IHByb3RvMi51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJwYXRoXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDUgLyogU2NhbGFyVHlwZS5JTlQzMiAqLywgcmVwZWF0ZWQ6IHRydWUsIHBhY2tlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwic291cmNlX2ZpbGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJiZWdpblwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8sIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwiZW5kXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDUgLyogU2NhbGFyVHlwZS5JTlQzMiAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJzZW1hbnRpY1wiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8yLmdldEVudW1UeXBlKEdlbmVyYXRlZENvZGVJbmZvX0Fubm90YXRpb25fU2VtYW50aWMpLCBvcHQ6IHRydWUgfSxcbl0pO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBpZGVudGlmaWVkIG9iamVjdCdzIGVmZmVjdCBvbiB0aGUgZWxlbWVudCBpbiB0aGUgb3JpZ2luYWxcbiAqIC5wcm90byBmaWxlLlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGdvb2dsZS5wcm90b2J1Zi5HZW5lcmF0ZWRDb2RlSW5mby5Bbm5vdGF0aW9uLlNlbWFudGljXG4gKi9cbnZhciBHZW5lcmF0ZWRDb2RlSW5mb19Bbm5vdGF0aW9uX1NlbWFudGljO1xuKGZ1bmN0aW9uIChHZW5lcmF0ZWRDb2RlSW5mb19Bbm5vdGF0aW9uX1NlbWFudGljKSB7XG4gICAgLyoqXG4gICAgICogVGhlcmUgaXMgbm8gZWZmZWN0IG9yIHRoZSBlZmZlY3QgaXMgaW5kZXNjcmliYWJsZS5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBOT05FID0gMDtcbiAgICAgKi9cbiAgICBHZW5lcmF0ZWRDb2RlSW5mb19Bbm5vdGF0aW9uX1NlbWFudGljW0dlbmVyYXRlZENvZGVJbmZvX0Fubm90YXRpb25fU2VtYW50aWNbXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgZWxlbWVudCBpcyBzZXQgb3Igb3RoZXJ3aXNlIG11dGF0ZWQuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogU0VUID0gMTtcbiAgICAgKi9cbiAgICBHZW5lcmF0ZWRDb2RlSW5mb19Bbm5vdGF0aW9uX1NlbWFudGljW0dlbmVyYXRlZENvZGVJbmZvX0Fubm90YXRpb25fU2VtYW50aWNbXCJTRVRcIl0gPSAxXSA9IFwiU0VUXCI7XG4gICAgLyoqXG4gICAgICogQW4gYWxpYXMgdG8gdGhlIGVsZW1lbnQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogQUxJQVMgPSAyO1xuICAgICAqL1xuICAgIEdlbmVyYXRlZENvZGVJbmZvX0Fubm90YXRpb25fU2VtYW50aWNbR2VuZXJhdGVkQ29kZUluZm9fQW5ub3RhdGlvbl9TZW1hbnRpY1tcIkFMSUFTXCJdID0gMl0gPSBcIkFMSUFTXCI7XG59KShHZW5lcmF0ZWRDb2RlSW5mb19Bbm5vdGF0aW9uX1NlbWFudGljIHx8IChHZW5lcmF0ZWRDb2RlSW5mb19Bbm5vdGF0aW9uX1NlbWFudGljID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8yLmdldEVudW1UeXBlKEdlbmVyYXRlZENvZGVJbmZvX0Fubm90YXRpb25fU2VtYW50aWMpXG5wcm90bzIudXRpbC5zZXRFbnVtVHlwZShHZW5lcmF0ZWRDb2RlSW5mb19Bbm5vdGF0aW9uX1NlbWFudGljLCBcImdvb2dsZS5wcm90b2J1Zi5HZW5lcmF0ZWRDb2RlSW5mby5Bbm5vdGF0aW9uLlNlbWFudGljXCIsIFtcbiAgICB7IG5vOiAwLCBuYW1lOiBcIk5PTkVcIiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiU0VUXCIgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIkFMSUFTXCIgfSxcbl0pO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3ByaXZhdGUvdGV4dC1mb3JtYXQuanNcbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cblxuXG5mdW5jdGlvbiBwYXJzZVRleHRGb3JtYXRFbnVtVmFsdWUoZGVzY0VudW0sIHZhbHVlKSB7XG4gICAgY29uc3QgZW51bVZhbHVlID0gZGVzY0VudW0udmFsdWVzLmZpbmQoKHYpID0+IHYubmFtZSA9PT0gdmFsdWUpO1xuICAgICgwLGFzc2VydC8qIGFzc2VydCAqLy5odSkoZW51bVZhbHVlLCBgY2Fubm90IHBhcnNlICR7ZGVzY0VudW0ubmFtZX0gZGVmYXVsdCB2YWx1ZTogJHt2YWx1ZX1gKTtcbiAgICByZXR1cm4gZW51bVZhbHVlLm51bWJlcjtcbn1cbmZ1bmN0aW9uIHBhcnNlVGV4dEZvcm1hdFNjYWxhclZhbHVlKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgZXNtX2ZpZWxkLyogU2NhbGFyVHlwZSAqLy53LlNUUklORzpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSBlc21fZmllbGQvKiBTY2FsYXJUeXBlICovLncuQllURVM6IHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSB1bmVzY2FwZUJ5dGVzRGVmYXVsdFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh1ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHBhcnNlICR7ZXNtX2ZpZWxkLyogU2NhbGFyVHlwZSAqLy53W3R5cGVdfSBkZWZhdWx0IHZhbHVlOiAke3ZhbHVlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBlc21fZmllbGQvKiBTY2FsYXJUeXBlICovLncuSU5UNjQ6XG4gICAgICAgIGNhc2UgZXNtX2ZpZWxkLyogU2NhbGFyVHlwZSAqLy53LlNGSVhFRDY0OlxuICAgICAgICBjYXNlIGVzbV9maWVsZC8qIFNjYWxhclR5cGUgKi8udy5TSU5UNjQ6XG4gICAgICAgICAgICByZXR1cm4gcHJvdG9faW50NjQvKiBwcm90b0ludDY0ICovLnEucGFyc2UodmFsdWUpO1xuICAgICAgICBjYXNlIGVzbV9maWVsZC8qIFNjYWxhclR5cGUgKi8udy5VSU5UNjQ6XG4gICAgICAgIGNhc2UgZXNtX2ZpZWxkLyogU2NhbGFyVHlwZSAqLy53LkZJWEVENjQ6XG4gICAgICAgICAgICByZXR1cm4gcHJvdG9faW50NjQvKiBwcm90b0ludDY0ICovLnEudVBhcnNlKHZhbHVlKTtcbiAgICAgICAgY2FzZSBlc21fZmllbGQvKiBTY2FsYXJUeXBlICovLncuRE9VQkxFOlxuICAgICAgICBjYXNlIGVzbV9maWVsZC8qIFNjYWxhclR5cGUgKi8udy5GTE9BVDpcbiAgICAgICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiaW5mXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIi1pbmZcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICAgICAgICAgICAgICBjYXNlIFwibmFuXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTmFOO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBlc21fZmllbGQvKiBTY2FsYXJUeXBlICovLncuQk9PTDpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgIGNhc2UgZXNtX2ZpZWxkLyogU2NhbGFyVHlwZSAqLy53LklOVDMyOlxuICAgICAgICBjYXNlIGVzbV9maWVsZC8qIFNjYWxhclR5cGUgKi8udy5VSU5UMzI6XG4gICAgICAgIGNhc2UgZXNtX2ZpZWxkLyogU2NhbGFyVHlwZSAqLy53LlNJTlQzMjpcbiAgICAgICAgY2FzZSBlc21fZmllbGQvKiBTY2FsYXJUeXBlICovLncuRklYRUQzMjpcbiAgICAgICAgY2FzZSBlc21fZmllbGQvKiBTY2FsYXJUeXBlICovLncuU0ZJWEVEMzI6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICB9XG59XG4vKipcbiAqIFBhcnNlcyBhIHRleHQtZW5jb2RlZCBkZWZhdWx0IHZhbHVlIChwcm90bzIpIG9mIGEgQllURVMgZmllbGQuXG4gKi9cbmZ1bmN0aW9uIHVuZXNjYXBlQnl0ZXNEZWZhdWx0VmFsdWUoc3RyKSB7XG4gICAgY29uc3QgYiA9IFtdO1xuICAgIGNvbnN0IGlucHV0ID0ge1xuICAgICAgICB0YWlsOiBzdHIsXG4gICAgICAgIGM6IFwiXCIsXG4gICAgICAgIG5leHQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50YWlsLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jID0gdGhpcy50YWlsWzBdO1xuICAgICAgICAgICAgdGhpcy50YWlsID0gdGhpcy50YWlsLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICB0YWtlKG4pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRhaWwubGVuZ3RoID49IG4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gdGhpcy50YWlsLnN1YnN0cmluZygwLCBuKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwuc3Vic3RyaW5nKG4pO1xuICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgd2hpbGUgKGlucHV0Lm5leHQoKSkge1xuICAgICAgICBzd2l0Y2ggKGlucHV0LmMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0Lm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGlucHV0LmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5wdXNoKGlucHV0LmMuY2hhckNvZGVBdCgwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaCgweDA4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5wdXNoKDB4MGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLnB1c2goMHgwYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaCgweDBkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5wdXNoKDB4MDkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInZcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLnB1c2goMHgwYik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiMFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIjFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiM1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIjRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI1XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiNlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIjdcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBpbnB1dC5jO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBpbnB1dC50YWtlKDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBwYXJzZUludChzICsgdCwgOCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKG4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5wdXNoKG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInhcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBpbnB1dC5jO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBpbnB1dC50YWtlKDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBwYXJzZUludChzICsgdCwgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaChuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ1XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzID0gaW5wdXQuYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gaW5wdXQudGFrZSg0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuID0gcGFyc2VJbnQocyArIHQsIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4obikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3LnNldEludDMyKDAsIG4sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaChjaHVua1swXSwgY2h1bmtbMV0sIGNodW5rWzJdLCBjaHVua1szXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiVVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcyA9IGlucHV0LmM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IGlucHV0LnRha2UoOCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGMgPSBwcm90b19pbnQ2NC8qIHByb3RvSW50NjQgKi8ucS51RW5jKHMgKyB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3LnNldEludDMyKDAsIHRjLmxvLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3LnNldEludDMyKDQsIHRjLmhpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLnB1c2goY2h1bmtbMF0sIGNodW5rWzFdLCBjaHVua1syXSwgY2h1bmtbM10sIGNodW5rWzRdLCBjaHVua1s1XSwgY2h1bmtbNl0sIGNodW5rWzddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYi5wdXNoKGlucHV0LmMuY2hhckNvZGVBdCgwKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGIpO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3ByaXZhdGUvZmVhdHVyZS1zZXQuanNcbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cblxuLyoqXG4gKiBTdGF0aWMgZWRpdGlvbiBmZWF0dXJlIGRlZmF1bHRzIHN1cHBvcnRlZCBieSBAYnVmYnVpbGQvcHJvdG9idWYuXG4gKi9cbmNvbnN0IGZlYXR1cmVTZXREZWZhdWx0cyA9IEZlYXR1cmVTZXREZWZhdWx0cy5mcm9tQmluYXJ5KHByb3RvX2Jhc2U2NC8qIHByb3RvQmFzZTY0ICovLlcuZGVjKFxuLyp1cHN0cmVhbS1pbmplY3QtZmVhdHVyZS1kZWZhdWx0cy1zdGFydCovIFwiQ2hFU0RBZ0JFQUlZQWlBQktBRXdBaGptQndvUkVnd0lBaEFCR0FFZ0FpZ0JNQUVZNXdjS0VSSU1DQUVRQVJnQklBSW9BVEFCR09nSElPWUhLT2dIXCIgLyp1cHN0cmVhbS1pbmplY3QtZmVhdHVyZS1kZWZhdWx0cy1lbmQqLykpO1xuLyoqXG4gKiBDcmVhdGUgYW4gZWRpdGlvbiBmZWF0dXJlIHJlc29sdmVyIHdpdGggdGhlIGdpdmVuIGZlYXR1cmUgc2V0IGRlZmF1bHRzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVGZWF0dXJlUmVzb2x2ZXIoY29tcGlsZWRGZWF0dXJlU2V0RGVmYXVsdHMpIHtcbiAgICBjb25zdCBtaW4gPSBjb21waWxlZEZlYXR1cmVTZXREZWZhdWx0cy5taW5pbXVtRWRpdGlvbjtcbiAgICBjb25zdCBtYXggPSBjb21waWxlZEZlYXR1cmVTZXREZWZhdWx0cy5tYXhpbXVtRWRpdGlvbjtcbiAgICBpZiAobWluID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgbWF4ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgY29tcGlsZWRGZWF0dXJlU2V0RGVmYXVsdHMuZGVmYXVsdHMuc29tZSgoZCkgPT4gZC5lZGl0aW9uID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgRmVhdHVyZVNldERlZmF1bHRzXCIpO1xuICAgIH1cbiAgICBjb25zdCBkZWZhdWx0c0JpbkJ5RWRpdGlvbiA9IG5ldyBNYXAoKTtcbiAgICByZXR1cm4gKGVkaXRpb24sIC4uLnJlc3QpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IGRlZmF1bHRzQmluID0gZGVmYXVsdHNCaW5CeUVkaXRpb24uZ2V0KGVkaXRpb24pO1xuICAgICAgICBpZiAoZGVmYXVsdHNCaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGVkaXRpb24gPCBtaW4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVkaXRpb24gJHtFZGl0aW9uW2VkaXRpb25dfSBpcyBlYXJsaWVyIHRoYW4gdGhlIG1pbmltdW0gc3VwcG9ydGVkIGVkaXRpb24gJHtFZGl0aW9uW21pbl19YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF4IDwgZWRpdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRWRpdGlvbiAke0VkaXRpb25bZWRpdGlvbl19IGlzIGxhdGVyIHRoYW4gdGhlIG1heGltdW0gc3VwcG9ydGVkIGVkaXRpb24gJHtFZGl0aW9uW21heF19YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaGlnaGVzdE1hdGNoID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjIG9mIGNvbXBpbGVkRmVhdHVyZVNldERlZmF1bHRzLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IChfYSA9IGMuZWRpdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgICAgICBpZiAoZSA+IGVkaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoaWdoZXN0TWF0Y2ggIT09IHVuZGVmaW5lZCAmJiBoaWdoZXN0TWF0Y2guZSA+IGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhpZ2hlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgICAgICAgZjogKF9iID0gYy5mZWF0dXJlcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IEZlYXR1cmVTZXQoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhpZ2hlc3RNYXRjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyB2YWxpZCBkZWZhdWx0IGZvdW5kIGZvciBlZGl0aW9uICR7RWRpdGlvbltlZGl0aW9uXX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHRzQmluID0gaGlnaGVzdE1hdGNoLmYudG9CaW5hcnkoKTtcbiAgICAgICAgICAgIGRlZmF1bHRzQmluQnlFZGl0aW9uLnNldChlZGl0aW9uLCBkZWZhdWx0c0Jpbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZiA9IEZlYXR1cmVTZXQuZnJvbUJpbmFyeShkZWZhdWx0c0Jpbik7XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiByZXN0KSB7XG4gICAgICAgICAgICBpZiAoYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZi5mcm9tQmluYXJ5KGMudG9CaW5hcnkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWxpZGF0ZU1lcmdlZEZlYXR1cmVzKGYpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgRmVhdHVyZVNldCBmb3IgZWRpdGlvbiAke0VkaXRpb25bZWRpdGlvbl19YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGY7XG4gICAgfTtcbn1cbi8vIFdoZW4gcHJvdG9jIGdlbmVyYXRlcyBnb29nbGUucHJvdG9idWYuRmVhdHVyZVNldERlZmF1bHRzLCBpdCBlbnN1cmVzIHRoYXRcbi8vIGZpZWxkcyBhcmUgbm90IHJlcGVhdGVkIG9yIHJlcXVpcmVkLCBkbyBub3QgdXNlIG9uZW9mLCBhbmQgaGF2ZSBhIGRlZmF1bHRcbi8vIHZhbHVlLlxuLy9cbi8vIFdoZW4gZmVhdHVyZXMgZm9yIGFuIGVsZW1lbnQgYXJlIHJlc29sdmVkLCBmZWF0dXJlcyBvZiB0aGUgZWxlbWVudCBhbmQgaXRzXG4vLyBwYXJlbnRzIGFyZSBtZXJnZWQgaW50byB0aGUgZGVmYXVsdCBGZWF0dXJlU2V0IGZvciB0aGUgZWRpdGlvbi4gQmVjYXVzZSB1bnNldFxuLy8gZmllbGRzIGluIHRoZSBGZWF0dXJlU2V0IG9mIGFuIGVsZW1lbnQgZG8gbm90IHVuc2V0IHRoZSBkZWZhdWx0IEZlYXR1cmVTZXRcbi8vIHZhbHVlcywgYSByZXNvbHZlZCBGZWF0dXJlU2V0IGlzIGd1YXJhbnRlZWQgdG8gaGF2ZSBhbGwgZmllbGRzIHNldC4gVGhpcyBpc1xuLy8gYWxzbyB0aGUgY2FzZSBmb3IgZXh0ZW5zaW9ucyB0byBGZWF0dXJlU2V0IHRoYXQgYSB1c2VyIG1pZ2h0IHByb3ZpZGUsIGFuZCBmb3Jcbi8vIGZlYXR1cmVzIGZyb20gdGhlIGZ1dHVyZS5cbi8vXG4vLyBXZSBjYW5ub3QgZXhoYXVzdGl2ZWx5IHZhbGlkYXRlIGNvcnJlY3RuZXNzIG9mIEZlYXR1cmVTZXREZWZhdWx0cyBhdCBydW50aW1lXG4vLyB3aXRob3V0IGtub3dpbmcgdGhlIHNjaGVtYTogSWYgbm8gdmFsdWUgZm9yIGEgZmVhdHVyZSBpcyBwcm92aWRlZCwgd2UgZG8gbm90XG4vLyBrbm93IHRoYXQgaXQgZXhpc3RzIGF0IGFsbC5cbi8vXG4vLyBBcyBhIHNhbml0eSBjaGVjaywgd2UgdmFsaWRhdGUgdGhhdCBhbGwgZmllbGRzIGtub3duIHRvIG91ciB2ZXJzaW9uIG9mXG4vLyBGZWF0dXJlU2V0IGFyZSBzZXQuXG5mdW5jdGlvbiB2YWxpZGF0ZU1lcmdlZEZlYXR1cmVzKGZlYXR1cmVTZXQpIHtcbiAgICBmb3IgKGNvbnN0IGZpIG9mIEZlYXR1cmVTZXQuZmllbGRzLmxpc3QoKSkge1xuICAgICAgICBjb25zdCB2ID0gZmVhdHVyZVNldFtmaS5sb2NhbE5hbWVdO1xuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpLmtpbmQgPT0gXCJlbnVtXCIgJiYgdiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL2NyZWF0ZS1kZXNjcmlwdG9yLXNldC5qc1xuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuXG5cblxuXG5cblxuLyoqXG4gKiBDcmVhdGUgYSBEZXNjcmlwdG9yU2V0LCBhIGNvbnZlbmllbnQgaW50ZXJmYWNlIGZvciB3b3JraW5nIHdpdGggYSBzZXQgb2ZcbiAqIGdvb2dsZS5wcm90b2J1Zi5GaWxlRGVzY3JpcHRvclByb3RvLlxuICpcbiAqIE5vdGUgdGhhdCBmaWxlcyBtdXN0IGJlIGdpdmVuIGluIHRvcG9sb2dpY2FsIG9yZGVyLCBzbyBlYWNoIGZpbGUgYXBwZWFyc1xuICogYmVmb3JlIGFueSBmaWxlIHRoYXQgaW1wb3J0cyBpdC4gUHJvdG9jb2wgYnVmZmVyIGNvbXBpbGVycyBhbHdheXMgcHJvZHVjZVxuICogZmlsZXMgaW4gdG9wb2xvZ2ljYWwgb3JkZXIuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURlc2NyaXB0b3JTZXQoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgY2FydCA9IHtcbiAgICAgICAgZW51bXM6IG5ldyBNYXAoKSxcbiAgICAgICAgbWVzc2FnZXM6IG5ldyBNYXAoKSxcbiAgICAgICAgc2VydmljZXM6IG5ldyBNYXAoKSxcbiAgICAgICAgZXh0ZW5zaW9uczogbmV3IE1hcCgpLFxuICAgICAgICBtYXBFbnRyaWVzOiBuZXcgTWFwKCksXG4gICAgICAgIHJlc29sdmVGZWF0dXJlczogY3JlYXRlRmVhdHVyZVJlc29sdmVyKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mZWF0dXJlU2V0RGVmYXVsdHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZlYXR1cmVTZXREZWZhdWx0cyksXG4gICAgfTtcbiAgICBjb25zdCBmaWxlRGVzY3JpcHRvcnMgPSBpbnB1dCBpbnN0YW5jZW9mIEZpbGVEZXNjcmlwdG9yU2V0XG4gICAgICAgID8gaW5wdXQuZmlsZVxuICAgICAgICA6IGlucHV0IGluc3RhbmNlb2YgVWludDhBcnJheVxuICAgICAgICAgICAgPyBGaWxlRGVzY3JpcHRvclNldC5mcm9tQmluYXJ5KGlucHV0KS5maWxlXG4gICAgICAgICAgICA6IGlucHV0O1xuICAgIGNvbnN0IGZpbGVzID0gZmlsZURlc2NyaXB0b3JzLm1hcCgocHJvdG8pID0+IG5ld0ZpbGUocHJvdG8sIGNhcnQpKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IGZpbGVzIH0sIGNhcnQpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBkZXNjcmlwdG9yIGZvciBhIGZpbGUuXG4gKi9cbmZ1bmN0aW9uIG5ld0ZpbGUocHJvdG8sIGNhcnQpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgICgwLGFzc2VydC8qIGFzc2VydCAqLy5odSkocHJvdG8ubmFtZSwgYGludmFsaWQgRmlsZURlc2NyaXB0b3JQcm90bzogbWlzc2luZyBuYW1lYCk7XG4gICAgY29uc3QgZmlsZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGtpbmQ6IFwiZmlsZVwiLCBwcm90bywgZGVwcmVjYXRlZDogKF9iID0gKF9hID0gcHJvdG8ub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlcHJlY2F0ZWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlIH0sIHBhcnNlRmlsZVN5bnRheChwcm90by5zeW50YXgsIHByb3RvLmVkaXRpb24pKSwgeyBuYW1lOiBwcm90by5uYW1lLnJlcGxhY2UoL1xcLnByb3RvLywgXCJcIiksIGVudW1zOiBbXSwgbWVzc2FnZXM6IFtdLCBleHRlbnNpb25zOiBbXSwgc2VydmljZXM6IFtdLCB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnMgLS0gd2UgYXNzZXJ0ZWQgYWJvdmVcbiAgICAgICAgICAgIHJldHVybiBgZmlsZSAke3RoaXMucHJvdG8ubmFtZX1gO1xuICAgICAgICB9LFxuICAgICAgICBnZXRTeW50YXhDb21tZW50cygpIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5kQ29tbWVudHModGhpcy5wcm90by5zb3VyY2VDb2RlSW5mbywgW1xuICAgICAgICAgICAgICAgIEZpZWxkTnVtYmVyLkZpbGVEZXNjcmlwdG9yUHJvdG9fU3ludGF4LFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFBhY2thZ2VDb21tZW50cygpIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5kQ29tbWVudHModGhpcy5wcm90by5zb3VyY2VDb2RlSW5mbywgW1xuICAgICAgICAgICAgICAgIEZpZWxkTnVtYmVyLkZpbGVEZXNjcmlwdG9yUHJvdG9fUGFja2FnZSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9LFxuICAgICAgICBnZXRGZWF0dXJlcygpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiBjYXJ0LnJlc29sdmVGZWF0dXJlcyh0aGlzLmVkaXRpb24sIChfYSA9IHRoaXMucHJvdG8ub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZlYXR1cmVzKTtcbiAgICAgICAgfSB9KTtcbiAgICBjYXJ0Lm1hcEVudHJpZXMuY2xlYXIoKTsgLy8gbWFwIGVudHJpZXMgYXJlIGxvY2FsIHRvIHRoZSBmaWxlLCB3ZSBjYW4gc2FmZWx5IGRpc2NhcmRcbiAgICBmb3IgKGNvbnN0IGVudW1Qcm90byBvZiBwcm90by5lbnVtVHlwZSkge1xuICAgICAgICBhZGRFbnVtKGVudW1Qcm90bywgZmlsZSwgdW5kZWZpbmVkLCBjYXJ0KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBtZXNzYWdlUHJvdG8gb2YgcHJvdG8ubWVzc2FnZVR5cGUpIHtcbiAgICAgICAgYWRkTWVzc2FnZShtZXNzYWdlUHJvdG8sIGZpbGUsIHVuZGVmaW5lZCwgY2FydCk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc2VydmljZVByb3RvIG9mIHByb3RvLnNlcnZpY2UpIHtcbiAgICAgICAgYWRkU2VydmljZShzZXJ2aWNlUHJvdG8sIGZpbGUsIGNhcnQpO1xuICAgIH1cbiAgICBhZGRFeHRlbnNpb25zKGZpbGUsIGNhcnQpO1xuICAgIGZvciAoY29uc3QgbWFwRW50cnkgb2YgY2FydC5tYXBFbnRyaWVzLnZhbHVlcygpKSB7XG4gICAgICAgIGFkZEZpZWxkcyhtYXBFbnRyeSwgY2FydCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBmaWxlLm1lc3NhZ2VzKSB7XG4gICAgICAgIGFkZEZpZWxkcyhtZXNzYWdlLCBjYXJ0KTtcbiAgICAgICAgYWRkRXh0ZW5zaW9ucyhtZXNzYWdlLCBjYXJ0KTtcbiAgICB9XG4gICAgY2FydC5tYXBFbnRyaWVzLmNsZWFyKCk7IC8vIG1hcCBlbnRyaWVzIGFyZSBsb2NhbCB0byB0aGUgZmlsZSwgd2UgY2FuIHNhZmVseSBkaXNjYXJkXG4gICAgcmV0dXJuIGZpbGU7XG59XG4vKipcbiAqIENyZWF0ZSBkZXNjcmlwdG9ycyBmb3IgZXh0ZW5zaW9ucywgYW5kIGFkZCB0aGVtIHRvIHRoZSBtZXNzYWdlIC8gZmlsZSxcbiAqIGFuZCB0byBvdXIgY2FydC5cbiAqIFJlY3Vyc2VzIGludG8gbmVzdGVkIHR5cGVzLlxuICovXG5mdW5jdGlvbiBhZGRFeHRlbnNpb25zKGRlc2MsIGNhcnQpIHtcbiAgICBzd2l0Y2ggKGRlc2Mua2luZCkge1xuICAgICAgICBjYXNlIFwiZmlsZVwiOlxuICAgICAgICAgICAgZm9yIChjb25zdCBwcm90byBvZiBkZXNjLnByb3RvLmV4dGVuc2lvbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dCA9IG5ld0V4dGVuc2lvbihwcm90bywgZGVzYywgdW5kZWZpbmVkLCBjYXJ0KTtcbiAgICAgICAgICAgICAgICBkZXNjLmV4dGVuc2lvbnMucHVzaChleHQpO1xuICAgICAgICAgICAgICAgIGNhcnQuZXh0ZW5zaW9ucy5zZXQoZXh0LnR5cGVOYW1lLCBleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3RvIG9mIGRlc2MucHJvdG8uZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXh0ID0gbmV3RXh0ZW5zaW9uKHByb3RvLCBkZXNjLmZpbGUsIGRlc2MsIGNhcnQpO1xuICAgICAgICAgICAgICAgIGRlc2MubmVzdGVkRXh0ZW5zaW9ucy5wdXNoKGV4dCk7XG4gICAgICAgICAgICAgICAgY2FydC5leHRlbnNpb25zLnNldChleHQudHlwZU5hbWUsIGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgZGVzYy5uZXN0ZWRNZXNzYWdlcykge1xuICAgICAgICAgICAgICAgIGFkZEV4dGVuc2lvbnMobWVzc2FnZSwgY2FydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZSBkZXNjcmlwdG9ycyBmb3IgZmllbGRzIGFuZCBvbmVvZiBncm91cHMsIGFuZCBhZGQgdGhlbSB0byB0aGUgbWVzc2FnZS5cbiAqIFJlY3Vyc2VzIGludG8gbmVzdGVkIHR5cGVzLlxuICovXG5mdW5jdGlvbiBhZGRGaWVsZHMobWVzc2FnZSwgY2FydCkge1xuICAgIGNvbnN0IGFsbE9uZW9mcyA9IG1lc3NhZ2UucHJvdG8ub25lb2ZEZWNsLm1hcCgocHJvdG8pID0+IG5ld09uZW9mKHByb3RvLCBtZXNzYWdlLCBjYXJ0KSk7XG4gICAgY29uc3Qgb25lb2ZzU2VlbiA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IHByb3RvIG9mIG1lc3NhZ2UucHJvdG8uZmllbGQpIHtcbiAgICAgICAgY29uc3Qgb25lb2YgPSBmaW5kT25lb2YocHJvdG8sIGFsbE9uZW9mcyk7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gbmV3RmllbGQocHJvdG8sIG1lc3NhZ2UuZmlsZSwgbWVzc2FnZSwgb25lb2YsIGNhcnQpO1xuICAgICAgICBtZXNzYWdlLmZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgICAgaWYgKG9uZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UubWVtYmVycy5wdXNoKGZpZWxkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9uZW9mLmZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgIGlmICghb25lb2ZzU2Vlbi5oYXMob25lb2YpKSB7XG4gICAgICAgICAgICAgICAgb25lb2ZzU2Vlbi5hZGQob25lb2YpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UubWVtYmVycy5wdXNoKG9uZW9mKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IG9uZW9mIG9mIGFsbE9uZW9mcy5maWx0ZXIoKG8pID0+IG9uZW9mc1NlZW4uaGFzKG8pKSkge1xuICAgICAgICBtZXNzYWdlLm9uZW9mcy5wdXNoKG9uZW9mKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBtZXNzYWdlLm5lc3RlZE1lc3NhZ2VzKSB7XG4gICAgICAgIGFkZEZpZWxkcyhjaGlsZCwgY2FydCk7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYSBkZXNjcmlwdG9yIGZvciBhbiBlbnVtZXJhdGlvbiwgYW5kIGFkZCBpdCBvdXIgY2FydCBhbmQgdG8gdGhlXG4gKiBwYXJlbnQgdHlwZSwgaWYgYW55LlxuICovXG5mdW5jdGlvbiBhZGRFbnVtKHByb3RvLCBmaWxlLCBwYXJlbnQsIGNhcnQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAoMCxhc3NlcnQvKiBhc3NlcnQgKi8uaHUpKHByb3RvLm5hbWUsIGBpbnZhbGlkIEVudW1EZXNjcmlwdG9yUHJvdG86IG1pc3NpbmcgbmFtZWApO1xuICAgIGNvbnN0IGRlc2MgPSB7XG4gICAgICAgIGtpbmQ6IFwiZW51bVwiLFxuICAgICAgICBwcm90byxcbiAgICAgICAgZGVwcmVjYXRlZDogKF9iID0gKF9hID0gcHJvdG8ub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlcHJlY2F0ZWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlLFxuICAgICAgICBmaWxlLFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIG5hbWU6IHByb3RvLm5hbWUsXG4gICAgICAgIHR5cGVOYW1lOiBtYWtlVHlwZU5hbWUocHJvdG8sIHBhcmVudCwgZmlsZSksXG4gICAgICAgIHZhbHVlczogW10sXG4gICAgICAgIHNoYXJlZFByZWZpeDogKDAsbmFtZXMvKiBmaW5kRW51bVNoYXJlZFByZWZpeCAqLy5TbSkocHJvdG8ubmFtZSwgcHJvdG8udmFsdWUubWFwKCh2KSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHYubmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjsgfSkpLFxuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiBgZW51bSAke3RoaXMudHlwZU5hbWV9YDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q29tbWVudHMoKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5wYXJlbnRcbiAgICAgICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5wYXJlbnQuZ2V0Q29tbWVudHMoKS5zb3VyY2VQYXRoLFxuICAgICAgICAgICAgICAgICAgICBGaWVsZE51bWJlci5EZXNjcmlwdG9yUHJvdG9fRW51bVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnByb3RvLmVudW1UeXBlLmluZGV4T2YodGhpcy5wcm90byksXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIDogW1xuICAgICAgICAgICAgICAgICAgICBGaWVsZE51bWJlci5GaWxlRGVzY3JpcHRvclByb3RvX0VudW1UeXBlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbGUucHJvdG8uZW51bVR5cGUuaW5kZXhPZih0aGlzLnByb3RvKSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgcmV0dXJuIGZpbmRDb21tZW50cyhmaWxlLnByb3RvLnNvdXJjZUNvZGVJbmZvLCBwYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0RmVhdHVyZXMoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEZlYXR1cmVzID0gKF9iID0gKF9hID0gdGhpcy5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRGZWF0dXJlcygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLmZpbGUuZ2V0RmVhdHVyZXMoKTtcbiAgICAgICAgICAgIHJldHVybiBjYXJ0LnJlc29sdmVGZWF0dXJlcyh0aGlzLmZpbGUuZWRpdGlvbiwgcGFyZW50RmVhdHVyZXMsIChfYyA9IHRoaXMucHJvdG8ub3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmZlYXR1cmVzKTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGNhcnQuZW51bXMuc2V0KGRlc2MudHlwZU5hbWUsIGRlc2MpO1xuICAgIHByb3RvLnZhbHVlLmZvckVhY2goKHByb3RvKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICgwLGFzc2VydC8qIGFzc2VydCAqLy5odSkocHJvdG8ubmFtZSwgYGludmFsaWQgRW51bVZhbHVlRGVzY3JpcHRvclByb3RvOiBtaXNzaW5nIG5hbWVgKTtcbiAgICAgICAgKDAsYXNzZXJ0LyogYXNzZXJ0ICovLmh1KShwcm90by5udW1iZXIgIT09IHVuZGVmaW5lZCwgYGludmFsaWQgRW51bVZhbHVlRGVzY3JpcHRvclByb3RvOiBtaXNzaW5nIG51bWJlcmApO1xuICAgICAgICBkZXNjLnZhbHVlcy5wdXNoKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiZW51bV92YWx1ZVwiLFxuICAgICAgICAgICAgcHJvdG8sXG4gICAgICAgICAgICBkZXByZWNhdGVkOiAoX2IgPSAoX2EgPSBwcm90by5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVwcmVjYXRlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2UsXG4gICAgICAgICAgICBwYXJlbnQ6IGRlc2MsXG4gICAgICAgICAgICBuYW1lOiBwcm90by5uYW1lLFxuICAgICAgICAgICAgbnVtYmVyOiBwcm90by5udW1iZXIsXG4gICAgICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYGVudW0gdmFsdWUgJHtkZXNjLnR5cGVOYW1lfS4ke3RoaXMubmFtZX1gO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uU3RyaW5nKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBsZXQgc3RyID0gYCR7dGhpcy5uYW1lfSA9ICR7dGhpcy5udW1iZXJ9YDtcbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHRoaXMucHJvdG8ub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlcHJlY2F0ZWQpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSBcIiBbZGVwcmVjYXRlZCA9IHRydWVdXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Q29tbWVudHMoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IFtcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5wYXJlbnQuZ2V0Q29tbWVudHMoKS5zb3VyY2VQYXRoLFxuICAgICAgICAgICAgICAgICAgICBGaWVsZE51bWJlci5FbnVtRGVzY3JpcHRvclByb3RvX1ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5wcm90by52YWx1ZS5pbmRleE9mKHRoaXMucHJvdG8pLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbmRDb21tZW50cyhmaWxlLnByb3RvLnNvdXJjZUNvZGVJbmZvLCBwYXRoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRGZWF0dXJlcygpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhcnQucmVzb2x2ZUZlYXR1cmVzKHRoaXMucGFyZW50LmZpbGUuZWRpdGlvbiwgdGhpcy5wYXJlbnQuZ2V0RmVhdHVyZXMoKSwgKF9hID0gdGhpcy5wcm90by5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmVhdHVyZXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgKChfYyA9IHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5uZXN0ZWRFbnVtcykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZmlsZS5lbnVtcykucHVzaChkZXNjKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgZGVzY3JpcHRvciBmb3IgYSBtZXNzYWdlLCBpbmNsdWRpbmcgbmVzdGVkIHR5cGVzLCBhbmQgYWRkIGl0IHRvIG91clxuICogY2FydC4gTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgY3JlYXRlIGRlc2NyaXB0b3JzIGZpZWxkcy5cbiAqL1xuZnVuY3Rpb24gYWRkTWVzc2FnZShwcm90bywgZmlsZSwgcGFyZW50LCBjYXJ0KSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICgwLGFzc2VydC8qIGFzc2VydCAqLy5odSkocHJvdG8ubmFtZSwgYGludmFsaWQgRGVzY3JpcHRvclByb3RvOiBtaXNzaW5nIG5hbWVgKTtcbiAgICBjb25zdCBkZXNjID0ge1xuICAgICAgICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgICAgICAgcHJvdG8sXG4gICAgICAgIGRlcHJlY2F0ZWQ6IChfYiA9IChfYSA9IHByb3RvLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXByZWNhdGVkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZSxcbiAgICAgICAgZmlsZSxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBuYW1lOiBwcm90by5uYW1lLFxuICAgICAgICB0eXBlTmFtZTogbWFrZVR5cGVOYW1lKHByb3RvLCBwYXJlbnQsIGZpbGUpLFxuICAgICAgICBmaWVsZHM6IFtdLFxuICAgICAgICBvbmVvZnM6IFtdLFxuICAgICAgICBtZW1iZXJzOiBbXSxcbiAgICAgICAgbmVzdGVkRW51bXM6IFtdLFxuICAgICAgICBuZXN0ZWRNZXNzYWdlczogW10sXG4gICAgICAgIG5lc3RlZEV4dGVuc2lvbnM6IFtdLFxuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiBgbWVzc2FnZSAke3RoaXMudHlwZU5hbWV9YDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q29tbWVudHMoKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5wYXJlbnRcbiAgICAgICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5wYXJlbnQuZ2V0Q29tbWVudHMoKS5zb3VyY2VQYXRoLFxuICAgICAgICAgICAgICAgICAgICBGaWVsZE51bWJlci5EZXNjcmlwdG9yUHJvdG9fTmVzdGVkVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQucHJvdG8ubmVzdGVkVHlwZS5pbmRleE9mKHRoaXMucHJvdG8pLFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICA6IFtcbiAgICAgICAgICAgICAgICAgICAgRmllbGROdW1iZXIuRmlsZURlc2NyaXB0b3JQcm90b19NZXNzYWdlVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWxlLnByb3RvLm1lc3NhZ2VUeXBlLmluZGV4T2YodGhpcy5wcm90byksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybiBmaW5kQ29tbWVudHMoZmlsZS5wcm90by5zb3VyY2VDb2RlSW5mbywgcGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEZlYXR1cmVzKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRGZWF0dXJlcyA9IChfYiA9IChfYSA9IHRoaXMucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0RmVhdHVyZXMoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5maWxlLmdldEZlYXR1cmVzKCk7XG4gICAgICAgICAgICByZXR1cm4gY2FydC5yZXNvbHZlRmVhdHVyZXModGhpcy5maWxlLmVkaXRpb24sIHBhcmVudEZlYXR1cmVzLCAoX2MgPSB0aGlzLnByb3RvLm9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5mZWF0dXJlcyk7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBpZiAoKChfYyA9IHByb3RvLm9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5tYXBFbnRyeSkgPT09IHRydWUpIHtcbiAgICAgICAgY2FydC5tYXBFbnRyaWVzLnNldChkZXNjLnR5cGVOYW1lLCBkZXNjKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgICgoX2QgPSBwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQubmVzdGVkTWVzc2FnZXMpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGZpbGUubWVzc2FnZXMpLnB1c2goZGVzYyk7XG4gICAgICAgIGNhcnQubWVzc2FnZXMuc2V0KGRlc2MudHlwZU5hbWUsIGRlc2MpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVudW1Qcm90byBvZiBwcm90by5lbnVtVHlwZSkge1xuICAgICAgICBhZGRFbnVtKGVudW1Qcm90bywgZmlsZSwgZGVzYywgY2FydCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbWVzc2FnZVByb3RvIG9mIHByb3RvLm5lc3RlZFR5cGUpIHtcbiAgICAgICAgYWRkTWVzc2FnZShtZXNzYWdlUHJvdG8sIGZpbGUsIGRlc2MsIGNhcnQpO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlIGEgZGVzY3JpcHRvciBmb3IgYSBzZXJ2aWNlLCBpbmNsdWRpbmcgbWV0aG9kcywgYW5kIGFkZCBpdCB0byBvdXJcbiAqIGNhcnQuXG4gKi9cbmZ1bmN0aW9uIGFkZFNlcnZpY2UocHJvdG8sIGZpbGUsIGNhcnQpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgICgwLGFzc2VydC8qIGFzc2VydCAqLy5odSkocHJvdG8ubmFtZSwgYGludmFsaWQgU2VydmljZURlc2NyaXB0b3JQcm90bzogbWlzc2luZyBuYW1lYCk7XG4gICAgY29uc3QgZGVzYyA9IHtcbiAgICAgICAga2luZDogXCJzZXJ2aWNlXCIsXG4gICAgICAgIHByb3RvLFxuICAgICAgICBkZXByZWNhdGVkOiAoX2IgPSAoX2EgPSBwcm90by5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVwcmVjYXRlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2UsXG4gICAgICAgIGZpbGUsXG4gICAgICAgIG5hbWU6IHByb3RvLm5hbWUsXG4gICAgICAgIHR5cGVOYW1lOiBtYWtlVHlwZU5hbWUocHJvdG8sIHVuZGVmaW5lZCwgZmlsZSksXG4gICAgICAgIG1ldGhvZHM6IFtdLFxuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiBgc2VydmljZSAke3RoaXMudHlwZU5hbWV9YDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q29tbWVudHMoKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gW1xuICAgICAgICAgICAgICAgIEZpZWxkTnVtYmVyLkZpbGVEZXNjcmlwdG9yUHJvdG9fU2VydmljZSxcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGUucHJvdG8uc2VydmljZS5pbmRleE9mKHRoaXMucHJvdG8pLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybiBmaW5kQ29tbWVudHMoZmlsZS5wcm90by5zb3VyY2VDb2RlSW5mbywgcGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEZlYXR1cmVzKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIGNhcnQucmVzb2x2ZUZlYXR1cmVzKHRoaXMuZmlsZS5lZGl0aW9uLCB0aGlzLmZpbGUuZ2V0RmVhdHVyZXMoKSwgKF9hID0gdGhpcy5wcm90by5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmVhdHVyZXMpO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgZmlsZS5zZXJ2aWNlcy5wdXNoKGRlc2MpO1xuICAgIGNhcnQuc2VydmljZXMuc2V0KGRlc2MudHlwZU5hbWUsIGRlc2MpO1xuICAgIGZvciAoY29uc3QgbWV0aG9kUHJvdG8gb2YgcHJvdG8ubWV0aG9kKSB7XG4gICAgICAgIGRlc2MubWV0aG9kcy5wdXNoKG5ld01ldGhvZChtZXRob2RQcm90bywgZGVzYywgY2FydCkpO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlIGEgZGVzY3JpcHRvciBmb3IgYSBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIG5ld01ldGhvZChwcm90bywgcGFyZW50LCBjYXJ0KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgKDAsYXNzZXJ0LyogYXNzZXJ0ICovLmh1KShwcm90by5uYW1lLCBgaW52YWxpZCBNZXRob2REZXNjcmlwdG9yUHJvdG86IG1pc3NpbmcgbmFtZWApO1xuICAgICgwLGFzc2VydC8qIGFzc2VydCAqLy5odSkocHJvdG8uaW5wdXRUeXBlLCBgaW52YWxpZCBNZXRob2REZXNjcmlwdG9yUHJvdG86IG1pc3NpbmcgaW5wdXRfdHlwZWApO1xuICAgICgwLGFzc2VydC8qIGFzc2VydCAqLy5odSkocHJvdG8ub3V0cHV0VHlwZSwgYGludmFsaWQgTWV0aG9kRGVzY3JpcHRvclByb3RvOiBtaXNzaW5nIG91dHB1dF90eXBlYCk7XG4gICAgbGV0IG1ldGhvZEtpbmQ7XG4gICAgaWYgKHByb3RvLmNsaWVudFN0cmVhbWluZyA9PT0gdHJ1ZSAmJiBwcm90by5zZXJ2ZXJTdHJlYW1pbmcgPT09IHRydWUpIHtcbiAgICAgICAgbWV0aG9kS2luZCA9IHNlcnZpY2VfdHlwZS8qIE1ldGhvZEtpbmQgKi8udC5CaURpU3RyZWFtaW5nO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm90by5jbGllbnRTdHJlYW1pbmcgPT09IHRydWUpIHtcbiAgICAgICAgbWV0aG9kS2luZCA9IHNlcnZpY2VfdHlwZS8qIE1ldGhvZEtpbmQgKi8udC5DbGllbnRTdHJlYW1pbmc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb3RvLnNlcnZlclN0cmVhbWluZyA9PT0gdHJ1ZSkge1xuICAgICAgICBtZXRob2RLaW5kID0gc2VydmljZV90eXBlLyogTWV0aG9kS2luZCAqLy50LlNlcnZlclN0cmVhbWluZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1ldGhvZEtpbmQgPSBzZXJ2aWNlX3R5cGUvKiBNZXRob2RLaW5kICovLnQuVW5hcnk7XG4gICAgfVxuICAgIGxldCBpZGVtcG90ZW5jeTtcbiAgICBzd2l0Y2ggKChfYSA9IHByb3RvLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pZGVtcG90ZW5jeUxldmVsKSB7XG4gICAgICAgIGNhc2UgTWV0aG9kT3B0aW9uc19JZGVtcG90ZW5jeUxldmVsLklERU1QT1RFTlQ6XG4gICAgICAgICAgICBpZGVtcG90ZW5jeSA9IHNlcnZpY2VfdHlwZS8qIE1ldGhvZElkZW1wb3RlbmN5ICovLncuSWRlbXBvdGVudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE1ldGhvZE9wdGlvbnNfSWRlbXBvdGVuY3lMZXZlbC5OT19TSURFX0VGRkVDVFM6XG4gICAgICAgICAgICBpZGVtcG90ZW5jeSA9IHNlcnZpY2VfdHlwZS8qIE1ldGhvZElkZW1wb3RlbmN5ICovLncuTm9TaWRlRWZmZWN0cztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE1ldGhvZE9wdGlvbnNfSWRlbXBvdGVuY3lMZXZlbC5JREVNUE9URU5DWV9VTktOT1dOOlxuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgIGlkZW1wb3RlbmN5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IGlucHV0ID0gY2FydC5tZXNzYWdlcy5nZXQodHJpbUxlYWRpbmdEb3QocHJvdG8uaW5wdXRUeXBlKSk7XG4gICAgY29uc3Qgb3V0cHV0ID0gY2FydC5tZXNzYWdlcy5nZXQodHJpbUxlYWRpbmdEb3QocHJvdG8ub3V0cHV0VHlwZSkpO1xuICAgICgwLGFzc2VydC8qIGFzc2VydCAqLy5odSkoaW5wdXQsIGBpbnZhbGlkIE1ldGhvZERlc2NyaXB0b3JQcm90bzogaW5wdXRfdHlwZSAke3Byb3RvLmlucHV0VHlwZX0gbm90IGZvdW5kYCk7XG4gICAgKDAsYXNzZXJ0LyogYXNzZXJ0ICovLmh1KShvdXRwdXQsIGBpbnZhbGlkIE1ldGhvZERlc2NyaXB0b3JQcm90bzogb3V0cHV0X3R5cGUgJHtwcm90by5pbnB1dFR5cGV9IG5vdCBmb3VuZGApO1xuICAgIGNvbnN0IG5hbWUgPSBwcm90by5uYW1lO1xuICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6IFwicnBjXCIsXG4gICAgICAgIHByb3RvLFxuICAgICAgICBkZXByZWNhdGVkOiAoX2MgPSAoX2IgPSBwcm90by5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGVwcmVjYXRlZCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZmFsc2UsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgbWV0aG9kS2luZCxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIG91dHB1dCxcbiAgICAgICAgaWRlbXBvdGVuY3ksXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIGBycGMgJHtwYXJlbnQudHlwZU5hbWV9LiR7bmFtZX1gO1xuICAgICAgICB9LFxuICAgICAgICBnZXRDb21tZW50cygpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBbXG4gICAgICAgICAgICAgICAgLi4udGhpcy5wYXJlbnQuZ2V0Q29tbWVudHMoKS5zb3VyY2VQYXRoLFxuICAgICAgICAgICAgICAgIEZpZWxkTnVtYmVyLlNlcnZpY2VEZXNjcmlwdG9yUHJvdG9fTWV0aG9kLFxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnByb3RvLm1ldGhvZC5pbmRleE9mKHRoaXMucHJvdG8pLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybiBmaW5kQ29tbWVudHMocGFyZW50LmZpbGUucHJvdG8uc291cmNlQ29kZUluZm8sIHBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRGZWF0dXJlcygpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiBjYXJ0LnJlc29sdmVGZWF0dXJlcyh0aGlzLnBhcmVudC5maWxlLmVkaXRpb24sIHRoaXMucGFyZW50LmdldEZlYXR1cmVzKCksIChfYSA9IHRoaXMucHJvdG8ub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZlYXR1cmVzKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBkZXNjcmlwdG9yIGZvciBhIG9uZW9mIGdyb3VwLlxuICovXG5mdW5jdGlvbiBuZXdPbmVvZihwcm90bywgcGFyZW50LCBjYXJ0KSB7XG4gICAgKDAsYXNzZXJ0LyogYXNzZXJ0ICovLmh1KShwcm90by5uYW1lLCBgaW52YWxpZCBPbmVvZkRlc2NyaXB0b3JQcm90bzogbWlzc2luZyBuYW1lYCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogXCJvbmVvZlwiLFxuICAgICAgICBwcm90byxcbiAgICAgICAgZGVwcmVjYXRlZDogZmFsc2UsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgZmllbGRzOiBbXSxcbiAgICAgICAgbmFtZTogcHJvdG8ubmFtZSxcbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gYG9uZW9mICR7cGFyZW50LnR5cGVOYW1lfS4ke3RoaXMubmFtZX1gO1xuICAgICAgICB9LFxuICAgICAgICBnZXRDb21tZW50cygpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBbXG4gICAgICAgICAgICAgICAgLi4udGhpcy5wYXJlbnQuZ2V0Q29tbWVudHMoKS5zb3VyY2VQYXRoLFxuICAgICAgICAgICAgICAgIEZpZWxkTnVtYmVyLkRlc2NyaXB0b3JQcm90b19PbmVvZkRlY2wsXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQucHJvdG8ub25lb2ZEZWNsLmluZGV4T2YodGhpcy5wcm90byksXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgcmV0dXJuIGZpbmRDb21tZW50cyhwYXJlbnQuZmlsZS5wcm90by5zb3VyY2VDb2RlSW5mbywgcGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEZlYXR1cmVzKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIGNhcnQucmVzb2x2ZUZlYXR1cmVzKHRoaXMucGFyZW50LmZpbGUuZWRpdGlvbiwgdGhpcy5wYXJlbnQuZ2V0RmVhdHVyZXMoKSwgKF9hID0gdGhpcy5wcm90by5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmVhdHVyZXMpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZSBhIGRlc2NyaXB0b3IgZm9yIGEgZmllbGQuXG4gKi9cbmZ1bmN0aW9uIG5ld0ZpZWxkKHByb3RvLCBmaWxlLCBwYXJlbnQsIG9uZW9mLCBjYXJ0KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgKDAsYXNzZXJ0LyogYXNzZXJ0ICovLmh1KShwcm90by5uYW1lLCBgaW52YWxpZCBGaWVsZERlc2NyaXB0b3JQcm90bzogbWlzc2luZyBuYW1lYCk7XG4gICAgKDAsYXNzZXJ0LyogYXNzZXJ0ICovLmh1KShwcm90by5udW1iZXIsIGBpbnZhbGlkIEZpZWxkRGVzY3JpcHRvclByb3RvOiBtaXNzaW5nIG51bWJlcmApO1xuICAgICgwLGFzc2VydC8qIGFzc2VydCAqLy5odSkocHJvdG8udHlwZSwgYGludmFsaWQgRmllbGREZXNjcmlwdG9yUHJvdG86IG1pc3NpbmcgdHlwZWApO1xuICAgIGNvbnN0IGNvbW1vbiA9IHtcbiAgICAgICAgcHJvdG8sXG4gICAgICAgIGRlcHJlY2F0ZWQ6IChfYiA9IChfYSA9IHByb3RvLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXByZWNhdGVkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZSxcbiAgICAgICAgbmFtZTogcHJvdG8ubmFtZSxcbiAgICAgICAgbnVtYmVyOiBwcm90by5udW1iZXIsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgb25lb2YsXG4gICAgICAgIG9wdGlvbmFsOiBpc09wdGlvbmFsRmllbGQocHJvdG8sIGZpbGUuc3ludGF4KSxcbiAgICAgICAgcGFja2VkQnlEZWZhdWx0OiBpc1BhY2tlZEZpZWxkQnlEZWZhdWx0KGZpbGUsIHByb3RvLCBjYXJ0LnJlc29sdmVGZWF0dXJlcyksXG4gICAgICAgIHBhY2tlZDogaXNQYWNrZWRGaWVsZChmaWxlLCBwYXJlbnQsIHByb3RvLCBjYXJ0LnJlc29sdmVGZWF0dXJlcyksXG4gICAgICAgIGpzb25OYW1lOiBwcm90by5qc29uTmFtZSA9PT0gKDAsbmFtZXMvKiBmaWVsZEpzb25OYW1lICovLngxKShwcm90by5uYW1lKSA/IHVuZGVmaW5lZCA6IHByb3RvLmpzb25OYW1lLFxuICAgICAgICBzY2FsYXI6IHVuZGVmaW5lZCxcbiAgICAgICAgbG9uZ1R5cGU6IHVuZGVmaW5lZCxcbiAgICAgICAgbWVzc2FnZTogdW5kZWZpbmVkLFxuICAgICAgICBlbnVtOiB1bmRlZmluZWQsXG4gICAgICAgIG1hcEtleTogdW5kZWZpbmVkLFxuICAgICAgICBtYXBWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkZWNsYXJhdGlvblN0cmluZyxcbiAgICAgICAgLy8gdG9TdHJpbmcsIGdldENvbW1lbnRzLCBnZXRGZWF0dXJlcyBhcmUgb3ZlcnJpZGRlbiBpbiBuZXdFeHRlbnNpb25cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gYGZpZWxkICR7dGhpcy5wYXJlbnQudHlwZU5hbWV9LiR7dGhpcy5uYW1lfWA7XG4gICAgICAgIH0sXG4gICAgICAgIGdldENvbW1lbnRzKCkge1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IFtcbiAgICAgICAgICAgICAgICAuLi50aGlzLnBhcmVudC5nZXRDb21tZW50cygpLnNvdXJjZVBhdGgsXG4gICAgICAgICAgICAgICAgRmllbGROdW1iZXIuRGVzY3JpcHRvclByb3RvX0ZpZWxkLFxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnByb3RvLmZpZWxkLmluZGV4T2YodGhpcy5wcm90byksXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgcmV0dXJuIGZpbmRDb21tZW50cyhmaWxlLnByb3RvLnNvdXJjZUNvZGVJbmZvLCBwYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0RmVhdHVyZXMoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gY2FydC5yZXNvbHZlRmVhdHVyZXMoZmlsZS5lZGl0aW9uLCB0aGlzLnBhcmVudC5nZXRGZWF0dXJlcygpLCAoX2EgPSB0aGlzLnByb3RvLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mZWF0dXJlcyk7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBjb25zdCByZXBlYXRlZCA9IHByb3RvLmxhYmVsID09PSBGaWVsZERlc2NyaXB0b3JQcm90b19MYWJlbC5SRVBFQVRFRDtcbiAgICBzd2l0Y2ggKHByb3RvLnR5cGUpIHtcbiAgICAgICAgY2FzZSBGaWVsZERlc2NyaXB0b3JQcm90b19UeXBlLk1FU1NBR0U6XG4gICAgICAgIGNhc2UgRmllbGREZXNjcmlwdG9yUHJvdG9fVHlwZS5HUk9VUDoge1xuICAgICAgICAgICAgKDAsYXNzZXJ0LyogYXNzZXJ0ICovLmh1KShwcm90by50eXBlTmFtZSwgYGludmFsaWQgRmllbGREZXNjcmlwdG9yUHJvdG86IG1pc3NpbmcgdHlwZV9uYW1lYCk7XG4gICAgICAgICAgICBjb25zdCBtYXBFbnRyeSA9IGNhcnQubWFwRW50cmllcy5nZXQodHJpbUxlYWRpbmdEb3QocHJvdG8udHlwZU5hbWUpKTtcbiAgICAgICAgICAgIGlmIChtYXBFbnRyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgKDAsYXNzZXJ0LyogYXNzZXJ0ICovLmh1KShyZXBlYXRlZCwgYGludmFsaWQgRmllbGREZXNjcmlwdG9yUHJvdG86IGV4cGVjdGVkIG1hcCBlbnRyeSB0byBiZSByZXBlYXRlZGApO1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uKSwgeyBraW5kOiBcImZpZWxkXCIsIGZpZWxkS2luZDogXCJtYXBcIiwgcmVwZWF0ZWQ6IGZhbHNlIH0pLCBnZXRNYXBGaWVsZFR5cGVzKG1hcEVudHJ5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gY2FydC5tZXNzYWdlcy5nZXQodHJpbUxlYWRpbmdEb3QocHJvdG8udHlwZU5hbWUpKTtcbiAgICAgICAgICAgICgwLGFzc2VydC8qIGFzc2VydCAqLy5odSkobWVzc2FnZSAhPT0gdW5kZWZpbmVkLCBgaW52YWxpZCBGaWVsZERlc2NyaXB0b3JQcm90bzogdHlwZV9uYW1lICR7cHJvdG8udHlwZU5hbWV9IG5vdCBmb3VuZGApO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uKSwgeyBraW5kOiBcImZpZWxkXCIsIGZpZWxkS2luZDogXCJtZXNzYWdlXCIsIHJlcGVhdGVkLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBGaWVsZERlc2NyaXB0b3JQcm90b19UeXBlLkVOVU06IHtcbiAgICAgICAgICAgICgwLGFzc2VydC8qIGFzc2VydCAqLy5odSkocHJvdG8udHlwZU5hbWUsIGBpbnZhbGlkIEZpZWxkRGVzY3JpcHRvclByb3RvOiBtaXNzaW5nIHR5cGVfbmFtZWApO1xuICAgICAgICAgICAgY29uc3QgZSA9IGNhcnQuZW51bXMuZ2V0KHRyaW1MZWFkaW5nRG90KHByb3RvLnR5cGVOYW1lKSk7XG4gICAgICAgICAgICAoMCxhc3NlcnQvKiBhc3NlcnQgKi8uaHUpKGUgIT09IHVuZGVmaW5lZCwgYGludmFsaWQgRmllbGREZXNjcmlwdG9yUHJvdG86IHR5cGVfbmFtZSAke3Byb3RvLnR5cGVOYW1lfSBub3QgZm91bmRgKTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vbiksIHsga2luZDogXCJmaWVsZFwiLCBmaWVsZEtpbmQ6IFwiZW51bVwiLCBnZXREZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICAgICAgcmVwZWF0ZWQsIGVudW06IGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgY29uc3Qgc2NhbGFyID0gZmllbGRUeXBlVG9TY2FsYXJUeXBlW3Byb3RvLnR5cGVdO1xuICAgICAgICAgICAgKDAsYXNzZXJ0LyogYXNzZXJ0ICovLmh1KShzY2FsYXIsIGBpbnZhbGlkIEZpZWxkRGVzY3JpcHRvclByb3RvOiB1bmtub3duIHR5cGUgJHtwcm90by50eXBlfWApO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uKSwgeyBraW5kOiBcImZpZWxkXCIsIGZpZWxkS2luZDogXCJzY2FsYXJcIiwgZ2V0RGVmYXVsdFZhbHVlLFxuICAgICAgICAgICAgICAgIHJlcGVhdGVkLFxuICAgICAgICAgICAgICAgIHNjYWxhciwgbG9uZ1R5cGU6ICgoX2MgPSBwcm90by5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuanN0eXBlKSA9PSBGaWVsZE9wdGlvbnNfSlNUeXBlLkpTX1NUUklOR1xuICAgICAgICAgICAgICAgICAgICA/IGVzbV9maWVsZC8qIExvbmdUeXBlICovLnAuU1RSSU5HXG4gICAgICAgICAgICAgICAgICAgIDogZXNtX2ZpZWxkLyogTG9uZ1R5cGUgKi8ucC5CSUdJTlQgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZSBhIGRlc2NyaXB0b3IgZm9yIGFuIGV4dGVuc2lvbiBmaWVsZC5cbiAqL1xuZnVuY3Rpb24gbmV3RXh0ZW5zaW9uKHByb3RvLCBmaWxlLCBwYXJlbnQsIGNhcnQpIHtcbiAgICAoMCxhc3NlcnQvKiBhc3NlcnQgKi8uaHUpKHByb3RvLmV4dGVuZGVlLCBgaW52YWxpZCBGaWVsZERlc2NyaXB0b3JQcm90bzogbWlzc2luZyBleHRlbmRlZWApO1xuICAgIGNvbnN0IGZpZWxkID0gbmV3RmllbGQocHJvdG8sIGZpbGUsIG51bGwsIC8vIHRvIHNhZmUgdXMgbWFueSBsaW5lcyBvZiBkdXBsaWNhdGVkIGNvZGUsIHdlIHRyaWNrIHRoZSB0eXBlIHN5c3RlbVxuICAgIHVuZGVmaW5lZCwgY2FydCk7XG4gICAgY29uc3QgZXh0ZW5kZWUgPSBjYXJ0Lm1lc3NhZ2VzLmdldCh0cmltTGVhZGluZ0RvdChwcm90by5leHRlbmRlZSkpO1xuICAgICgwLGFzc2VydC8qIGFzc2VydCAqLy5odSkoZXh0ZW5kZWUsIGBpbnZhbGlkIEZpZWxkRGVzY3JpcHRvclByb3RvOiBleHRlbmRlZSAke3Byb3RvLmV4dGVuZGVlfSBub3QgZm91bmRgKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmaWVsZCksIHsga2luZDogXCJleHRlbnNpb25cIiwgdHlwZU5hbWU6IG1ha2VUeXBlTmFtZShwcm90bywgcGFyZW50LCBmaWxlKSwgcGFyZW50LFxuICAgICAgICBmaWxlLFxuICAgICAgICBleHRlbmRlZSxcbiAgICAgICAgLy8gTXVzdCBvdmVycmlkZSB0b1N0cmluZywgZ2V0Q29tbWVudHMsIGdldEZlYXR1cmVzIGZyb20gbmV3RmllbGQsIGJlY2F1c2Ugd2VcbiAgICAgICAgLy8gY2FsbCBuZXdGaWVsZCB3aXRoIHBhcmVudCB1bmRlZmluZWQuXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIGBleHRlbnNpb24gJHt0aGlzLnR5cGVOYW1lfWA7XG4gICAgICAgIH0sXG4gICAgICAgIGdldENvbW1lbnRzKCkge1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMucGFyZW50XG4gICAgICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgICAgIC4uLnRoaXMucGFyZW50LmdldENvbW1lbnRzKCkuc291cmNlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgRmllbGROdW1iZXIuRGVzY3JpcHRvclByb3RvX0V4dGVuc2lvbixcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQucHJvdG8uZXh0ZW5zaW9uLmluZGV4T2YocHJvdG8pLFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICA6IFtcbiAgICAgICAgICAgICAgICAgICAgRmllbGROdW1iZXIuRmlsZURlc2NyaXB0b3JQcm90b19FeHRlbnNpb24sXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsZS5wcm90by5leHRlbnNpb24uaW5kZXhPZihwcm90byksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybiBmaW5kQ29tbWVudHMoZmlsZS5wcm90by5zb3VyY2VDb2RlSW5mbywgcGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEZlYXR1cmVzKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHJldHVybiBjYXJ0LnJlc29sdmVGZWF0dXJlcyh0aGlzLmZpbGUuZWRpdGlvbiwgKChfYSA9IHRoaXMucGFyZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmZpbGUpLmdldEZlYXR1cmVzKCksIChfYiA9IHRoaXMucHJvdG8ub3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZlYXR1cmVzKTtcbiAgICAgICAgfSB9KTtcbn1cbi8qKlxuICogUGFyc2UgdGhlIFwic3ludGF4XCIgYW5kIFwiZWRpdGlvblwiIGZpZWxkcywgc3RyaXBwaW5nIHRlc3QgZWRpdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRmlsZVN5bnRheChzeW50YXgsIGVkaXRpb24pIHtcbiAgICBsZXQgZTtcbiAgICBsZXQgcztcbiAgICBzd2l0Y2ggKHN5bnRheCkge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgY2FzZSBcInByb3RvMlwiOlxuICAgICAgICAgICAgcyA9IFwicHJvdG8yXCI7XG4gICAgICAgICAgICBlID0gRWRpdGlvbi5FRElUSU9OX1BST1RPMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicHJvdG8zXCI6XG4gICAgICAgICAgICBzID0gXCJwcm90bzNcIjtcbiAgICAgICAgICAgIGUgPSBFZGl0aW9uLkVESVRJT05fUFJPVE8zO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlZGl0aW9uc1wiOlxuICAgICAgICAgICAgcyA9IFwiZWRpdGlvbnNcIjtcbiAgICAgICAgICAgIHN3aXRjaCAoZWRpdGlvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgICAgIGNhc2UgRWRpdGlvbi5FRElUSU9OXzFfVEVTVF9PTkxZOlxuICAgICAgICAgICAgICAgIGNhc2UgRWRpdGlvbi5FRElUSU9OXzJfVEVTVF9PTkxZOlxuICAgICAgICAgICAgICAgIGNhc2UgRWRpdGlvbi5FRElUSU9OXzk5OTk3X1RFU1RfT05MWTpcbiAgICAgICAgICAgICAgICBjYXNlIEVkaXRpb24uRURJVElPTl85OTk5OF9URVNUX09OTFk6XG4gICAgICAgICAgICAgICAgY2FzZSBFZGl0aW9uLkVESVRJT05fOTk5OTlfVEVTVF9PTkxZOlxuICAgICAgICAgICAgICAgIGNhc2UgRWRpdGlvbi5FRElUSU9OX1VOS05PV046XG4gICAgICAgICAgICAgICAgICAgIGUgPSBFZGl0aW9uLkVESVRJT05fVU5LTk9XTjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgZSA9IGVkaXRpb247XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgRmlsZURlc2NyaXB0b3JQcm90bzogdW5zdXBwb3J0ZWQgc3ludGF4OiAke3N5bnRheH1gKTtcbiAgICB9XG4gICAgaWYgKHN5bnRheCA9PT0gXCJlZGl0aW9uc1wiICYmIGVkaXRpb24gPT09IEVkaXRpb24uRURJVElPTl9VTktOT1dOKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBGaWxlRGVzY3JpcHRvclByb3RvOiBzeW50YXggJHtzeW50YXh9IGNhbm5vdCBoYXZlIGVkaXRpb24gJHtTdHJpbmcoZWRpdGlvbil9YCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHN5bnRheDogcyxcbiAgICAgICAgZWRpdGlvbjogZSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBmdWxseSBxdWFsaWZpZWQgbmFtZSBmb3IgYSBwcm90b2J1ZiB0eXBlIG9yIGV4dGVuc2lvbiBmaWVsZC5cbiAqXG4gKiBUaGUgZnVsbHkgcXVhbGlmaWVkIG5hbWUgZm9yIG1lc3NhZ2VzLCBlbnVtZXJhdGlvbnMsIGFuZCBzZXJ2aWNlcyBpc1xuICogY29uc3RydWN0ZWQgYnkgY29uY2F0ZW5hdGluZyB0aGUgcGFja2FnZSBuYW1lIChpZiBwcmVzZW50KSwgcGFyZW50XG4gKiBtZXNzYWdlIG5hbWVzIChmb3IgbmVzdGVkIHR5cGVzKSwgYW5kIHRoZSB0eXBlIG5hbWUuIFdlIG9taXQgdGhlIGxlYWRpbmdcbiAqIGRvdCBhZGRlZCBieSBwcm90b2J1ZiBjb21waWxlcnMuIEV4YW1wbGVzOlxuICogLSBteXBhY2thZ2UuTXlNZXNzYWdlXG4gKiAtIG15cGFja2FnZS5NeU1lc3NhZ2UuTmVzdGVkTWVzc2FnZVxuICpcbiAqIFRoZSBmdWxseSBxdWFsaWZpZWQgbmFtZSBmb3IgZXh0ZW5zaW9uIGZpZWxkcyBpcyBjb25zdHJ1Y3RlZCBieVxuICogY29uY2F0ZW5hdGluZyB0aGUgcGFja2FnZSBuYW1lIChpZiBwcmVzZW50KSwgcGFyZW50IG1lc3NhZ2UgbmFtZXMgKGZvclxuICogZXh0ZW5zaW9ucyBkZWNsYXJlZCB3aXRoaW4gYSBtZXNzYWdlKSwgYW5kIHRoZSBmaWVsZCBuYW1lLiBFeGFtcGxlczpcbiAqIC0gbXlwYWNrYWdlLmV4dGZpZWxkXG4gKiAtIG15cGFja2FnZS5NeU1lc3NhZ2UuZXh0ZmllbGRcbiAqL1xuZnVuY3Rpb24gbWFrZVR5cGVOYW1lKHByb3RvLCBwYXJlbnQsIGZpbGUpIHtcbiAgICAoMCxhc3NlcnQvKiBhc3NlcnQgKi8uaHUpKHByb3RvLm5hbWUsIGBpbnZhbGlkICR7cHJvdG8uZ2V0VHlwZSgpLnR5cGVOYW1lfTogbWlzc2luZyBuYW1lYCk7XG4gICAgbGV0IHR5cGVOYW1lO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgdHlwZU5hbWUgPSBgJHtwYXJlbnQudHlwZU5hbWV9LiR7cHJvdG8ubmFtZX1gO1xuICAgIH1cbiAgICBlbHNlIGlmIChmaWxlLnByb3RvLnBhY2thZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0eXBlTmFtZSA9IGAke2ZpbGUucHJvdG8ucGFja2FnZX0uJHtwcm90by5uYW1lfWA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0eXBlTmFtZSA9IGAke3Byb3RvLm5hbWV9YDtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVOYW1lO1xufVxuLyoqXG4gKiBSZW1vdmUgdGhlIGxlYWRpbmcgZG90IGZyb20gYSBmdWxseSBxdWFsaWZpZWQgdHlwZSBuYW1lLlxuICovXG5mdW5jdGlvbiB0cmltTGVhZGluZ0RvdCh0eXBlTmFtZSkge1xuICAgIHJldHVybiB0eXBlTmFtZS5zdGFydHNXaXRoKFwiLlwiKSA/IHR5cGVOYW1lLnN1YnN0cmluZygxKSA6IHR5cGVOYW1lO1xufVxuZnVuY3Rpb24gZ2V0TWFwRmllbGRUeXBlcyhtYXBFbnRyeSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgKDAsYXNzZXJ0LyogYXNzZXJ0ICovLmh1KSgoX2EgPSBtYXBFbnRyeS5wcm90by5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwRW50cnksIGBpbnZhbGlkIERlc2NyaXB0b3JQcm90bzogZXhwZWN0ZWQgJHttYXBFbnRyeS50b1N0cmluZygpfSB0byBiZSBhIG1hcCBlbnRyeWApO1xuICAgICgwLGFzc2VydC8qIGFzc2VydCAqLy5odSkobWFwRW50cnkuZmllbGRzLmxlbmd0aCA9PT0gMiwgYGludmFsaWQgRGVzY3JpcHRvclByb3RvOiBtYXAgZW50cnkgJHttYXBFbnRyeS50b1N0cmluZygpfSBoYXMgJHttYXBFbnRyeS5maWVsZHMubGVuZ3RofSBmaWVsZHNgKTtcbiAgICBjb25zdCBrZXlGaWVsZCA9IG1hcEVudHJ5LmZpZWxkcy5maW5kKChmKSA9PiBmLnByb3RvLm51bWJlciA9PT0gMSk7XG4gICAgKDAsYXNzZXJ0LyogYXNzZXJ0ICovLmh1KShrZXlGaWVsZCwgYGludmFsaWQgRGVzY3JpcHRvclByb3RvOiBtYXAgZW50cnkgJHttYXBFbnRyeS50b1N0cmluZygpfSBpcyBtaXNzaW5nIGtleSBmaWVsZGApO1xuICAgIGNvbnN0IG1hcEtleSA9IGtleUZpZWxkLnNjYWxhcjtcbiAgICAoMCxhc3NlcnQvKiBhc3NlcnQgKi8uaHUpKG1hcEtleSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIG1hcEtleSAhPT0gZXNtX2ZpZWxkLyogU2NhbGFyVHlwZSAqLy53LkJZVEVTICYmXG4gICAgICAgIG1hcEtleSAhPT0gZXNtX2ZpZWxkLyogU2NhbGFyVHlwZSAqLy53LkZMT0FUICYmXG4gICAgICAgIG1hcEtleSAhPT0gZXNtX2ZpZWxkLyogU2NhbGFyVHlwZSAqLy53LkRPVUJMRSwgYGludmFsaWQgRGVzY3JpcHRvclByb3RvOiBtYXAgZW50cnkgJHttYXBFbnRyeS50b1N0cmluZygpfSBoYXMgdW5leHBlY3RlZCBrZXkgdHlwZSAkeyhfYiA9IGtleUZpZWxkLnByb3RvLnR5cGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IC0xfWApO1xuICAgIGNvbnN0IHZhbHVlRmllbGQgPSBtYXBFbnRyeS5maWVsZHMuZmluZCgoZikgPT4gZi5wcm90by5udW1iZXIgPT09IDIpO1xuICAgICgwLGFzc2VydC8qIGFzc2VydCAqLy5odSkodmFsdWVGaWVsZCwgYGludmFsaWQgRGVzY3JpcHRvclByb3RvOiBtYXAgZW50cnkgJHttYXBFbnRyeS50b1N0cmluZygpfSBpcyBtaXNzaW5nIHZhbHVlIGZpZWxkYCk7XG4gICAgc3dpdGNoICh2YWx1ZUZpZWxkLmZpZWxkS2luZCkge1xuICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1hcEtleSxcbiAgICAgICAgICAgICAgICBtYXBWYWx1ZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2YWx1ZUZpZWxkKSwgeyBraW5kOiBcInNjYWxhclwiIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWFwS2V5LFxuICAgICAgICAgICAgICAgIG1hcFZhbHVlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHZhbHVlRmllbGQpLCB7IGtpbmQ6IFwibWVzc2FnZVwiIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWFwS2V5LFxuICAgICAgICAgICAgICAgIG1hcFZhbHVlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHZhbHVlRmllbGQpLCB7IGtpbmQ6IFwiZW51bVwiIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgRGVzY3JpcHRvclByb3RvOiB1bnN1cHBvcnRlZCBtYXAgZW50cnkgdmFsdWUgZmllbGRcIik7XG4gICAgfVxufVxuLyoqXG4gKiBEaWQgdGhlIHVzZXIgcHV0IHRoZSBmaWVsZCBpbiBhIG9uZW9mIGdyb3VwP1xuICogVGhpcyBoYW5kbGVzIHByb3RvMyBvcHRpb25hbHMuXG4gKi9cbmZ1bmN0aW9uIGZpbmRPbmVvZihwcm90bywgYWxsT25lb2ZzKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IG9uZW9mSW5kZXggPSBwcm90by5vbmVvZkluZGV4O1xuICAgIGlmIChvbmVvZkluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IG9uZW9mO1xuICAgIGlmIChwcm90by5wcm90bzNPcHRpb25hbCAhPT0gdHJ1ZSkge1xuICAgICAgICBvbmVvZiA9IGFsbE9uZW9mc1tvbmVvZkluZGV4XTtcbiAgICAgICAgKDAsYXNzZXJ0LyogYXNzZXJ0ICovLmh1KShvbmVvZiwgYGludmFsaWQgRmllbGREZXNjcmlwdG9yUHJvdG86IG9uZW9mICMke29uZW9mSW5kZXh9IGZvciBmaWVsZCAjJHsoX2EgPSBwcm90by5udW1iZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IC0xfSBub3QgZm91bmRgKTtcbiAgICB9XG4gICAgcmV0dXJuIG9uZW9mO1xufVxuLyoqXG4gKiBEaWQgdGhlIHVzZXIgdXNlIHRoZSBgb3B0aW9uYWxgIGtleXdvcmQ/XG4gKiBUaGlzIGhhbmRsZXMgcHJvdG8zIG9wdGlvbmFscy5cbiAqL1xuZnVuY3Rpb24gaXNPcHRpb25hbEZpZWxkKHByb3RvLCBzeW50YXgpIHtcbiAgICBzd2l0Y2ggKHN5bnRheCkge1xuICAgICAgICBjYXNlIFwicHJvdG8yXCI6XG4gICAgICAgICAgICByZXR1cm4gKHByb3RvLm9uZW9mSW5kZXggPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHByb3RvLmxhYmVsID09PSBGaWVsZERlc2NyaXB0b3JQcm90b19MYWJlbC5PUFRJT05BTCk7XG4gICAgICAgIGNhc2UgXCJwcm90bzNcIjpcbiAgICAgICAgICAgIHJldHVybiBwcm90by5wcm90bzNPcHRpb25hbCA9PT0gdHJ1ZTtcbiAgICAgICAgY2FzZSBcImVkaXRpb25zXCI6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBJcyB0aGlzIGZpZWxkIHBhY2tlZCBieSBkZWZhdWx0PyBPbmx5IHZhbGlkIGZvciByZXBlYXRlZCBlbnVtIGZpZWxkcywgYW5kXG4gKiBmb3IgcmVwZWF0ZWQgc2NhbGFyIGZpZWxkcyBleGNlcHQgQllURVMgYW5kIFNUUklORy5cbiAqXG4gKiBJbiBwcm90bzMgc3ludGF4LCBmaWVsZHMgYXJlIHBhY2tlZCBieSBkZWZhdWx0LiBJbiBwcm90bzIgc3ludGF4LCBmaWVsZHNcbiAqIGFyZSB1bnBhY2tlZCBieSBkZWZhdWx0LiBXaXRoIGVkaXRpb25zLCB0aGUgZGVmYXVsdCBpcyB3aGF0ZXZlciB0aGUgZWRpdGlvblxuICogc3BlY2lmaWVzIGFzIGEgZGVmYXVsdC4gSW4gZWRpdGlvbiAyMDIzLCBmaWVsZHMgYXJlIHBhY2tlZCBieSBkZWZhdWx0LlxuICovXG5mdW5jdGlvbiBpc1BhY2tlZEZpZWxkQnlEZWZhdWx0KGZpbGUsIHByb3RvLCByZXNvbHZlRmVhdHVyZXMpIHtcbiAgICBjb25zdCB7IHJlcGVhdGVkRmllbGRFbmNvZGluZyB9ID0gcmVzb2x2ZUZlYXR1cmVzKGZpbGUuZWRpdGlvbik7XG4gICAgaWYgKHJlcGVhdGVkRmllbGRFbmNvZGluZyAhPSBGZWF0dXJlU2V0X1JlcGVhdGVkRmllbGRFbmNvZGluZy5QQUNLRUQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBGcm9tIHRoZSBwcm90bzMgbGFuZ3VhZ2UgZ3VpZGU6XG4gICAgLy8gPiBJbiBwcm90bzMsIHJlcGVhdGVkIGZpZWxkcyBvZiBzY2FsYXIgbnVtZXJpYyB0eXBlcyBhcmUgcGFja2VkIGJ5IGRlZmF1bHQuXG4gICAgLy8gVGhpcyBpbmZvcm1hdGlvbiBpcyBpbmNvbXBsZXRlIC0gYWNjb3JkaW5nIHRvIHRoZSBjb25mb3JtYW5jZSB0ZXN0cywgQk9PTFxuICAgIC8vIGFuZCBFTlVNIGFyZSBwYWNrZWQgYnkgZGVmYXVsdCBhcyB3ZWxsLiBUaGlzIG1lYW5zIG9ubHkgU1RSSU5HIGFuZCBCWVRFU1xuICAgIC8vIGFyZSBub3QgcGFja2VkIGJ5IGRlZmF1bHQsIHdoaWNoIG1ha2VzIHNlbnNlIGJlY2F1c2UgdGhleSBhcmUgbGVuZ3RoLWRlbGltaXRlZC5cbiAgICBzd2l0Y2ggKHByb3RvLnR5cGUpIHtcbiAgICAgICAgY2FzZSBGaWVsZERlc2NyaXB0b3JQcm90b19UeXBlLlNUUklORzpcbiAgICAgICAgY2FzZSBGaWVsZERlc2NyaXB0b3JQcm90b19UeXBlLkJZVEVTOlxuICAgICAgICBjYXNlIEZpZWxkRGVzY3JpcHRvclByb3RvX1R5cGUuR1JPVVA6XG4gICAgICAgIGNhc2UgRmllbGREZXNjcmlwdG9yUHJvdG9fVHlwZS5NRVNTQUdFOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuLyoqXG4gKiBQYWNrIHRoaXMgcmVwZWF0ZWQgZmllbGQ/XG4gKlxuICogUmVzcGVjdHMgZmllbGQgdHlwZSwgcHJvdG8yL3Byb3RvMyBkZWZhdWx0cyBhbmQgdGhlIGBwYWNrZWRgIG9wdGlvbiwgb3JcbiAqIGVkaXRpb24gZGVmYXVsdHMgYW5kIHRoZSBlZGl0aW9uIGZlYXR1cmVzLnJlcGVhdGVkX2ZpZWxkX2VuY29kaW5nIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGlzUGFja2VkRmllbGQoZmlsZSwgcGFyZW50LCBwcm90bywgcmVzb2x2ZUZlYXR1cmVzKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgc3dpdGNoIChwcm90by50eXBlKSB7XG4gICAgICAgIGNhc2UgRmllbGREZXNjcmlwdG9yUHJvdG9fVHlwZS5TVFJJTkc6XG4gICAgICAgIGNhc2UgRmllbGREZXNjcmlwdG9yUHJvdG9fVHlwZS5CWVRFUzpcbiAgICAgICAgY2FzZSBGaWVsZERlc2NyaXB0b3JQcm90b19UeXBlLkdST1VQOlxuICAgICAgICBjYXNlIEZpZWxkRGVzY3JpcHRvclByb3RvX1R5cGUuTUVTU0FHRTpcbiAgICAgICAgICAgIC8vIGxlbmd0aC1kZWxpbWl0ZWQgdHlwZXMgY2Fubm90IGJlIHBhY2tlZFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc3dpdGNoIChmaWxlLmVkaXRpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlIEVkaXRpb24uRURJVElPTl9QUk9UTzI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSBwcm90by5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFja2VkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICBjYXNlIEVkaXRpb24uRURJVElPTl9QUk9UTzM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoX2QgPSAoX2MgPSBwcm90by5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucGFja2VkKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0cnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByZXBlYXRlZEZpZWxkRW5jb2RpbmcgfSA9IHJlc29sdmVGZWF0dXJlcyhmaWxlLmVkaXRpb24sIChfZSA9IHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5nZXRGZWF0dXJlcygpKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBmaWxlLmdldEZlYXR1cmVzKCksIChfZiA9IHByb3RvLm9wdGlvbnMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5mZWF0dXJlcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAocmVwZWF0ZWRGaWVsZEVuY29kaW5nID09IEZlYXR1cmVTZXRfUmVwZWF0ZWRGaWVsZEVuY29kaW5nLlBBQ0tFRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogTWFwIGZyb20gYSBjb21waWxlci1nZW5lcmF0ZWQgZmllbGQgdHlwZSB0byBvdXIgU2NhbGFyVHlwZSwgd2hpY2ggaXMgYVxuICogc3Vic2V0IG9mIGZpZWxkIHR5cGVzIGRlY2xhcmVkIGJ5IHByb3RvYnVmIGVudW0gZ29vZ2xlLnByb3RvYnVmLkZpZWxkRGVzY3JpcHRvclByb3RvLlxuICovXG5jb25zdCBmaWVsZFR5cGVUb1NjYWxhclR5cGUgPSB7XG4gICAgW0ZpZWxkRGVzY3JpcHRvclByb3RvX1R5cGUuRE9VQkxFXTogZXNtX2ZpZWxkLyogU2NhbGFyVHlwZSAqLy53LkRPVUJMRSxcbiAgICBbRmllbGREZXNjcmlwdG9yUHJvdG9fVHlwZS5GTE9BVF06IGVzbV9maWVsZC8qIFNjYWxhclR5cGUgKi8udy5GTE9BVCxcbiAgICBbRmllbGREZXNjcmlwdG9yUHJvdG9fVHlwZS5JTlQ2NF06IGVzbV9maWVsZC8qIFNjYWxhclR5cGUgKi8udy5JTlQ2NCxcbiAgICBbRmllbGREZXNjcmlwdG9yUHJvdG9fVHlwZS5VSU5UNjRdOiBlc21fZmllbGQvKiBTY2FsYXJUeXBlICovLncuVUlOVDY0LFxuICAgIFtGaWVsZERlc2NyaXB0b3JQcm90b19UeXBlLklOVDMyXTogZXNtX2ZpZWxkLyogU2NhbGFyVHlwZSAqLy53LklOVDMyLFxuICAgIFtGaWVsZERlc2NyaXB0b3JQcm90b19UeXBlLkZJWEVENjRdOiBlc21fZmllbGQvKiBTY2FsYXJUeXBlICovLncuRklYRUQ2NCxcbiAgICBbRmllbGREZXNjcmlwdG9yUHJvdG9fVHlwZS5GSVhFRDMyXTogZXNtX2ZpZWxkLyogU2NhbGFyVHlwZSAqLy53LkZJWEVEMzIsXG4gICAgW0ZpZWxkRGVzY3JpcHRvclByb3RvX1R5cGUuQk9PTF06IGVzbV9maWVsZC8qIFNjYWxhclR5cGUgKi8udy5CT09MLFxuICAgIFtGaWVsZERlc2NyaXB0b3JQcm90b19UeXBlLlNUUklOR106IGVzbV9maWVsZC8qIFNjYWxhclR5cGUgKi8udy5TVFJJTkcsXG4gICAgW0ZpZWxkRGVzY3JpcHRvclByb3RvX1R5cGUuR1JPVVBdOiB1bmRlZmluZWQsXG4gICAgW0ZpZWxkRGVzY3JpcHRvclByb3RvX1R5cGUuTUVTU0FHRV06IHVuZGVmaW5lZCxcbiAgICBbRmllbGREZXNjcmlwdG9yUHJvdG9fVHlwZS5CWVRFU106IGVzbV9maWVsZC8qIFNjYWxhclR5cGUgKi8udy5CWVRFUyxcbiAgICBbRmllbGREZXNjcmlwdG9yUHJvdG9fVHlwZS5VSU5UMzJdOiBlc21fZmllbGQvKiBTY2FsYXJUeXBlICovLncuVUlOVDMyLFxuICAgIFtGaWVsZERlc2NyaXB0b3JQcm90b19UeXBlLkVOVU1dOiB1bmRlZmluZWQsXG4gICAgW0ZpZWxkRGVzY3JpcHRvclByb3RvX1R5cGUuU0ZJWEVEMzJdOiBlc21fZmllbGQvKiBTY2FsYXJUeXBlICovLncuU0ZJWEVEMzIsXG4gICAgW0ZpZWxkRGVzY3JpcHRvclByb3RvX1R5cGUuU0ZJWEVENjRdOiBlc21fZmllbGQvKiBTY2FsYXJUeXBlICovLncuU0ZJWEVENjQsXG4gICAgW0ZpZWxkRGVzY3JpcHRvclByb3RvX1R5cGUuU0lOVDMyXTogZXNtX2ZpZWxkLyogU2NhbGFyVHlwZSAqLy53LlNJTlQzMixcbiAgICBbRmllbGREZXNjcmlwdG9yUHJvdG9fVHlwZS5TSU5UNjRdOiBlc21fZmllbGQvKiBTY2FsYXJUeXBlICovLncuU0lOVDY0LFxufTtcbi8qKlxuICogRmluZCBjb21tZW50cy5cbiAqL1xuZnVuY3Rpb24gZmluZENvbW1lbnRzKHNvdXJjZUNvZGVJbmZvLCBzb3VyY2VQYXRoKSB7XG4gICAgaWYgKCFzb3VyY2VDb2RlSW5mbykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVhZGluZ0RldGFjaGVkOiBbXSxcbiAgICAgICAgICAgIHNvdXJjZVBhdGgsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZvciAoY29uc3QgbG9jYXRpb24gb2Ygc291cmNlQ29kZUluZm8ubG9jYXRpb24pIHtcbiAgICAgICAgaWYgKGxvY2F0aW9uLnBhdGgubGVuZ3RoICE9PSBzb3VyY2VQYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2F0aW9uLnBhdGguc29tZSgodmFsdWUsIGluZGV4KSA9PiBzb3VyY2VQYXRoW2luZGV4XSAhPT0gdmFsdWUpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVhZGluZ0RldGFjaGVkOiBsb2NhdGlvbi5sZWFkaW5nRGV0YWNoZWRDb21tZW50cyxcbiAgICAgICAgICAgIGxlYWRpbmc6IGxvY2F0aW9uLmxlYWRpbmdDb21tZW50cyxcbiAgICAgICAgICAgIHRyYWlsaW5nOiBsb2NhdGlvbi50cmFpbGluZ0NvbW1lbnRzLFxuICAgICAgICAgICAgc291cmNlUGF0aCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVhZGluZ0RldGFjaGVkOiBbXSxcbiAgICAgICAgc291cmNlUGF0aCxcbiAgICB9O1xufVxuLyoqXG4gKiBUaGUgZm9sbG93aW5nIGZpZWxkIG51bWJlcnMgYXJlIHVzZWQgdG8gZmluZCBjb21tZW50cyBpblxuICogZ29vZ2xlLnByb3RvYnVmLlNvdXJjZUNvZGVJbmZvLlxuICovXG52YXIgRmllbGROdW1iZXI7XG4oZnVuY3Rpb24gKEZpZWxkTnVtYmVyKSB7XG4gICAgRmllbGROdW1iZXJbRmllbGROdW1iZXJbXCJGaWxlRGVzY3JpcHRvclByb3RvX1BhY2thZ2VcIl0gPSAyXSA9IFwiRmlsZURlc2NyaXB0b3JQcm90b19QYWNrYWdlXCI7XG4gICAgRmllbGROdW1iZXJbRmllbGROdW1iZXJbXCJGaWxlRGVzY3JpcHRvclByb3RvX01lc3NhZ2VUeXBlXCJdID0gNF0gPSBcIkZpbGVEZXNjcmlwdG9yUHJvdG9fTWVzc2FnZVR5cGVcIjtcbiAgICBGaWVsZE51bWJlcltGaWVsZE51bWJlcltcIkZpbGVEZXNjcmlwdG9yUHJvdG9fRW51bVR5cGVcIl0gPSA1XSA9IFwiRmlsZURlc2NyaXB0b3JQcm90b19FbnVtVHlwZVwiO1xuICAgIEZpZWxkTnVtYmVyW0ZpZWxkTnVtYmVyW1wiRmlsZURlc2NyaXB0b3JQcm90b19TZXJ2aWNlXCJdID0gNl0gPSBcIkZpbGVEZXNjcmlwdG9yUHJvdG9fU2VydmljZVwiO1xuICAgIEZpZWxkTnVtYmVyW0ZpZWxkTnVtYmVyW1wiRmlsZURlc2NyaXB0b3JQcm90b19FeHRlbnNpb25cIl0gPSA3XSA9IFwiRmlsZURlc2NyaXB0b3JQcm90b19FeHRlbnNpb25cIjtcbiAgICBGaWVsZE51bWJlcltGaWVsZE51bWJlcltcIkZpbGVEZXNjcmlwdG9yUHJvdG9fU3ludGF4XCJdID0gMTJdID0gXCJGaWxlRGVzY3JpcHRvclByb3RvX1N5bnRheFwiO1xuICAgIEZpZWxkTnVtYmVyW0ZpZWxkTnVtYmVyW1wiRGVzY3JpcHRvclByb3RvX0ZpZWxkXCJdID0gMl0gPSBcIkRlc2NyaXB0b3JQcm90b19GaWVsZFwiO1xuICAgIEZpZWxkTnVtYmVyW0ZpZWxkTnVtYmVyW1wiRGVzY3JpcHRvclByb3RvX05lc3RlZFR5cGVcIl0gPSAzXSA9IFwiRGVzY3JpcHRvclByb3RvX05lc3RlZFR5cGVcIjtcbiAgICBGaWVsZE51bWJlcltGaWVsZE51bWJlcltcIkRlc2NyaXB0b3JQcm90b19FbnVtVHlwZVwiXSA9IDRdID0gXCJEZXNjcmlwdG9yUHJvdG9fRW51bVR5cGVcIjtcbiAgICBGaWVsZE51bWJlcltGaWVsZE51bWJlcltcIkRlc2NyaXB0b3JQcm90b19FeHRlbnNpb25cIl0gPSA2XSA9IFwiRGVzY3JpcHRvclByb3RvX0V4dGVuc2lvblwiO1xuICAgIEZpZWxkTnVtYmVyW0ZpZWxkTnVtYmVyW1wiRGVzY3JpcHRvclByb3RvX09uZW9mRGVjbFwiXSA9IDhdID0gXCJEZXNjcmlwdG9yUHJvdG9fT25lb2ZEZWNsXCI7XG4gICAgRmllbGROdW1iZXJbRmllbGROdW1iZXJbXCJFbnVtRGVzY3JpcHRvclByb3RvX1ZhbHVlXCJdID0gMl0gPSBcIkVudW1EZXNjcmlwdG9yUHJvdG9fVmFsdWVcIjtcbiAgICBGaWVsZE51bWJlcltGaWVsZE51bWJlcltcIlNlcnZpY2VEZXNjcmlwdG9yUHJvdG9fTWV0aG9kXCJdID0gMl0gPSBcIlNlcnZpY2VEZXNjcmlwdG9yUHJvdG9fTWV0aG9kXCI7XG59KShGaWVsZE51bWJlciB8fCAoRmllbGROdW1iZXIgPSB7fSkpO1xuLyoqXG4gKiBSZXR1cm4gYSBzdHJpbmcgdGhhdCBtYXRjaGVzIHRoZSBkZWZpbml0aW9uIG9mIGEgZmllbGQgaW4gdGhlIHByb3RvYnVmXG4gKiBzb3VyY2UuIERvZXMgbm90IHRha2UgY3VzdG9tIG9wdGlvbnMgaW50byBhY2NvdW50LlxuICovXG5mdW5jdGlvbiBkZWNsYXJhdGlvblN0cmluZygpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgIGlmICh0aGlzLnJlcGVhdGVkKSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCJyZXBlYXRlZFwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9uYWwpIHtcbiAgICAgICAgcGFydHMucHVzaChcIm9wdGlvbmFsXCIpO1xuICAgIH1cbiAgICBjb25zdCBmaWxlID0gdGhpcy5raW5kID09PSBcImV4dGVuc2lvblwiID8gdGhpcy5maWxlIDogdGhpcy5wYXJlbnQuZmlsZTtcbiAgICBpZiAoZmlsZS5zeW50YXggPT0gXCJwcm90bzJcIiAmJlxuICAgICAgICB0aGlzLnByb3RvLmxhYmVsID09PSBGaWVsZERlc2NyaXB0b3JQcm90b19MYWJlbC5SRVFVSVJFRCkge1xuICAgICAgICBwYXJ0cy5wdXNoKFwicmVxdWlyZWRcIik7XG4gICAgfVxuICAgIGxldCB0eXBlO1xuICAgIHN3aXRjaCAodGhpcy5maWVsZEtpbmQpIHtcbiAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgdHlwZSA9IGVzbV9maWVsZC8qIFNjYWxhclR5cGUgKi8ud1t0aGlzLnNjYWxhcl0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgdHlwZSA9IHRoaXMuZW51bS50eXBlTmFtZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgdHlwZSA9IHRoaXMubWVzc2FnZS50eXBlTmFtZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWFwXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IGsgPSBlc21fZmllbGQvKiBTY2FsYXJUeXBlICovLndbdGhpcy5tYXBLZXldLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBsZXQgdjtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5tYXBWYWx1ZS5raW5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICB2ID0gZXNtX2ZpZWxkLyogU2NhbGFyVHlwZSAqLy53W3RoaXMubWFwVmFsdWUuc2NhbGFyXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5tYXBWYWx1ZS5lbnVtLnR5cGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5tYXBWYWx1ZS5tZXNzYWdlLnR5cGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGUgPSBgbWFwPCR7a30sICR7dn0+YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnRzLnB1c2goYCR7dHlwZX0gJHt0aGlzLm5hbWV9ID0gJHt0aGlzLm51bWJlcn1gKTtcbiAgICBjb25zdCBvcHRpb25zID0gW107XG4gICAgaWYgKCgoX2EgPSB0aGlzLnByb3RvLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYWNrZWQpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5wdXNoKGBwYWNrZWQgPSAke3RoaXMucHJvdG8ub3B0aW9ucy5wYWNrZWQudG9TdHJpbmcoKX1gKTtcbiAgICB9XG4gICAgbGV0IGRlZmF1bHRWYWx1ZSA9IHRoaXMucHJvdG8uZGVmYXVsdFZhbHVlO1xuICAgIGlmIChkZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodGhpcy5wcm90by50eXBlID09IEZpZWxkRGVzY3JpcHRvclByb3RvX1R5cGUuQllURVMgfHxcbiAgICAgICAgICAgIHRoaXMucHJvdG8udHlwZSA9PSBGaWVsZERlc2NyaXB0b3JQcm90b19UeXBlLlNUUklORykge1xuICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gJ1wiJyArIGRlZmF1bHRWYWx1ZS5yZXBsYWNlKCdcIicsICdcXFxcXCInKSArICdcIic7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5wdXNoKGBkZWZhdWx0ID0gJHtkZWZhdWx0VmFsdWV9YCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmpzb25OYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5wdXNoKGBqc29uX25hbWUgPSBcIiR7dGhpcy5qc29uTmFtZX1cImApO1xuICAgIH1cbiAgICBpZiAoKChfYiA9IHRoaXMucHJvdG8ub3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmpzdHlwZSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLnB1c2goYGpzdHlwZSA9ICR7RmllbGRPcHRpb25zX0pTVHlwZVt0aGlzLnByb3RvLm9wdGlvbnMuanN0eXBlXX1gKTtcbiAgICB9XG4gICAgaWYgKCgoX2MgPSB0aGlzLnByb3RvLm9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kZXByZWNhdGVkKSA9PT0gdHJ1ZSkge1xuICAgICAgICBvcHRpb25zLnB1c2goYGRlcHJlY2F0ZWQgPSB0cnVlYCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcGFydHMucHVzaChcIltcIiArIG9wdGlvbnMuam9pbihcIiwgXCIpICsgXCJdXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHMuam9pbihcIiBcIik7XG59XG4vKipcbiAqIFBhcnNlcyBhIHRleHQtZW5jb2RlZCBkZWZhdWx0IHZhbHVlIChwcm90bzIpIG9mIGEgc2NhbGFyIG9yIGVudW0gZmllbGQuXG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRWYWx1ZSgpIHtcbiAgICBjb25zdCBkID0gdGhpcy5wcm90by5kZWZhdWx0VmFsdWU7XG4gICAgaWYgKGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMuZmllbGRLaW5kKSB7XG4gICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUZXh0Rm9ybWF0RW51bVZhbHVlKHRoaXMuZW51bSwgZCk7XG4gICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRleHRGb3JtYXRTY2FsYXJWYWx1ZSh0aGlzLnNjYWxhciwgZCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9jcmVhdGUtcmVnaXN0cnkuanNcbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyByZWdpc3RyeSBmcm9tIHRoZSBnaXZlbiB0eXBlcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmVnaXN0cnkoLi4udHlwZXMpIHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IHt9O1xuICAgIGNvbnN0IGVudW1zID0ge307XG4gICAgY29uc3Qgc2VydmljZXMgPSB7fTtcbiAgICBjb25zdCByZWdpc3RyeSA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhIHR5cGUgdG8gdGhlIHJlZ2lzdHJ5LiBGb3IgbWVzc2FnZXMsIHRoZSB0eXBlcyB1c2VkIGluIG1lc3NhZ2VcbiAgICAgICAgICogZmllbGRzIGFyZSBhZGRlZCByZWN1cnNpdmVseS4gRm9yIHNlcnZpY2VzLCB0aGUgbWVzc2FnZSB0eXBlcyB1c2VkXG4gICAgICAgICAqIGZvciByZXF1ZXN0cyBhbmQgcmVzcG9uc2VzIGFyZSBhZGRlZCByZWN1cnNpdmVseS5cbiAgICAgICAgICovXG4gICAgICAgIGFkZCh0eXBlKSB7XG4gICAgICAgICAgICBpZiAoXCJmaWVsZHNcIiBpbiB0eXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZpbmRNZXNzYWdlKHR5cGUudHlwZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzW3R5cGUudHlwZU5hbWVdID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlLmZpZWxkcy5saXN0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5raW5kID09IFwibWVzc2FnZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQoZmllbGQuVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5raW5kID09IFwibWFwXCIgJiYgZmllbGQuVi5raW5kID09IFwibWVzc2FnZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQoZmllbGQuVi5UKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkLmtpbmQgPT0gXCJlbnVtXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZChmaWVsZC5UKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFwibWV0aG9kc1wiIGluIHR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZmluZFNlcnZpY2UodHlwZS50eXBlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VydmljZXNbdHlwZS50eXBlTmFtZV0gPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBPYmplY3QudmFsdWVzKHR5cGUubWV0aG9kcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKG1ldGhvZC5JKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKG1ldGhvZC5PKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVudW1zW3R5cGUudHlwZU5hbWVdID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmluZE1lc3NhZ2UodHlwZU5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlc1t0eXBlTmFtZV07XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmRFbnVtKHR5cGVOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZW51bXNbdHlwZU5hbWVdO1xuICAgICAgICB9LFxuICAgICAgICBmaW5kU2VydmljZSh0eXBlTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcnZpY2VzW3R5cGVOYW1lXTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGZvciAoY29uc3QgdHlwZSBvZiB0eXBlcykge1xuICAgICAgICByZWdpc3RyeS5hZGQodHlwZSk7XG4gICAgfVxuICAgIHJldHVybiByZWdpc3RyeTtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9nb29nbGUvcHJvdG9idWYvdGltZXN0YW1wX3BiLmpzXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5cblxuLyoqXG4gKiBBIFRpbWVzdGFtcCByZXByZXNlbnRzIGEgcG9pbnQgaW4gdGltZSBpbmRlcGVuZGVudCBvZiBhbnkgdGltZSB6b25lIG9yIGxvY2FsXG4gKiBjYWxlbmRhciwgZW5jb2RlZCBhcyBhIGNvdW50IG9mIHNlY29uZHMgYW5kIGZyYWN0aW9ucyBvZiBzZWNvbmRzIGF0XG4gKiBuYW5vc2Vjb25kIHJlc29sdXRpb24uIFRoZSBjb3VudCBpcyByZWxhdGl2ZSB0byBhbiBlcG9jaCBhdCBVVEMgbWlkbmlnaHQgb25cbiAqIEphbnVhcnkgMSwgMTk3MCwgaW4gdGhlIHByb2xlcHRpYyBHcmVnb3JpYW4gY2FsZW5kYXIgd2hpY2ggZXh0ZW5kcyB0aGVcbiAqIEdyZWdvcmlhbiBjYWxlbmRhciBiYWNrd2FyZHMgdG8geWVhciBvbmUuXG4gKlxuICogQWxsIG1pbnV0ZXMgYXJlIDYwIHNlY29uZHMgbG9uZy4gTGVhcCBzZWNvbmRzIGFyZSBcInNtZWFyZWRcIiBzbyB0aGF0IG5vIGxlYXBcbiAqIHNlY29uZCB0YWJsZSBpcyBuZWVkZWQgZm9yIGludGVycHJldGF0aW9uLCB1c2luZyBhIFsyNC1ob3VyIGxpbmVhclxuICogc21lYXJdKGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3RpbWUvc21lYXIpLlxuICpcbiAqIFRoZSByYW5nZSBpcyBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvIDk5OTktMTItMzFUMjM6NTk6NTkuOTk5OTk5OTk5Wi4gQnlcbiAqIHJlc3RyaWN0aW5nIHRvIHRoYXQgcmFuZ2UsIHdlIGVuc3VyZSB0aGF0IHdlIGNhbiBjb252ZXJ0IHRvIGFuZCBmcm9tIFtSRkNcbiAqIDMzMzldKGh0dHBzOi8vd3d3LmlldGYub3JnL3JmYy9yZmMzMzM5LnR4dCkgZGF0ZSBzdHJpbmdzLlxuICpcbiAqICMgRXhhbXBsZXNcbiAqXG4gKiBFeGFtcGxlIDE6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gUE9TSVggYHRpbWUoKWAuXG4gKlxuICogICAgIFRpbWVzdGFtcCB0aW1lc3RhbXA7XG4gKiAgICAgdGltZXN0YW1wLnNldF9zZWNvbmRzKHRpbWUoTlVMTCkpO1xuICogICAgIHRpbWVzdGFtcC5zZXRfbmFub3MoMCk7XG4gKlxuICogRXhhbXBsZSAyOiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIFBPU0lYIGBnZXR0aW1lb2ZkYXkoKWAuXG4gKlxuICogICAgIHN0cnVjdCB0aW1ldmFsIHR2O1xuICogICAgIGdldHRpbWVvZmRheSgmdHYsIE5VTEwpO1xuICpcbiAqICAgICBUaW1lc3RhbXAgdGltZXN0YW1wO1xuICogICAgIHRpbWVzdGFtcC5zZXRfc2Vjb25kcyh0di50dl9zZWMpO1xuICogICAgIHRpbWVzdGFtcC5zZXRfbmFub3ModHYudHZfdXNlYyAqIDEwMDApO1xuICpcbiAqIEV4YW1wbGUgMzogQ29tcHV0ZSBUaW1lc3RhbXAgZnJvbSBXaW4zMiBgR2V0U3lzdGVtVGltZUFzRmlsZVRpbWUoKWAuXG4gKlxuICogICAgIEZJTEVUSU1FIGZ0O1xuICogICAgIEdldFN5c3RlbVRpbWVBc0ZpbGVUaW1lKCZmdCk7XG4gKiAgICAgVUlOVDY0IHRpY2tzID0gKCgoVUlOVDY0KWZ0LmR3SGlnaERhdGVUaW1lKSA8PCAzMikgfCBmdC5kd0xvd0RhdGVUaW1lO1xuICpcbiAqICAgICAvLyBBIFdpbmRvd3MgdGljayBpcyAxMDAgbmFub3NlY29uZHMuIFdpbmRvd3MgZXBvY2ggMTYwMS0wMS0wMVQwMDowMDowMFpcbiAqICAgICAvLyBpcyAxMTY0NDQ3MzYwMCBzZWNvbmRzIGJlZm9yZSBVbml4IGVwb2NoIDE5NzAtMDEtMDFUMDA6MDA6MDBaLlxuICogICAgIFRpbWVzdGFtcCB0aW1lc3RhbXA7XG4gKiAgICAgdGltZXN0YW1wLnNldF9zZWNvbmRzKChJTlQ2NCkgKCh0aWNrcyAvIDEwMDAwMDAwKSAtIDExNjQ0NDczNjAwTEwpKTtcbiAqICAgICB0aW1lc3RhbXAuc2V0X25hbm9zKChJTlQzMikgKCh0aWNrcyAlIDEwMDAwMDAwKSAqIDEwMCkpO1xuICpcbiAqIEV4YW1wbGUgNDogQ29tcHV0ZSBUaW1lc3RhbXAgZnJvbSBKYXZhIGBTeXN0ZW0uY3VycmVudFRpbWVNaWxsaXMoKWAuXG4gKlxuICogICAgIGxvbmcgbWlsbGlzID0gU3lzdGVtLmN1cnJlbnRUaW1lTWlsbGlzKCk7XG4gKlxuICogICAgIFRpbWVzdGFtcCB0aW1lc3RhbXAgPSBUaW1lc3RhbXAubmV3QnVpbGRlcigpLnNldFNlY29uZHMobWlsbGlzIC8gMTAwMClcbiAqICAgICAgICAgLnNldE5hbm9zKChpbnQpICgobWlsbGlzICUgMTAwMCkgKiAxMDAwMDAwKSkuYnVpbGQoKTtcbiAqXG4gKiBFeGFtcGxlIDU6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gSmF2YSBgSW5zdGFudC5ub3coKWAuXG4gKlxuICogICAgIEluc3RhbnQgbm93ID0gSW5zdGFudC5ub3coKTtcbiAqXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcCA9XG4gKiAgICAgICAgIFRpbWVzdGFtcC5uZXdCdWlsZGVyKCkuc2V0U2Vjb25kcyhub3cuZ2V0RXBvY2hTZWNvbmQoKSlcbiAqICAgICAgICAgICAgIC5zZXROYW5vcyhub3cuZ2V0TmFubygpKS5idWlsZCgpO1xuICpcbiAqIEV4YW1wbGUgNjogQ29tcHV0ZSBUaW1lc3RhbXAgZnJvbSBjdXJyZW50IHRpbWUgaW4gUHl0aG9uLlxuICpcbiAqICAgICB0aW1lc3RhbXAgPSBUaW1lc3RhbXAoKVxuICogICAgIHRpbWVzdGFtcC5HZXRDdXJyZW50VGltZSgpXG4gKlxuICogIyBKU09OIE1hcHBpbmdcbiAqXG4gKiBJbiBKU09OIGZvcm1hdCwgdGhlIFRpbWVzdGFtcCB0eXBlIGlzIGVuY29kZWQgYXMgYSBzdHJpbmcgaW4gdGhlXG4gKiBbUkZDIDMzMzldKGh0dHBzOi8vd3d3LmlldGYub3JnL3JmYy9yZmMzMzM5LnR4dCkgZm9ybWF0LiBUaGF0IGlzLCB0aGVcbiAqIGZvcm1hdCBpcyBcInt5ZWFyfS17bW9udGh9LXtkYXl9VHtob3VyfTp7bWlufTp7c2VjfVsue2ZyYWNfc2VjfV1aXCJcbiAqIHdoZXJlIHt5ZWFyfSBpcyBhbHdheXMgZXhwcmVzc2VkIHVzaW5nIGZvdXIgZGlnaXRzIHdoaWxlIHttb250aH0sIHtkYXl9LFxuICoge2hvdXJ9LCB7bWlufSwgYW5kIHtzZWN9IGFyZSB6ZXJvLXBhZGRlZCB0byB0d28gZGlnaXRzIGVhY2guIFRoZSBmcmFjdGlvbmFsXG4gKiBzZWNvbmRzLCB3aGljaCBjYW4gZ28gdXAgdG8gOSBkaWdpdHMgKGkuZS4gdXAgdG8gMSBuYW5vc2Vjb25kIHJlc29sdXRpb24pLFxuICogYXJlIG9wdGlvbmFsLiBUaGUgXCJaXCIgc3VmZml4IGluZGljYXRlcyB0aGUgdGltZXpvbmUgKFwiVVRDXCIpOyB0aGUgdGltZXpvbmVcbiAqIGlzIHJlcXVpcmVkLiBBIHByb3RvMyBKU09OIHNlcmlhbGl6ZXIgc2hvdWxkIGFsd2F5cyB1c2UgVVRDIChhcyBpbmRpY2F0ZWQgYnlcbiAqIFwiWlwiKSB3aGVuIHByaW50aW5nIHRoZSBUaW1lc3RhbXAgdHlwZSBhbmQgYSBwcm90bzMgSlNPTiBwYXJzZXIgc2hvdWxkIGJlXG4gKiBhYmxlIHRvIGFjY2VwdCBib3RoIFVUQyBhbmQgb3RoZXIgdGltZXpvbmVzIChhcyBpbmRpY2F0ZWQgYnkgYW4gb2Zmc2V0KS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgXCIyMDE3LTAxLTE1VDAxOjMwOjE1LjAxWlwiIGVuY29kZXMgMTUuMDEgc2Vjb25kcyBwYXN0XG4gKiAwMTozMCBVVEMgb24gSmFudWFyeSAxNSwgMjAxNy5cbiAqXG4gKiBJbiBKYXZhU2NyaXB0LCBvbmUgY2FuIGNvbnZlcnQgYSBEYXRlIG9iamVjdCB0byB0aGlzIGZvcm1hdCB1c2luZyB0aGVcbiAqIHN0YW5kYXJkXG4gKiBbdG9JU09TdHJpbmcoKV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS90b0lTT1N0cmluZylcbiAqIG1ldGhvZC4gSW4gUHl0aG9uLCBhIHN0YW5kYXJkIGBkYXRldGltZS5kYXRldGltZWAgb2JqZWN0IGNhbiBiZSBjb252ZXJ0ZWRcbiAqIHRvIHRoaXMgZm9ybWF0IHVzaW5nXG4gKiBbYHN0cmZ0aW1lYF0oaHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMi9saWJyYXJ5L3RpbWUuaHRtbCN0aW1lLnN0cmZ0aW1lKSB3aXRoXG4gKiB0aGUgdGltZSBmb3JtYXQgc3BlYyAnJVktJW0tJWRUJUg6JU06JVMuJWZaJy4gTGlrZXdpc2UsIGluIEphdmEsIG9uZSBjYW4gdXNlXG4gKiB0aGUgSm9kYSBUaW1lJ3MgW2BJU09EYXRlVGltZUZvcm1hdC5kYXRlVGltZSgpYF0oXG4gKiBodHRwOi8vam9kYS10aW1lLnNvdXJjZWZvcmdlLm5ldC9hcGlkb2NzL29yZy9qb2RhL3RpbWUvZm9ybWF0L0lTT0RhdGVUaW1lRm9ybWF0Lmh0bWwjZGF0ZVRpbWUoKVxuICogKSB0byBvYnRhaW4gYSBmb3JtYXR0ZXIgY2FwYWJsZSBvZiBnZW5lcmF0aW5nIHRpbWVzdGFtcHMgaW4gdGhpcyBmb3JtYXQuXG4gKlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcbiAqL1xuY2xhc3MgVGltZXN0YW1wIGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcHJlc2VudHMgc2Vjb25kcyBvZiBVVEMgdGltZSBzaW5jZSBVbml4IGVwb2NoXG4gICAgICAgICAqIDE5NzAtMDEtMDFUMDA6MDA6MDBaLiBNdXN0IGJlIGZyb20gMDAwMS0wMS0wMVQwMDowMDowMFogdG9cbiAgICAgICAgICogOTk5OS0xMi0zMVQyMzo1OTo1OVogaW5jbHVzaXZlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDY0IHNlY29uZHMgPSAxO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWNvbmRzID0gcHJvdG9faW50NjQvKiBwcm90b0ludDY0ICovLnEuemVybztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbi1uZWdhdGl2ZSBmcmFjdGlvbnMgb2YgYSBzZWNvbmQgYXQgbmFub3NlY29uZCByZXNvbHV0aW9uLiBOZWdhdGl2ZVxuICAgICAgICAgKiBzZWNvbmQgdmFsdWVzIHdpdGggZnJhY3Rpb25zIG11c3Qgc3RpbGwgaGF2ZSBub24tbmVnYXRpdmUgbmFub3MgdmFsdWVzXG4gICAgICAgICAqIHRoYXQgY291bnQgZm9yd2FyZCBpbiB0aW1lLiBNdXN0IGJlIGZyb20gMCB0byA5OTksOTk5LDk5OVxuICAgICAgICAgKiBpbmNsdXNpdmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50MzIgbmFub3MgPSAyO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW5vcyA9IDA7XG4gICAgICAgIHByb3RvMy8qIHByb3RvMyAqLy53LnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIGZyb21Kc29uKGpzb24sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBkZWNvZGUgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBmcm9tIEpTT046ICR7cHJvdG8zLyogcHJvdG8zICovLncuanNvbi5kZWJ1Zyhqc29uKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXRjaGVzID0ganNvbi5tYXRjaCgvXihbMC05XXs0fSktKFswLTldezJ9KS0oWzAtOV17Mn0pVChbMC05XXsyfSk6KFswLTldezJ9KTooWzAtOV17Mn0pKD86WnxcXC4oWzAtOV17Myw5fSlafChbKy1dWzAtOV1bMC05XTpbMC05XVswLTldKSkkLyk7XG4gICAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgZnJvbSBKU09OOiBpbnZhbGlkIFJGQyAzMzM5IHN0cmluZ2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1zID0gRGF0ZS5wYXJzZShtYXRjaGVzWzFdICsgXCItXCIgKyBtYXRjaGVzWzJdICsgXCItXCIgKyBtYXRjaGVzWzNdICsgXCJUXCIgKyBtYXRjaGVzWzRdICsgXCI6XCIgKyBtYXRjaGVzWzVdICsgXCI6XCIgKyBtYXRjaGVzWzZdICsgKG1hdGNoZXNbOF0gPyBtYXRjaGVzWzhdIDogXCJaXCIpKTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihtcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIGZyb20gSlNPTjogaW52YWxpZCBSRkMgMzMzOSBzdHJpbmdgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMgPCBEYXRlLnBhcnNlKFwiMDAwMS0wMS0wMVQwMDowMDowMFpcIikgfHwgbXMgPiBEYXRlLnBhcnNlKFwiOTk5OS0xMi0zMVQyMzo1OTo1OVpcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgZnJvbSBKU09OOiBtdXN0IGJlIGZyb20gMDAwMS0wMS0wMVQwMDowMDowMFogdG8gOTk5OS0xMi0zMVQyMzo1OTo1OVogaW5jbHVzaXZlYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWNvbmRzID0gcHJvdG9faW50NjQvKiBwcm90b0ludDY0ICovLnEucGFyc2UobXMgLyAxMDAwKTtcbiAgICAgICAgdGhpcy5uYW5vcyA9IDA7XG4gICAgICAgIGlmIChtYXRjaGVzWzddKSB7XG4gICAgICAgICAgICB0aGlzLm5hbm9zID0gKHBhcnNlSW50KFwiMVwiICsgbWF0Y2hlc1s3XSArIFwiMFwiLnJlcGVhdCg5IC0gbWF0Y2hlc1s3XS5sZW5ndGgpKSAtIDEwMDAwMDAwMDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b0pzb24ob3B0aW9ucykge1xuICAgICAgICBjb25zdCBtcyA9IE51bWJlcih0aGlzLnNlY29uZHMpICogMTAwMDtcbiAgICAgICAgaWYgKG1zIDwgRGF0ZS5wYXJzZShcIjAwMDEtMDEtMDFUMDA6MDA6MDBaXCIpIHx8IG1zID4gRGF0ZS5wYXJzZShcIjk5OTktMTItMzFUMjM6NTk6NTlaXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBlbmNvZGUgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCB0byBKU09OOiBtdXN0IGJlIGZyb20gMDAwMS0wMS0wMVQwMDowMDowMFogdG8gOTk5OS0xMi0zMVQyMzo1OTo1OVogaW5jbHVzaXZlYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmFub3MgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBlbmNvZGUgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCB0byBKU09OOiBuYW5vcyBtdXN0IG5vdCBiZSBuZWdhdGl2ZWApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB6ID0gXCJaXCI7XG4gICAgICAgIGlmICh0aGlzLm5hbm9zID4gMCkge1xuICAgICAgICAgICAgY29uc3QgbmFub3NTdHIgPSAodGhpcy5uYW5vcyArIDEwMDAwMDAwMDApLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgaWYgKG5hbm9zU3RyLnN1YnN0cmluZygzKSA9PT0gXCIwMDAwMDBcIikge1xuICAgICAgICAgICAgICAgIHogPSBcIi5cIiArIG5hbm9zU3RyLnN1YnN0cmluZygwLCAzKSArIFwiWlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmFub3NTdHIuc3Vic3RyaW5nKDYpID09PSBcIjAwMFwiKSB7XG4gICAgICAgICAgICAgICAgeiA9IFwiLlwiICsgbmFub3NTdHIuc3Vic3RyaW5nKDAsIDYpICsgXCJaXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB6ID0gXCIuXCIgKyBuYW5vc1N0ciArIFwiWlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShtcykudG9JU09TdHJpbmcoKS5yZXBsYWNlKFwiLjAwMFpcIiwgeik7XG4gICAgfVxuICAgIHRvRGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE51bWJlcih0aGlzLnNlY29uZHMpICogMTAwMCArIE1hdGguY2VpbCh0aGlzLm5hbm9zIC8gMTAwMDAwMCkpO1xuICAgIH1cbiAgICBzdGF0aWMgbm93KCkge1xuICAgICAgICByZXR1cm4gVGltZXN0YW1wLmZyb21EYXRlKG5ldyBEYXRlKCkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbURhdGUoZGF0ZSkge1xuICAgICAgICBjb25zdCBtcyA9IGRhdGUuZ2V0VGltZSgpO1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVzdGFtcCh7XG4gICAgICAgICAgICBzZWNvbmRzOiBwcm90b19pbnQ2NC8qIHByb3RvSW50NjQgKi8ucS5wYXJzZShNYXRoLmZsb29yKG1zIC8gMTAwMCkpLFxuICAgICAgICAgICAgbmFub3M6IChtcyAlIDEwMDApICogMTAwMDAwMCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGltZXN0YW1wKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVzdGFtcCgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvMy8qIHByb3RvMyAqLy53LnV0aWwuZXF1YWxzKFRpbWVzdGFtcCwgYSwgYik7XG4gICAgfVxufVxuVGltZXN0YW1wLnJ1bnRpbWUgPSBwcm90bzMvKiBwcm90bzMgKi8udztcblRpbWVzdGFtcC50eXBlTmFtZSA9IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiO1xuVGltZXN0YW1wLmZpZWxkcyA9IHByb3RvMy8qIHByb3RvMyAqLy53LnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInNlY29uZHNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJuYW5vc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8gfSxcbl0pO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL2dvb2dsZS9wcm90b2J1Zi9kdXJhdGlvbl9wYi5qc1xuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuXG5cbi8qKlxuICogQSBEdXJhdGlvbiByZXByZXNlbnRzIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggc3BhbiBvZiB0aW1lIHJlcHJlc2VudGVkXG4gKiBhcyBhIGNvdW50IG9mIHNlY29uZHMgYW5kIGZyYWN0aW9ucyBvZiBzZWNvbmRzIGF0IG5hbm9zZWNvbmRcbiAqIHJlc29sdXRpb24uIEl0IGlzIGluZGVwZW5kZW50IG9mIGFueSBjYWxlbmRhciBhbmQgY29uY2VwdHMgbGlrZSBcImRheVwiXG4gKiBvciBcIm1vbnRoXCIuIEl0IGlzIHJlbGF0ZWQgdG8gVGltZXN0YW1wIGluIHRoYXQgdGhlIGRpZmZlcmVuY2UgYmV0d2VlblxuICogdHdvIFRpbWVzdGFtcCB2YWx1ZXMgaXMgYSBEdXJhdGlvbiBhbmQgaXQgY2FuIGJlIGFkZGVkIG9yIHN1YnRyYWN0ZWRcbiAqIGZyb20gYSBUaW1lc3RhbXAuIFJhbmdlIGlzIGFwcHJveGltYXRlbHkgKy0xMCwwMDAgeWVhcnMuXG4gKlxuICogIyBFeGFtcGxlc1xuICpcbiAqIEV4YW1wbGUgMTogQ29tcHV0ZSBEdXJhdGlvbiBmcm9tIHR3byBUaW1lc3RhbXBzIGluIHBzZXVkbyBjb2RlLlxuICpcbiAqICAgICBUaW1lc3RhbXAgc3RhcnQgPSAuLi47XG4gKiAgICAgVGltZXN0YW1wIGVuZCA9IC4uLjtcbiAqICAgICBEdXJhdGlvbiBkdXJhdGlvbiA9IC4uLjtcbiAqXG4gKiAgICAgZHVyYXRpb24uc2Vjb25kcyA9IGVuZC5zZWNvbmRzIC0gc3RhcnQuc2Vjb25kcztcbiAqICAgICBkdXJhdGlvbi5uYW5vcyA9IGVuZC5uYW5vcyAtIHN0YXJ0Lm5hbm9zO1xuICpcbiAqICAgICBpZiAoZHVyYXRpb24uc2Vjb25kcyA8IDAgJiYgZHVyYXRpb24ubmFub3MgPiAwKSB7XG4gKiAgICAgICBkdXJhdGlvbi5zZWNvbmRzICs9IDE7XG4gKiAgICAgICBkdXJhdGlvbi5uYW5vcyAtPSAxMDAwMDAwMDAwO1xuICogICAgIH0gZWxzZSBpZiAoZHVyYXRpb24uc2Vjb25kcyA+IDAgJiYgZHVyYXRpb24ubmFub3MgPCAwKSB7XG4gKiAgICAgICBkdXJhdGlvbi5zZWNvbmRzIC09IDE7XG4gKiAgICAgICBkdXJhdGlvbi5uYW5vcyArPSAxMDAwMDAwMDAwO1xuICogICAgIH1cbiAqXG4gKiBFeGFtcGxlIDI6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gVGltZXN0YW1wICsgRHVyYXRpb24gaW4gcHNldWRvIGNvZGUuXG4gKlxuICogICAgIFRpbWVzdGFtcCBzdGFydCA9IC4uLjtcbiAqICAgICBEdXJhdGlvbiBkdXJhdGlvbiA9IC4uLjtcbiAqICAgICBUaW1lc3RhbXAgZW5kID0gLi4uO1xuICpcbiAqICAgICBlbmQuc2Vjb25kcyA9IHN0YXJ0LnNlY29uZHMgKyBkdXJhdGlvbi5zZWNvbmRzO1xuICogICAgIGVuZC5uYW5vcyA9IHN0YXJ0Lm5hbm9zICsgZHVyYXRpb24ubmFub3M7XG4gKlxuICogICAgIGlmIChlbmQubmFub3MgPCAwKSB7XG4gKiAgICAgICBlbmQuc2Vjb25kcyAtPSAxO1xuICogICAgICAgZW5kLm5hbm9zICs9IDEwMDAwMDAwMDA7XG4gKiAgICAgfSBlbHNlIGlmIChlbmQubmFub3MgPj0gMTAwMDAwMDAwMCkge1xuICogICAgICAgZW5kLnNlY29uZHMgKz0gMTtcbiAqICAgICAgIGVuZC5uYW5vcyAtPSAxMDAwMDAwMDAwO1xuICogICAgIH1cbiAqXG4gKiBFeGFtcGxlIDM6IENvbXB1dGUgRHVyYXRpb24gZnJvbSBkYXRldGltZS50aW1lZGVsdGEgaW4gUHl0aG9uLlxuICpcbiAqICAgICB0ZCA9IGRhdGV0aW1lLnRpbWVkZWx0YShkYXlzPTMsIG1pbnV0ZXM9MTApXG4gKiAgICAgZHVyYXRpb24gPSBEdXJhdGlvbigpXG4gKiAgICAgZHVyYXRpb24uRnJvbVRpbWVkZWx0YSh0ZClcbiAqXG4gKiAjIEpTT04gTWFwcGluZ1xuICpcbiAqIEluIEpTT04gZm9ybWF0LCB0aGUgRHVyYXRpb24gdHlwZSBpcyBlbmNvZGVkIGFzIGEgc3RyaW5nIHJhdGhlciB0aGFuIGFuXG4gKiBvYmplY3QsIHdoZXJlIHRoZSBzdHJpbmcgZW5kcyBpbiB0aGUgc3VmZml4IFwic1wiIChpbmRpY2F0aW5nIHNlY29uZHMpIGFuZFxuICogaXMgcHJlY2VkZWQgYnkgdGhlIG51bWJlciBvZiBzZWNvbmRzLCB3aXRoIG5hbm9zZWNvbmRzIGV4cHJlc3NlZCBhc1xuICogZnJhY3Rpb25hbCBzZWNvbmRzLiBGb3IgZXhhbXBsZSwgMyBzZWNvbmRzIHdpdGggMCBuYW5vc2Vjb25kcyBzaG91bGQgYmVcbiAqIGVuY29kZWQgaW4gSlNPTiBmb3JtYXQgYXMgXCIzc1wiLCB3aGlsZSAzIHNlY29uZHMgYW5kIDEgbmFub3NlY29uZCBzaG91bGRcbiAqIGJlIGV4cHJlc3NlZCBpbiBKU09OIGZvcm1hdCBhcyBcIjMuMDAwMDAwMDAxc1wiLCBhbmQgMyBzZWNvbmRzIGFuZCAxXG4gKiBtaWNyb3NlY29uZCBzaG91bGQgYmUgZXhwcmVzc2VkIGluIEpTT04gZm9ybWF0IGFzIFwiMy4wMDAwMDFzXCIuXG4gKlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvblxuICovXG5jbGFzcyBEdXJhdGlvbiBleHRlbmRzIGVzbV9tZXNzYWdlLyogTWVzc2FnZSAqLy52IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaWduZWQgc2Vjb25kcyBvZiB0aGUgc3BhbiBvZiB0aW1lLiBNdXN0IGJlIGZyb20gLTMxNSw1NzYsMDAwLDAwMFxuICAgICAgICAgKiB0byArMzE1LDU3NiwwMDAsMDAwIGluY2x1c2l2ZS4gTm90ZTogdGhlc2UgYm91bmRzIGFyZSBjb21wdXRlZCBmcm9tOlxuICAgICAgICAgKiA2MCBzZWMvbWluICogNjAgbWluL2hyICogMjQgaHIvZGF5ICogMzY1LjI1IGRheXMveWVhciAqIDEwMDAwIHllYXJzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50NjQgc2Vjb25kcyA9IDE7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlY29uZHMgPSBwcm90b19pbnQ2NC8qIHByb3RvSW50NjQgKi8ucS56ZXJvO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2lnbmVkIGZyYWN0aW9ucyBvZiBhIHNlY29uZCBhdCBuYW5vc2Vjb25kIHJlc29sdXRpb24gb2YgdGhlIHNwYW5cbiAgICAgICAgICogb2YgdGltZS4gRHVyYXRpb25zIGxlc3MgdGhhbiBvbmUgc2Vjb25kIGFyZSByZXByZXNlbnRlZCB3aXRoIGEgMFxuICAgICAgICAgKiBgc2Vjb25kc2AgZmllbGQgYW5kIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgYG5hbm9zYCBmaWVsZC4gRm9yIGR1cmF0aW9uc1xuICAgICAgICAgKiBvZiBvbmUgc2Vjb25kIG9yIG1vcmUsIGEgbm9uLXplcm8gdmFsdWUgZm9yIHRoZSBgbmFub3NgIGZpZWxkIG11c3QgYmVcbiAgICAgICAgICogb2YgdGhlIHNhbWUgc2lnbiBhcyB0aGUgYHNlY29uZHNgIGZpZWxkLiBNdXN0IGJlIGZyb20gLTk5OSw5OTksOTk5XG4gICAgICAgICAqIHRvICs5OTksOTk5LDk5OSBpbmNsdXNpdmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50MzIgbmFub3MgPSAyO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW5vcyA9IDA7XG4gICAgICAgIHByb3RvMy8qIHByb3RvMyAqLy53LnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIGZyb21Kc29uKGpzb24sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBkZWNvZGUgZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uIGZyb20gSlNPTjogJHtwcm90bzMvKiBwcm90bzMgKi8udy5qc29uLmRlYnVnKGpzb24pfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hdGNoID0ganNvbi5tYXRjaCgvXigtP1swLTldKykoPzpcXC4oWzAtOV0rKSk/cy8pO1xuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSBnb29nbGUucHJvdG9idWYuRHVyYXRpb24gZnJvbSBKU09OOiAke3Byb3RvMy8qIHByb3RvMyAqLy53Lmpzb24uZGVidWcoanNvbil9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9uZ1NlY29uZHMgPSBOdW1iZXIobWF0Y2hbMV0pO1xuICAgICAgICBpZiAobG9uZ1NlY29uZHMgPiAzMTU1NzYwMDAwMDAgfHwgbG9uZ1NlY29uZHMgPCAtMzE1NTc2MDAwMDAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBkZWNvZGUgZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uIGZyb20gSlNPTjogJHtwcm90bzMvKiBwcm90bzMgKi8udy5qc29uLmRlYnVnKGpzb24pfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Vjb25kcyA9IHByb3RvX2ludDY0LyogcHJvdG9JbnQ2NCAqLy5xLnBhcnNlKGxvbmdTZWNvbmRzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXRjaFsyXSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBuYW5vc1N0ciA9IG1hdGNoWzJdICsgXCIwXCIucmVwZWF0KDkgLSBtYXRjaFsyXS5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5uYW5vcyA9IHBhcnNlSW50KG5hbm9zU3RyKTtcbiAgICAgICAgICAgIGlmIChsb25nU2Vjb25kcyA8IDAgfHwgT2JqZWN0LmlzKGxvbmdTZWNvbmRzLCAtMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hbm9zID0gLXRoaXMubmFub3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvSnNvbihvcHRpb25zKSB7XG4gICAgICAgIGlmIChOdW1iZXIodGhpcy5zZWNvbmRzKSA+IDMxNTU3NjAwMDAwMCB8fCBOdW1iZXIodGhpcy5zZWNvbmRzKSA8IC0zMTU1NzYwMDAwMDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGVuY29kZSBnb29nbGUucHJvdG9idWYuRHVyYXRpb24gdG8gSlNPTjogdmFsdWUgb3V0IG9mIHJhbmdlYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRleHQgPSB0aGlzLnNlY29uZHMudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHRoaXMubmFub3MgIT09IDApIHtcbiAgICAgICAgICAgIGxldCBuYW5vc1N0ciA9IE1hdGguYWJzKHRoaXMubmFub3MpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBuYW5vc1N0ciA9IFwiMFwiLnJlcGVhdCg5IC0gbmFub3NTdHIubGVuZ3RoKSArIG5hbm9zU3RyO1xuICAgICAgICAgICAgaWYgKG5hbm9zU3RyLnN1YnN0cmluZygzKSA9PT0gXCIwMDAwMDBcIikge1xuICAgICAgICAgICAgICAgIG5hbm9zU3RyID0gbmFub3NTdHIuc3Vic3RyaW5nKDAsIDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmFub3NTdHIuc3Vic3RyaW5nKDYpID09PSBcIjAwMFwiKSB7XG4gICAgICAgICAgICAgICAgbmFub3NTdHIgPSBuYW5vc1N0ci5zdWJzdHJpbmcoMCwgNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0ICs9IFwiLlwiICsgbmFub3NTdHI7XG4gICAgICAgICAgICBpZiAodGhpcy5uYW5vcyA8IDAgJiYgTnVtYmVyKHRoaXMuc2Vjb25kcykgPT0gMCkge1xuICAgICAgICAgICAgICAgIHRleHQgPSBcIi1cIiArIHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQgKyBcInNcIjtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbigpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IER1cmF0aW9uKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5lcXVhbHMoRHVyYXRpb24sIGEsIGIpO1xuICAgIH1cbn1cbkR1cmF0aW9uLnJ1bnRpbWUgPSBwcm90bzMvKiBwcm90bzMgKi8udztcbkR1cmF0aW9uLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuRHVyYXRpb25cIjtcbkR1cmF0aW9uLmZpZWxkcyA9IHByb3RvMy8qIHByb3RvMyAqLy53LnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInNlY29uZHNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJuYW5vc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8gfSxcbl0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9nb29nbGUvcHJvdG9idWYvYW55X3BiLmpzXG52YXIgYW55X3BiID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MzMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9nb29nbGUvcHJvdG9idWYvZW1wdHlfcGIuanNcbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cblxuLyoqXG4gKiBBIGdlbmVyaWMgZW1wdHkgbWVzc2FnZSB0aGF0IHlvdSBjYW4gcmUtdXNlIHRvIGF2b2lkIGRlZmluaW5nIGR1cGxpY2F0ZWRcbiAqIGVtcHR5IG1lc3NhZ2VzIGluIHlvdXIgQVBJcy4gQSB0eXBpY2FsIGV4YW1wbGUgaXMgdG8gdXNlIGl0IGFzIHRoZSByZXF1ZXN0XG4gKiBvciB0aGUgcmVzcG9uc2UgdHlwZSBvZiBhbiBBUEkgbWV0aG9kLiBGb3IgaW5zdGFuY2U6XG4gKlxuICogICAgIHNlcnZpY2UgRm9vIHtcbiAqICAgICAgIHJwYyBCYXIoZ29vZ2xlLnByb3RvYnVmLkVtcHR5KSByZXR1cm5zIChnb29nbGUucHJvdG9idWYuRW1wdHkpO1xuICogICAgIH1cbiAqXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLkVtcHR5XG4gKi9cbmNsYXNzIEVtcHR5IGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbXB0eSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW1wdHkoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEVtcHR5KCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5lcXVhbHMoRW1wdHksIGEsIGIpO1xuICAgIH1cbn1cbkVtcHR5LnJ1bnRpbWUgPSBwcm90bzMvKiBwcm90bzMgKi8udztcbkVtcHR5LnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuRW1wdHlcIjtcbkVtcHR5LmZpZWxkcyA9IHByb3RvMy8qIHByb3RvMyAqLy53LnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtdKTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9nb29nbGUvcHJvdG9idWYvZmllbGRfbWFza19wYi5qc1xuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuXG4vKipcbiAqIGBGaWVsZE1hc2tgIHJlcHJlc2VudHMgYSBzZXQgb2Ygc3ltYm9saWMgZmllbGQgcGF0aHMsIGZvciBleGFtcGxlOlxuICpcbiAqICAgICBwYXRoczogXCJmLmFcIlxuICogICAgIHBhdGhzOiBcImYuYi5kXCJcbiAqXG4gKiBIZXJlIGBmYCByZXByZXNlbnRzIGEgZmllbGQgaW4gc29tZSByb290IG1lc3NhZ2UsIGBhYCBhbmQgYGJgXG4gKiBmaWVsZHMgaW4gdGhlIG1lc3NhZ2UgZm91bmQgaW4gYGZgLCBhbmQgYGRgIGEgZmllbGQgZm91bmQgaW4gdGhlXG4gKiBtZXNzYWdlIGluIGBmLmJgLlxuICpcbiAqIEZpZWxkIG1hc2tzIGFyZSB1c2VkIHRvIHNwZWNpZnkgYSBzdWJzZXQgb2YgZmllbGRzIHRoYXQgc2hvdWxkIGJlXG4gKiByZXR1cm5lZCBieSBhIGdldCBvcGVyYXRpb24gb3IgbW9kaWZpZWQgYnkgYW4gdXBkYXRlIG9wZXJhdGlvbi5cbiAqIEZpZWxkIG1hc2tzIGFsc28gaGF2ZSBhIGN1c3RvbSBKU09OIGVuY29kaW5nIChzZWUgYmVsb3cpLlxuICpcbiAqICMgRmllbGQgTWFza3MgaW4gUHJvamVjdGlvbnNcbiAqXG4gKiBXaGVuIHVzZWQgaW4gdGhlIGNvbnRleHQgb2YgYSBwcm9qZWN0aW9uLCBhIHJlc3BvbnNlIG1lc3NhZ2Ugb3JcbiAqIHN1Yi1tZXNzYWdlIGlzIGZpbHRlcmVkIGJ5IHRoZSBBUEkgdG8gb25seSBjb250YWluIHRob3NlIGZpZWxkcyBhc1xuICogc3BlY2lmaWVkIGluIHRoZSBtYXNrLiBGb3IgZXhhbXBsZSwgaWYgdGhlIG1hc2sgaW4gdGhlIHByZXZpb3VzXG4gKiBleGFtcGxlIGlzIGFwcGxpZWQgdG8gYSByZXNwb25zZSBtZXNzYWdlIGFzIGZvbGxvd3M6XG4gKlxuICogICAgIGYge1xuICogICAgICAgYSA6IDIyXG4gKiAgICAgICBiIHtcbiAqICAgICAgICAgZCA6IDFcbiAqICAgICAgICAgeCA6IDJcbiAqICAgICAgIH1cbiAqICAgICAgIHkgOiAxM1xuICogICAgIH1cbiAqICAgICB6OiA4XG4gKlxuICogVGhlIHJlc3VsdCB3aWxsIG5vdCBjb250YWluIHNwZWNpZmljIHZhbHVlcyBmb3IgZmllbGRzIHgseSBhbmQgelxuICogKHRoZWlyIHZhbHVlIHdpbGwgYmUgc2V0IHRvIHRoZSBkZWZhdWx0LCBhbmQgb21pdHRlZCBpbiBwcm90byB0ZXh0XG4gKiBvdXRwdXQpOlxuICpcbiAqXG4gKiAgICAgZiB7XG4gKiAgICAgICBhIDogMjJcbiAqICAgICAgIGIge1xuICogICAgICAgICBkIDogMVxuICogICAgICAgfVxuICogICAgIH1cbiAqXG4gKiBBIHJlcGVhdGVkIGZpZWxkIGlzIG5vdCBhbGxvd2VkIGV4Y2VwdCBhdCB0aGUgbGFzdCBwb3NpdGlvbiBvZiBhXG4gKiBwYXRocyBzdHJpbmcuXG4gKlxuICogSWYgYSBGaWVsZE1hc2sgb2JqZWN0IGlzIG5vdCBwcmVzZW50IGluIGEgZ2V0IG9wZXJhdGlvbiwgdGhlXG4gKiBvcGVyYXRpb24gYXBwbGllcyB0byBhbGwgZmllbGRzIChhcyBpZiBhIEZpZWxkTWFzayBvZiBhbGwgZmllbGRzXG4gKiBoYWQgYmVlbiBzcGVjaWZpZWQpLlxuICpcbiAqIE5vdGUgdGhhdCBhIGZpZWxkIG1hc2sgZG9lcyBub3QgbmVjZXNzYXJpbHkgYXBwbHkgdG8gdGhlXG4gKiB0b3AtbGV2ZWwgcmVzcG9uc2UgbWVzc2FnZS4gSW4gY2FzZSBvZiBhIFJFU1QgZ2V0IG9wZXJhdGlvbiwgdGhlXG4gKiBmaWVsZCBtYXNrIGFwcGxpZXMgZGlyZWN0bHkgdG8gdGhlIHJlc3BvbnNlLCBidXQgaW4gY2FzZSBvZiBhIFJFU1RcbiAqIGxpc3Qgb3BlcmF0aW9uLCB0aGUgbWFzayBpbnN0ZWFkIGFwcGxpZXMgdG8gZWFjaCBpbmRpdmlkdWFsIG1lc3NhZ2VcbiAqIGluIHRoZSByZXR1cm5lZCByZXNvdXJjZSBsaXN0LiBJbiBjYXNlIG9mIGEgUkVTVCBjdXN0b20gbWV0aG9kLFxuICogb3RoZXIgZGVmaW5pdGlvbnMgbWF5IGJlIHVzZWQuIFdoZXJlIHRoZSBtYXNrIGFwcGxpZXMgd2lsbCBiZVxuICogY2xlYXJseSBkb2N1bWVudGVkIHRvZ2V0aGVyIHdpdGggaXRzIGRlY2xhcmF0aW9uIGluIHRoZSBBUEkuICBJblxuICogYW55IGNhc2UsIHRoZSBlZmZlY3Qgb24gdGhlIHJldHVybmVkIHJlc291cmNlL3Jlc291cmNlcyBpcyByZXF1aXJlZFxuICogYmVoYXZpb3IgZm9yIEFQSXMuXG4gKlxuICogIyBGaWVsZCBNYXNrcyBpbiBVcGRhdGUgT3BlcmF0aW9uc1xuICpcbiAqIEEgZmllbGQgbWFzayBpbiB1cGRhdGUgb3BlcmF0aW9ucyBzcGVjaWZpZXMgd2hpY2ggZmllbGRzIG9mIHRoZVxuICogdGFyZ2V0ZWQgcmVzb3VyY2UgYXJlIGdvaW5nIHRvIGJlIHVwZGF0ZWQuIFRoZSBBUEkgaXMgcmVxdWlyZWRcbiAqIHRvIG9ubHkgY2hhbmdlIHRoZSB2YWx1ZXMgb2YgdGhlIGZpZWxkcyBhcyBzcGVjaWZpZWQgaW4gdGhlIG1hc2tcbiAqIGFuZCBsZWF2ZSB0aGUgb3RoZXJzIHVudG91Y2hlZC4gSWYgYSByZXNvdXJjZSBpcyBwYXNzZWQgaW4gdG9cbiAqIGRlc2NyaWJlIHRoZSB1cGRhdGVkIHZhbHVlcywgdGhlIEFQSSBpZ25vcmVzIHRoZSB2YWx1ZXMgb2YgYWxsXG4gKiBmaWVsZHMgbm90IGNvdmVyZWQgYnkgdGhlIG1hc2suXG4gKlxuICogSWYgYSByZXBlYXRlZCBmaWVsZCBpcyBzcGVjaWZpZWQgZm9yIGFuIHVwZGF0ZSBvcGVyYXRpb24sIG5ldyB2YWx1ZXMgd2lsbFxuICogYmUgYXBwZW5kZWQgdG8gdGhlIGV4aXN0aW5nIHJlcGVhdGVkIGZpZWxkIGluIHRoZSB0YXJnZXQgcmVzb3VyY2UuIE5vdGUgdGhhdFxuICogYSByZXBlYXRlZCBmaWVsZCBpcyBvbmx5IGFsbG93ZWQgaW4gdGhlIGxhc3QgcG9zaXRpb24gb2YgYSBgcGF0aHNgIHN0cmluZy5cbiAqXG4gKiBJZiBhIHN1Yi1tZXNzYWdlIGlzIHNwZWNpZmllZCBpbiB0aGUgbGFzdCBwb3NpdGlvbiBvZiB0aGUgZmllbGQgbWFzayBmb3IgYW5cbiAqIHVwZGF0ZSBvcGVyYXRpb24sIHRoZW4gbmV3IHZhbHVlIHdpbGwgYmUgbWVyZ2VkIGludG8gdGhlIGV4aXN0aW5nIHN1Yi1tZXNzYWdlXG4gKiBpbiB0aGUgdGFyZ2V0IHJlc291cmNlLlxuICpcbiAqIEZvciBleGFtcGxlLCBnaXZlbiB0aGUgdGFyZ2V0IG1lc3NhZ2U6XG4gKlxuICogICAgIGYge1xuICogICAgICAgYiB7XG4gKiAgICAgICAgIGQ6IDFcbiAqICAgICAgICAgeDogMlxuICogICAgICAgfVxuICogICAgICAgYzogWzFdXG4gKiAgICAgfVxuICpcbiAqIEFuZCBhbiB1cGRhdGUgbWVzc2FnZTpcbiAqXG4gKiAgICAgZiB7XG4gKiAgICAgICBiIHtcbiAqICAgICAgICAgZDogMTBcbiAqICAgICAgIH1cbiAqICAgICAgIGM6IFsyXVxuICogICAgIH1cbiAqXG4gKiB0aGVuIGlmIHRoZSBmaWVsZCBtYXNrIGlzOlxuICpcbiAqICBwYXRoczogW1wiZi5iXCIsIFwiZi5jXCJdXG4gKlxuICogdGhlbiB0aGUgcmVzdWx0IHdpbGwgYmU6XG4gKlxuICogICAgIGYge1xuICogICAgICAgYiB7XG4gKiAgICAgICAgIGQ6IDEwXG4gKiAgICAgICAgIHg6IDJcbiAqICAgICAgIH1cbiAqICAgICAgIGM6IFsxLCAyXVxuICogICAgIH1cbiAqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBtYXkgcHJvdmlkZSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoaXMgZGVmYXVsdCBiZWhhdmlvciBmb3JcbiAqIHJlcGVhdGVkIGFuZCBtZXNzYWdlIGZpZWxkcy5cbiAqXG4gKiBJbiBvcmRlciB0byByZXNldCBhIGZpZWxkJ3MgdmFsdWUgdG8gdGhlIGRlZmF1bHQsIHRoZSBmaWVsZCBtdXN0XG4gKiBiZSBpbiB0aGUgbWFzayBhbmQgc2V0IHRvIHRoZSBkZWZhdWx0IHZhbHVlIGluIHRoZSBwcm92aWRlZCByZXNvdXJjZS5cbiAqIEhlbmNlLCBpbiBvcmRlciB0byByZXNldCBhbGwgZmllbGRzIG9mIGEgcmVzb3VyY2UsIHByb3ZpZGUgYSBkZWZhdWx0XG4gKiBpbnN0YW5jZSBvZiB0aGUgcmVzb3VyY2UgYW5kIHNldCBhbGwgZmllbGRzIGluIHRoZSBtYXNrLCBvciBkb1xuICogbm90IHByb3ZpZGUgYSBtYXNrIGFzIGRlc2NyaWJlZCBiZWxvdy5cbiAqXG4gKiBJZiBhIGZpZWxkIG1hc2sgaXMgbm90IHByZXNlbnQgb24gdXBkYXRlLCB0aGUgb3BlcmF0aW9uIGFwcGxpZXMgdG9cbiAqIGFsbCBmaWVsZHMgKGFzIGlmIGEgZmllbGQgbWFzayBvZiBhbGwgZmllbGRzIGhhcyBiZWVuIHNwZWNpZmllZCkuXG4gKiBOb3RlIHRoYXQgaW4gdGhlIHByZXNlbmNlIG9mIHNjaGVtYSBldm9sdXRpb24sIHRoaXMgbWF5IG1lYW4gdGhhdFxuICogZmllbGRzIHRoZSBjbGllbnQgZG9lcyBub3Qga25vdyBhbmQgaGFzIHRoZXJlZm9yZSBub3QgZmlsbGVkIGludG9cbiAqIHRoZSByZXF1ZXN0IHdpbGwgYmUgcmVzZXQgdG8gdGhlaXIgZGVmYXVsdC4gSWYgdGhpcyBpcyB1bndhbnRlZFxuICogYmVoYXZpb3IsIGEgc3BlY2lmaWMgc2VydmljZSBtYXkgcmVxdWlyZSBhIGNsaWVudCB0byBhbHdheXMgc3BlY2lmeVxuICogYSBmaWVsZCBtYXNrLCBwcm9kdWNpbmcgYW4gZXJyb3IgaWYgbm90LlxuICpcbiAqIEFzIHdpdGggZ2V0IG9wZXJhdGlvbnMsIHRoZSBsb2NhdGlvbiBvZiB0aGUgcmVzb3VyY2Ugd2hpY2hcbiAqIGRlc2NyaWJlcyB0aGUgdXBkYXRlZCB2YWx1ZXMgaW4gdGhlIHJlcXVlc3QgbWVzc2FnZSBkZXBlbmRzIG9uIHRoZVxuICogb3BlcmF0aW9uIGtpbmQuIEluIGFueSBjYXNlLCB0aGUgZWZmZWN0IG9mIHRoZSBmaWVsZCBtYXNrIGlzXG4gKiByZXF1aXJlZCB0byBiZSBob25vcmVkIGJ5IHRoZSBBUEkuXG4gKlxuICogIyMgQ29uc2lkZXJhdGlvbnMgZm9yIEhUVFAgUkVTVFxuICpcbiAqIFRoZSBIVFRQIGtpbmQgb2YgYW4gdXBkYXRlIG9wZXJhdGlvbiB3aGljaCB1c2VzIGEgZmllbGQgbWFzayBtdXN0XG4gKiBiZSBzZXQgdG8gUEFUQ0ggaW5zdGVhZCBvZiBQVVQgaW4gb3JkZXIgdG8gc2F0aXNmeSBIVFRQIHNlbWFudGljc1xuICogKFBVVCBtdXN0IG9ubHkgYmUgdXNlZCBmb3IgZnVsbCB1cGRhdGVzKS5cbiAqXG4gKiAjIEpTT04gRW5jb2Rpbmcgb2YgRmllbGQgTWFza3NcbiAqXG4gKiBJbiBKU09OLCBhIGZpZWxkIG1hc2sgaXMgZW5jb2RlZCBhcyBhIHNpbmdsZSBzdHJpbmcgd2hlcmUgcGF0aHMgYXJlXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb21tYS4gRmllbGRzIG5hbWUgaW4gZWFjaCBwYXRoIGFyZSBjb252ZXJ0ZWRcbiAqIHRvL2Zyb20gbG93ZXItY2FtZWwgbmFtaW5nIGNvbnZlbnRpb25zLlxuICpcbiAqIEFzIGFuIGV4YW1wbGUsIGNvbnNpZGVyIHRoZSBmb2xsb3dpbmcgbWVzc2FnZSBkZWNsYXJhdGlvbnM6XG4gKlxuICogICAgIG1lc3NhZ2UgUHJvZmlsZSB7XG4gKiAgICAgICBVc2VyIHVzZXIgPSAxO1xuICogICAgICAgUGhvdG8gcGhvdG8gPSAyO1xuICogICAgIH1cbiAqICAgICBtZXNzYWdlIFVzZXIge1xuICogICAgICAgc3RyaW5nIGRpc3BsYXlfbmFtZSA9IDE7XG4gKiAgICAgICBzdHJpbmcgYWRkcmVzcyA9IDI7XG4gKiAgICAgfVxuICpcbiAqIEluIHByb3RvIGEgZmllbGQgbWFzayBmb3IgYFByb2ZpbGVgIG1heSBsb29rIGFzIHN1Y2g6XG4gKlxuICogICAgIG1hc2sge1xuICogICAgICAgcGF0aHM6IFwidXNlci5kaXNwbGF5X25hbWVcIlxuICogICAgICAgcGF0aHM6IFwicGhvdG9cIlxuICogICAgIH1cbiAqXG4gKiBJbiBKU09OLCB0aGUgc2FtZSBtYXNrIGlzIHJlcHJlc2VudGVkIGFzIGJlbG93OlxuICpcbiAqICAgICB7XG4gKiAgICAgICBtYXNrOiBcInVzZXIuZGlzcGxheU5hbWUscGhvdG9cIlxuICogICAgIH1cbiAqXG4gKiAjIEZpZWxkIE1hc2tzIGFuZCBPbmVvZiBGaWVsZHNcbiAqXG4gKiBGaWVsZCBtYXNrcyB0cmVhdCBmaWVsZHMgaW4gb25lb2ZzIGp1c3QgYXMgcmVndWxhciBmaWVsZHMuIENvbnNpZGVyIHRoZVxuICogZm9sbG93aW5nIG1lc3NhZ2U6XG4gKlxuICogICAgIG1lc3NhZ2UgU2FtcGxlTWVzc2FnZSB7XG4gKiAgICAgICBvbmVvZiB0ZXN0X29uZW9mIHtcbiAqICAgICAgICAgc3RyaW5nIG5hbWUgPSA0O1xuICogICAgICAgICBTdWJNZXNzYWdlIHN1Yl9tZXNzYWdlID0gOTtcbiAqICAgICAgIH1cbiAqICAgICB9XG4gKlxuICogVGhlIGZpZWxkIG1hc2sgY2FuIGJlOlxuICpcbiAqICAgICBtYXNrIHtcbiAqICAgICAgIHBhdGhzOiBcIm5hbWVcIlxuICogICAgIH1cbiAqXG4gKiBPcjpcbiAqXG4gKiAgICAgbWFzayB7XG4gKiAgICAgICBwYXRoczogXCJzdWJfbWVzc2FnZVwiXG4gKiAgICAgfVxuICpcbiAqIE5vdGUgdGhhdCBvbmVvZiB0eXBlIG5hbWVzIChcInRlc3Rfb25lb2ZcIiBpbiB0aGlzIGNhc2UpIGNhbm5vdCBiZSB1c2VkIGluXG4gKiBwYXRocy5cbiAqXG4gKiAjIyBGaWVsZCBNYXNrIFZlcmlmaWNhdGlvblxuICpcbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiBhbnkgQVBJIG1ldGhvZCB3aGljaCBoYXMgYSBGaWVsZE1hc2sgdHlwZSBmaWVsZCBpbiB0aGVcbiAqIHJlcXVlc3Qgc2hvdWxkIHZlcmlmeSB0aGUgaW5jbHVkZWQgZmllbGQgcGF0aHMsIGFuZCByZXR1cm4gYW5cbiAqIGBJTlZBTElEX0FSR1VNRU5UYCBlcnJvciBpZiBhbnkgcGF0aCBpcyB1bm1hcHBhYmxlLlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5GaWVsZE1hc2tcbiAqL1xuY2xhc3MgRmllbGRNYXNrIGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzZXQgb2YgZmllbGQgbWFzayBwYXRocy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBzdHJpbmcgcGF0aHMgPSAxO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYXRocyA9IFtdO1xuICAgICAgICBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICAgIH1cbiAgICB0b0pzb24ob3B0aW9ucykge1xuICAgICAgICAvLyBDb252ZXJ0cyBzbmFrZV9jYXNlIHRvIHByb3RvQ2FtZWxDYXNlIGFjY29yZGluZyB0byB0aGUgY29udmVudGlvblxuICAgICAgICAvLyB1c2VkIGJ5IHByb3RvYyB0byBjb252ZXJ0IGEgZmllbGQgbmFtZSB0byBhIEpTT04gbmFtZS5cbiAgICAgICAgZnVuY3Rpb24gcHJvdG9DYW1lbENhc2Uoc25ha2VDYXNlKSB7XG4gICAgICAgICAgICBsZXQgY2FwTmV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgYiA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbmFrZUNhc2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgYyA9IHNuYWtlQ2FzZS5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ18nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FwTmV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJzEnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICcyJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnMyc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJzQnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICc1JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnNic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJzcnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICc4JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnOSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBiLnB1c2goYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXBOZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXBOZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwTmV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBjLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBiLnB1c2goYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYi5qb2luKCcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXRocy5tYXAocCA9PiB7XG4gICAgICAgICAgICBpZiAocC5tYXRjaCgvX1swLTldP18vZykgfHwgcC5tYXRjaCgvW0EtWl0vZykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZW5jb2RlIGdvb2dsZS5wcm90b2J1Zi5GaWVsZE1hc2sgdG8gSlNPTjogbG93ZXJDYW1lbENhc2Ugb2YgcGF0aCBuYW1lIFxcXCJcIiArIHAgKyBcIlxcXCIgaXMgaXJyZXZlcnNpYmxlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb3RvQ2FtZWxDYXNlKHApO1xuICAgICAgICB9KS5qb2luKFwiLFwiKTtcbiAgICB9XG4gICAgZnJvbUpzb24oanNvbiwgb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZ29vZ2xlLnByb3RvYnVmLkZpZWxkTWFzayBmcm9tIEpTT046IFwiICsgcHJvdG8zLyogcHJvdG8zICovLncuanNvbi5kZWJ1Zyhqc29uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpzb24gPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhbWVsVG9TbmFrZShzdHIpIHtcbiAgICAgICAgICAgIGlmIChzdHIuaW5jbHVkZXMoXCJfXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBnb29nbGUucHJvdG9idWYuRmllbGRNYXNrIGZyb20gSlNPTjogcGF0aCBuYW1lcyBtdXN0IGJlIGxvd2VyQ2FtZWxDYXNlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2MgPSBzdHIucmVwbGFjZSgvW0EtWl0vZywgbGV0dGVyID0+IFwiX1wiICsgbGV0dGVyLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgcmV0dXJuIChzY1swXSA9PT0gXCJfXCIpID8gc2Muc3Vic3RyaW5nKDEpIDogc2M7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXRocyA9IGpzb24uc3BsaXQoXCIsXCIpLm1hcChjYW1lbFRvU25ha2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZE1hc2soKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEZpZWxkTWFzaygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGRNYXNrKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5lcXVhbHMoRmllbGRNYXNrLCBhLCBiKTtcbiAgICB9XG59XG5GaWVsZE1hc2sucnVudGltZSA9IHByb3RvMy8qIHByb3RvMyAqLy53O1xuRmllbGRNYXNrLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuRmllbGRNYXNrXCI7XG5GaWVsZE1hc2suZmllbGRzID0gcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwicGF0aHNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgcmVwZWF0ZWQ6IHRydWUgfSxcbl0pO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL2dvb2dsZS9wcm90b2J1Zi9zdHJ1Y3RfcGIuanNcbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vLyBAZ2VuZXJhdGVkIGJ5IHByb3RvYy1nZW4tZXMgdjEuNi4wIHdpdGggcGFyYW1ldGVyIFwiYm9vdHN0cmFwX3drdD10cnVlLHRzX25vY2hlY2s9ZmFsc2UsdGFyZ2V0PXRzXCJcbi8vIEBnZW5lcmF0ZWQgZnJvbSBmaWxlIGdvb2dsZS9wcm90b2J1Zi9zdHJ1Y3QucHJvdG8gKHBhY2thZ2UgZ29vZ2xlLnByb3RvYnVmLCBzeW50YXggcHJvdG8zKVxuLyogZXNsaW50LWRpc2FibGUgKi9cblxuXG4vKipcbiAqIGBOdWxsVmFsdWVgIGlzIGEgc2luZ2xldG9uIGVudW1lcmF0aW9uIHRvIHJlcHJlc2VudCB0aGUgbnVsbCB2YWx1ZSBmb3IgdGhlXG4gKiBgVmFsdWVgIHR5cGUgdW5pb24uXG4gKlxuICogVGhlIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIGBOdWxsVmFsdWVgIGlzIEpTT04gYG51bGxgLlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGdvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWVcbiAqL1xudmFyIE51bGxWYWx1ZTtcbihmdW5jdGlvbiAoTnVsbFZhbHVlKSB7XG4gICAgLyoqXG4gICAgICogTnVsbCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBOVUxMX1ZBTFVFID0gMDtcbiAgICAgKi9cbiAgICBOdWxsVmFsdWVbTnVsbFZhbHVlW1wiTlVMTF9WQUxVRVwiXSA9IDBdID0gXCJOVUxMX1ZBTFVFXCI7XG59KShOdWxsVmFsdWUgfHwgKE51bGxWYWx1ZSA9IHt9KSk7XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShOdWxsVmFsdWUpXG5wcm90bzMvKiBwcm90bzMgKi8udy51dGlsLnNldEVudW1UeXBlKE51bGxWYWx1ZSwgXCJnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlXCIsIFtcbiAgICB7IG5vOiAwLCBuYW1lOiBcIk5VTExfVkFMVUVcIiB9LFxuXSk7XG4vKipcbiAqIGBTdHJ1Y3RgIHJlcHJlc2VudHMgYSBzdHJ1Y3R1cmVkIGRhdGEgdmFsdWUsIGNvbnNpc3Rpbmcgb2YgZmllbGRzXG4gKiB3aGljaCBtYXAgdG8gZHluYW1pY2FsbHkgdHlwZWQgdmFsdWVzLiBJbiBzb21lIGxhbmd1YWdlcywgYFN0cnVjdGBcbiAqIG1pZ2h0IGJlIHN1cHBvcnRlZCBieSBhIG5hdGl2ZSByZXByZXNlbnRhdGlvbi4gRm9yIGV4YW1wbGUsIGluXG4gKiBzY3JpcHRpbmcgbGFuZ3VhZ2VzIGxpa2UgSlMgYSBzdHJ1Y3QgaXMgcmVwcmVzZW50ZWQgYXMgYW5cbiAqIG9iamVjdC4gVGhlIGRldGFpbHMgb2YgdGhhdCByZXByZXNlbnRhdGlvbiBhcmUgZGVzY3JpYmVkIHRvZ2V0aGVyXG4gKiB3aXRoIHRoZSBwcm90byBzdXBwb3J0IGZvciB0aGUgbGFuZ3VhZ2UuXG4gKlxuICogVGhlIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIGBTdHJ1Y3RgIGlzIEpTT04gb2JqZWN0LlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3RcbiAqL1xuY2xhc3MgU3RydWN0IGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVub3JkZXJlZCBtYXAgb2YgZHluYW1pY2FsbHkgdHlwZWQgdmFsdWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IG1hcDxzdHJpbmcsIGdvb2dsZS5wcm90b2J1Zi5WYWx1ZT4gZmllbGRzID0gMTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmllbGRzID0ge307XG4gICAgICAgIHByb3RvMy8qIHByb3RvMyAqLy53LnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIHRvSnNvbihvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGpzb24gPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5maWVsZHMpKSB7XG4gICAgICAgICAgICBqc29uW2tdID0gdi50b0pzb24ob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIGZyb21Kc29uKGpzb24sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9IFwib2JqZWN0XCIgfHwganNvbiA9PSBudWxsIHx8IEFycmF5LmlzQXJyYXkoanNvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZ29vZ2xlLnByb3RvYnVmLlN0cnVjdCBmcm9tIEpTT04gXCIgKyBwcm90bzMvKiBwcm90bzMgKi8udy5qc29uLmRlYnVnKGpzb24pKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhqc29uKSkge1xuICAgICAgICAgICAgdGhpcy5maWVsZHNba10gPSBWYWx1ZS5mcm9tSnNvbih2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3QoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdCgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0KCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5lcXVhbHMoU3RydWN0LCBhLCBiKTtcbiAgICB9XG59XG5TdHJ1Y3QucnVudGltZSA9IHByb3RvMy8qIHByb3RvMyAqLy53O1xuU3RydWN0LnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuU3RydWN0XCI7XG5TdHJ1Y3QuZmllbGRzID0gcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiZmllbGRzXCIsIGtpbmQ6IFwibWFwXCIsIEs6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIFY6IHsga2luZDogXCJtZXNzYWdlXCIsIFQ6IFZhbHVlIH0gfSxcbl0pO1xuLyoqXG4gKiBgVmFsdWVgIHJlcHJlc2VudHMgYSBkeW5hbWljYWxseSB0eXBlZCB2YWx1ZSB3aGljaCBjYW4gYmUgZWl0aGVyXG4gKiBudWxsLCBhIG51bWJlciwgYSBzdHJpbmcsIGEgYm9vbGVhbiwgYSByZWN1cnNpdmUgc3RydWN0IHZhbHVlLCBvciBhXG4gKiBsaXN0IG9mIHZhbHVlcy4gQSBwcm9kdWNlciBvZiB2YWx1ZSBpcyBleHBlY3RlZCB0byBzZXQgb25lIG9mIHRoZXNlXG4gKiB2YXJpYW50cy4gQWJzZW5jZSBvZiBhbnkgdmFyaWFudCBpbmRpY2F0ZXMgYW4gZXJyb3IuXG4gKlxuICogVGhlIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIGBWYWx1ZWAgaXMgSlNPTiB2YWx1ZS5cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuVmFsdWVcbiAqL1xuY2xhc3MgVmFsdWUgZXh0ZW5kcyBlc21fbWVzc2FnZS8qIE1lc3NhZ2UgKi8udiB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGtpbmQgb2YgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBvbmVvZiBnb29nbGUucHJvdG9idWYuVmFsdWUua2luZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5raW5kID0geyBjYXNlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgdG9Kc29uKG9wdGlvbnMpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmtpbmQuY2FzZSkge1xuICAgICAgICAgICAgY2FzZSBcIm51bGxWYWx1ZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY2FzZSBcIm51bWJlclZhbHVlXCI6XG4gICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodGhpcy5raW5kLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnb29nbGUucHJvdG9idWYuVmFsdWUgY2Fubm90IGJlIE5hTiBvciBJbmZpbml0eVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMua2luZC52YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgXCJib29sVmFsdWVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5raW5kLnZhbHVlO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1ZhbHVlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMua2luZC52YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJ1Y3RWYWx1ZVwiOlxuICAgICAgICAgICAgY2FzZSBcImxpc3RWYWx1ZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmtpbmQudmFsdWUudG9Kc29uKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgZW1pdERlZmF1bHRWYWx1ZXM6IHRydWUgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImdvb2dsZS5wcm90b2J1Zi5WYWx1ZSBtdXN0IGhhdmUgYSB2YWx1ZVwiKTtcbiAgICB9XG4gICAgZnJvbUpzb24oanNvbiwgb3B0aW9ucykge1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiBqc29uKSB7XG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5raW5kID0geyBjYXNlOiBcIm51bWJlclZhbHVlXCIsIHZhbHVlOiBqc29uIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5raW5kID0geyBjYXNlOiBcInN0cmluZ1ZhbHVlXCIsIHZhbHVlOiBqc29uIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgIHRoaXMua2luZCA9IHsgY2FzZTogXCJib29sVmFsdWVcIiwgdmFsdWU6IGpzb24gfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgICAgICBpZiAoanNvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmtpbmQgPSB7IGNhc2U6IFwibnVsbFZhbHVlXCIsIHZhbHVlOiBOdWxsVmFsdWUuTlVMTF9WQUxVRSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGpzb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMua2luZCA9IHsgY2FzZTogXCJsaXN0VmFsdWVcIiwgdmFsdWU6IExpc3RWYWx1ZS5mcm9tSnNvbihqc29uKSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5raW5kID0geyBjYXNlOiBcInN0cnVjdFZhbHVlXCIsIHZhbHVlOiBTdHJ1Y3QuZnJvbUpzb24oanNvbikgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZ29vZ2xlLnByb3RvYnVmLlZhbHVlIGZyb20gSlNPTiBcIiArIHByb3RvMy8qIHByb3RvMyAqLy53Lmpzb24uZGVidWcoanNvbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWUoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLmVxdWFscyhWYWx1ZSwgYSwgYik7XG4gICAgfVxufVxuVmFsdWUucnVudGltZSA9IHByb3RvMy8qIHByb3RvMyAqLy53O1xuVmFsdWUudHlwZU5hbWUgPSBcImdvb2dsZS5wcm90b2J1Zi5WYWx1ZVwiO1xuVmFsdWUuZmllbGRzID0gcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwibnVsbF92YWx1ZVwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLyogcHJvdG8zICovLncuZ2V0RW51bVR5cGUoTnVsbFZhbHVlKSwgb25lb2Y6IFwia2luZFwiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJudW1iZXJfdmFsdWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMSAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqLywgb25lb2Y6IFwia2luZFwiIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJzdHJpbmdfdmFsdWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgb25lb2Y6IFwia2luZFwiIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJib29sX3ZhbHVlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovLCBvbmVvZjogXCJraW5kXCIgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcInN0cnVjdF92YWx1ZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU3RydWN0LCBvbmVvZjogXCJraW5kXCIgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcImxpc3RfdmFsdWVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IExpc3RWYWx1ZSwgb25lb2Y6IFwia2luZFwiIH0sXG5dKTtcbi8qKlxuICogYExpc3RWYWx1ZWAgaXMgYSB3cmFwcGVyIGFyb3VuZCBhIHJlcGVhdGVkIGZpZWxkIG9mIHZhbHVlcy5cbiAqXG4gKiBUaGUgSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgYExpc3RWYWx1ZWAgaXMgSlNPTiBhcnJheS5cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuTGlzdFZhbHVlXG4gKi9cbmNsYXNzIExpc3RWYWx1ZSBleHRlbmRzIGVzbV9tZXNzYWdlLyogTWVzc2FnZSAqLy52IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXBlYXRlZCBmaWVsZCBvZiBkeW5hbWljYWxseSB0eXBlZCB2YWx1ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgZ29vZ2xlLnByb3RvYnVmLlZhbHVlIHZhbHVlcyA9IDE7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgICAgICBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICAgIH1cbiAgICB0b0pzb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXMubWFwKHYgPT4gdi50b0pzb24oKSk7XG4gICAgfVxuICAgIGZyb21Kc29uKGpzb24sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGpzb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIGdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWUgZnJvbSBKU09OIFwiICsgcHJvdG8zLyogcHJvdG8zICovLncuanNvbi5kZWJ1Zyhqc29uKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgZSBvZiBqc29uKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKFZhbHVlLmZyb21Kc29uKGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXN0VmFsdWUoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IExpc3RWYWx1ZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGlzdFZhbHVlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5lcXVhbHMoTGlzdFZhbHVlLCBhLCBiKTtcbiAgICB9XG59XG5MaXN0VmFsdWUucnVudGltZSA9IHByb3RvMy8qIHByb3RvMyAqLy53O1xuTGlzdFZhbHVlLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuTGlzdFZhbHVlXCI7XG5MaXN0VmFsdWUuZmllbGRzID0gcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidmFsdWVzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBWYWx1ZSwgcmVwZWF0ZWQ6IHRydWUgfSxcbl0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL2VudW0uanNcbnZhciBwcml2YXRlX2VudW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwOSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL2dvb2dsZS9wcm90b2J1Zi93cmFwcGVyc19wYi5qc1xuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuXG5cblxuLyoqXG4gKiBXcmFwcGVyIG1lc3NhZ2UgZm9yIGBkb3VibGVgLlxuICpcbiAqIFRoZSBKU09OIHJlcHJlc2VudGF0aW9uIGZvciBgRG91YmxlVmFsdWVgIGlzIEpTT04gbnVtYmVyLlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5Eb3VibGVWYWx1ZVxuICovXG5jbGFzcyBEb3VibGVWYWx1ZSBleHRlbmRzIGVzbV9tZXNzYWdlLyogTWVzc2FnZSAqLy52IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZG91YmxlIHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGRvdWJsZSB2YWx1ZSA9IDE7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gMDtcbiAgICAgICAgcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgdG9Kc29uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvMy8qIHByb3RvMyAqLy53Lmpzb24ud3JpdGVTY2FsYXIoZXNtX2ZpZWxkLyogU2NhbGFyVHlwZSAqLy53LkRPVUJMRSwgdGhpcy52YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGZyb21Kc29uKGpzb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBwcm90bzMvKiBwcm90bzMgKi8udy5qc29uLnJlYWRTY2FsYXIoZXNtX2ZpZWxkLyogU2NhbGFyVHlwZSAqLy53LkRPVUJMRSwganNvbik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxldCBtID0gYGNhbm5vdCBkZWNvZGUgbWVzc2FnZSBnb29nbGUucHJvdG9idWYuRG91YmxlVmFsdWUgZnJvbSBKU09OXCJgO1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG0gKz0gYDogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEb3VibGVWYWx1ZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRG91YmxlVmFsdWUoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IERvdWJsZVZhbHVlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5lcXVhbHMoRG91YmxlVmFsdWUsIGEsIGIpO1xuICAgIH1cbn1cbkRvdWJsZVZhbHVlLnJ1bnRpbWUgPSBwcm90bzMvKiBwcm90bzMgKi8udztcbkRvdWJsZVZhbHVlLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuRG91YmxlVmFsdWVcIjtcbkRvdWJsZVZhbHVlLmZpZWxkcyA9IHByb3RvMy8qIHByb3RvMyAqLy53LnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInZhbHVlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi8gfSxcbl0pO1xuRG91YmxlVmFsdWUuZmllbGRXcmFwcGVyID0ge1xuICAgIHdyYXBGaWVsZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IERvdWJsZVZhbHVlKHsgdmFsdWUgfSk7XG4gICAgfSxcbiAgICB1bndyYXBGaWVsZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudmFsdWU7XG4gICAgfVxufTtcbi8qKlxuICogV3JhcHBlciBtZXNzYWdlIGZvciBgZmxvYXRgLlxuICpcbiAqIFRoZSBKU09OIHJlcHJlc2VudGF0aW9uIGZvciBgRmxvYXRWYWx1ZWAgaXMgSlNPTiBudW1iZXIuXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLkZsb2F0VmFsdWVcbiAqL1xuY2xhc3MgRmxvYXRWYWx1ZSBleHRlbmRzIGVzbV9tZXNzYWdlLyogTWVzc2FnZSAqLy52IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZmxvYXQgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZmxvYXQgdmFsdWUgPSAxO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZSA9IDA7XG4gICAgICAgIHByb3RvMy8qIHByb3RvMyAqLy53LnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIHRvSnNvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBwcm90bzMvKiBwcm90bzMgKi8udy5qc29uLndyaXRlU2NhbGFyKGVzbV9maWVsZC8qIFNjYWxhclR5cGUgKi8udy5GTE9BVCwgdGhpcy52YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGZyb21Kc29uKGpzb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBwcm90bzMvKiBwcm90bzMgKi8udy5qc29uLnJlYWRTY2FsYXIoZXNtX2ZpZWxkLyogU2NhbGFyVHlwZSAqLy53LkZMT0FULCBqc29uKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbGV0IG0gPSBgY2Fubm90IGRlY29kZSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5GbG9hdFZhbHVlIGZyb20gSlNPTlwiYDtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBtICs9IGA6ICR7ZS5tZXNzYWdlfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXRWYWx1ZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXRWYWx1ZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXRWYWx1ZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvMy8qIHByb3RvMyAqLy53LnV0aWwuZXF1YWxzKEZsb2F0VmFsdWUsIGEsIGIpO1xuICAgIH1cbn1cbkZsb2F0VmFsdWUucnVudGltZSA9IHByb3RvMy8qIHByb3RvMyAqLy53O1xuRmxvYXRWYWx1ZS50eXBlTmFtZSA9IFwiZ29vZ2xlLnByb3RvYnVmLkZsb2F0VmFsdWVcIjtcbkZsb2F0VmFsdWUuZmllbGRzID0gcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidmFsdWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMiAvKiBTY2FsYXJUeXBlLkZMT0FUICovIH0sXG5dKTtcbkZsb2F0VmFsdWUuZmllbGRXcmFwcGVyID0ge1xuICAgIHdyYXBGaWVsZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0VmFsdWUoeyB2YWx1ZSB9KTtcbiAgICB9LFxuICAgIHVud3JhcEZpZWxkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS52YWx1ZTtcbiAgICB9XG59O1xuLyoqXG4gKiBXcmFwcGVyIG1lc3NhZ2UgZm9yIGBpbnQ2NGAuXG4gKlxuICogVGhlIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIGBJbnQ2NFZhbHVlYCBpcyBKU09OIHN0cmluZy5cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuSW50NjRWYWx1ZVxuICovXG5jbGFzcyBJbnQ2NFZhbHVlIGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbnQ2NCB2YWx1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQ2NCB2YWx1ZSA9IDE7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gcHJvdG9faW50NjQvKiBwcm90b0ludDY0ICovLnEuemVybztcbiAgICAgICAgcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgdG9Kc29uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvMy8qIHByb3RvMyAqLy53Lmpzb24ud3JpdGVTY2FsYXIoZXNtX2ZpZWxkLyogU2NhbGFyVHlwZSAqLy53LklOVDY0LCB0aGlzLnZhbHVlLCB0cnVlKTtcbiAgICB9XG4gICAgZnJvbUpzb24oanNvbiwgb3B0aW9ucykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHByb3RvMy8qIHByb3RvMyAqLy53Lmpzb24ucmVhZFNjYWxhcihlc21fZmllbGQvKiBTY2FsYXJUeXBlICovLncuSU5UNjQsIGpzb24pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsZXQgbSA9IGBjYW5ub3QgZGVjb2RlIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLkludDY0VmFsdWUgZnJvbSBKU09OXCJgO1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG0gKz0gYDogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQ2NFZhbHVlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQ2NFZhbHVlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQ2NFZhbHVlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5lcXVhbHMoSW50NjRWYWx1ZSwgYSwgYik7XG4gICAgfVxufVxuSW50NjRWYWx1ZS5ydW50aW1lID0gcHJvdG8zLyogcHJvdG8zICovLnc7XG5JbnQ2NFZhbHVlLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuSW50NjRWYWx1ZVwiO1xuSW50NjRWYWx1ZS5maWVsZHMgPSBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJ2YWx1ZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAzIC8qIFNjYWxhclR5cGUuSU5UNjQgKi8gfSxcbl0pO1xuSW50NjRWYWx1ZS5maWVsZFdyYXBwZXIgPSB7XG4gICAgd3JhcEZpZWxkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50NjRWYWx1ZSh7IHZhbHVlIH0pO1xuICAgIH0sXG4gICAgdW53cmFwRmllbGQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlO1xuICAgIH1cbn07XG4vKipcbiAqIFdyYXBwZXIgbWVzc2FnZSBmb3IgYHVpbnQ2NGAuXG4gKlxuICogVGhlIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIGBVSW50NjRWYWx1ZWAgaXMgSlNPTiBzdHJpbmcuXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLlVJbnQ2NFZhbHVlXG4gKi9cbmNsYXNzIFVJbnQ2NFZhbHVlIGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1aW50NjQgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDY0IHZhbHVlID0gMTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWUgPSBwcm90b19pbnQ2NC8qIHByb3RvSW50NjQgKi8ucS56ZXJvO1xuICAgICAgICBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICAgIH1cbiAgICB0b0pzb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gcHJvdG8zLyogcHJvdG8zICovLncuanNvbi53cml0ZVNjYWxhcihlc21fZmllbGQvKiBTY2FsYXJUeXBlICovLncuVUlOVDY0LCB0aGlzLnZhbHVlLCB0cnVlKTtcbiAgICB9XG4gICAgZnJvbUpzb24oanNvbiwgb3B0aW9ucykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHByb3RvMy8qIHByb3RvMyAqLy53Lmpzb24ucmVhZFNjYWxhcihlc21fZmllbGQvKiBTY2FsYXJUeXBlICovLncuVUlOVDY0LCBqc29uKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbGV0IG0gPSBgY2Fubm90IGRlY29kZSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5VSW50NjRWYWx1ZSBmcm9tIEpTT05cImA7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbSArPSBgOiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFVJbnQ2NFZhbHVlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVSW50NjRWYWx1ZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgVUludDY0VmFsdWUoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLmVxdWFscyhVSW50NjRWYWx1ZSwgYSwgYik7XG4gICAgfVxufVxuVUludDY0VmFsdWUucnVudGltZSA9IHByb3RvMy8qIHByb3RvMyAqLy53O1xuVUludDY0VmFsdWUudHlwZU5hbWUgPSBcImdvb2dsZS5wcm90b2J1Zi5VSW50NjRWYWx1ZVwiO1xuVUludDY0VmFsdWUuZmllbGRzID0gcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidmFsdWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNCAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqLyB9LFxuXSk7XG5VSW50NjRWYWx1ZS5maWVsZFdyYXBwZXIgPSB7XG4gICAgd3JhcEZpZWxkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgVUludDY0VmFsdWUoeyB2YWx1ZSB9KTtcbiAgICB9LFxuICAgIHVud3JhcEZpZWxkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS52YWx1ZTtcbiAgICB9XG59O1xuLyoqXG4gKiBXcmFwcGVyIG1lc3NhZ2UgZm9yIGBpbnQzMmAuXG4gKlxuICogVGhlIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIGBJbnQzMlZhbHVlYCBpcyBKU09OIG51bWJlci5cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuSW50MzJWYWx1ZVxuICovXG5jbGFzcyBJbnQzMlZhbHVlIGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbnQzMiB2YWx1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQzMiB2YWx1ZSA9IDE7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gMDtcbiAgICAgICAgcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgdG9Kc29uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvMy8qIHByb3RvMyAqLy53Lmpzb24ud3JpdGVTY2FsYXIoZXNtX2ZpZWxkLyogU2NhbGFyVHlwZSAqLy53LklOVDMyLCB0aGlzLnZhbHVlLCB0cnVlKTtcbiAgICB9XG4gICAgZnJvbUpzb24oanNvbiwgb3B0aW9ucykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHByb3RvMy8qIHByb3RvMyAqLy53Lmpzb24ucmVhZFNjYWxhcihlc21fZmllbGQvKiBTY2FsYXJUeXBlICovLncuSU5UMzIsIGpzb24pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsZXQgbSA9IGBjYW5ub3QgZGVjb2RlIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLkludDMyVmFsdWUgZnJvbSBKU09OXCJgO1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG0gKz0gYDogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQzMlZhbHVlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQzMlZhbHVlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQzMlZhbHVlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5lcXVhbHMoSW50MzJWYWx1ZSwgYSwgYik7XG4gICAgfVxufVxuSW50MzJWYWx1ZS5ydW50aW1lID0gcHJvdG8zLyogcHJvdG8zICovLnc7XG5JbnQzMlZhbHVlLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuSW50MzJWYWx1ZVwiO1xuSW50MzJWYWx1ZS5maWVsZHMgPSBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJ2YWx1ZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8gfSxcbl0pO1xuSW50MzJWYWx1ZS5maWVsZFdyYXBwZXIgPSB7XG4gICAgd3JhcEZpZWxkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50MzJWYWx1ZSh7IHZhbHVlIH0pO1xuICAgIH0sXG4gICAgdW53cmFwRmllbGQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlO1xuICAgIH1cbn07XG4vKipcbiAqIFdyYXBwZXIgbWVzc2FnZSBmb3IgYHVpbnQzMmAuXG4gKlxuICogVGhlIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIGBVSW50MzJWYWx1ZWAgaXMgSlNPTiBudW1iZXIuXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLlVJbnQzMlZhbHVlXG4gKi9cbmNsYXNzIFVJbnQzMlZhbHVlIGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1aW50MzIgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIHZhbHVlID0gMTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWUgPSAwO1xuICAgICAgICBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICAgIH1cbiAgICB0b0pzb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gcHJvdG8zLyogcHJvdG8zICovLncuanNvbi53cml0ZVNjYWxhcihlc21fZmllbGQvKiBTY2FsYXJUeXBlICovLncuVUlOVDMyLCB0aGlzLnZhbHVlLCB0cnVlKTtcbiAgICB9XG4gICAgZnJvbUpzb24oanNvbiwgb3B0aW9ucykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHByb3RvMy8qIHByb3RvMyAqLy53Lmpzb24ucmVhZFNjYWxhcihlc21fZmllbGQvKiBTY2FsYXJUeXBlICovLncuVUlOVDMyLCBqc29uKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbGV0IG0gPSBgY2Fubm90IGRlY29kZSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5VSW50MzJWYWx1ZSBmcm9tIEpTT05cImA7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbSArPSBgOiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFVJbnQzMlZhbHVlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVSW50MzJWYWx1ZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgVUludDMyVmFsdWUoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLmVxdWFscyhVSW50MzJWYWx1ZSwgYSwgYik7XG4gICAgfVxufVxuVUludDMyVmFsdWUucnVudGltZSA9IHByb3RvMy8qIHByb3RvMyAqLy53O1xuVUludDMyVmFsdWUudHlwZU5hbWUgPSBcImdvb2dsZS5wcm90b2J1Zi5VSW50MzJWYWx1ZVwiO1xuVUludDMyVmFsdWUuZmllbGRzID0gcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidmFsdWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbl0pO1xuVUludDMyVmFsdWUuZmllbGRXcmFwcGVyID0ge1xuICAgIHdyYXBGaWVsZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFVJbnQzMlZhbHVlKHsgdmFsdWUgfSk7XG4gICAgfSxcbiAgICB1bndyYXBGaWVsZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudmFsdWU7XG4gICAgfVxufTtcbi8qKlxuICogV3JhcHBlciBtZXNzYWdlIGZvciBgYm9vbGAuXG4gKlxuICogVGhlIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIGBCb29sVmFsdWVgIGlzIEpTT04gYHRydWVgIGFuZCBgZmFsc2VgLlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5Cb29sVmFsdWVcbiAqL1xuY2xhc3MgQm9vbFZhbHVlIGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBib29sIHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgdmFsdWUgPSAxO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZSA9IGZhbHNlO1xuICAgICAgICBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICAgIH1cbiAgICB0b0pzb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gcHJvdG8zLyogcHJvdG8zICovLncuanNvbi53cml0ZVNjYWxhcihlc21fZmllbGQvKiBTY2FsYXJUeXBlICovLncuQk9PTCwgdGhpcy52YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGZyb21Kc29uKGpzb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBwcm90bzMvKiBwcm90bzMgKi8udy5qc29uLnJlYWRTY2FsYXIoZXNtX2ZpZWxkLyogU2NhbGFyVHlwZSAqLy53LkJPT0wsIGpzb24pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsZXQgbSA9IGBjYW5ub3QgZGVjb2RlIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLkJvb2xWYWx1ZSBmcm9tIEpTT05cImA7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbSArPSBgOiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEJvb2xWYWx1ZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgQm9vbFZhbHVlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCb29sVmFsdWUoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLmVxdWFscyhCb29sVmFsdWUsIGEsIGIpO1xuICAgIH1cbn1cbkJvb2xWYWx1ZS5ydW50aW1lID0gcHJvdG8zLyogcHJvdG8zICovLnc7XG5Cb29sVmFsdWUudHlwZU5hbWUgPSBcImdvb2dsZS5wcm90b2J1Zi5Cb29sVmFsdWVcIjtcbkJvb2xWYWx1ZS5maWVsZHMgPSBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJ2YWx1ZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuXSk7XG5Cb29sVmFsdWUuZmllbGRXcmFwcGVyID0ge1xuICAgIHdyYXBGaWVsZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IEJvb2xWYWx1ZSh7IHZhbHVlIH0pO1xuICAgIH0sXG4gICAgdW53cmFwRmllbGQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlO1xuICAgIH1cbn07XG4vKipcbiAqIFdyYXBwZXIgbWVzc2FnZSBmb3IgYHN0cmluZ2AuXG4gKlxuICogVGhlIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIGBTdHJpbmdWYWx1ZWAgaXMgSlNPTiBzdHJpbmcuXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLlN0cmluZ1ZhbHVlXG4gKi9cbmNsYXNzIFN0cmluZ1ZhbHVlIGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzdHJpbmcgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHZhbHVlID0gMTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICAgIH1cbiAgICB0b0pzb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gcHJvdG8zLyogcHJvdG8zICovLncuanNvbi53cml0ZVNjYWxhcihlc21fZmllbGQvKiBTY2FsYXJUeXBlICovLncuU1RSSU5HLCB0aGlzLnZhbHVlLCB0cnVlKTtcbiAgICB9XG4gICAgZnJvbUpzb24oanNvbiwgb3B0aW9ucykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHByb3RvMy8qIHByb3RvMyAqLy53Lmpzb24ucmVhZFNjYWxhcihlc21fZmllbGQvKiBTY2FsYXJUeXBlICovLncuU1RSSU5HLCBqc29uKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbGV0IG0gPSBgY2Fubm90IGRlY29kZSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5TdHJpbmdWYWx1ZSBmcm9tIEpTT05cImA7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbSArPSBgOiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1ZhbHVlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdWYWx1ZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyaW5nVmFsdWUoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLmVxdWFscyhTdHJpbmdWYWx1ZSwgYSwgYik7XG4gICAgfVxufVxuU3RyaW5nVmFsdWUucnVudGltZSA9IHByb3RvMy8qIHByb3RvMyAqLy53O1xuU3RyaW5nVmFsdWUudHlwZU5hbWUgPSBcImdvb2dsZS5wcm90b2J1Zi5TdHJpbmdWYWx1ZVwiO1xuU3RyaW5nVmFsdWUuZmllbGRzID0gcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidmFsdWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuXSk7XG5TdHJpbmdWYWx1ZS5maWVsZFdyYXBwZXIgPSB7XG4gICAgd3JhcEZpZWxkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyaW5nVmFsdWUoeyB2YWx1ZSB9KTtcbiAgICB9LFxuICAgIHVud3JhcEZpZWxkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS52YWx1ZTtcbiAgICB9XG59O1xuLyoqXG4gKiBXcmFwcGVyIG1lc3NhZ2UgZm9yIGBieXRlc2AuXG4gKlxuICogVGhlIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIGBCeXRlc1ZhbHVlYCBpcyBKU09OIHN0cmluZy5cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuQnl0ZXNWYWx1ZVxuICovXG5jbGFzcyBCeXRlc1ZhbHVlIGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBieXRlcyB2YWx1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBieXRlcyB2YWx1ZSA9IDE7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIHByb3RvMy8qIHByb3RvMyAqLy53LnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIHRvSnNvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBwcm90bzMvKiBwcm90bzMgKi8udy5qc29uLndyaXRlU2NhbGFyKGVzbV9maWVsZC8qIFNjYWxhclR5cGUgKi8udy5CWVRFUywgdGhpcy52YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGZyb21Kc29uKGpzb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBwcm90bzMvKiBwcm90bzMgKi8udy5qc29uLnJlYWRTY2FsYXIoZXNtX2ZpZWxkLyogU2NhbGFyVHlwZSAqLy53LkJZVEVTLCBqc29uKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbGV0IG0gPSBgY2Fubm90IGRlY29kZSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5CeXRlc1ZhbHVlIGZyb20gSlNPTlwiYDtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBtICs9IGA6ICR7ZS5tZXNzYWdlfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgQnl0ZXNWYWx1ZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgQnl0ZXNWYWx1ZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgQnl0ZXNWYWx1ZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvMy8qIHByb3RvMyAqLy53LnV0aWwuZXF1YWxzKEJ5dGVzVmFsdWUsIGEsIGIpO1xuICAgIH1cbn1cbkJ5dGVzVmFsdWUucnVudGltZSA9IHByb3RvMy8qIHByb3RvMyAqLy53O1xuQnl0ZXNWYWx1ZS50eXBlTmFtZSA9IFwiZ29vZ2xlLnByb3RvYnVmLkJ5dGVzVmFsdWVcIjtcbkJ5dGVzVmFsdWUuZmllbGRzID0gcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidmFsdWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTIgLyogU2NhbGFyVHlwZS5CWVRFUyAqLyB9LFxuXSk7XG5CeXRlc1ZhbHVlLmZpZWxkV3JhcHBlciA9IHtcbiAgICB3cmFwRmllbGQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCeXRlc1ZhbHVlKHsgdmFsdWUgfSk7XG4gICAgfSxcbiAgICB1bndyYXBGaWVsZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudmFsdWU7XG4gICAgfVxufTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9jcmVhdGUtcmVnaXN0cnktZnJvbS1kZXNjLmpzXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLy8gd2VsbC1rbm93biBtZXNzYWdlIHR5cGVzIHdpdGggc3BlY2lhbGl6ZWQgSlNPTiByZXByZXNlbnRhdGlvblxuY29uc3Qgd2tNZXNzYWdlcyA9IFtcbiAgICBhbnlfcGIvKiBBbnkgKi8uSSxcbiAgICBEdXJhdGlvbixcbiAgICBFbXB0eSxcbiAgICBGaWVsZE1hc2ssXG4gICAgU3RydWN0LFxuICAgIFZhbHVlLFxuICAgIExpc3RWYWx1ZSxcbiAgICBUaW1lc3RhbXAsXG4gICAgRHVyYXRpb24sXG4gICAgRG91YmxlVmFsdWUsXG4gICAgRmxvYXRWYWx1ZSxcbiAgICBJbnQ2NFZhbHVlLFxuICAgIEludDMyVmFsdWUsXG4gICAgVUludDMyVmFsdWUsXG4gICAgVUludDY0VmFsdWUsXG4gICAgQm9vbFZhbHVlLFxuICAgIFN0cmluZ1ZhbHVlLFxuICAgIEJ5dGVzVmFsdWUsXG5dO1xuLy8gd2VsbC1rbm93biBlbnVtIHR5cGVzIHdpdGggc3BlY2lhbGl6ZWQgSlNPTiByZXByZXNlbnRhdGlvblxuY29uc3Qgd2tFbnVtcyA9IFsoMCxwcml2YXRlX2VudW0vKiBnZXRFbnVtVHlwZSAqLy5WMykoTnVsbFZhbHVlKV07XG4vKipcbiAqIENyZWF0ZSBhIHJlZ2lzdHJ5IGZyb20gYSBzZXQgb2YgZGVzY3JpcHRvcnMuIFRoZSB0eXBlcyByZXR1cm5lZCBieSB0aGlzXG4gKiByZWdpc3RyeSBiZWhhdmUgZXhhY3RseSBsaWtlIHR5cGVzIGZyb20gZ2VuZXJhdGVkIGNvZGUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGdvb2dsZS5wcm90b2J1Zi5GaWxlRGVzY3JpcHRvclNldCBpbiBzZXJpYWxpemVkIG9yXG4gKiBkZXNlcmlhbGl6ZWQgZm9ybS4gQWx0ZXJuYXRpdmVseSwgaXQgYWxzbyBhY2NlcHRzIGEgRGVzY3JpcHRvclNldCAoc2VlXG4gKiBjcmVhdGVEZXNjcmlwdG9yU2V0KCkpLlxuICpcbiAqIEJ5IGRlZmF1bHQsIGFsbCB3ZWxsLWtub3duIHR5cGVzIHdpdGggYSBzcGVjaWFsaXplZCBKU09OIHJlcHJlc2VudGF0aW9uXG4gKiBhcmUgcmVwbGFjZWQgd2l0aCB0aGVpciBnZW5lcmF0ZWQgY291bnRlcnBhcnQgaW4gdGhpcyBwYWNrYWdlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVSZWdpc3RyeUZyb21EZXNjcmlwdG9ycyhpbnB1dCwgcmVwbGFjZVdrdCA9IHRydWUpIHtcbiAgICBjb25zdCBzZXQgPSBpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgaW5wdXQgaW5zdGFuY2VvZiBGaWxlRGVzY3JpcHRvclNldFxuICAgICAgICA/IGNyZWF0ZURlc2NyaXB0b3JTZXQoaW5wdXQpXG4gICAgICAgIDogaW5wdXQ7XG4gICAgY29uc3QgZW51bXMgPSB7fTtcbiAgICBjb25zdCBtZXNzYWdlcyA9IHt9O1xuICAgIGNvbnN0IHNlcnZpY2VzID0ge307XG4gICAgaWYgKHJlcGxhY2VXa3QpIHtcbiAgICAgICAgZm9yIChjb25zdCBtdCBvZiB3a01lc3NhZ2VzKSB7XG4gICAgICAgICAgICBtZXNzYWdlc1ttdC50eXBlTmFtZV0gPSBtdDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGV0IG9mIHdrRW51bXMpIHtcbiAgICAgICAgICAgIGVudW1zW2V0LnR5cGVOYW1lXSA9IGV0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXkgcmFpc2UgYW4gZXJyb3Igb24gaW52YWxpZCBkZXNjcmlwdG9ycy5cbiAgICAgICAgICovXG4gICAgICAgIGZpbmRFbnVtKHR5cGVOYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IGVudW1zW3R5cGVOYW1lXTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRlc2MgPSBzZXQuZW51bXMuZ2V0KHR5cGVOYW1lKTtcbiAgICAgICAgICAgIGlmICghZGVzYykge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBydW50aW1lID0gZGVzYy5maWxlLnN5bnRheCA9PSBcInByb3RvM1wiID8gcHJvdG8zLyogcHJvdG8zICovLncgOiBwcm90bzI7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gcnVudGltZS5tYWtlRW51bVR5cGUodHlwZU5hbWUsIGRlc2MudmFsdWVzLm1hcCgodSkgPT4gKHtcbiAgICAgICAgICAgICAgICBubzogdS5udW1iZXIsXG4gICAgICAgICAgICAgICAgbmFtZTogdS5uYW1lLFxuICAgICAgICAgICAgICAgIGxvY2FsTmFtZTogKDAsbmFtZXMvKiBsb2NhbE5hbWUgKi8ucjEpKHUpLFxuICAgICAgICAgICAgfSkpLCB7fSk7XG4gICAgICAgICAgICBlbnVtc1t0eXBlTmFtZV0gPSB0eXBlO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXkgcmFpc2UgYW4gZXJyb3Igb24gaW52YWxpZCBkZXNjcmlwdG9ycy5cbiAgICAgICAgICovXG4gICAgICAgIGZpbmRNZXNzYWdlKHR5cGVOYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IG1lc3NhZ2VzW3R5cGVOYW1lXTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRlc2MgPSBzZXQubWVzc2FnZXMuZ2V0KHR5cGVOYW1lKTtcbiAgICAgICAgICAgIGlmICghZGVzYykge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBydW50aW1lID0gZGVzYy5maWxlLnN5bnRheCA9PSBcInByb3RvM1wiID8gcHJvdG8zLyogcHJvdG8zICovLncgOiBwcm90bzI7XG4gICAgICAgICAgICBjb25zdCBmaWVsZHMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBydW50aW1lLm1ha2VNZXNzYWdlVHlwZSh0eXBlTmFtZSwgKCkgPT4gZmllbGRzLCB7XG4gICAgICAgICAgICAgICAgbG9jYWxOYW1lOiAoMCxuYW1lcy8qIGxvY2FsTmFtZSAqLy5yMSkoZGVzYyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1lc3NhZ2VzW3R5cGVOYW1lXSA9IHR5cGU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGRlc2MuZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRJbmZvID0gbWFrZUZpZWxkSW5mbyhmaWVsZCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2goZmllbGRJbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTWF5IHJhaXNlIGFuIGVycm9yIG9uIGludmFsaWQgZGVzY3JpcHRvcnMuXG4gICAgICAgICAqL1xuICAgICAgICBmaW5kU2VydmljZSh0eXBlTmFtZSkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBzZXJ2aWNlc1t0eXBlTmFtZV07XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZXNjID0gc2V0LnNlcnZpY2VzLmdldCh0eXBlTmFtZSk7XG4gICAgICAgICAgICBpZiAoIWRlc2MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWV0aG9kcyA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBtZXRob2Qgb2YgZGVzYy5tZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgSSA9IHRoaXMuZmluZE1lc3NhZ2UobWV0aG9kLmlucHV0LnR5cGVOYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBPID0gdGhpcy5maW5kTWVzc2FnZShtZXRob2Qub3V0cHV0LnR5cGVOYW1lKTtcbiAgICAgICAgICAgICAgICAoMCxhc3NlcnQvKiBhc3NlcnQgKi8uaHUpKEksIGBtZXNzYWdlIFwiJHttZXRob2QuaW5wdXQudHlwZU5hbWV9XCIgZm9yICR7bWV0aG9kLnRvU3RyaW5nKCl9IG5vdCBmb3VuZGApO1xuICAgICAgICAgICAgICAgICgwLGFzc2VydC8qIGFzc2VydCAqLy5odSkoTywgYG91dHB1dCBtZXNzYWdlIFwiJHttZXRob2Qub3V0cHV0LnR5cGVOYW1lfVwiIGZvciAke21ldGhvZC50b1N0cmluZygpfSBub3QgZm91bmRgKTtcbiAgICAgICAgICAgICAgICBtZXRob2RzWygwLG5hbWVzLyogbG9jYWxOYW1lICovLnIxKShtZXRob2QpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbWV0aG9kLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIEksXG4gICAgICAgICAgICAgICAgICAgIE8sXG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IG1ldGhvZC5tZXRob2RLaW5kLFxuICAgICAgICAgICAgICAgICAgICBpZGVtcG90ZW5jeTogbWV0aG9kLmlkZW1wb3RlbmN5LFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkbyBub3Qgc3VyZmFjZSBvcHRpb25zIGF0IHRoaXMgdGltZVxuICAgICAgICAgICAgICAgICAgICAvLyBvcHRpb25zOiB7fSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChzZXJ2aWNlc1t0eXBlTmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZU5hbWU6IGRlc2MudHlwZU5hbWUsXG4gICAgICAgICAgICAgICAgbWV0aG9kcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBtYWtlRmllbGRJbmZvKGRlc2MsIHJlc29sdmVyKSB7XG4gICAgc3dpdGNoIChkZXNjLmZpZWxkS2luZCkge1xuICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICByZXR1cm4gbWFrZU1hcEZpZWxkSW5mbyhkZXNjLCByZXNvbHZlcik7XG4gICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICByZXR1cm4gbWFrZU1lc3NhZ2VGaWVsZEluZm8oZGVzYywgcmVzb2x2ZXIpO1xuICAgICAgICBjYXNlIFwiZW51bVwiOiB7XG4gICAgICAgICAgICBjb25zdCBmaSA9IG1ha2VFbnVtRmllbGRJbmZvKGRlc2MsIHJlc29sdmVyKTtcbiAgICAgICAgICAgIGZpLmRlZmF1bHQgPSBkZXNjLmdldERlZmF1bHRWYWx1ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJzY2FsYXJcIjoge1xuICAgICAgICAgICAgY29uc3QgZmkgPSBtYWtlU2NhbGFyRmllbGRJbmZvKGRlc2MpO1xuICAgICAgICAgICAgZmkuZGVmYXVsdCA9IGRlc2MuZ2V0RGVmYXVsdFZhbHVlKCk7XG4gICAgICAgICAgICByZXR1cm4gZmk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBtYWtlTWFwRmllbGRJbmZvKGZpZWxkLCByZXNvbHZlcikge1xuICAgIGNvbnN0IGJhc2UgPSB7XG4gICAgICAgIGtpbmQ6IFwibWFwXCIsXG4gICAgICAgIG5vOiBmaWVsZC5udW1iZXIsXG4gICAgICAgIG5hbWU6IGZpZWxkLm5hbWUsXG4gICAgICAgIGpzb25OYW1lOiBmaWVsZC5qc29uTmFtZSxcbiAgICAgICAgSzogZmllbGQubWFwS2V5LFxuICAgIH07XG4gICAgaWYgKGZpZWxkLm1hcFZhbHVlLm1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSByZXNvbHZlci5maW5kTWVzc2FnZShmaWVsZC5tYXBWYWx1ZS5tZXNzYWdlLnR5cGVOYW1lKTtcbiAgICAgICAgKDAsYXNzZXJ0LyogYXNzZXJ0ICovLmh1KShtZXNzYWdlVHlwZSwgYG1lc3NhZ2UgXCIke2ZpZWxkLm1hcFZhbHVlLm1lc3NhZ2UudHlwZU5hbWV9XCIgZm9yICR7ZmllbGQudG9TdHJpbmcoKX0gbm90IGZvdW5kYCk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJhc2UpLCB7IFY6IHtcbiAgICAgICAgICAgICAgICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgICAgICAgICAgICAgICBUOiBtZXNzYWdlVHlwZSxcbiAgICAgICAgICAgIH0gfSk7XG4gICAgfVxuICAgIGlmIChmaWVsZC5tYXBWYWx1ZS5lbnVtKSB7XG4gICAgICAgIGNvbnN0IGVudW1UeXBlID0gcmVzb2x2ZXIuZmluZEVudW0oZmllbGQubWFwVmFsdWUuZW51bS50eXBlTmFtZSk7XG4gICAgICAgICgwLGFzc2VydC8qIGFzc2VydCAqLy5odSkoZW51bVR5cGUsIGBlbnVtIFwiJHtmaWVsZC5tYXBWYWx1ZS5lbnVtLnR5cGVOYW1lfVwiIGZvciAke2ZpZWxkLnRvU3RyaW5nKCl9IG5vdCBmb3VuZGApO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBiYXNlKSwgeyBWOiB7XG4gICAgICAgICAgICAgICAga2luZDogXCJlbnVtXCIsXG4gICAgICAgICAgICAgICAgVDogZW51bVR5cGUsXG4gICAgICAgICAgICB9IH0pO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBiYXNlKSwgeyBWOiB7XG4gICAgICAgICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgICAgICAgVDogZmllbGQubWFwVmFsdWUuc2NhbGFyLFxuICAgICAgICB9IH0pO1xufVxuZnVuY3Rpb24gbWFrZVNjYWxhckZpZWxkSW5mbyhmaWVsZCkge1xuICAgIC8vIFdlIGFyZSBjcmVhdGluZyBfcGFydGlhbF8gZmllbGQgaW5mbyBoZXJlLCBzbyB3ZSBvbWl0IGxvbmcgdHlwZSBiaWdpbnQsXG4gICAgLy8gd2hpY2ggaXMgdGhlIGRlZmF1bHQuXG4gICAgY29uc3QgbG9uZ1R5cGUgPSBmaWVsZC5sb25nVHlwZSA9PSBlc21fZmllbGQvKiBMb25nVHlwZSAqLy5wLlNUUklOR1xuICAgICAgICA/IHsgTDogZXNtX2ZpZWxkLyogTG9uZ1R5cGUgKi8ucC5TVFJJTkcgfVxuICAgICAgICA6IHt9O1xuICAgIGNvbnN0IGJhc2UgPSBPYmplY3QuYXNzaWduKHsga2luZDogXCJzY2FsYXJcIiwgbm86IGZpZWxkLm51bWJlciwgbmFtZTogZmllbGQubmFtZSwganNvbk5hbWU6IGZpZWxkLmpzb25OYW1lLCBUOiBmaWVsZC5zY2FsYXIgfSwgbG9uZ1R5cGUpO1xuICAgIGlmIChmaWVsZC5yZXBlYXRlZCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBiYXNlKSwgeyByZXBlYXRlZDogdHJ1ZSwgcGFja2VkOiBmaWVsZC5wYWNrZWQsIG9uZW9mOiB1bmRlZmluZWQsIFQ6IGZpZWxkLnNjYWxhciB9KTtcbiAgICB9XG4gICAgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJhc2UpLCB7IG9uZW9mOiBmaWVsZC5vbmVvZi5uYW1lIH0pO1xuICAgIH1cbiAgICBpZiAoZmllbGQub3B0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYmFzZSksIHsgb3B0OiB0cnVlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTtcbn1cbmZ1bmN0aW9uIG1ha2VNZXNzYWdlRmllbGRJbmZvKGZpZWxkLCByZXNvbHZlcikge1xuICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gcmVzb2x2ZXIuZmluZE1lc3NhZ2UoZmllbGQubWVzc2FnZS50eXBlTmFtZSk7XG4gICAgKDAsYXNzZXJ0LyogYXNzZXJ0ICovLmh1KShtZXNzYWdlVHlwZSwgYG1lc3NhZ2UgXCIke2ZpZWxkLm1lc3NhZ2UudHlwZU5hbWV9XCIgZm9yICR7ZmllbGQudG9TdHJpbmcoKX0gbm90IGZvdW5kYCk7XG4gICAgY29uc3QgYmFzZSA9IHtcbiAgICAgICAga2luZDogXCJtZXNzYWdlXCIsXG4gICAgICAgIG5vOiBmaWVsZC5udW1iZXIsXG4gICAgICAgIG5hbWU6IGZpZWxkLm5hbWUsXG4gICAgICAgIGpzb25OYW1lOiBmaWVsZC5qc29uTmFtZSxcbiAgICAgICAgVDogbWVzc2FnZVR5cGUsXG4gICAgICAgIGRlbGltaXRlZDogZmllbGQucHJvdG8udHlwZSA9PSBGaWVsZERlc2NyaXB0b3JQcm90b19UeXBlLkdST1VQLFxuICAgIH07XG4gICAgaWYgKGZpZWxkLnJlcGVhdGVkKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJhc2UpLCB7IHJlcGVhdGVkOiB0cnVlLCBwYWNrZWQ6IGZpZWxkLnBhY2tlZCwgb25lb2Y6IHVuZGVmaW5lZCB9KTtcbiAgICB9XG4gICAgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJhc2UpLCB7IG9uZW9mOiBmaWVsZC5vbmVvZi5uYW1lIH0pO1xuICAgIH1cbiAgICBpZiAoZmllbGQub3B0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYmFzZSksIHsgb3B0OiB0cnVlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTtcbn1cbmZ1bmN0aW9uIG1ha2VFbnVtRmllbGRJbmZvKGZpZWxkLCByZXNvbHZlcikge1xuICAgIGNvbnN0IGVudW1UeXBlID0gcmVzb2x2ZXIuZmluZEVudW0oZmllbGQuZW51bS50eXBlTmFtZSk7XG4gICAgKDAsYXNzZXJ0LyogYXNzZXJ0ICovLmh1KShlbnVtVHlwZSwgYGVudW0gXCIke2ZpZWxkLmVudW0udHlwZU5hbWV9XCIgZm9yICR7ZmllbGQudG9TdHJpbmcoKX0gbm90IGZvdW5kYCk7XG4gICAgY29uc3QgYmFzZSA9IHtcbiAgICAgICAga2luZDogXCJlbnVtXCIsXG4gICAgICAgIG5vOiBmaWVsZC5udW1iZXIsXG4gICAgICAgIG5hbWU6IGZpZWxkLm5hbWUsXG4gICAgICAgIGpzb25OYW1lOiBmaWVsZC5qc29uTmFtZSxcbiAgICAgICAgVDogZW51bVR5cGUsXG4gICAgfTtcbiAgICBpZiAoZmllbGQucmVwZWF0ZWQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYmFzZSksIHsgcmVwZWF0ZWQ6IHRydWUsIHBhY2tlZDogZmllbGQucGFja2VkLCBvbmVvZjogdW5kZWZpbmVkIH0pO1xuICAgIH1cbiAgICBpZiAoZmllbGQub25lb2YpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYmFzZSksIHsgb25lb2Y6IGZpZWxkLm9uZW9mLm5hbWUgfSk7XG4gICAgfVxuICAgIGlmIChmaWVsZC5vcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBiYXNlKSwgeyBvcHQ6IHRydWUgfSk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3RvLXBsYWluLW1lc3NhZ2UuanNcbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm4sQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCxuby1jYXNlLWRlY2xhcmF0aW9ucyAqL1xuXG4vKipcbiAqIHRvUGxhaW5NZXNzYWdlIHJldHVybnMgYSBuZXcgb2JqZWN0IGJ5IHN0cmlwcGluZ1xuICogYWxsIG1ldGhvZHMgZnJvbSBhIG1lc3NhZ2UsIGxlYXZpbmcgb25seSBmaWVsZHMgYW5kXG4gKiBvbmVvZiBncm91cHMuIEl0IGlzIHJlY3Vyc2l2ZSwgbWVhbmluZyBpdCBhcHBsaWVzIHRoaXNcbiAqIHNhbWUgbG9naWMgdG8gYWxsIG5lc3RlZCBtZXNzYWdlIGZpZWxkcyBhcyB3ZWxsLlxuICpcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBhbHJlYWR5IGEgcGxhaW4gbWVzc2FnZSwgaXQgaXNcbiAqIHJldHVybmVkIGFzLWlzLlxuICovXG5mdW5jdGlvbiB0b1BsYWluTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgaWYgKCEobWVzc2FnZSBpbnN0YW5jZW9mIGVzbV9tZXNzYWdlLyogTWVzc2FnZSAqLy52KSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UuZ2V0VHlwZSgpO1xuICAgIGNvbnN0IHRhcmdldCA9IHt9O1xuICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIHR5cGUuZmllbGRzLmJ5TWVtYmVyKCkpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gbWVzc2FnZVttZW1iZXIubG9jYWxOYW1lXTtcbiAgICAgICAgbGV0IGNvcHk7XG4gICAgICAgIGlmIChtZW1iZXIucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgIGNvcHkgPSBzb3VyY2UubWFwKChlKSA9PiB0b1BsYWluVmFsdWUoZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1lbWJlci5raW5kID09IFwibWFwXCIpIHtcbiAgICAgICAgICAgIGNvcHkgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdl0gb2YgT2JqZWN0LmVudHJpZXMoc291cmNlKSkge1xuICAgICAgICAgICAgICAgIGNvcHlba2V5XSA9IHRvUGxhaW5WYWx1ZSh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZW1iZXIua2luZCA9PSBcIm9uZW9mXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSBtZW1iZXIuZmluZEZpZWxkKHNvdXJjZS5jYXNlKTtcbiAgICAgICAgICAgIGNvcHkgPSBmXG4gICAgICAgICAgICAgICAgPyB7IGNhc2U6IHNvdXJjZS5jYXNlLCB2YWx1ZTogdG9QbGFpblZhbHVlKHNvdXJjZS52YWx1ZSkgfVxuICAgICAgICAgICAgICAgIDogeyBjYXNlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvcHkgPSB0b1BsYWluVmFsdWUoc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXRbbWVtYmVyLmxvY2FsTmFtZV0gPSBjb3B5O1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gdG9QbGFpblZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBlc21fbWVzc2FnZS8qIE1lc3NhZ2UgKi8udikge1xuICAgICAgICByZXR1cm4gdG9QbGFpbk1lc3NhZ2UodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIGNvbnN0IGMgPSBuZXcgVWludDhBcnJheSh2YWx1ZS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgYy5zZXQodmFsdWUpO1xuICAgICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL2dvb2dsZS9wcm90b2J1Zi9jb21waWxlci9wbHVnaW5fcGIuanNcbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cblxuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG51bWJlciBvZiBwcm90b2NvbCBjb21waWxlci5cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuY29tcGlsZXIuVmVyc2lvblxuICovXG5jbGFzcyBWZXJzaW9uIGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgcHJvdG8yLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVyc2lvbigpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVyc2lvbigpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVyc2lvbigpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvMi51dGlsLmVxdWFscyhWZXJzaW9uLCBhLCBiKTtcbiAgICB9XG59XG5WZXJzaW9uLnJ1bnRpbWUgPSBwcm90bzI7XG5WZXJzaW9uLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuY29tcGlsZXIuVmVyc2lvblwiO1xuVmVyc2lvbi5maWVsZHMgPSBwcm90bzIudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwibWFqb3JcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNSAvKiBTY2FsYXJUeXBlLklOVDMyICovLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIm1pbm9yXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDUgLyogU2NhbGFyVHlwZS5JTlQzMiAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJwYXRjaFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8sIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwic3VmZml4XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIG9wdDogdHJ1ZSB9LFxuXSk7XG4vKipcbiAqIEFuIGVuY29kZWQgQ29kZUdlbmVyYXRvclJlcXVlc3QgaXMgd3JpdHRlbiB0byB0aGUgcGx1Z2luJ3Mgc3RkaW4uXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLmNvbXBpbGVyLkNvZGVHZW5lcmF0b3JSZXF1ZXN0XG4gKi9cbmNsYXNzIENvZGVHZW5lcmF0b3JSZXF1ZXN0IGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSAucHJvdG8gZmlsZXMgdGhhdCB3ZXJlIGV4cGxpY2l0bHkgbGlzdGVkIG9uIHRoZSBjb21tYW5kLWxpbmUuICBUaGVcbiAgICAgICAgICogY29kZSBnZW5lcmF0b3Igc2hvdWxkIGdlbmVyYXRlIGNvZGUgb25seSBmb3IgdGhlc2UgZmlsZXMuICBFYWNoIGZpbGUnc1xuICAgICAgICAgKiBkZXNjcmlwdG9yIHdpbGwgYmUgaW5jbHVkZWQgaW4gcHJvdG9fZmlsZSwgYmVsb3cuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgc3RyaW5nIGZpbGVfdG9fZ2VuZXJhdGUgPSAxO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWxlVG9HZW5lcmF0ZSA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlsZURlc2NyaXB0b3JQcm90b3MgZm9yIGFsbCBmaWxlcyBpbiBmaWxlc190b19nZW5lcmF0ZSBhbmQgZXZlcnl0aGluZ1xuICAgICAgICAgKiB0aGV5IGltcG9ydC4gIFRoZSBmaWxlcyB3aWxsIGFwcGVhciBpbiB0b3BvbG9naWNhbCBvcmRlciwgc28gZWFjaCBmaWxlXG4gICAgICAgICAqIGFwcGVhcnMgYmVmb3JlIGFueSBmaWxlIHRoYXQgaW1wb3J0cyBpdC5cbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZTogdGhlIGZpbGVzIGxpc3RlZCBpbiBmaWxlc190b19nZW5lcmF0ZSB3aWxsIGluY2x1ZGUgcnVudGltZS1yZXRlbnRpb25cbiAgICAgICAgICogb3B0aW9ucyBvbmx5LCBidXQgYWxsIG90aGVyIGZpbGVzIHdpbGwgaW5jbHVkZSBzb3VyY2UtcmV0ZW50aW9uIG9wdGlvbnMuXG4gICAgICAgICAqIFRoZSBzb3VyY2VfZmlsZV9kZXNjcmlwdG9ycyBmaWVsZCBiZWxvdyBpcyBhdmFpbGFibGUgaW4gY2FzZSB5b3UgbmVlZFxuICAgICAgICAgKiBzb3VyY2UtcmV0ZW50aW9uIG9wdGlvbnMgZm9yIGZpbGVzX3RvX2dlbmVyYXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBwcm90b2MgZ3VhcmFudGVlcyB0aGF0IGFsbCBwcm90b19maWxlcyB3aWxsIGJlIHdyaXR0ZW4gYWZ0ZXJcbiAgICAgICAgICogdGhlIGZpZWxkcyBhYm92ZSwgZXZlbiB0aG91Z2ggdGhpcyBpcyBub3QgdGVjaG5pY2FsbHkgZ3VhcmFudGVlZCBieSB0aGVcbiAgICAgICAgICogcHJvdG9idWYgd2lyZSBmb3JtYXQuICBUaGlzIHRoZW9yZXRpY2FsbHkgY291bGQgYWxsb3cgYSBwbHVnaW4gdG8gc3RyZWFtXG4gICAgICAgICAqIGluIHRoZSBGaWxlRGVzY3JpcHRvclByb3RvcyBhbmQgaGFuZGxlIHRoZW0gb25lIGJ5IG9uZSByYXRoZXIgdGhhbiByZWFkXG4gICAgICAgICAqIHRoZSBlbnRpcmUgc2V0IGludG8gbWVtb3J5IGF0IG9uY2UuICBIb3dldmVyLCBhcyBvZiB0aGlzIHdyaXRpbmcsIHRoaXNcbiAgICAgICAgICogaXMgbm90IHNpbWlsYXJseSBvcHRpbWl6ZWQgb24gcHJvdG9jJ3MgZW5kIC0tIGl0IHdpbGwgc3RvcmUgYWxsIGZpZWxkcyBpblxuICAgICAgICAgKiBtZW1vcnkgYXQgb25jZSBiZWZvcmUgc2VuZGluZyB0aGVtIHRvIHRoZSBwbHVnaW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIFR5cGUgbmFtZXMgb2YgZmllbGRzIGFuZCBleHRlbnNpb25zIGluIHRoZSBGaWxlRGVzY3JpcHRvclByb3RvIGFyZSBhbHdheXNcbiAgICAgICAgICogZnVsbHkgcXVhbGlmaWVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGdvb2dsZS5wcm90b2J1Zi5GaWxlRGVzY3JpcHRvclByb3RvIHByb3RvX2ZpbGUgPSAxNTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJvdG9GaWxlID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaWxlIGRlc2NyaXB0b3JzIHdpdGggYWxsIG9wdGlvbnMsIGluY2x1ZGluZyBzb3VyY2UtcmV0ZW50aW9uIG9wdGlvbnMuXG4gICAgICAgICAqIFRoZXNlIGRlc2NyaXB0b3JzIGFyZSBvbmx5IHByb3ZpZGVkIGZvciB0aGUgZmlsZXMgbGlzdGVkIGluXG4gICAgICAgICAqIGZpbGVzX3RvX2dlbmVyYXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGdvb2dsZS5wcm90b2J1Zi5GaWxlRGVzY3JpcHRvclByb3RvIHNvdXJjZV9maWxlX2Rlc2NyaXB0b3JzID0gMTc7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNvdXJjZUZpbGVEZXNjcmlwdG9ycyA9IFtdO1xuICAgICAgICBwcm90bzIudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2RlR2VuZXJhdG9yUmVxdWVzdCgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29kZUdlbmVyYXRvclJlcXVlc3QoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IENvZGVHZW5lcmF0b3JSZXF1ZXN0KCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gcHJvdG8yLnV0aWwuZXF1YWxzKENvZGVHZW5lcmF0b3JSZXF1ZXN0LCBhLCBiKTtcbiAgICB9XG59XG5Db2RlR2VuZXJhdG9yUmVxdWVzdC5ydW50aW1lID0gcHJvdG8yO1xuQ29kZUdlbmVyYXRvclJlcXVlc3QudHlwZU5hbWUgPSBcImdvb2dsZS5wcm90b2J1Zi5jb21waWxlci5Db2RlR2VuZXJhdG9yUmVxdWVzdFwiO1xuQ29kZUdlbmVyYXRvclJlcXVlc3QuZmllbGRzID0gcHJvdG8yLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImZpbGVfdG9fZ2VuZXJhdGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInBhcmFtZXRlclwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiAxNSwgbmFtZTogXCJwcm90b19maWxlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBGaWxlRGVzY3JpcHRvclByb3RvLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDE3LCBuYW1lOiBcInNvdXJjZV9maWxlX2Rlc2NyaXB0b3JzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBGaWxlRGVzY3JpcHRvclByb3RvLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiY29tcGlsZXJfdmVyc2lvblwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVmVyc2lvbiwgb3B0OiB0cnVlIH0sXG5dKTtcbi8qKlxuICogVGhlIHBsdWdpbiB3cml0ZXMgYW4gZW5jb2RlZCBDb2RlR2VuZXJhdG9yUmVzcG9uc2UgdG8gc3Rkb3V0LlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5jb21waWxlci5Db2RlR2VuZXJhdG9yUmVzcG9uc2VcbiAqL1xuY2xhc3MgQ29kZUdlbmVyYXRvclJlc3BvbnNlIGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgZ29vZ2xlLnByb3RvYnVmLmNvbXBpbGVyLkNvZGVHZW5lcmF0b3JSZXNwb25zZS5GaWxlIGZpbGUgPSAxNTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsZSA9IFtdO1xuICAgICAgICBwcm90bzIudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2RlR2VuZXJhdG9yUmVzcG9uc2UoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IENvZGVHZW5lcmF0b3JSZXNwb25zZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29kZUdlbmVyYXRvclJlc3BvbnNlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gcHJvdG8yLnV0aWwuZXF1YWxzKENvZGVHZW5lcmF0b3JSZXNwb25zZSwgYSwgYik7XG4gICAgfVxufVxuQ29kZUdlbmVyYXRvclJlc3BvbnNlLnJ1bnRpbWUgPSBwcm90bzI7XG5Db2RlR2VuZXJhdG9yUmVzcG9uc2UudHlwZU5hbWUgPSBcImdvb2dsZS5wcm90b2J1Zi5jb21waWxlci5Db2RlR2VuZXJhdG9yUmVzcG9uc2VcIjtcbkNvZGVHZW5lcmF0b3JSZXNwb25zZS5maWVsZHMgPSBwcm90bzIudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiZXJyb3JcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJzdXBwb3J0ZWRfZmVhdHVyZXNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNCAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogMTUsIG5hbWU6IFwiZmlsZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogQ29kZUdlbmVyYXRvclJlc3BvbnNlX0ZpbGUsIHJlcGVhdGVkOiB0cnVlIH0sXG5dKTtcbi8qKlxuICogU3luYyB3aXRoIGNvZGVfZ2VuZXJhdG9yLmguXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gZ29vZ2xlLnByb3RvYnVmLmNvbXBpbGVyLkNvZGVHZW5lcmF0b3JSZXNwb25zZS5GZWF0dXJlXG4gKi9cbnZhciBDb2RlR2VuZXJhdG9yUmVzcG9uc2VfRmVhdHVyZTtcbihmdW5jdGlvbiAoQ29kZUdlbmVyYXRvclJlc3BvbnNlX0ZlYXR1cmUpIHtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogRkVBVFVSRV9OT05FID0gMDtcbiAgICAgKi9cbiAgICBDb2RlR2VuZXJhdG9yUmVzcG9uc2VfRmVhdHVyZVtDb2RlR2VuZXJhdG9yUmVzcG9uc2VfRmVhdHVyZVtcIk5PTkVcIl0gPSAwXSA9IFwiTk9ORVwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBGRUFUVVJFX1BST1RPM19PUFRJT05BTCA9IDE7XG4gICAgICovXG4gICAgQ29kZUdlbmVyYXRvclJlc3BvbnNlX0ZlYXR1cmVbQ29kZUdlbmVyYXRvclJlc3BvbnNlX0ZlYXR1cmVbXCJQUk9UTzNfT1BUSU9OQUxcIl0gPSAxXSA9IFwiUFJPVE8zX09QVElPTkFMXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEZFQVRVUkVfU1VQUE9SVFNfRURJVElPTlMgPSAyO1xuICAgICAqL1xuICAgIENvZGVHZW5lcmF0b3JSZXNwb25zZV9GZWF0dXJlW0NvZGVHZW5lcmF0b3JSZXNwb25zZV9GZWF0dXJlW1wiU1VQUE9SVFNfRURJVElPTlNcIl0gPSAyXSA9IFwiU1VQUE9SVFNfRURJVElPTlNcIjtcbn0pKENvZGVHZW5lcmF0b3JSZXNwb25zZV9GZWF0dXJlIHx8IChDb2RlR2VuZXJhdG9yUmVzcG9uc2VfRmVhdHVyZSA9IHt9KSk7XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMi5nZXRFbnVtVHlwZShDb2RlR2VuZXJhdG9yUmVzcG9uc2VfRmVhdHVyZSlcbnByb3RvMi51dGlsLnNldEVudW1UeXBlKENvZGVHZW5lcmF0b3JSZXNwb25zZV9GZWF0dXJlLCBcImdvb2dsZS5wcm90b2J1Zi5jb21waWxlci5Db2RlR2VuZXJhdG9yUmVzcG9uc2UuRmVhdHVyZVwiLCBbXG4gICAgeyBubzogMCwgbmFtZTogXCJGRUFUVVJFX05PTkVcIiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiRkVBVFVSRV9QUk9UTzNfT1BUSU9OQUxcIiB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiRkVBVFVSRV9TVVBQT1JUU19FRElUSU9OU1wiIH0sXG5dKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIHNpbmdsZSBnZW5lcmF0ZWQgZmlsZS5cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuY29tcGlsZXIuQ29kZUdlbmVyYXRvclJlc3BvbnNlLkZpbGVcbiAqL1xuY2xhc3MgQ29kZUdlbmVyYXRvclJlc3BvbnNlX0ZpbGUgZXh0ZW5kcyBlc21fbWVzc2FnZS8qIE1lc3NhZ2UgKi8udiB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBwcm90bzIudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2RlR2VuZXJhdG9yUmVzcG9uc2VfRmlsZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29kZUdlbmVyYXRvclJlc3BvbnNlX0ZpbGUoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IENvZGVHZW5lcmF0b3JSZXNwb25zZV9GaWxlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gcHJvdG8yLnV0aWwuZXF1YWxzKENvZGVHZW5lcmF0b3JSZXNwb25zZV9GaWxlLCBhLCBiKTtcbiAgICB9XG59XG5Db2RlR2VuZXJhdG9yUmVzcG9uc2VfRmlsZS5ydW50aW1lID0gcHJvdG8yO1xuQ29kZUdlbmVyYXRvclJlc3BvbnNlX0ZpbGUudHlwZU5hbWUgPSBcImdvb2dsZS5wcm90b2J1Zi5jb21waWxlci5Db2RlR2VuZXJhdG9yUmVzcG9uc2UuRmlsZVwiO1xuQ29kZUdlbmVyYXRvclJlc3BvbnNlX0ZpbGUuZmllbGRzID0gcHJvdG8yLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcIm5hbWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJpbnNlcnRpb25fcG9pbnRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogMTUsIG5hbWU6IFwiY29udGVudFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiAxNiwgbmFtZTogXCJnZW5lcmF0ZWRfY29kZV9pbmZvXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBHZW5lcmF0ZWRDb2RlSW5mbywgb3B0OiB0cnVlIH0sXG5dKTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9nb29nbGUvcHJvdG9idWYvc291cmNlX2NvbnRleHRfcGIuanNcbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cblxuLyoqXG4gKiBgU291cmNlQ29udGV4dGAgcmVwcmVzZW50cyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc291cmNlIG9mIGFcbiAqIHByb3RvYnVmIGVsZW1lbnQsIGxpa2UgdGhlIGZpbGUgaW4gd2hpY2ggaXQgaXMgZGVmaW5lZC5cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuU291cmNlQ29udGV4dFxuICovXG5jbGFzcyBTb3VyY2VDb250ZXh0IGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYXRoLXF1YWxpZmllZCBuYW1lIG9mIHRoZSAucHJvdG8gZmlsZSB0aGF0IGNvbnRhaW5lZCB0aGUgYXNzb2NpYXRlZFxuICAgICAgICAgKiBwcm90b2J1ZiBlbGVtZW50LiAgRm9yIGV4YW1wbGU6IGBcImdvb2dsZS9wcm90b2J1Zi9zb3VyY2VfY29udGV4dC5wcm90b1wiYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgZmlsZV9uYW1lID0gMTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSBcIlwiO1xuICAgICAgICBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFNvdXJjZUNvbnRleHQoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFNvdXJjZUNvbnRleHQoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFNvdXJjZUNvbnRleHQoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLmVxdWFscyhTb3VyY2VDb250ZXh0LCBhLCBiKTtcbiAgICB9XG59XG5Tb3VyY2VDb250ZXh0LnJ1bnRpbWUgPSBwcm90bzMvKiBwcm90bzMgKi8udztcblNvdXJjZUNvbnRleHQudHlwZU5hbWUgPSBcImdvb2dsZS5wcm90b2J1Zi5Tb3VyY2VDb250ZXh0XCI7XG5Tb3VyY2VDb250ZXh0LmZpZWxkcyA9IHByb3RvMy8qIHByb3RvMyAqLy53LnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImZpbGVfbmFtZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG5dKTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9nb29nbGUvcHJvdG9idWYvdHlwZV9wYi5qc1xuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8vIEBnZW5lcmF0ZWQgYnkgcHJvdG9jLWdlbi1lcyB2MS42LjAgd2l0aCBwYXJhbWV0ZXIgXCJib290c3RyYXBfd2t0PXRydWUsdHNfbm9jaGVjaz1mYWxzZSx0YXJnZXQ9dHNcIlxuLy8gQGdlbmVyYXRlZCBmcm9tIGZpbGUgZ29vZ2xlL3Byb3RvYnVmL3R5cGUucHJvdG8gKHBhY2thZ2UgZ29vZ2xlLnByb3RvYnVmLCBzeW50YXggcHJvdG8zKVxuLyogZXNsaW50LWRpc2FibGUgKi9cblxuXG5cblxuLyoqXG4gKiBUaGUgc3ludGF4IGluIHdoaWNoIGEgcHJvdG9jb2wgYnVmZmVyIGVsZW1lbnQgaXMgZGVmaW5lZC5cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBnb29nbGUucHJvdG9idWYuU3ludGF4XG4gKi9cbnZhciBTeW50YXg7XG4oZnVuY3Rpb24gKFN5bnRheCkge1xuICAgIC8qKlxuICAgICAqIFN5bnRheCBgcHJvdG8yYC5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBTWU5UQVhfUFJPVE8yID0gMDtcbiAgICAgKi9cbiAgICBTeW50YXhbU3ludGF4W1wiUFJPVE8yXCJdID0gMF0gPSBcIlBST1RPMlwiO1xuICAgIC8qKlxuICAgICAqIFN5bnRheCBgcHJvdG8zYC5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBTWU5UQVhfUFJPVE8zID0gMTtcbiAgICAgKi9cbiAgICBTeW50YXhbU3ludGF4W1wiUFJPVE8zXCJdID0gMV0gPSBcIlBST1RPM1wiO1xuICAgIC8qKlxuICAgICAqIFN5bnRheCBgZWRpdGlvbnNgLlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFNZTlRBWF9FRElUSU9OUyA9IDI7XG4gICAgICovXG4gICAgU3ludGF4W1N5bnRheFtcIkVESVRJT05TXCJdID0gMl0gPSBcIkVESVRJT05TXCI7XG59KShTeW50YXggfHwgKFN5bnRheCA9IHt9KSk7XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShTeW50YXgpXG5wcm90bzMvKiBwcm90bzMgKi8udy51dGlsLnNldEVudW1UeXBlKFN5bnRheCwgXCJnb29nbGUucHJvdG9idWYuU3ludGF4XCIsIFtcbiAgICB7IG5vOiAwLCBuYW1lOiBcIlNZTlRBWF9QUk9UTzJcIiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiU1lOVEFYX1BST1RPM1wiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJTWU5UQVhfRURJVElPTlNcIiB9LFxuXSk7XG4vKipcbiAqIEEgcHJvdG9jb2wgYnVmZmVyIG1lc3NhZ2UgdHlwZS5cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuVHlwZVxuICovXG5jbGFzcyBUeXBlIGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmdWxseSBxdWFsaWZpZWQgbWVzc2FnZSBuYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBuYW1lID0gMTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9IFwiXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGlzdCBvZiBmaWVsZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgZ29vZ2xlLnByb3RvYnVmLkZpZWxkIGZpZWxkcyA9IDI7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpZWxkcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxpc3Qgb2YgdHlwZXMgYXBwZWFyaW5nIGluIGBvbmVvZmAgZGVmaW5pdGlvbnMgaW4gdGhpcyB0eXBlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIHN0cmluZyBvbmVvZnMgPSAzO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbmVvZnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwcm90b2NvbCBidWZmZXIgb3B0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBnb29nbGUucHJvdG9idWYuT3B0aW9uIG9wdGlvbnMgPSA0O1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcHRpb25zID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc291cmNlIHN5bnRheC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBnb29nbGUucHJvdG9idWYuU3ludGF4IHN5bnRheCA9IDY7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN5bnRheCA9IFN5bnRheC5QUk9UTzI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc291cmNlIGVkaXRpb24gc3RyaW5nLCBvbmx5IHZhbGlkIHdoZW4gc3ludGF4IGlzIFNZTlRBWF9FRElUSU9OUy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgZWRpdGlvbiA9IDc7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVkaXRpb24gPSBcIlwiO1xuICAgICAgICBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGUoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGUoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGUoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLmVxdWFscyhUeXBlLCBhLCBiKTtcbiAgICB9XG59XG5UeXBlLnJ1bnRpbWUgPSBwcm90bzMvKiBwcm90bzMgKi8udztcblR5cGUudHlwZU5hbWUgPSBcImdvb2dsZS5wcm90b2J1Zi5UeXBlXCI7XG5UeXBlLmZpZWxkcyA9IHByb3RvMy8qIHByb3RvMyAqLy53LnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcIm5hbWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiZmllbGRzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBGaWVsZCwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcIm9uZW9mc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwib3B0aW9uc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogT3B0aW9uLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwic291cmNlX2NvbnRleHRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNvdXJjZUNvbnRleHQgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcInN5bnRheFwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLyogcHJvdG8zICovLncuZ2V0RW51bVR5cGUoU3ludGF4KSB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwiZWRpdGlvblwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG5dKTtcbi8qKlxuICogQSBzaW5nbGUgZmllbGQgb2YgYSBtZXNzYWdlIHR5cGUuXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLkZpZWxkXG4gKi9cbmNsYXNzIEZpZWxkIGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmaWVsZCB0eXBlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGdvb2dsZS5wcm90b2J1Zi5GaWVsZC5LaW5kIGtpbmQgPSAxO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5raW5kID0gRmllbGRfS2luZC5UWVBFX1VOS05PV047XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZmllbGQgY2FyZGluYWxpdHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZ29vZ2xlLnByb3RvYnVmLkZpZWxkLkNhcmRpbmFsaXR5IGNhcmRpbmFsaXR5ID0gMjtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FyZGluYWxpdHkgPSBGaWVsZF9DYXJkaW5hbGl0eS5VTktOT1dOO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZpZWxkIG51bWJlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQzMiBudW1iZXIgPSAzO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5udW1iZXIgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZpZWxkIG5hbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG5hbWUgPSA0O1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gXCJcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmaWVsZCB0eXBlIFVSTCwgd2l0aG91dCB0aGUgc2NoZW1lLCBmb3IgbWVzc2FnZSBvciBlbnVtZXJhdGlvblxuICAgICAgICAgKiB0eXBlcy4gRXhhbXBsZTogYFwidHlwZS5nb29nbGVhcGlzLmNvbS9nb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCJgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyB0eXBlX3VybCA9IDY7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGVVcmwgPSBcIlwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluZGV4IG9mIHRoZSBmaWVsZCB0eXBlIGluIGBUeXBlLm9uZW9mc2AsIGZvciBtZXNzYWdlIG9yIGVudW1lcmF0aW9uXG4gICAgICAgICAqIHR5cGVzLiBUaGUgZmlyc3QgdHlwZSBoYXMgaW5kZXggMTsgemVybyBtZWFucyB0aGUgdHlwZSBpcyBub3QgaW4gdGhlIGxpc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50MzIgb25lb2ZfaW5kZXggPSA3O1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbmVvZkluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdG8gdXNlIGFsdGVybmF0aXZlIHBhY2tlZCB3aXJlIHJlcHJlc2VudGF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgcGFja2VkID0gODtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFja2VkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcHJvdG9jb2wgYnVmZmVyIG9wdGlvbnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgZ29vZ2xlLnByb3RvYnVmLk9wdGlvbiBvcHRpb25zID0gOTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZpZWxkIEpTT04gbmFtZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcganNvbl9uYW1lID0gMTA7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmpzb25OYW1lID0gXCJcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzdHJpbmcgdmFsdWUgb2YgdGhlIGRlZmF1bHQgdmFsdWUgb2YgdGhpcyBmaWVsZC4gUHJvdG8yIHN5bnRheCBvbmx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBkZWZhdWx0X3ZhbHVlID0gMTE7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IFwiXCI7XG4gICAgICAgIHByb3RvMy8qIHByb3RvMyAqLy53LnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGQoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEZpZWxkKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZCgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvMy8qIHByb3RvMyAqLy53LnV0aWwuZXF1YWxzKEZpZWxkLCBhLCBiKTtcbiAgICB9XG59XG5GaWVsZC5ydW50aW1lID0gcHJvdG8zLyogcHJvdG8zICovLnc7XG5GaWVsZC50eXBlTmFtZSA9IFwiZ29vZ2xlLnByb3RvYnVmLkZpZWxkXCI7XG5GaWVsZC5maWVsZHMgPSBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJraW5kXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMvKiBwcm90bzMgKi8udy5nZXRFbnVtVHlwZShGaWVsZF9LaW5kKSB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiY2FyZGluYWxpdHlcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy8qIHByb3RvMyAqLy53LmdldEVudW1UeXBlKEZpZWxkX0NhcmRpbmFsaXR5KSB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwibnVtYmVyXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDUgLyogU2NhbGFyVHlwZS5JTlQzMiAqLyB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwibmFtZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJ0eXBlX3VybFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJvbmVvZl9pbmRleFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8gfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcInBhY2tlZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDksIG5hbWU6IFwib3B0aW9uc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogT3B0aW9uLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDEwLCBuYW1lOiBcImpzb25fbmFtZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMTEsIG5hbWU6IFwiZGVmYXVsdF92YWx1ZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG5dKTtcbi8qKlxuICogQmFzaWMgZmllbGQgdHlwZXMuXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gZ29vZ2xlLnByb3RvYnVmLkZpZWxkLktpbmRcbiAqL1xudmFyIEZpZWxkX0tpbmQ7XG4oZnVuY3Rpb24gKEZpZWxkX0tpbmQpIHtcbiAgICAvKipcbiAgICAgKiBGaWVsZCB0eXBlIHVua25vd24uXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVFlQRV9VTktOT1dOID0gMDtcbiAgICAgKi9cbiAgICBGaWVsZF9LaW5kW0ZpZWxkX0tpbmRbXCJUWVBFX1VOS05PV05cIl0gPSAwXSA9IFwiVFlQRV9VTktOT1dOXCI7XG4gICAgLyoqXG4gICAgICogRmllbGQgdHlwZSBkb3VibGUuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVFlQRV9ET1VCTEUgPSAxO1xuICAgICAqL1xuICAgIEZpZWxkX0tpbmRbRmllbGRfS2luZFtcIlRZUEVfRE9VQkxFXCJdID0gMV0gPSBcIlRZUEVfRE9VQkxFXCI7XG4gICAgLyoqXG4gICAgICogRmllbGQgdHlwZSBmbG9hdC5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBUWVBFX0ZMT0FUID0gMjtcbiAgICAgKi9cbiAgICBGaWVsZF9LaW5kW0ZpZWxkX0tpbmRbXCJUWVBFX0ZMT0FUXCJdID0gMl0gPSBcIlRZUEVfRkxPQVRcIjtcbiAgICAvKipcbiAgICAgKiBGaWVsZCB0eXBlIGludDY0LlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFRZUEVfSU5UNjQgPSAzO1xuICAgICAqL1xuICAgIEZpZWxkX0tpbmRbRmllbGRfS2luZFtcIlRZUEVfSU5UNjRcIl0gPSAzXSA9IFwiVFlQRV9JTlQ2NFwiO1xuICAgIC8qKlxuICAgICAqIEZpZWxkIHR5cGUgdWludDY0LlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFRZUEVfVUlOVDY0ID0gNDtcbiAgICAgKi9cbiAgICBGaWVsZF9LaW5kW0ZpZWxkX0tpbmRbXCJUWVBFX1VJTlQ2NFwiXSA9IDRdID0gXCJUWVBFX1VJTlQ2NFwiO1xuICAgIC8qKlxuICAgICAqIEZpZWxkIHR5cGUgaW50MzIuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVFlQRV9JTlQzMiA9IDU7XG4gICAgICovXG4gICAgRmllbGRfS2luZFtGaWVsZF9LaW5kW1wiVFlQRV9JTlQzMlwiXSA9IDVdID0gXCJUWVBFX0lOVDMyXCI7XG4gICAgLyoqXG4gICAgICogRmllbGQgdHlwZSBmaXhlZDY0LlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFRZUEVfRklYRUQ2NCA9IDY7XG4gICAgICovXG4gICAgRmllbGRfS2luZFtGaWVsZF9LaW5kW1wiVFlQRV9GSVhFRDY0XCJdID0gNl0gPSBcIlRZUEVfRklYRUQ2NFwiO1xuICAgIC8qKlxuICAgICAqIEZpZWxkIHR5cGUgZml4ZWQzMi5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBUWVBFX0ZJWEVEMzIgPSA3O1xuICAgICAqL1xuICAgIEZpZWxkX0tpbmRbRmllbGRfS2luZFtcIlRZUEVfRklYRUQzMlwiXSA9IDddID0gXCJUWVBFX0ZJWEVEMzJcIjtcbiAgICAvKipcbiAgICAgKiBGaWVsZCB0eXBlIGJvb2wuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVFlQRV9CT09MID0gODtcbiAgICAgKi9cbiAgICBGaWVsZF9LaW5kW0ZpZWxkX0tpbmRbXCJUWVBFX0JPT0xcIl0gPSA4XSA9IFwiVFlQRV9CT09MXCI7XG4gICAgLyoqXG4gICAgICogRmllbGQgdHlwZSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVFlQRV9TVFJJTkcgPSA5O1xuICAgICAqL1xuICAgIEZpZWxkX0tpbmRbRmllbGRfS2luZFtcIlRZUEVfU1RSSU5HXCJdID0gOV0gPSBcIlRZUEVfU1RSSU5HXCI7XG4gICAgLyoqXG4gICAgICogRmllbGQgdHlwZSBncm91cC4gUHJvdG8yIHN5bnRheCBvbmx5LCBhbmQgZGVwcmVjYXRlZC5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBUWVBFX0dST1VQID0gMTA7XG4gICAgICovXG4gICAgRmllbGRfS2luZFtGaWVsZF9LaW5kW1wiVFlQRV9HUk9VUFwiXSA9IDEwXSA9IFwiVFlQRV9HUk9VUFwiO1xuICAgIC8qKlxuICAgICAqIEZpZWxkIHR5cGUgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBUWVBFX01FU1NBR0UgPSAxMTtcbiAgICAgKi9cbiAgICBGaWVsZF9LaW5kW0ZpZWxkX0tpbmRbXCJUWVBFX01FU1NBR0VcIl0gPSAxMV0gPSBcIlRZUEVfTUVTU0FHRVwiO1xuICAgIC8qKlxuICAgICAqIEZpZWxkIHR5cGUgYnl0ZXMuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVFlQRV9CWVRFUyA9IDEyO1xuICAgICAqL1xuICAgIEZpZWxkX0tpbmRbRmllbGRfS2luZFtcIlRZUEVfQllURVNcIl0gPSAxMl0gPSBcIlRZUEVfQllURVNcIjtcbiAgICAvKipcbiAgICAgKiBGaWVsZCB0eXBlIHVpbnQzMi5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBUWVBFX1VJTlQzMiA9IDEzO1xuICAgICAqL1xuICAgIEZpZWxkX0tpbmRbRmllbGRfS2luZFtcIlRZUEVfVUlOVDMyXCJdID0gMTNdID0gXCJUWVBFX1VJTlQzMlwiO1xuICAgIC8qKlxuICAgICAqIEZpZWxkIHR5cGUgZW51bS5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBUWVBFX0VOVU0gPSAxNDtcbiAgICAgKi9cbiAgICBGaWVsZF9LaW5kW0ZpZWxkX0tpbmRbXCJUWVBFX0VOVU1cIl0gPSAxNF0gPSBcIlRZUEVfRU5VTVwiO1xuICAgIC8qKlxuICAgICAqIEZpZWxkIHR5cGUgc2ZpeGVkMzIuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVFlQRV9TRklYRUQzMiA9IDE1O1xuICAgICAqL1xuICAgIEZpZWxkX0tpbmRbRmllbGRfS2luZFtcIlRZUEVfU0ZJWEVEMzJcIl0gPSAxNV0gPSBcIlRZUEVfU0ZJWEVEMzJcIjtcbiAgICAvKipcbiAgICAgKiBGaWVsZCB0eXBlIHNmaXhlZDY0LlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFRZUEVfU0ZJWEVENjQgPSAxNjtcbiAgICAgKi9cbiAgICBGaWVsZF9LaW5kW0ZpZWxkX0tpbmRbXCJUWVBFX1NGSVhFRDY0XCJdID0gMTZdID0gXCJUWVBFX1NGSVhFRDY0XCI7XG4gICAgLyoqXG4gICAgICogRmllbGQgdHlwZSBzaW50MzIuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVFlQRV9TSU5UMzIgPSAxNztcbiAgICAgKi9cbiAgICBGaWVsZF9LaW5kW0ZpZWxkX0tpbmRbXCJUWVBFX1NJTlQzMlwiXSA9IDE3XSA9IFwiVFlQRV9TSU5UMzJcIjtcbiAgICAvKipcbiAgICAgKiBGaWVsZCB0eXBlIHNpbnQ2NC5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBUWVBFX1NJTlQ2NCA9IDE4O1xuICAgICAqL1xuICAgIEZpZWxkX0tpbmRbRmllbGRfS2luZFtcIlRZUEVfU0lOVDY0XCJdID0gMThdID0gXCJUWVBFX1NJTlQ2NFwiO1xufSkoRmllbGRfS2luZCB8fCAoRmllbGRfS2luZCA9IHt9KSk7XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShGaWVsZF9LaW5kKVxucHJvdG8zLyogcHJvdG8zICovLncudXRpbC5zZXRFbnVtVHlwZShGaWVsZF9LaW5kLCBcImdvb2dsZS5wcm90b2J1Zi5GaWVsZC5LaW5kXCIsIFtcbiAgICB7IG5vOiAwLCBuYW1lOiBcIlRZUEVfVU5LTk9XTlwiIH0sXG4gICAgeyBubzogMSwgbmFtZTogXCJUWVBFX0RPVUJMRVwiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJUWVBFX0ZMT0FUXCIgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcIlRZUEVfSU5UNjRcIiB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwiVFlQRV9VSU5UNjRcIiB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwiVFlQRV9JTlQzMlwiIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJUWVBFX0ZJWEVENjRcIiB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwiVFlQRV9GSVhFRDMyXCIgfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcIlRZUEVfQk9PTFwiIH0sXG4gICAgeyBubzogOSwgbmFtZTogXCJUWVBFX1NUUklOR1wiIH0sXG4gICAgeyBubzogMTAsIG5hbWU6IFwiVFlQRV9HUk9VUFwiIH0sXG4gICAgeyBubzogMTEsIG5hbWU6IFwiVFlQRV9NRVNTQUdFXCIgfSxcbiAgICB7IG5vOiAxMiwgbmFtZTogXCJUWVBFX0JZVEVTXCIgfSxcbiAgICB7IG5vOiAxMywgbmFtZTogXCJUWVBFX1VJTlQzMlwiIH0sXG4gICAgeyBubzogMTQsIG5hbWU6IFwiVFlQRV9FTlVNXCIgfSxcbiAgICB7IG5vOiAxNSwgbmFtZTogXCJUWVBFX1NGSVhFRDMyXCIgfSxcbiAgICB7IG5vOiAxNiwgbmFtZTogXCJUWVBFX1NGSVhFRDY0XCIgfSxcbiAgICB7IG5vOiAxNywgbmFtZTogXCJUWVBFX1NJTlQzMlwiIH0sXG4gICAgeyBubzogMTgsIG5hbWU6IFwiVFlQRV9TSU5UNjRcIiB9LFxuXSk7XG4vKipcbiAqIFdoZXRoZXIgYSBmaWVsZCBpcyBvcHRpb25hbCwgcmVxdWlyZWQsIG9yIHJlcGVhdGVkLlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGdvb2dsZS5wcm90b2J1Zi5GaWVsZC5DYXJkaW5hbGl0eVxuICovXG52YXIgRmllbGRfQ2FyZGluYWxpdHk7XG4oZnVuY3Rpb24gKEZpZWxkX0NhcmRpbmFsaXR5KSB7XG4gICAgLyoqXG4gICAgICogRm9yIGZpZWxkcyB3aXRoIHVua25vd24gY2FyZGluYWxpdHkuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogQ0FSRElOQUxJVFlfVU5LTk9XTiA9IDA7XG4gICAgICovXG4gICAgRmllbGRfQ2FyZGluYWxpdHlbRmllbGRfQ2FyZGluYWxpdHlbXCJVTktOT1dOXCJdID0gMF0gPSBcIlVOS05PV05cIjtcbiAgICAvKipcbiAgICAgKiBGb3Igb3B0aW9uYWwgZmllbGRzLlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IENBUkRJTkFMSVRZX09QVElPTkFMID0gMTtcbiAgICAgKi9cbiAgICBGaWVsZF9DYXJkaW5hbGl0eVtGaWVsZF9DYXJkaW5hbGl0eVtcIk9QVElPTkFMXCJdID0gMV0gPSBcIk9QVElPTkFMXCI7XG4gICAgLyoqXG4gICAgICogRm9yIHJlcXVpcmVkIGZpZWxkcy4gUHJvdG8yIHN5bnRheCBvbmx5LlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IENBUkRJTkFMSVRZX1JFUVVJUkVEID0gMjtcbiAgICAgKi9cbiAgICBGaWVsZF9DYXJkaW5hbGl0eVtGaWVsZF9DYXJkaW5hbGl0eVtcIlJFUVVJUkVEXCJdID0gMl0gPSBcIlJFUVVJUkVEXCI7XG4gICAgLyoqXG4gICAgICogRm9yIHJlcGVhdGVkIGZpZWxkcy5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBDQVJESU5BTElUWV9SRVBFQVRFRCA9IDM7XG4gICAgICovXG4gICAgRmllbGRfQ2FyZGluYWxpdHlbRmllbGRfQ2FyZGluYWxpdHlbXCJSRVBFQVRFRFwiXSA9IDNdID0gXCJSRVBFQVRFRFwiO1xufSkoRmllbGRfQ2FyZGluYWxpdHkgfHwgKEZpZWxkX0NhcmRpbmFsaXR5ID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKEZpZWxkX0NhcmRpbmFsaXR5KVxucHJvdG8zLyogcHJvdG8zICovLncudXRpbC5zZXRFbnVtVHlwZShGaWVsZF9DYXJkaW5hbGl0eSwgXCJnb29nbGUucHJvdG9idWYuRmllbGQuQ2FyZGluYWxpdHlcIiwgW1xuICAgIHsgbm86IDAsIG5hbWU6IFwiQ0FSRElOQUxJVFlfVU5LTk9XTlwiIH0sXG4gICAgeyBubzogMSwgbmFtZTogXCJDQVJESU5BTElUWV9PUFRJT05BTFwiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJDQVJESU5BTElUWV9SRVFVSVJFRFwiIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJDQVJESU5BTElUWV9SRVBFQVRFRFwiIH0sXG5dKTtcbi8qKlxuICogRW51bSB0eXBlIGRlZmluaXRpb24uXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLkVudW1cbiAqL1xuY2xhc3MgRW51bSBleHRlbmRzIGVzbV9tZXNzYWdlLyogTWVzc2FnZSAqLy52IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbnVtIHR5cGUgbmFtZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbmFtZSA9IDE7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW51bSB2YWx1ZSBkZWZpbml0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBnb29nbGUucHJvdG9idWYuRW51bVZhbHVlIGVudW12YWx1ZSA9IDI7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVudW12YWx1ZSA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvdG9jb2wgYnVmZmVyIG9wdGlvbnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgZ29vZ2xlLnByb3RvYnVmLk9wdGlvbiBvcHRpb25zID0gMztcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNvdXJjZSBzeW50YXguXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZ29vZ2xlLnByb3RvYnVmLlN5bnRheCBzeW50YXggPSA1O1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zeW50YXggPSBTeW50YXguUFJPVE8yO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNvdXJjZSBlZGl0aW9uIHN0cmluZywgb25seSB2YWxpZCB3aGVuIHN5bnRheCBpcyBTWU5UQVhfRURJVElPTlMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIGVkaXRpb24gPSA2O1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lZGl0aW9uID0gXCJcIjtcbiAgICAgICAgcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbnVtKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbnVtKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbnVtKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5lcXVhbHMoRW51bSwgYSwgYik7XG4gICAgfVxufVxuRW51bS5ydW50aW1lID0gcHJvdG8zLyogcHJvdG8zICovLnc7XG5FbnVtLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuRW51bVwiO1xuRW51bS5maWVsZHMgPSBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJuYW1lXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImVudW12YWx1ZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogRW51bVZhbHVlLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwib3B0aW9uc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogT3B0aW9uLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwic291cmNlX2NvbnRleHRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNvdXJjZUNvbnRleHQgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcInN5bnRheFwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLyogcHJvdG8zICovLncuZ2V0RW51bVR5cGUoU3ludGF4KSB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwiZWRpdGlvblwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG5dKTtcbi8qKlxuICogRW51bSB2YWx1ZSBkZWZpbml0aW9uLlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5FbnVtVmFsdWVcbiAqL1xuY2xhc3MgRW51bVZhbHVlIGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVudW0gdmFsdWUgbmFtZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbmFtZSA9IDE7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW51bSB2YWx1ZSBudW1iZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50MzIgbnVtYmVyID0gMjtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubnVtYmVyID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3RvY29sIGJ1ZmZlciBvcHRpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGdvb2dsZS5wcm90b2J1Zi5PcHRpb24gb3B0aW9ucyA9IDM7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBbXTtcbiAgICAgICAgcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbnVtVmFsdWUoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEVudW1WYWx1ZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW51bVZhbHVlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5lcXVhbHMoRW51bVZhbHVlLCBhLCBiKTtcbiAgICB9XG59XG5FbnVtVmFsdWUucnVudGltZSA9IHByb3RvMy8qIHByb3RvMyAqLy53O1xuRW51bVZhbHVlLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuRW51bVZhbHVlXCI7XG5FbnVtVmFsdWUuZmllbGRzID0gcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwibmFtZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJudW1iZXJcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNSAvKiBTY2FsYXJUeXBlLklOVDMyICovIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJvcHRpb25zXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBPcHRpb24sIHJlcGVhdGVkOiB0cnVlIH0sXG5dKTtcbi8qKlxuICogQSBwcm90b2NvbCBidWZmZXIgb3B0aW9uLCB3aGljaCBjYW4gYmUgYXR0YWNoZWQgdG8gYSBtZXNzYWdlLCBmaWVsZCxcbiAqIGVudW1lcmF0aW9uLCBldGMuXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLk9wdGlvblxuICovXG5jbGFzcyBPcHRpb24gZXh0ZW5kcyBlc21fbWVzc2FnZS8qIE1lc3NhZ2UgKi8udiB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9wdGlvbidzIG5hbWUuIEZvciBwcm90b2J1ZiBidWlsdC1pbiBvcHRpb25zIChvcHRpb25zIGRlZmluZWQgaW5cbiAgICAgICAgICogZGVzY3JpcHRvci5wcm90byksIHRoaXMgaXMgdGhlIHNob3J0IG5hbWUuIEZvciBleGFtcGxlLCBgXCJtYXBfZW50cnlcImAuXG4gICAgICAgICAqIEZvciBjdXN0b20gb3B0aW9ucywgaXQgc2hvdWxkIGJlIHRoZSBmdWxseS1xdWFsaWZpZWQgbmFtZS4gRm9yIGV4YW1wbGUsXG4gICAgICAgICAqIGBcImdvb2dsZS5hcGkuaHR0cFwiYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbmFtZSA9IDE7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlwiO1xuICAgICAgICBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IE9wdGlvbigpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgT3B0aW9uKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPcHRpb24oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLmVxdWFscyhPcHRpb24sIGEsIGIpO1xuICAgIH1cbn1cbk9wdGlvbi5ydW50aW1lID0gcHJvdG8zLyogcHJvdG8zICovLnc7XG5PcHRpb24udHlwZU5hbWUgPSBcImdvb2dsZS5wcm90b2J1Zi5PcHRpb25cIjtcbk9wdGlvbi5maWVsZHMgPSBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJuYW1lXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInZhbHVlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBhbnlfcGIvKiBBbnkgKi8uSSB9LFxuXSk7XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vZ29vZ2xlL3Byb3RvYnVmL2FwaV9wYi5qc1xuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuXG5cblxuLyoqXG4gKiBBcGkgaXMgYSBsaWdodC13ZWlnaHQgZGVzY3JpcHRvciBmb3IgYW4gQVBJIEludGVyZmFjZS5cbiAqXG4gKiBJbnRlcmZhY2VzIGFyZSBhbHNvIGRlc2NyaWJlZCBhcyBcInByb3RvY29sIGJ1ZmZlciBzZXJ2aWNlc1wiIGluIHNvbWUgY29udGV4dHMsXG4gKiBzdWNoIGFzIGJ5IHRoZSBcInNlcnZpY2VcIiBrZXl3b3JkIGluIGEgLnByb3RvIGZpbGUsIGJ1dCB0aGV5IGFyZSBkaWZmZXJlbnRcbiAqIGZyb20gQVBJIFNlcnZpY2VzLCB3aGljaCByZXByZXNlbnQgYSBjb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBhbiBpbnRlcmZhY2VcbiAqIGFzIG9wcG9zZWQgdG8gc2ltcGx5IGEgZGVzY3JpcHRpb24gb2YgbWV0aG9kcyBhbmQgYmluZGluZ3MuIFRoZXkgYXJlIGFsc29cbiAqIHNvbWV0aW1lcyBzaW1wbHkgcmVmZXJyZWQgdG8gYXMgXCJBUElzXCIgaW4gb3RoZXIgY29udGV4dHMsIHN1Y2ggYXMgdGhlIG5hbWUgb2ZcbiAqIHRoaXMgbWVzc2FnZSBpdHNlbGYuIFNlZSBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vYXBpcy9kZXNpZ24vZ2xvc3NhcnkgZm9yXG4gKiBkZXRhaWxlZCB0ZXJtaW5vbG9neS5cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuQXBpXG4gKi9cbmNsYXNzIEFwaSBleHRlbmRzIGVzbV9tZXNzYWdlLyogTWVzc2FnZSAqLy52IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZnVsbHkgcXVhbGlmaWVkIG5hbWUgb2YgdGhpcyBpbnRlcmZhY2UsIGluY2x1ZGluZyBwYWNrYWdlIG5hbWVcbiAgICAgICAgICogZm9sbG93ZWQgYnkgdGhlIGludGVyZmFjZSdzIHNpbXBsZSBuYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBuYW1lID0gMTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9IFwiXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWV0aG9kcyBvZiB0aGlzIGludGVyZmFjZSwgaW4gdW5zcGVjaWZpZWQgb3JkZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgZ29vZ2xlLnByb3RvYnVmLk1ldGhvZCBtZXRob2RzID0gMjtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWV0aG9kcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW55IG1ldGFkYXRhIGF0dGFjaGVkIHRvIHRoZSBpbnRlcmZhY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgZ29vZ2xlLnByb3RvYnVmLk9wdGlvbiBvcHRpb25zID0gMztcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSB2ZXJzaW9uIHN0cmluZyBmb3IgdGhpcyBpbnRlcmZhY2UuIElmIHNwZWNpZmllZCwgbXVzdCBoYXZlIHRoZSBmb3JtXG4gICAgICAgICAqIGBtYWpvci12ZXJzaW9uLm1pbm9yLXZlcnNpb25gLCBhcyBpbiBgMS4xMGAuIElmIHRoZSBtaW5vciB2ZXJzaW9uIGlzXG4gICAgICAgICAqIG9taXR0ZWQsIGl0IGRlZmF1bHRzIHRvIHplcm8uIElmIHRoZSBlbnRpcmUgdmVyc2lvbiBmaWVsZCBpcyBlbXB0eSwgdGhlXG4gICAgICAgICAqIG1ham9yIHZlcnNpb24gaXMgZGVyaXZlZCBmcm9tIHRoZSBwYWNrYWdlIG5hbWUsIGFzIG91dGxpbmVkIGJlbG93LiBJZiB0aGVcbiAgICAgICAgICogZmllbGQgaXMgbm90IGVtcHR5LCB0aGUgdmVyc2lvbiBpbiB0aGUgcGFja2FnZSBuYW1lIHdpbGwgYmUgdmVyaWZpZWQgdG8gYmVcbiAgICAgICAgICogY29uc2lzdGVudCB3aXRoIHdoYXQgaXMgcHJvdmlkZWQgaGVyZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHZlcnNpb25pbmcgc2NoZW1hIHVzZXMgW3NlbWFudGljXG4gICAgICAgICAqIHZlcnNpb25pbmddKGh0dHA6Ly9zZW12ZXIub3JnKSB3aGVyZSB0aGUgbWFqb3IgdmVyc2lvbiBudW1iZXJcbiAgICAgICAgICogaW5kaWNhdGVzIGEgYnJlYWtpbmcgY2hhbmdlIGFuZCB0aGUgbWlub3IgdmVyc2lvbiBhbiBhZGRpdGl2ZSxcbiAgICAgICAgICogbm9uLWJyZWFraW5nIGNoYW5nZS4gQm90aCB2ZXJzaW9uIG51bWJlcnMgYXJlIHNpZ25hbHMgdG8gdXNlcnNcbiAgICAgICAgICogd2hhdCB0byBleHBlY3QgZnJvbSBkaWZmZXJlbnQgdmVyc2lvbnMsIGFuZCBzaG91bGQgYmUgY2FyZWZ1bGx5XG4gICAgICAgICAqIGNob3NlbiBiYXNlZCBvbiB0aGUgcHJvZHVjdCBwbGFuLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgbWFqb3IgdmVyc2lvbiBpcyBhbHNvIHJlZmxlY3RlZCBpbiB0aGUgcGFja2FnZSBuYW1lIG9mIHRoZVxuICAgICAgICAgKiBpbnRlcmZhY2UsIHdoaWNoIG11c3QgZW5kIGluIGB2PG1ham9yLXZlcnNpb24+YCwgYXMgaW5cbiAgICAgICAgICogYGdvb2dsZS5mZWF0dXJlLnYxYC4gRm9yIG1ham9yIHZlcnNpb25zIDAgYW5kIDEsIHRoZSBzdWZmaXggY2FuXG4gICAgICAgICAqIGJlIG9taXR0ZWQuIFplcm8gbWFqb3IgdmVyc2lvbnMgbXVzdCBvbmx5IGJlIHVzZWQgZm9yXG4gICAgICAgICAqIGV4cGVyaW1lbnRhbCwgbm9uLUdBIGludGVyZmFjZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHZlcnNpb24gPSA0O1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52ZXJzaW9uID0gXCJcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluY2x1ZGVkIGludGVyZmFjZXMuIFNlZSBbTWl4aW5dW10uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgZ29vZ2xlLnByb3RvYnVmLk1peGluIG1peGlucyA9IDY7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1peGlucyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNvdXJjZSBzeW50YXggb2YgdGhlIHNlcnZpY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZ29vZ2xlLnByb3RvYnVmLlN5bnRheCBzeW50YXggPSA3O1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zeW50YXggPSBTeW50YXguUFJPVE8yO1xuICAgICAgICBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEFwaSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXBpKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcGkoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLmVxdWFscyhBcGksIGEsIGIpO1xuICAgIH1cbn1cbkFwaS5ydW50aW1lID0gcHJvdG8zLyogcHJvdG8zICovLnc7XG5BcGkudHlwZU5hbWUgPSBcImdvb2dsZS5wcm90b2J1Zi5BcGlcIjtcbkFwaS5maWVsZHMgPSBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJuYW1lXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIm1ldGhvZHNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IE1ldGhvZCwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcIm9wdGlvbnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IE9wdGlvbiwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcInZlcnNpb25cIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwic291cmNlX2NvbnRleHRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNvdXJjZUNvbnRleHQgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcIm1peGluc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogTWl4aW4sIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJzeW50YXhcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy8qIHByb3RvMyAqLy53LmdldEVudW1UeXBlKFN5bnRheCkgfSxcbl0pO1xuLyoqXG4gKiBNZXRob2QgcmVwcmVzZW50cyBhIG1ldGhvZCBvZiBhbiBBUEkgaW50ZXJmYWNlLlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5NZXRob2RcbiAqL1xuY2xhc3MgTWV0aG9kIGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzaW1wbGUgbmFtZSBvZiB0aGlzIG1ldGhvZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbmFtZSA9IDE7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBVUkwgb2YgdGhlIGlucHV0IG1lc3NhZ2UgdHlwZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgcmVxdWVzdF90eXBlX3VybCA9IDI7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlcXVlc3RUeXBlVXJsID0gXCJcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIHRoZSByZXF1ZXN0IGlzIHN0cmVhbWVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgcmVxdWVzdF9zdHJlYW1pbmcgPSAzO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXF1ZXN0U3RyZWFtaW5nID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgVVJMIG9mIHRoZSBvdXRwdXQgbWVzc2FnZSB0eXBlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyByZXNwb25zZV90eXBlX3VybCA9IDQ7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc3BvbnNlVHlwZVVybCA9IFwiXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCB0aGUgcmVzcG9uc2UgaXMgc3RyZWFtZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCByZXNwb25zZV9zdHJlYW1pbmcgPSA1O1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNwb25zZVN0cmVhbWluZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW55IG1ldGFkYXRhIGF0dGFjaGVkIHRvIHRoZSBtZXRob2QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgZ29vZ2xlLnByb3RvYnVmLk9wdGlvbiBvcHRpb25zID0gNjtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNvdXJjZSBzeW50YXggb2YgdGhpcyBtZXRob2QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZ29vZ2xlLnByb3RvYnVmLlN5bnRheCBzeW50YXggPSA3O1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zeW50YXggPSBTeW50YXguUFJPVE8yO1xuICAgICAgICBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IE1ldGhvZCgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWV0aG9kKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNZXRob2QoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLmVxdWFscyhNZXRob2QsIGEsIGIpO1xuICAgIH1cbn1cbk1ldGhvZC5ydW50aW1lID0gcHJvdG8zLyogcHJvdG8zICovLnc7XG5NZXRob2QudHlwZU5hbWUgPSBcImdvb2dsZS5wcm90b2J1Zi5NZXRob2RcIjtcbk1ldGhvZC5maWVsZHMgPSBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJuYW1lXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInJlcXVlc3RfdHlwZV91cmxcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwicmVxdWVzdF9zdHJlYW1pbmdcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcInJlc3BvbnNlX3R5cGVfdXJsXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcInJlc3BvbnNlX3N0cmVhbWluZ1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwib3B0aW9uc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogT3B0aW9uLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwic3ludGF4XCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMvKiBwcm90bzMgKi8udy5nZXRFbnVtVHlwZShTeW50YXgpIH0sXG5dKTtcbi8qKlxuICogRGVjbGFyZXMgYW4gQVBJIEludGVyZmFjZSB0byBiZSBpbmNsdWRlZCBpbiB0aGlzIGludGVyZmFjZS4gVGhlIGluY2x1ZGluZ1xuICogaW50ZXJmYWNlIG11c3QgcmVkZWNsYXJlIGFsbCB0aGUgbWV0aG9kcyBmcm9tIHRoZSBpbmNsdWRlZCBpbnRlcmZhY2UsIGJ1dFxuICogZG9jdW1lbnRhdGlvbiBhbmQgb3B0aW9ucyBhcmUgaW5oZXJpdGVkIGFzIGZvbGxvd3M6XG4gKlxuICogLSBJZiBhZnRlciBjb21tZW50IGFuZCB3aGl0ZXNwYWNlIHN0cmlwcGluZywgdGhlIGRvY3VtZW50YXRpb25cbiAqICAgc3RyaW5nIG9mIHRoZSByZWRlY2xhcmVkIG1ldGhvZCBpcyBlbXB0eSwgaXQgd2lsbCBiZSBpbmhlcml0ZWRcbiAqICAgZnJvbSB0aGUgb3JpZ2luYWwgbWV0aG9kLlxuICpcbiAqIC0gRWFjaCBhbm5vdGF0aW9uIGJlbG9uZ2luZyB0byB0aGUgc2VydmljZSBjb25maWcgKGh0dHAsXG4gKiAgIHZpc2liaWxpdHkpIHdoaWNoIGlzIG5vdCBzZXQgaW4gdGhlIHJlZGVjbGFyZWQgbWV0aG9kIHdpbGwgYmVcbiAqICAgaW5oZXJpdGVkLlxuICpcbiAqIC0gSWYgYW4gaHR0cCBhbm5vdGF0aW9uIGlzIGluaGVyaXRlZCwgdGhlIHBhdGggcGF0dGVybiB3aWxsIGJlXG4gKiAgIG1vZGlmaWVkIGFzIGZvbGxvd3MuIEFueSB2ZXJzaW9uIHByZWZpeCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZVxuICogICB2ZXJzaW9uIG9mIHRoZSBpbmNsdWRpbmcgaW50ZXJmYWNlIHBsdXMgdGhlIFtyb290XVtdIHBhdGggaWZcbiAqICAgc3BlY2lmaWVkLlxuICpcbiAqIEV4YW1wbGUgb2YgYSBzaW1wbGUgbWl4aW46XG4gKlxuICogICAgIHBhY2thZ2UgZ29vZ2xlLmFjbC52MTtcbiAqICAgICBzZXJ2aWNlIEFjY2Vzc0NvbnRyb2wge1xuICogICAgICAgLy8gR2V0IHRoZSB1bmRlcmx5aW5nIEFDTCBvYmplY3QuXG4gKiAgICAgICBycGMgR2V0QWNsKEdldEFjbFJlcXVlc3QpIHJldHVybnMgKEFjbCkge1xuICogICAgICAgICBvcHRpb24gKGdvb2dsZS5hcGkuaHR0cCkuZ2V0ID0gXCIvdjEve3Jlc291cmNlPSoqfTpnZXRBY2xcIjtcbiAqICAgICAgIH1cbiAqICAgICB9XG4gKlxuICogICAgIHBhY2thZ2UgZ29vZ2xlLnN0b3JhZ2UudjI7XG4gKiAgICAgc2VydmljZSBTdG9yYWdlIHtcbiAqICAgICAgIHJwYyBHZXRBY2woR2V0QWNsUmVxdWVzdCkgcmV0dXJucyAoQWNsKTtcbiAqXG4gKiAgICAgICAvLyBHZXQgYSBkYXRhIHJlY29yZC5cbiAqICAgICAgIHJwYyBHZXREYXRhKEdldERhdGFSZXF1ZXN0KSByZXR1cm5zIChEYXRhKSB7XG4gKiAgICAgICAgIG9wdGlvbiAoZ29vZ2xlLmFwaS5odHRwKS5nZXQgPSBcIi92Mi97cmVzb3VyY2U9Kip9XCI7XG4gKiAgICAgICB9XG4gKiAgICAgfVxuICpcbiAqIEV4YW1wbGUgb2YgYSBtaXhpbiBjb25maWd1cmF0aW9uOlxuICpcbiAqICAgICBhcGlzOlxuICogICAgIC0gbmFtZTogZ29vZ2xlLnN0b3JhZ2UudjIuU3RvcmFnZVxuICogICAgICAgbWl4aW5zOlxuICogICAgICAgLSBuYW1lOiBnb29nbGUuYWNsLnYxLkFjY2Vzc0NvbnRyb2xcbiAqXG4gKiBUaGUgbWl4aW4gY29uc3RydWN0IGltcGxpZXMgdGhhdCBhbGwgbWV0aG9kcyBpbiBgQWNjZXNzQ29udHJvbGAgYXJlXG4gKiBhbHNvIGRlY2xhcmVkIHdpdGggc2FtZSBuYW1lIGFuZCByZXF1ZXN0L3Jlc3BvbnNlIHR5cGVzIGluXG4gKiBgU3RvcmFnZWAuIEEgZG9jdW1lbnRhdGlvbiBnZW5lcmF0b3Igb3IgYW5ub3RhdGlvbiBwcm9jZXNzb3Igd2lsbFxuICogc2VlIHRoZSBlZmZlY3RpdmUgYFN0b3JhZ2UuR2V0QWNsYCBtZXRob2QgYWZ0ZXIgaW5oZXJ0aW5nXG4gKiBkb2N1bWVudGF0aW9uIGFuZCBhbm5vdGF0aW9ucyBhcyBmb2xsb3dzOlxuICpcbiAqICAgICBzZXJ2aWNlIFN0b3JhZ2Uge1xuICogICAgICAgLy8gR2V0IHRoZSB1bmRlcmx5aW5nIEFDTCBvYmplY3QuXG4gKiAgICAgICBycGMgR2V0QWNsKEdldEFjbFJlcXVlc3QpIHJldHVybnMgKEFjbCkge1xuICogICAgICAgICBvcHRpb24gKGdvb2dsZS5hcGkuaHR0cCkuZ2V0ID0gXCIvdjIve3Jlc291cmNlPSoqfTpnZXRBY2xcIjtcbiAqICAgICAgIH1cbiAqICAgICAgIC4uLlxuICogICAgIH1cbiAqXG4gKiBOb3RlIGhvdyB0aGUgdmVyc2lvbiBpbiB0aGUgcGF0aCBwYXR0ZXJuIGNoYW5nZWQgZnJvbSBgdjFgIHRvIGB2MmAuXG4gKlxuICogSWYgdGhlIGByb290YCBmaWVsZCBpbiB0aGUgbWl4aW4gaXMgc3BlY2lmaWVkLCBpdCBzaG91bGQgYmUgYVxuICogcmVsYXRpdmUgcGF0aCB1bmRlciB3aGljaCBpbmhlcml0ZWQgSFRUUCBwYXRocyBhcmUgcGxhY2VkLiBFeGFtcGxlOlxuICpcbiAqICAgICBhcGlzOlxuICogICAgIC0gbmFtZTogZ29vZ2xlLnN0b3JhZ2UudjIuU3RvcmFnZVxuICogICAgICAgbWl4aW5zOlxuICogICAgICAgLSBuYW1lOiBnb29nbGUuYWNsLnYxLkFjY2Vzc0NvbnRyb2xcbiAqICAgICAgICAgcm9vdDogYWNsc1xuICpcbiAqIFRoaXMgaW1wbGllcyB0aGUgZm9sbG93aW5nIGluaGVyaXRlZCBIVFRQIGFubm90YXRpb246XG4gKlxuICogICAgIHNlcnZpY2UgU3RvcmFnZSB7XG4gKiAgICAgICAvLyBHZXQgdGhlIHVuZGVybHlpbmcgQUNMIG9iamVjdC5cbiAqICAgICAgIHJwYyBHZXRBY2woR2V0QWNsUmVxdWVzdCkgcmV0dXJucyAoQWNsKSB7XG4gKiAgICAgICAgIG9wdGlvbiAoZ29vZ2xlLmFwaS5odHRwKS5nZXQgPSBcIi92Mi9hY2xzL3tyZXNvdXJjZT0qKn06Z2V0QWNsXCI7XG4gKiAgICAgICB9XG4gKiAgICAgICAuLi5cbiAqICAgICB9XG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLk1peGluXG4gKi9cbmNsYXNzIE1peGluIGV4dGVuZHMgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmdWxseSBxdWFsaWZpZWQgbmFtZSBvZiB0aGUgaW50ZXJmYWNlIHdoaWNoIGlzIGluY2x1ZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBuYW1lID0gMTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9IFwiXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBub24tZW1wdHkgc3BlY2lmaWVzIGEgcGF0aCB1bmRlciB3aGljaCBpbmhlcml0ZWQgSFRUUCBwYXRoc1xuICAgICAgICAgKiBhcmUgcm9vdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyByb290ID0gMjtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucm9vdCA9IFwiXCI7XG4gICAgICAgIHByb3RvMy8qIHByb3RvMyAqLy53LnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWl4aW4oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IE1peGluKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNaXhpbigpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvMy8qIHByb3RvMyAqLy53LnV0aWwuZXF1YWxzKE1peGluLCBhLCBiKTtcbiAgICB9XG59XG5NaXhpbi5ydW50aW1lID0gcHJvdG8zLyogcHJvdG8zICovLnc7XG5NaXhpbi50eXBlTmFtZSA9IFwiZ29vZ2xlLnByb3RvYnVmLk1peGluXCI7XG5NaXhpbi5maWVsZHMgPSBwcm90bzMvKiBwcm90bzMgKi8udy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJuYW1lXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInJvb3RcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuXSk7XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vaW5kZXguanNcbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vLyBpZGVhbGx5LCB3ZSB3b3VsZCBleHBvcnQgdGhlc2UgdHlwZXMgd2l0aCBzdWItcGF0aCBleHBvcnRzOlxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NjE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHY6ICgpID0+ICgvKiBiaW5kaW5nICovIE1lc3NhZ2UpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIE1lc3NhZ2UgaXMgdGhlIGJhc2UgY2xhc3Mgb2YgZXZlcnkgbWVzc2FnZSwgZ2VuZXJhdGVkLCBvciBjcmVhdGVkIGF0XG4gKiBydW50aW1lLlxuICpcbiAqIEl0IGlzIF9ub3RfIHNhZmUgdG8gZXh0ZW5kIHRoaXMgY2xhc3MuIElmIHlvdSB3YW50IHRvIGNyZWF0ZSBhIG1lc3NhZ2UgYXRcbiAqIHJ1biB0aW1lLCB1c2UgcHJvdG8zLm1ha2VNZXNzYWdlVHlwZSgpLlxuICovXG5jbGFzcyBNZXNzYWdlIHtcbiAgICAvKipcbiAgICAgKiBDb21wYXJlIHdpdGggYSBtZXNzYWdlIG9mIHRoZSBzYW1lIHR5cGUuXG4gICAgICovXG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoKS5ydW50aW1lLnV0aWwuZXF1YWxzKHRoaXMuZ2V0VHlwZSgpLCB0aGlzLCBvdGhlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGRlZXAgY29weS5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZSgpLnJ1bnRpbWUudXRpbC5jbG9uZSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgZnJvbSBiaW5hcnkgZGF0YSwgbWVyZ2luZyBmaWVsZHMuXG4gICAgICpcbiAgICAgKiBSZXBlYXRlZCBmaWVsZHMgYXJlIGFwcGVuZGVkLiBNYXAgZW50cmllcyBhcmUgYWRkZWQsIG92ZXJ3cml0aW5nXG4gICAgICogZXhpc3Rpbmcga2V5cy5cbiAgICAgKlxuICAgICAqIElmIGEgbWVzc2FnZSBmaWVsZCBpcyBhbHJlYWR5IHByZXNlbnQsIGl0IHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlXG4gICAgICogbmV3IGRhdGEuXG4gICAgICovXG4gICAgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKCksIGZvcm1hdCA9IHR5cGUucnVudGltZS5iaW4sIG9wdCA9IGZvcm1hdC5tYWtlUmVhZE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGZvcm1hdC5yZWFkTWVzc2FnZSh0aGlzLCBvcHQucmVhZGVyRmFjdG9yeShieXRlcyksIGJ5dGVzLmJ5dGVMZW5ndGgsIG9wdCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBhIG1lc3NhZ2UgZnJvbSBhIEpTT04gdmFsdWUuXG4gICAgICovXG4gICAgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoKSwgZm9ybWF0ID0gdHlwZS5ydW50aW1lLmpzb24sIG9wdCA9IGZvcm1hdC5tYWtlUmVhZE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGZvcm1hdC5yZWFkTWVzc2FnZSh0eXBlLCBqc29uVmFsdWUsIG9wdCwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBhIG1lc3NhZ2UgZnJvbSBhIEpTT04gc3RyaW5nLlxuICAgICAqL1xuICAgIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGpzb247XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBqc29uID0gSlNPTi5wYXJzZShqc29uU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjb2RlICR7dGhpcy5nZXRUeXBlKCkudHlwZU5hbWV9IGZyb20gSlNPTjogJHtlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiBTdHJpbmcoZSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUpzb24oanNvbiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGUgbWVzc2FnZSB0byBiaW5hcnkgZGF0YS5cbiAgICAgKi9cbiAgICB0b0JpbmFyeShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoKSwgYmluID0gdHlwZS5ydW50aW1lLmJpbiwgb3B0ID0gYmluLm1ha2VXcml0ZU9wdGlvbnMob3B0aW9ucyksIHdyaXRlciA9IG9wdC53cml0ZXJGYWN0b3J5KCk7XG4gICAgICAgIGJpbi53cml0ZU1lc3NhZ2UodGhpcywgd3JpdGVyLCBvcHQpO1xuICAgICAgICByZXR1cm4gd3JpdGVyLmZpbmlzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhlIG1lc3NhZ2UgdG8gYSBKU09OIHZhbHVlLCBhIEphdmFTY3JpcHQgdmFsdWUgdGhhdCBjYW4gYmVcbiAgICAgKiBwYXNzZWQgdG8gSlNPTi5zdHJpbmdpZnkoKS5cbiAgICAgKi9cbiAgICB0b0pzb24ob3B0aW9ucykge1xuICAgICAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKCksIGpzb24gPSB0eXBlLnJ1bnRpbWUuanNvbiwgb3B0ID0ganNvbi5tYWtlV3JpdGVPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4ganNvbi53cml0ZU1lc3NhZ2UodGhpcywgb3B0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoZSBtZXNzYWdlIHRvIGEgSlNPTiBzdHJpbmcuXG4gICAgICovXG4gICAgdG9Kc29uU3RyaW5nKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudG9Kc29uKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIG51bGwsIChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmV0dHlTcGFjZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBmb3Igc2VyaWFsaXphdGlvbiBiZWhhdmlvci4gVGhpcyB3aWxsIGJlIGludm9rZWQgd2hlbiBjYWxsaW5nXG4gICAgICogSlNPTi5zdHJpbmdpZnkgb24gdGhpcyBtZXNzYWdlIChpLmUuIEpTT04uc3RyaW5naWZ5KG1zZykpLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgd2lsbCBub3Qgc2VyaWFsaXplIGdvb2dsZS5wcm90b2J1Zi5Bbnkgd2l0aCBhIHBhY2tlZFxuICAgICAqIG1lc3NhZ2UgYmVjYXVzZSB0aGUgcHJvdG9idWYgSlNPTiBmb3JtYXQgc3BlY2lmaWVzIHRoYXQgaXQgbmVlZHMgdG8gYmVcbiAgICAgKiB1bnBhY2tlZCwgYW5kIHRoaXMgaXMgb25seSBwb3NzaWJsZSB3aXRoIGEgdHlwZSByZWdpc3RyeSB0byBsb29rIHVwIHRoZVxuICAgICAqIG1lc3NhZ2UgdHlwZS4gIEFzIGEgcmVzdWx0LCBhdHRlbXB0aW5nIHRvIHNlcmlhbGl6ZSBhIG1lc3NhZ2Ugd2l0aCB0aGlzXG4gICAgICogdHlwZSB3aWxsIHRocm93IGFuIEVycm9yLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgcHJvdGVjdGVkIGJlY2F1c2UgeW91IHNob3VsZCBub3QgbmVlZCB0byBpbnZva2UgaXRcbiAgICAgKiBkaXJlY3RseSAtLSBpbnN0ZWFkIHVzZSBKU09OLnN0cmluZ2lmeSBvciB0b0pzb25TdHJpbmcgZm9yXG4gICAgICogc3RyaW5naWZpZWQgSlNPTi4gIEFsdGVybmF0aXZlbHksIGlmIGFjdHVhbCBKU09OIGlzIGRlc2lyZWQsIHlvdSBzaG91bGRcbiAgICAgKiB1c2UgdG9Kc29uLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9Kc29uKHtcbiAgICAgICAgICAgIGVtaXREZWZhdWx0VmFsdWVzOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIE1lc3NhZ2VUeXBlIG9mIHRoaXMgbWVzc2FnZSAtIGEgc2luZ2xldG9uIHRoYXQgcmVwcmVzZW50c1xuICAgICAqIHRoZSBwcm90b2J1ZiBtZXNzYWdlIGRlY2xhcmF0aW9uIGFuZCBwcm92aWRlcyBtZXRhZGF0YSBmb3IgcmVmbGVjdGlvbi1cbiAgICAgKiBiYXNlZCBvcGVyYXRpb25zLlxuICAgICAqL1xuICAgIGdldFR5cGUoKSB7XG4gICAgICAgIC8vIEFueSBjbGFzcyB0aGF0IGV4dGVuZHMgTWVzc2FnZSBfbXVzdF8gcHJvdmlkZSBhIGNvbXBsZXRlIHN0YXRpY1xuICAgICAgICAvLyBpbXBsZW1lbnRhdGlvbiBvZiBNZXNzYWdlVHlwZS5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTIwOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBFXzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gYXNzZXJ0RmxvYXQzMiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGZwOiAoKSA9PiAoLyogYmluZGluZyAqLyBhc3NlcnRVSW50MzIpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBodTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gYXNzZXJ0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgdWc6ICgpID0+ICgvKiBiaW5kaW5nICovIGFzc2VydEludDMyKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBBc3NlcnQgdGhhdCBjb25kaXRpb24gaXMgdHJ1dGh5IG9yIHRocm93IGVycm9yICh3aXRoIG1lc3NhZ2UpXG4gKi9cbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1zZykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnMgLS0gd2Ugd2FudCB0aGUgaW1wbGljaXQgY29udmVyc2lvbiB0byBib29sZWFuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufVxuY29uc3QgRkxPQVQzMl9NQVggPSAzLjQwMjgyMzQ2NjM4NTI4ODZlMzgsIEZMT0FUMzJfTUlOID0gLTMuNDAyODIzNDY2Mzg1Mjg4NmUzOCwgVUlOVDMyX01BWCA9IDB4ZmZmZmZmZmYsIElOVDMyX01BWCA9IDB4N2ZmZmZmZmYsIElOVDMyX01JTiA9IC0weDgwMDAwMDAwO1xuLyoqXG4gKiBBc3NlcnQgYSB2YWxpZCBzaWduZWQgcHJvdG9idWYgMzItYml0IGludGVnZXIuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydEludDMyKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSBcIm51bWJlclwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGludCAzMjogXCIgKyB0eXBlb2YgYXJnKTtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoYXJnKSB8fCBhcmcgPiBJTlQzMl9NQVggfHwgYXJnIDwgSU5UMzJfTUlOKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGludCAzMjogXCIgKyBhcmcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzIC0tIHdlIHdhbnQgdGhlIGltcGxpY2l0IGNvbnZlcnNpb24gdG8gc3RyaW5nXG59XG4vKipcbiAqIEFzc2VydCBhIHZhbGlkIHVuc2lnbmVkIHByb3RvYnVmIDMyLWJpdCBpbnRlZ2VyLlxuICovXG5mdW5jdGlvbiBhc3NlcnRVSW50MzIoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdWludCAzMjogXCIgKyB0eXBlb2YgYXJnKTtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoYXJnKSB8fCBhcmcgPiBVSU5UMzJfTUFYIHx8IGFyZyA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdWludCAzMjogXCIgKyBhcmcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzIC0tIHdlIHdhbnQgdGhlIGltcGxpY2l0IGNvbnZlcnNpb24gdG8gc3RyaW5nXG59XG4vKipcbiAqIEFzc2VydCBhIHZhbGlkIHByb3RvYnVmIGZsb2F0IHZhbHVlLlxuICovXG5mdW5jdGlvbiBhc3NlcnRGbG9hdDMyKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSBcIm51bWJlclwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZsb2F0IDMyOiBcIiArIHR5cGVvZiBhcmcpO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGFyZykpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoYXJnID4gRkxPQVQzMl9NQVggfHwgYXJnIDwgRkxPQVQzMl9NSU4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZmxvYXQgMzI6IFwiICsgYXJnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyAtLSB3ZSB3YW50IHRoZSBpbXBsaWNpdCBjb252ZXJzaW9uIHRvIHN0cmluZ1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NDQ6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEpqOiAoKSA9PiAoLyogYmluZGluZyAqLyB3cml0ZVBhY2tlZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIE5OOiAoKSA9PiAoLyogYmluZGluZyAqLyB3cml0ZVNjYWxhciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGdROiAoKSA9PiAoLyogYmluZGluZyAqLyB3cml0ZU1hcEVudHJ5KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgZ1k6ICgpID0+ICgvKiBiaW5kaW5nICovIG1ha2VCaW5hcnlGb3JtYXRDb21tb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBvUTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gd3JpdGVNZXNzYWdlRmllbGQpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCByZWFkU2NhbGFyTFRTdHJpbmcgKi9cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmluYXJ5X2VuY29kaW5nX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc5KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWVzc2FnZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NjEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NjUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9maWVsZF93cmFwcGVyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NjYWxhcnNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNzgxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYXNzZXJ0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMCk7XG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5cblxuXG5cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm4sIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcywgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGwsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb24sIG5vLWNhc2UtZGVjbGFyYXRpb25zLCBwcmVmZXItY29uc3QgKi9cbmNvbnN0IHVua25vd25GaWVsZHNTeW1ib2wgPSBTeW1ib2woXCJAYnVmYnVpbGQvcHJvdG9idWYvdW5rbm93bi1maWVsZHNcIik7XG4vLyBEZWZhdWx0IG9wdGlvbnMgZm9yIHBhcnNpbmcgYmluYXJ5IGRhdGEuXG5jb25zdCByZWFkRGVmYXVsdHMgPSB7XG4gICAgcmVhZFVua25vd25GaWVsZHM6IHRydWUsXG4gICAgcmVhZGVyRmFjdG9yeTogKGJ5dGVzKSA9PiBuZXcgX2JpbmFyeV9lbmNvZGluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLkJpbmFyeVJlYWRlciAqLyAub1AoYnl0ZXMpLFxufTtcbi8vIERlZmF1bHQgb3B0aW9ucyBmb3Igc2VyaWFsaXppbmcgYmluYXJ5IGRhdGEuXG5jb25zdCB3cml0ZURlZmF1bHRzID0ge1xuICAgIHdyaXRlVW5rbm93bkZpZWxkczogdHJ1ZSxcbiAgICB3cml0ZXJGYWN0b3J5OiAoKSA9PiBuZXcgX2JpbmFyeV9lbmNvZGluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLkJpbmFyeVdyaXRlciAqLyAuTHQoKSxcbn07XG5mdW5jdGlvbiBtYWtlUmVhZE9wdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZWFkRGVmYXVsdHMpLCBvcHRpb25zKSA6IHJlYWREZWZhdWx0cztcbn1cbmZ1bmN0aW9uIG1ha2VXcml0ZU9wdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB3cml0ZURlZmF1bHRzKSwgb3B0aW9ucykgOiB3cml0ZURlZmF1bHRzO1xufVxuZnVuY3Rpb24gbWFrZUJpbmFyeUZvcm1hdENvbW1vbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBtYWtlUmVhZE9wdGlvbnMsXG4gICAgICAgIG1ha2VXcml0ZU9wdGlvbnMsXG4gICAgICAgIGxpc3RVbmtub3duRmllbGRzKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSBtZXNzYWdlW3Vua25vd25GaWVsZHNTeW1ib2xdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgZGlzY2FyZFVua25vd25GaWVsZHMobWVzc2FnZSkge1xuICAgICAgICAgICAgZGVsZXRlIG1lc3NhZ2VbdW5rbm93bkZpZWxkc1N5bWJvbF07XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRlVW5rbm93bkZpZWxkcyhtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBtZXNzYWdlO1xuICAgICAgICAgICAgY29uc3QgYyA9IG1bdW5rbm93bkZpZWxkc1N5bWJvbF07XG4gICAgICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZiBvZiBjKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci50YWcoZi5ubywgZi53aXJlVHlwZSkucmF3KGYuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblVua25vd25GaWVsZChtZXNzYWdlLCBubywgd2lyZVR5cGUsIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBtZXNzYWdlO1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1bdW5rbm93bkZpZWxkc1N5bWJvbF0pKSB7XG4gICAgICAgICAgICAgICAgbVt1bmtub3duRmllbGRzU3ltYm9sXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbVt1bmtub3duRmllbGRzU3ltYm9sXS5wdXNoKHsgbm8sIHdpcmVUeXBlLCBkYXRhIH0pO1xuICAgICAgICB9LFxuICAgICAgICByZWFkTWVzc2FnZShtZXNzYWdlLCByZWFkZXIsIGxlbmd0aE9yRW5kVGFnRmllbGRObywgb3B0aW9ucywgZGVsaW1pdGVkTWVzc2FnZUVuY29kaW5nKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5nZXRUeXBlKCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgICAgICAgICBjb25zdCBlbmQgPSBkZWxpbWl0ZWRNZXNzYWdlRW5jb2RpbmdcbiAgICAgICAgICAgICAgICA/IHJlYWRlci5sZW5cbiAgICAgICAgICAgICAgICA6IHJlYWRlci5wb3MgKyBsZW5ndGhPckVuZFRhZ0ZpZWxkTm87XG4gICAgICAgICAgICBsZXQgZmllbGRObywgd2lyZVR5cGU7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICAgICAgaWYgKHdpcmVUeXBlID09IF9iaW5hcnlfZW5jb2RpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5XaXJlVHlwZSAqLyAuVEQuRW5kR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gdHlwZS5maWVsZHMuZmluZChmaWVsZE5vKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnJlYWRVbmtub3duRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uVW5rbm93bkZpZWxkKG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldCA9IG1lc3NhZ2UsIHJlcGVhdGVkID0gZmllbGQucmVwZWF0ZWQsIGxvY2FsTmFtZSA9IGZpZWxkLmxvY2FsTmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQub25lb2YpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0W2ZpZWxkLm9uZW9mLmxvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuY2FzZSAhPSBsb2NhbE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmNhc2UgPSBsb2NhbE5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsTmFtZSA9IFwidmFsdWVcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxhclR5cGUgPSBmaWVsZC5raW5kID09IFwiZW51bVwiID8gX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18vKiAuU2NhbGFyVHlwZSAqLyAudy5JTlQzMiA6IGZpZWxkLlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVhZCA9IHJlYWRTY2FsYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb24gLS0gYWNjZXB0YWJsZSBzaW5jZSBpdCdzIGNvdmVyZWQgYnkgdGVzdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5raW5kID09IFwic2NhbGFyXCIgJiYgZmllbGQuTCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkID0gcmVhZFNjYWxhckxUU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFyciA9IHRhcmdldFtsb2NhbE5hbWVdOyAvLyBzYWZlIHRvIGFzc3VtZSBwcmVzZW5jZSBvZiBhcnJheSwgb25lb2YgY2Fubm90IGNvbnRhaW4gcmVwZWF0ZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpcmVUeXBlID09IF9iaW5hcnlfZW5jb2RpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5XaXJlVHlwZSAqLyAuVEQuTGVuZ3RoRGVsaW1pdGVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxhclR5cGUgIT0gX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18vKiAuU2NhbGFyVHlwZSAqLyAudy5TVFJJTkcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGFyVHlwZSAhPSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5TY2FsYXJUeXBlICovIC53LkJZVEVTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChyZWFkKHJlYWRlciwgc2NhbGFyVHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChyZWFkKHJlYWRlciwgc2NhbGFyVHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gcmVhZChyZWFkZXIsIHNjYWxhclR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlVHlwZSA9IGZpZWxkLlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzYWZlIHRvIGFzc3VtZSBwcmVzZW5jZSBvZiBhcnJheSwgb25lb2YgY2Fubm90IGNvbnRhaW4gcmVwZWF0ZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0ucHVzaChyZWFkTWVzc2FnZUZpZWxkKHJlYWRlciwgbmV3IG1lc3NhZ2VUeXBlKCksIG9wdGlvbnMsIGZpZWxkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0W2xvY2FsTmFtZV0gaW5zdGFuY2VvZiBfbWVzc2FnZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLyogLk1lc3NhZ2UgKi8gLnYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIHRhcmdldFtsb2NhbE5hbWVdLCBvcHRpb25zLCBmaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHJlYWRNZXNzYWdlRmllbGQocmVhZGVyLCBuZXcgbWVzc2FnZVR5cGUoKSwgb3B0aW9ucywgZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZmllbGQub25lb2YgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFmaWVsZC5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBtZXNzYWdlVHlwZS5maWVsZFdyYXBwZXIudW53cmFwRmllbGQodGFyZ2V0W2xvY2FsTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBbbWFwS2V5LCBtYXBWYWxdID0gcmVhZE1hcEVudHJ5KGZpZWxkLCByZWFkZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2FmZSB0byBhc3N1bWUgcHJlc2VuY2Ugb2YgbWFwIG9iamVjdCwgb25lb2YgY2Fubm90IGNvbnRhaW4gcmVwZWF0ZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXVttYXBLZXldID0gbWFwVmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlbGltaXRlZE1lc3NhZ2VFbmNvZGluZyAmJiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICAgICAgICAgICAgICAgICh3aXJlVHlwZSAhPSBfYmluYXJ5X2VuY29kaW5nX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAuV2lyZVR5cGUgKi8gLlRELkVuZEdyb3VwIHx8IGZpZWxkTm8gIT09IGxlbmd0aE9yRW5kVGFnRmllbGRObykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZW5kIGdyb3VwIHRhZ2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59XG4vLyBSZWFkIGEgbWVzc2FnZSwgYXZvaWRpbmcgTWVzc2FnZVR5cGUuZnJvbUJpbmFyeSgpIHRvIHJlLXVzZSB0aGVcbi8vIEJpbmFyeVJlYWRPcHRpb25zIGFuZCB0aGUgSUJpbmFyeVJlYWRlci5cbmZ1bmN0aW9uIHJlYWRNZXNzYWdlRmllbGQocmVhZGVyLCBtZXNzYWdlLCBvcHRpb25zLCBmaWVsZCkge1xuICAgIGNvbnN0IGZvcm1hdCA9IG1lc3NhZ2UuZ2V0VHlwZSgpLnJ1bnRpbWUuYmluO1xuICAgIGNvbnN0IGRlbGltaXRlZCA9IGZpZWxkID09PSBudWxsIHx8IGZpZWxkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWVsZC5kZWxpbWl0ZWQ7XG4gICAgZm9ybWF0LnJlYWRNZXNzYWdlKG1lc3NhZ2UsIHJlYWRlciwgZGVsaW1pdGVkID8gZmllbGQgPT09IG51bGwgfHwgZmllbGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpZWxkLm5vIDogcmVhZGVyLnVpbnQzMigpLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICAgIG9wdGlvbnMsIGRlbGltaXRlZCk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG59XG4vLyBSZWFkIGEgbWFwIGZpZWxkLCBleHBlY3Rpbmcga2V5IGZpZWxkID0gMSwgdmFsdWUgZmllbGQgPSAyXG5mdW5jdGlvbiByZWFkTWFwRW50cnkoZmllbGQsIHJlYWRlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGxlbmd0aCA9IHJlYWRlci51aW50MzIoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICBsZXQga2V5LCB2YWw7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgbGV0IFtmaWVsZE5vXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAga2V5ID0gcmVhZFNjYWxhcihyZWFkZXIsIGZpZWxkLkspO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHJlYWRTY2FsYXIocmVhZGVyLCBmaWVsZC5WLlQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIG5ldyBmaWVsZC5WLlQoKSwgb3B0aW9ucywgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IGtleVJhdyA9ICgwLF9zY2FsYXJzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18vKiAuc2NhbGFyRGVmYXVsdFZhbHVlICovIC5rWSkoZmllbGQuSywgX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18vKiAuTG9uZ1R5cGUgKi8gLnAuQklHSU5UKTtcbiAgICAgICAga2V5ID1cbiAgICAgICAgICAgIGZpZWxkLksgPT0gX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18vKiAuU2NhbGFyVHlwZSAqLyAudy5CT09MXG4gICAgICAgICAgICAgICAgPyBrZXlSYXcudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgIDoga2V5UmF3O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGtleSAhPSBcInN0cmluZ1wiICYmIHR5cGVvZiBrZXkgIT0gXCJudW1iZXJcIikge1xuICAgICAgICBrZXkgPSBrZXkudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XG4gICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgdmFsID0gKDAsX3NjYWxhcnNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy8qIC5zY2FsYXJEZWZhdWx0VmFsdWUgKi8gLmtZKShmaWVsZC5WLlQsIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLkxvbmdUeXBlICovIC5wLkJJR0lOVCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIHZhbCA9IG5ldyBmaWVsZC5WLlQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2tleSwgdmFsXTtcbn1cbi8vIFJlYWQgYSBzY2FsYXIgdmFsdWUsIGJ1dCByZXR1cm4gNjQgYml0IGludGVncmFsIHR5cGVzIChpbnQ2NCwgdWludDY0LFxuLy8gc2ludDY0LCBmaXhlZDY0LCBzZml4ZWQ2NCkgYXMgc3RyaW5nIGluc3RlYWQgb2YgYmlnaW50LlxuZnVuY3Rpb24gcmVhZFNjYWxhckxUU3RyaW5nKHJlYWRlciwgdHlwZSkge1xuICAgIGNvbnN0IHYgPSByZWFkU2NhbGFyKHJlYWRlciwgdHlwZSk7XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09IFwiYmlnaW50XCIgPyB2LnRvU3RyaW5nKCkgOiB2O1xufVxuLy8gRG9lcyBub3QgdXNlIHNjYWxhclR5cGVJbmZvKCkgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5cbmZ1bmN0aW9uIHJlYWRTY2FsYXIocmVhZGVyLCB0eXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18vKiAuU2NhbGFyVHlwZSAqLyAudy5TVFJJTkc6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICBjYXNlIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLlNjYWxhclR5cGUgKi8gLncuQk9PTDpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIuYm9vbCgpO1xuICAgICAgICBjYXNlIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLlNjYWxhclR5cGUgKi8gLncuRE9VQkxFOlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5kb3VibGUoKTtcbiAgICAgICAgY2FzZSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5TY2FsYXJUeXBlICovIC53LkZMT0FUOlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5mbG9hdCgpO1xuICAgICAgICBjYXNlIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLlNjYWxhclR5cGUgKi8gLncuSU5UMzI6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLmludDMyKCk7XG4gICAgICAgIGNhc2UgX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18vKiAuU2NhbGFyVHlwZSAqLyAudy5JTlQ2NDpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIuaW50NjQoKTtcbiAgICAgICAgY2FzZSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5TY2FsYXJUeXBlICovIC53LlVJTlQ2NDpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIudWludDY0KCk7XG4gICAgICAgIGNhc2UgX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18vKiAuU2NhbGFyVHlwZSAqLyAudy5GSVhFRDY0OlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5maXhlZDY0KCk7XG4gICAgICAgIGNhc2UgX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18vKiAuU2NhbGFyVHlwZSAqLyAudy5CWVRFUzpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgY2FzZSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5TY2FsYXJUeXBlICovIC53LkZJWEVEMzI6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLmZpeGVkMzIoKTtcbiAgICAgICAgY2FzZSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5TY2FsYXJUeXBlICovIC53LlNGSVhFRDMyOlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5zZml4ZWQzMigpO1xuICAgICAgICBjYXNlIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLlNjYWxhclR5cGUgKi8gLncuU0ZJWEVENjQ6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLnNmaXhlZDY0KCk7XG4gICAgICAgIGNhc2UgX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18vKiAuU2NhbGFyVHlwZSAqLyAudy5TSU5UNjQ6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLnNpbnQ2NCgpO1xuICAgICAgICBjYXNlIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLlNjYWxhclR5cGUgKi8gLncuVUlOVDMyOlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgY2FzZSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5TY2FsYXJUeXBlICovIC53LlNJTlQzMjpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIuc2ludDMyKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gd3JpdGVNYXBFbnRyeSh3cml0ZXIsIG9wdGlvbnMsIGZpZWxkLCBrZXksIHZhbHVlKSB7XG4gICAgd3JpdGVyLnRhZyhmaWVsZC5ubywgX2JpbmFyeV9lbmNvZGluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLldpcmVUeXBlICovIC5URC5MZW5ndGhEZWxpbWl0ZWQpO1xuICAgIHdyaXRlci5mb3JrKCk7XG4gICAgLy8gamF2YXNjcmlwdCBvbmx5IGFsbG93cyBudW1iZXIgb3Igc3RyaW5nIGZvciBvYmplY3QgcHJvcGVydGllc1xuICAgIC8vIHdlIGNvbnZlcnQgZnJvbSBvdXIgcmVwcmVzZW50YXRpb24gdG8gdGhlIHByb3RvYnVmIHR5cGVcbiAgICBsZXQga2V5VmFsdWUgPSBrZXk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2sgLS0gd2UgZGVsaWJlcmF0ZWx5IGhhbmRsZSBqdXN0IHRoZSBzcGVjaWFsIGNhc2VzIGZvciBtYXAga2V5c1xuICAgIHN3aXRjaCAoZmllbGQuSykge1xuICAgICAgICBjYXNlIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLlNjYWxhclR5cGUgKi8gLncuSU5UMzI6XG4gICAgICAgIGNhc2UgX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18vKiAuU2NhbGFyVHlwZSAqLyAudy5GSVhFRDMyOlxuICAgICAgICBjYXNlIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLlNjYWxhclR5cGUgKi8gLncuVUlOVDMyOlxuICAgICAgICBjYXNlIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLlNjYWxhclR5cGUgKi8gLncuU0ZJWEVEMzI6XG4gICAgICAgIGNhc2UgX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18vKiAuU2NhbGFyVHlwZSAqLyAudy5TSU5UMzI6XG4gICAgICAgICAgICBrZXlWYWx1ZSA9IE51bWJlci5wYXJzZUludChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18vKiAuU2NhbGFyVHlwZSAqLyAudy5CT09MOlxuICAgICAgICAgICAgKDAsX2Fzc2VydF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLyogLmFzc2VydCAqLyAuaHUpKGtleSA9PSBcInRydWVcIiB8fCBrZXkgPT0gXCJmYWxzZVwiKTtcbiAgICAgICAgICAgIGtleVZhbHVlID0ga2V5ID09IFwidHJ1ZVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIHdyaXRlIGtleSwgZXhwZWN0aW5nIGtleSBmaWVsZCBudW1iZXIgPSAxXG4gICAgd3JpdGVTY2FsYXIod3JpdGVyLCBmaWVsZC5LLCAxLCBrZXlWYWx1ZSwgdHJ1ZSk7XG4gICAgLy8gd3JpdGUgdmFsdWUsIGV4cGVjdGluZyB2YWx1ZSBmaWVsZCBudW1iZXIgPSAyXG4gICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgd3JpdGVTY2FsYXIod3JpdGVyLCBmaWVsZC5WLlQsIDIsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgd3JpdGVTY2FsYXIod3JpdGVyLCBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5TY2FsYXJUeXBlICovIC53LklOVDMyLCAyLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgX2JpbmFyeV9lbmNvZGluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLldpcmVUeXBlICovIC5URC5MZW5ndGhEZWxpbWl0ZWQpLmJ5dGVzKHZhbHVlLnRvQmluYXJ5KG9wdGlvbnMpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB3cml0ZXIuam9pbigpO1xufVxuZnVuY3Rpb24gd3JpdGVNZXNzYWdlRmllbGQod3JpdGVyLCBvcHRpb25zLCBmaWVsZCwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gKDAsX2ZpZWxkX3dyYXBwZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy8qIC53cmFwRmllbGQgKi8gLkUpKGZpZWxkLlQsIHZhbHVlKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICAgICAgICBpZiAoZmllbGQgPT09IG51bGwgfHwgZmllbGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpZWxkLmRlbGltaXRlZClcbiAgICAgICAgICAgIHdyaXRlclxuICAgICAgICAgICAgICAgIC50YWcoZmllbGQubm8sIF9iaW5hcnlfZW5jb2RpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5XaXJlVHlwZSAqLyAuVEQuU3RhcnRHcm91cClcbiAgICAgICAgICAgICAgICAucmF3KG1lc3NhZ2UudG9CaW5hcnkob3B0aW9ucykpXG4gICAgICAgICAgICAgICAgLnRhZyhmaWVsZC5ubywgX2JpbmFyeV9lbmNvZGluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLldpcmVUeXBlICovIC5URC5FbmRHcm91cCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHdyaXRlclxuICAgICAgICAgICAgICAgIC50YWcoZmllbGQubm8sIF9iaW5hcnlfZW5jb2RpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5XaXJlVHlwZSAqLyAuVEQuTGVuZ3RoRGVsaW1pdGVkKVxuICAgICAgICAgICAgICAgIC5ieXRlcyhtZXNzYWdlLnRvQmluYXJ5KG9wdGlvbnMpKTtcbiAgICB9XG59XG5mdW5jdGlvbiB3cml0ZVNjYWxhcih3cml0ZXIsIHR5cGUsIGZpZWxkTm8sIHZhbHVlLCBlbWl0SW50cmluc2ljRGVmYXVsdCkge1xuICAgIGxldCBbd2lyZVR5cGUsIG1ldGhvZCwgaXNJbnRyaW5zaWNEZWZhdWx0XSA9ICgwLF9zY2FsYXJzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18vKiAuc2NhbGFyVHlwZUluZm8gKi8gLlQxKSh0eXBlLCB2YWx1ZSk7XG4gICAgaWYgKCFpc0ludHJpbnNpY0RlZmF1bHQgfHwgZW1pdEludHJpbnNpY0RlZmF1bHQpIHtcbiAgICAgICAgd3JpdGVyLnRhZyhmaWVsZE5vLCB3aXJlVHlwZSlbbWV0aG9kXSh2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gd3JpdGVQYWNrZWQod3JpdGVyLCB0eXBlLCBmaWVsZE5vLCB2YWx1ZSkge1xuICAgIGlmICghdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd3JpdGVyLnRhZyhmaWVsZE5vLCBfYmluYXJ5X2VuY29kaW5nX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAuV2lyZVR5cGUgKi8gLlRELkxlbmd0aERlbGltaXRlZCkuZm9yaygpO1xuICAgIGxldCBbLCBtZXRob2RdID0gKDAsX3NjYWxhcnNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy8qIC5zY2FsYXJUeXBlSW5mbyAqLyAuVDEpKHR5cGUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd3JpdGVyW21ldGhvZF0odmFsdWVbaV0pO1xuICAgIH1cbiAgICB3cml0ZXIuam9pbigpO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2MDk6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFYzOiAoKSA9PiAoLyogYmluZGluZyAqLyBnZXRFbnVtVHlwZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGJlOiAoKSA9PiAoLyogYmluZGluZyAqLyBtYWtlRW51bVR5cGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICB1dDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gbWFrZUVudW0pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICB6ZzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gc2V0RW51bVR5cGUpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYXNzZXJ0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMCk7XG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5jb25zdCBlbnVtVHlwZVN5bWJvbCA9IFN5bWJvbChcIkBidWZidWlsZC9wcm90b2J1Zi9lbnVtLXR5cGVcIik7XG4vKipcbiAqIEdldCByZWZsZWN0aW9uIGluZm9ybWF0aW9uIGZyb20gYSBnZW5lcmF0ZWQgZW51bS5cbiAqIElmIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIHNvbWV0aGluZyBvdGhlciB0aGFuIGEgZ2VuZXJhdGVkXG4gKiBlbnVtLCBpdCByYWlzZXMgYW4gZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIGdldEVudW1UeXBlKGVudW1PYmplY3QpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY29uc3QgdCA9IGVudW1PYmplY3RbZW51bVR5cGVTeW1ib2xdO1xuICAgICgwLF9hc3NlcnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5hc3NlcnQgKi8gLmh1KSh0LCBcIm1pc3NpbmcgZW51bSB0eXBlIG9uIGVudW0gb2JqZWN0XCIpO1xuICAgIHJldHVybiB0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG59XG4vKipcbiAqIFNldHMgcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiBvbiBhIGdlbmVyYXRlZCBlbnVtLlxuICovXG5mdW5jdGlvbiBzZXRFbnVtVHlwZShlbnVtT2JqZWN0LCB0eXBlTmFtZSwgdmFsdWVzLCBvcHQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZW51bU9iamVjdFtlbnVtVHlwZVN5bWJvbF0gPSBtYWtlRW51bVR5cGUodHlwZU5hbWUsIHZhbHVlcy5tYXAoKHYpID0+ICh7XG4gICAgICAgIG5vOiB2Lm5vLFxuICAgICAgICBuYW1lOiB2Lm5hbWUsXG4gICAgICAgIGxvY2FsTmFtZTogZW51bU9iamVjdFt2Lm5vXSxcbiAgICB9KSksIG9wdCk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBFbnVtVHlwZSB3aXRoIHRoZSBnaXZlbiB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIG1ha2VFbnVtVHlwZSh0eXBlTmFtZSwgdmFsdWVzLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbl9vcHQpIHtcbiAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3QgbnVtYmVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3Qgbm9ybWFsVmFsdWVzID0gW107XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgLy8gV2UgZG8gbm90IHN1cmZhY2Ugb3B0aW9ucyBhdCB0aGlzIHRpbWVcbiAgICAgICAgLy8gY29uc3QgdmFsdWU6IEVudW1WYWx1ZUluZm8gPSB7Li4udiwgb3B0aW9uczogdi5vcHRpb25zID8/IGVtcHR5UmVhZG9ubHlPYmplY3R9O1xuICAgICAgICBjb25zdCBuID0gbm9ybWFsaXplRW51bVZhbHVlKHZhbHVlKTtcbiAgICAgICAgbm9ybWFsVmFsdWVzLnB1c2gobik7XG4gICAgICAgIG5hbWVzW3ZhbHVlLm5hbWVdID0gbjtcbiAgICAgICAgbnVtYmVyc1t2YWx1ZS5ub10gPSBuO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZSxcbiAgICAgICAgdmFsdWVzOiBub3JtYWxWYWx1ZXMsXG4gICAgICAgIC8vIFdlIGRvIG5vdCBzdXJmYWNlIG9wdGlvbnMgYXQgdGhpcyB0aW1lXG4gICAgICAgIC8vIG9wdGlvbnM6IG9wdD8ub3B0aW9ucyA/PyBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICBmaW5kTmFtZShuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZXNbbmFtZV07XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmROdW1iZXIobm8pIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJzW25vXTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgZW51bSBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzLlxuICogU2V0cyByZWZsZWN0aW9uIGluZm9ybWF0aW9uLlxuICovXG5mdW5jdGlvbiBtYWtlRW51bSh0eXBlTmFtZSwgdmFsdWVzLCBvcHQpIHtcbiAgICBjb25zdCBlbnVtT2JqZWN0ID0ge307XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgY29uc3QgbiA9IG5vcm1hbGl6ZUVudW1WYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGVudW1PYmplY3Rbbi5sb2NhbE5hbWVdID0gbi5ubztcbiAgICAgICAgZW51bU9iamVjdFtuLm5vXSA9IG4ubG9jYWxOYW1lO1xuICAgIH1cbiAgICBzZXRFbnVtVHlwZShlbnVtT2JqZWN0LCB0eXBlTmFtZSwgdmFsdWVzLCBvcHQpO1xuICAgIHJldHVybiBlbnVtT2JqZWN0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplRW51bVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKFwibG9jYWxOYW1lXCIgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2YWx1ZSksIHsgbG9jYWxOYW1lOiB2YWx1ZS5uYW1lIH0pO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MDE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGk6ICgpID0+ICgvKiBiaW5kaW5nICovIEludGVybmFsRmllbGRMaXN0KVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuY2xhc3MgSW50ZXJuYWxGaWVsZExpc3Qge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgbm9ybWFsaXplcikge1xuICAgICAgICB0aGlzLl9maWVsZHMgPSBmaWVsZHM7XG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZXIgPSBub3JtYWxpemVyO1xuICAgIH1cbiAgICBmaW5kSnNvbk5hbWUoanNvbk5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmpzb25OYW1lcykge1xuICAgICAgICAgICAgY29uc3QgdCA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBmIG9mIHRoaXMubGlzdCgpKSB7XG4gICAgICAgICAgICAgICAgdFtmLmpzb25OYW1lXSA9IHRbZi5uYW1lXSA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmpzb25OYW1lcyA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuanNvbk5hbWVzW2pzb25OYW1lXTtcbiAgICB9XG4gICAgZmluZChmaWVsZE5vKSB7XG4gICAgICAgIGlmICghdGhpcy5udW1iZXJzKSB7XG4gICAgICAgICAgICBjb25zdCB0ID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGYgb2YgdGhpcy5saXN0KCkpIHtcbiAgICAgICAgICAgICAgICB0W2Yubm9dID0gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubnVtYmVycyA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubnVtYmVyc1tmaWVsZE5vXTtcbiAgICB9XG4gICAgbGlzdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbCkge1xuICAgICAgICAgICAgdGhpcy5hbGwgPSB0aGlzLl9ub3JtYWxpemVyKHRoaXMuX2ZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsO1xuICAgIH1cbiAgICBieU51bWJlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm51bWJlcnNBc2MpIHtcbiAgICAgICAgICAgIHRoaXMubnVtYmVyc0FzYyA9IHRoaXMubGlzdCgpXG4gICAgICAgICAgICAgICAgLmNvbmNhdCgpXG4gICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEubm8gLSBiLm5vKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5udW1iZXJzQXNjO1xuICAgIH1cbiAgICBieU1lbWJlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1lbWJlcnMpIHtcbiAgICAgICAgICAgIHRoaXMubWVtYmVycyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgYSA9IHRoaXMubWVtYmVycztcbiAgICAgICAgICAgIGxldCBvO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmIG9mIHRoaXMubGlzdCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGYub25lb2YpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGYub25lb2YgIT09IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBmLm9uZW9mO1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKG8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhLnB1c2goZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1lbWJlcnM7XG4gICAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MzI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEU6ICgpID0+ICgvKiBiaW5kaW5nICovIHdyYXBGaWVsZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHc6ICgpID0+ICgvKiBiaW5kaW5nICovIGdldFVud3JhcHBlZEZpZWxkVHlwZSlcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tZXNzYWdlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2MSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2NSk7XG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5cbi8qKlxuICogV3JhcCBhIHByaW1pdGl2ZSBtZXNzYWdlIGZpZWxkIHZhbHVlIGluIGl0cyBjb3JyZXNwb25kaW5nIHdyYXBwZXJcbiAqIG1lc3NhZ2UuIFRoaXMgZnVuY3Rpb24gaXMgaWRlbXBvdGVudC5cbiAqL1xuZnVuY3Rpb24gd3JhcEZpZWxkKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgX21lc3NhZ2VfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5NZXNzYWdlICovIC52IHx8ICF0eXBlLmZpZWxkV3JhcHBlcikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0eXBlLmZpZWxkV3JhcHBlci53cmFwRmllbGQodmFsdWUpO1xufVxuLyoqXG4gKiBJZiB0aGUgZ2l2ZW4gZmllbGQgdXNlcyBvbmUgb2YgdGhlIHdlbGwta25vd24gd3JhcHBlciB0eXBlcywgcmV0dXJuXG4gKiB0aGUgcHJpbWl0aXZlIHR5cGUgaXQgd3JhcHMuXG4gKi9cbmZ1bmN0aW9uIGdldFVud3JhcHBlZEZpZWxkVHlwZShmaWVsZCkge1xuICAgIGlmIChmaWVsZC5maWVsZEtpbmQgIT09IFwibWVzc2FnZVwiKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChmaWVsZC5yZXBlYXRlZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoZmllbGQub25lb2YgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB3a3RXcmFwcGVyVG9TY2FsYXJUeXBlW2ZpZWxkLm1lc3NhZ2UudHlwZU5hbWVdO1xufVxuY29uc3Qgd2t0V3JhcHBlclRvU2NhbGFyVHlwZSA9IHtcbiAgICBcImdvb2dsZS5wcm90b2J1Zi5Eb3VibGVWYWx1ZVwiOiBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5TY2FsYXJUeXBlICovIC53LkRPVUJMRSxcbiAgICBcImdvb2dsZS5wcm90b2J1Zi5GbG9hdFZhbHVlXCI6IF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLlNjYWxhclR5cGUgKi8gLncuRkxPQVQsXG4gICAgXCJnb29nbGUucHJvdG9idWYuSW50NjRWYWx1ZVwiOiBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5TY2FsYXJUeXBlICovIC53LklOVDY0LFxuICAgIFwiZ29vZ2xlLnByb3RvYnVmLlVJbnQ2NFZhbHVlXCI6IF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLlNjYWxhclR5cGUgKi8gLncuVUlOVDY0LFxuICAgIFwiZ29vZ2xlLnByb3RvYnVmLkludDMyVmFsdWVcIjogX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18vKiAuU2NhbGFyVHlwZSAqLyAudy5JTlQzMixcbiAgICBcImdvb2dsZS5wcm90b2J1Zi5VSW50MzJWYWx1ZVwiOiBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5TY2FsYXJUeXBlICovIC53LlVJTlQzMixcbiAgICBcImdvb2dsZS5wcm90b2J1Zi5Cb29sVmFsdWVcIjogX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18vKiAuU2NhbGFyVHlwZSAqLyAudy5CT09MLFxuICAgIFwiZ29vZ2xlLnByb3RvYnVmLlN0cmluZ1ZhbHVlXCI6IF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLlNjYWxhclR5cGUgKi8gLncuU1RSSU5HLFxuICAgIFwiZ29vZ2xlLnByb3RvYnVmLkJ5dGVzVmFsdWVcIjogX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18vKiAuU2NhbGFyVHlwZSAqLyAudy5CWVRFUyxcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDIxNTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19fX3dlYnBhY2tfbW9kdWxlX18sIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgbzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW50ZXJuYWxPbmVvZkluZm8pXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbmFtZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNTA0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYXNzZXJ0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMCk7XG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5cbmNsYXNzIEludGVybmFsT25lb2ZJbmZvIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHRoaXMua2luZCA9IFwib25lb2ZcIjtcbiAgICAgICAgdGhpcy5yZXBlYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhY2tlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9wdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlZmF1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZmllbGRzID0gW107XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMubG9jYWxOYW1lID0gKDAsX25hbWVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAubG9jYWxPbmVvZk5hbWUgKi8gLnVBKShuYW1lKTtcbiAgICB9XG4gICAgYWRkRmllbGQoZmllbGQpIHtcbiAgICAgICAgKDAsX2Fzc2VydF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLmFzc2VydCAqLyAuaHUpKGZpZWxkLm9uZW9mID09PSB0aGlzLCBgZmllbGQgJHtmaWVsZC5uYW1lfSBub3Qgb25lIG9mICR7dGhpcy5uYW1lfWApO1xuICAgICAgICB0aGlzLmZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICB9XG4gICAgZmluZEZpZWxkKGxvY2FsTmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2xvb2t1cCkge1xuICAgICAgICAgICAgdGhpcy5fbG9va3VwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb29rdXBbdGhpcy5maWVsZHNbaV0ubG9jYWxOYW1lXSA9IHRoaXMuZmllbGRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9sb29rdXBbbG9jYWxOYW1lXTtcbiAgICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDgxNDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19fX3dlYnBhY2tfbW9kdWxlX18sIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgYjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gbWFrZUpzb25Gb3JtYXRDb21tb24pXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWVzc2FnZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NjEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NjUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9hc3NlcnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcHJvdG9faW50NjRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjEwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcHJvdG9fYmFzZTY0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzNik7XG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5cblxuXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNhc2UtZGVjbGFyYXRpb25zLCBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGwsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQgKi9cbi8vIERlZmF1bHQgb3B0aW9ucyBmb3IgcGFyc2luZyBKU09OLlxuY29uc3QganNvblJlYWREZWZhdWx0cyA9IHtcbiAgICBpZ25vcmVVbmtub3duRmllbGRzOiBmYWxzZSxcbn07XG4vLyBEZWZhdWx0IG9wdGlvbnMgZm9yIHNlcmlhbGl6aW5nIHRvIEpTT04uXG5jb25zdCBqc29uV3JpdGVEZWZhdWx0cyA9IHtcbiAgICBlbWl0RGVmYXVsdFZhbHVlczogZmFsc2UsXG4gICAgZW51bUFzSW50ZWdlcjogZmFsc2UsXG4gICAgdXNlUHJvdG9GaWVsZE5hbWU6IGZhbHNlLFxuICAgIHByZXR0eVNwYWNlczogMCxcbn07XG5mdW5jdGlvbiBtYWtlUmVhZE9wdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBqc29uUmVhZERlZmF1bHRzKSwgb3B0aW9ucykgOiBqc29uUmVhZERlZmF1bHRzO1xufVxuZnVuY3Rpb24gbWFrZVdyaXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGpzb25Xcml0ZURlZmF1bHRzKSwgb3B0aW9ucykgOiBqc29uV3JpdGVEZWZhdWx0cztcbn1cbmZ1bmN0aW9uIG1ha2VKc29uRm9ybWF0Q29tbW9uKG1ha2VXcml0ZUZpZWxkKSB7XG4gICAgY29uc3Qgd3JpdGVGaWVsZCA9IG1ha2VXcml0ZUZpZWxkKHdyaXRlRW51bSwgd3JpdGVTY2FsYXIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1ha2VSZWFkT3B0aW9ucyxcbiAgICAgICAgbWFrZVdyaXRlT3B0aW9ucyxcbiAgICAgICAgcmVhZE1lc3NhZ2UodHlwZSwganNvbiwgb3B0aW9ucywgbWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKGpzb24gPT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGpzb24pIHx8IHR5cGVvZiBqc29uICE9IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBkZWNvZGUgbWVzc2FnZSAke3R5cGUudHlwZU5hbWV9IGZyb20gSlNPTjogJHt0aGlzLmRlYnVnKGpzb24pfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IG5ldyB0eXBlKCk7XG4gICAgICAgICAgICBjb25zdCBvbmVvZlNlZW4gPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2pzb25LZXksIGpzb25WYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoanNvbikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IHR5cGUuZmllbGRzLmZpbmRKc29uTmFtZShqc29uS2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBkZWNvZGUgbWVzc2FnZSAke3R5cGUudHlwZU5hbWV9IGZyb20gSlNPTjoga2V5IFwiJHtqc29uS2V5fVwiIGlzIHVua25vd25gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGxvY2FsTmFtZSA9IGZpZWxkLmxvY2FsTmFtZTtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0ID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQub25lb2YpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCAmJiBmaWVsZC5raW5kID09IFwic2NhbGFyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlZSBjb25mb3JtYW5jZSB0ZXN0IFJlcXVpcmVkLlByb3RvMy5Kc29uSW5wdXQuT25lb2ZGaWVsZE51bGx7Rmlyc3QsU2Vjb25kfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VlbiA9IG9uZW9mU2VlbltmaWVsZC5vbmVvZi5sb2NhbE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2Vlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjb2RlIG1lc3NhZ2UgJHt0eXBlLnR5cGVOYW1lfSBmcm9tIEpTT046IG11bHRpcGxlIGtleXMgZm9yIG9uZW9mIFwiJHtmaWVsZC5vbmVvZi5uYW1lfVwiIHByZXNlbnQ6IFwiJHtzZWVufVwiLCBcIiR7anNvbktleX1cImApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9uZW9mU2VlbltmaWVsZC5vbmVvZi5sb2NhbE5hbWVdID0ganNvbktleTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0W2ZpZWxkLm9uZW9mLmxvY2FsTmFtZV0gPSB7IGNhc2U6IGxvY2FsTmFtZSB9O1xuICAgICAgICAgICAgICAgICAgICBsb2NhbE5hbWUgPSBcInZhbHVlXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoanNvblZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvblZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjb2RlIGZpZWxkICR7dHlwZS50eXBlTmFtZX0uJHtmaWVsZC5uYW1lfSBmcm9tIEpTT046ICR7dGhpcy5kZWJ1Zyhqc29uVmFsdWUpfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldEFycmF5ID0gdGFyZ2V0W2xvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QganNvbkl0ZW0gb2YganNvblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvbkl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBkZWNvZGUgZmllbGQgJHt0eXBlLnR5cGVOYW1lfS4ke2ZpZWxkLm5hbWV9IGZyb20gSlNPTjogJHt0aGlzLmRlYnVnKGpzb25JdGVtKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVjayAtLSBcIm1hcFwiIGlzIGludmFsaWQgZm9yIHJlcGVhdGVkIGZpZWxkc1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gZmllbGQuVC5mcm9tSnNvbihqc29uSXRlbSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHJlYWRFbnVtKGZpZWxkLlQsIGpzb25JdGVtLCBvcHRpb25zLmlnbm9yZVVua25vd25GaWVsZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcmVhZFNjYWxhcihmaWVsZC5ULCBqc29uSXRlbSwgZmllbGQuTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtID0gYGNhbm5vdCBkZWNvZGUgZmllbGQgJHt0eXBlLnR5cGVOYW1lfS4ke2ZpZWxkLm5hbWV9IGZyb20gSlNPTjogJHt0aGlzLmRlYnVnKGpzb25JdGVtKX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gKz0gYDogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEFycmF5LnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5raW5kID09IFwibWFwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoanNvblZhbHVlKSB8fCB0eXBlb2YganNvblZhbHVlICE9IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSBmaWVsZCAke3R5cGUudHlwZU5hbWV9LiR7ZmllbGQubmFtZX0gZnJvbSBKU09OOiAke3RoaXMuZGVidWcoanNvblZhbHVlKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRNYXAgPSB0YXJnZXRbbG9jYWxOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbanNvbk1hcEtleSwganNvbk1hcFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhqc29uVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvbk1hcFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjb2RlIGZpZWxkICR7dHlwZS50eXBlTmFtZX0uJHtmaWVsZC5uYW1lfSBmcm9tIEpTT046IG1hcCB2YWx1ZSBudWxsYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBmaWVsZC5WLlQuZnJvbUpzb24oanNvbk1hcFZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcmVhZEVudW0oZmllbGQuVi5ULCBqc29uTWFwVmFsdWUsIG9wdGlvbnMuaWdub3JlVW5rbm93bkZpZWxkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSByZWFkU2NhbGFyKGZpZWxkLlYuVCwganNvbk1hcFZhbHVlLCBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5Mb25nVHlwZSAqLyAucC5CSUdJTlQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbSA9IGBjYW5ub3QgZGVjb2RlIG1hcCB2YWx1ZSBmb3IgZmllbGQgJHt0eXBlLnR5cGVOYW1lfS4ke2ZpZWxkLm5hbWV9IGZyb20gSlNPTjogJHt0aGlzLmRlYnVnKGpzb25WYWx1ZSl9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtICs9IGA6ICR7ZS5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE1hcFtyZWFkU2NhbGFyKGZpZWxkLkssIGZpZWxkLksgPT0gX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAuU2NhbGFyVHlwZSAqLyAudy5CT09MXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ganNvbk1hcEtleSA9PSBcInRydWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGpzb25NYXBLZXkgPT0gXCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoganNvbk1hcEtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGpzb25NYXBLZXksIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLkxvbmdUeXBlICovIC5wLkJJR0lOVCkudG9TdHJpbmcoKV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtID0gYGNhbm5vdCBkZWNvZGUgbWFwIGtleSBmb3IgZmllbGQgJHt0eXBlLnR5cGVOYW1lfS4ke2ZpZWxkLm5hbWV9IGZyb20gSlNPTjogJHt0aGlzLmRlYnVnKGpzb25WYWx1ZSl9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gKz0gYDogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBmaWVsZC5UO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc29uVmFsdWUgPT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVR5cGUudHlwZU5hbWUgIT0gXCJnb29nbGUucHJvdG9idWYuVmFsdWVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQub25lb2YpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSBmaWVsZCAke3R5cGUudHlwZU5hbWV9LiR7ZmllbGQubmFtZX0gZnJvbSBKU09OOiBudWxsIGlzIGludmFsaWQgZm9yIG9uZW9mIGZpZWxkIFwiJHtqc29uS2V5fVwiYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRbbG9jYWxOYW1lXSBpbnN0YW5jZW9mIF9tZXNzYWdlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18vKiAuTWVzc2FnZSAqLyAudikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBtZXNzYWdlVHlwZS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyICYmICFmaWVsZC5vbmVvZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBtZXNzYWdlVHlwZS5maWVsZFdyYXBwZXIudW53cmFwRmllbGQodGFyZ2V0W2xvY2FsTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnVtVmFsdWUgPSByZWFkRW51bShmaWVsZC5ULCBqc29uVmFsdWUsIG9wdGlvbnMuaWdub3JlVW5rbm93bkZpZWxkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudW1WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gZW51bVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHJlYWRTY2FsYXIoZmllbGQuVCwganNvblZhbHVlLCBmaWVsZC5MKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSBgY2Fubm90IGRlY29kZSBmaWVsZCAke3R5cGUudHlwZU5hbWV9LiR7ZmllbGQubmFtZX0gZnJvbSBKU09OOiAke3RoaXMuZGVidWcoanNvblZhbHVlKX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtICs9IGA6ICR7ZS5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9LFxuICAgICAgICB3cml0ZU1lc3NhZ2UobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UuZ2V0VHlwZSgpO1xuICAgICAgICAgICAgY29uc3QganNvbiA9IHt9O1xuICAgICAgICAgICAgbGV0IGZpZWxkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0eXBlLmZpZWxkcy5ieU1lbWJlcigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBqc29uVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZW1iZXIua2luZCA9PSBcIm9uZW9mXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9uZW9mID0gbWVzc2FnZVttZW1iZXIubG9jYWxOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbmVvZi52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IG1lbWJlci5maW5kRmllbGQob25lb2YuY2FzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJvbmVvZiBjYXNlIG5vdCBmb3VuZDogXCIgKyBvbmVvZi5jYXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAganNvblZhbHVlID0gd3JpdGVGaWVsZChmaWVsZCwgb25lb2YudmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQgPSBtZW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uVmFsdWUgPSB3cml0ZUZpZWxkKGZpZWxkLCBtZXNzYWdlW2ZpZWxkLmxvY2FsTmFtZV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAganNvbltvcHRpb25zLnVzZVByb3RvRmllbGROYW1lID8gZmllbGQubmFtZSA6IGZpZWxkLmpzb25OYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvblZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gZmllbGRcbiAgICAgICAgICAgICAgICAgICAgPyBgY2Fubm90IGVuY29kZSBmaWVsZCAke3R5cGUudHlwZU5hbWV9LiR7ZmllbGQubmFtZX0gdG8gSlNPTmBcbiAgICAgICAgICAgICAgICAgICAgOiBgY2Fubm90IGVuY29kZSBtZXNzYWdlICR7dHlwZS50eXBlTmFtZX0gdG8gSlNPTmA7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFN0cmluZyhlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSArIChyLmxlbmd0aCA+IDAgPyBgOiAke3J9YCA6IFwiXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICB9LFxuICAgICAgICByZWFkU2NhbGFyLFxuICAgICAgICB3cml0ZVNjYWxhcixcbiAgICAgICAgZGVidWc6IGRlYnVnSnNvblZhbHVlLFxuICAgIH07XG59XG5mdW5jdGlvbiBkZWJ1Z0pzb25WYWx1ZShqc29uKSB7XG4gICAgaWYgKGpzb24gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGVvZiBqc29uKSB7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGpzb24pID8gXCJhcnJheVwiIDogXCJvYmplY3RcIjtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIGpzb24ubGVuZ3RoID4gMTAwID8gXCJzdHJpbmdcIiA6IGBcIiR7anNvbi5zcGxpdCgnXCInKS5qb2luKCdcXFxcXCInKX1cImA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKGpzb24pO1xuICAgIH1cbn1cbi8vIE1heSB0aHJvdyBhbiBlcnJvci4gSWYgdGhlIGVycm9yIG1lc3NhZ2UgaXMgbm9uLWJsYW5rLCBpdCBzaG91bGQgYmUgc2hvd24uXG4vLyBJdCBpcyB1cCB0byB0aGUgY2FsbGVyIHRvIHByb3ZpZGUgY29udGV4dC5cbmZ1bmN0aW9uIHJlYWRTY2FsYXIodHlwZSwganNvbiwgbG9uZ1R5cGUpIHtcbiAgICAvLyBldmVyeSB2YWxpZCBjYXNlIGluIHRoZSBzd2l0Y2ggYmVsb3cgcmV0dXJucywgYW5kIGV2ZXJ5IGZhbGxcbiAgICAvLyB0aHJvdWdoIGlzIHJlZ2FyZGVkIGFzIGEgZmFpbHVyZS5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgLy8gZmxvYXQsIGRvdWJsZTogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgbnVtYmVyIG9yIG9uZSBvZiB0aGUgc3BlY2lhbCBzdHJpbmcgdmFsdWVzIFwiTmFOXCIsIFwiSW5maW5pdHlcIiwgYW5kIFwiLUluZmluaXR5XCIuXG4gICAgICAgIC8vIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLiBFeHBvbmVudCBub3RhdGlvbiBpcyBhbHNvIGFjY2VwdGVkLlxuICAgICAgICBjYXNlIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLlNjYWxhclR5cGUgKi8gLncuRE9VQkxFOlxuICAgICAgICBjYXNlIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLlNjYWxhclR5cGUgKi8gLncuRkxPQVQ6XG4gICAgICAgICAgICBpZiAoanNvbiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICAgICAgaWYgKGpzb24gPT09IFwiTmFOXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlci5OYU47XG4gICAgICAgICAgICBpZiAoanNvbiA9PT0gXCJJbmZpbml0eVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgICAgICBpZiAoanNvbiA9PT0gXCItSW5maW5pdHlcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgICAgICAgaWYgKGpzb24gPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBlbXB0eSBzdHJpbmcgaXMgbm90IGEgbnVtYmVyXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gPT0gXCJzdHJpbmdcIiAmJiBqc29uLnRyaW0oKS5sZW5ndGggIT09IGpzb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gZXh0cmEgd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9IFwic3RyaW5nXCIgJiYgdHlwZW9mIGpzb24gIT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmxvYXQgPSBOdW1iZXIoanNvbik7XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGZsb2F0KSkge1xuICAgICAgICAgICAgICAgIC8vIG5vdCBhIG51bWJlclxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZmxvYXQpKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5maW5pdHkgYW5kIC1pbmZpbml0eSBhcmUgaGFuZGxlZCBieSBzdHJpbmcgcmVwcmVzZW50YXRpb24gYWJvdmUsIHNvIHRoaXMgaXMgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09IF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLlNjYWxhclR5cGUgKi8gLncuRkxPQVQpXG4gICAgICAgICAgICAgICAgKDAsX2Fzc2VydF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLyogLmFzc2VydEZsb2F0MzIgKi8gLkVfKShmbG9hdCk7XG4gICAgICAgICAgICByZXR1cm4gZmxvYXQ7XG4gICAgICAgIC8vIGludDMyLCBmaXhlZDMyLCB1aW50MzI6IEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgbnVtYmVyLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICAgICAgY2FzZSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5TY2FsYXJUeXBlICovIC53LklOVDMyOlxuICAgICAgICBjYXNlIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLlNjYWxhclR5cGUgKi8gLncuRklYRUQzMjpcbiAgICAgICAgY2FzZSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5TY2FsYXJUeXBlICovIC53LlNGSVhFRDMyOlxuICAgICAgICBjYXNlIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLlNjYWxhclR5cGUgKi8gLncuU0lOVDMyOlxuICAgICAgICBjYXNlIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLlNjYWxhclR5cGUgKi8gLncuVUlOVDMyOlxuICAgICAgICAgICAgaWYgKGpzb24gPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBsZXQgaW50MzI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBpbnQzMiA9IGpzb247XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YganNvbiA9PSBcInN0cmluZ1wiICYmIGpzb24ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChqc29uLnRyaW0oKS5sZW5ndGggPT09IGpzb24ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBpbnQzMiA9IE51bWJlcihqc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnQzMiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAuU2NhbGFyVHlwZSAqLyAudy5VSU5UMzIpXG4gICAgICAgICAgICAgICAgKDAsX2Fzc2VydF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLyogLmFzc2VydFVJbnQzMiAqLyAuZnApKGludDMyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAoMCxfYXNzZXJ0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18vKiAuYXNzZXJ0SW50MzIgKi8gLnVnKShpbnQzMik7XG4gICAgICAgICAgICByZXR1cm4gaW50MzI7XG4gICAgICAgIC8vIGludDY0LCBmaXhlZDY0LCB1aW50NjQ6IEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgc3RyaW5nLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICAgICAgY2FzZSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5TY2FsYXJUeXBlICovIC53LklOVDY0OlxuICAgICAgICBjYXNlIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLlNjYWxhclR5cGUgKi8gLncuU0ZJWEVENjQ6XG4gICAgICAgIGNhc2UgX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAuU2NhbGFyVHlwZSAqLyAudy5TSU5UNjQ6XG4gICAgICAgICAgICBpZiAoanNvbiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gX3Byb3RvX2ludDY0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18vKiAucHJvdG9JbnQ2NCAqLyAucS56ZXJvO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9IFwibnVtYmVyXCIgJiYgdHlwZW9mIGpzb24gIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNvbnN0IGxvbmcgPSBfcHJvdG9faW50NjRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy8qIC5wcm90b0ludDY0ICovIC5xLnBhcnNlKGpzb24pO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICAgICAgICAgICAgcmV0dXJuIGxvbmdUeXBlID8gbG9uZy50b1N0cmluZygpIDogbG9uZztcbiAgICAgICAgY2FzZSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5TY2FsYXJUeXBlICovIC53LkZJWEVENjQ6XG4gICAgICAgIGNhc2UgX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAuU2NhbGFyVHlwZSAqLyAudy5VSU5UNjQ6XG4gICAgICAgICAgICBpZiAoanNvbiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gX3Byb3RvX2ludDY0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18vKiAucHJvdG9JbnQ2NCAqLyAucS56ZXJvO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9IFwibnVtYmVyXCIgJiYgdHlwZW9mIGpzb24gIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNvbnN0IHVMb25nID0gX3Byb3RvX2ludDY0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18vKiAucHJvdG9JbnQ2NCAqLyAucS51UGFyc2UoanNvbik7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgICAgICAgICByZXR1cm4gbG9uZ1R5cGUgPyB1TG9uZy50b1N0cmluZygpIDogdUxvbmc7XG4gICAgICAgIC8vIGJvb2w6XG4gICAgICAgIGNhc2UgX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAuU2NhbGFyVHlwZSAqLyAudy5CT09MOlxuICAgICAgICAgICAgaWYgKGpzb24gPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICAvLyBzdHJpbmc6XG4gICAgICAgIGNhc2UgX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAuU2NhbGFyVHlwZSAqLyAudy5TVFJJTkc6XG4gICAgICAgICAgICBpZiAoanNvbiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQSBzdHJpbmcgbXVzdCBhbHdheXMgY29udGFpbiBVVEYtOCBlbmNvZGVkIG9yIDctYml0IEFTQ0lJLlxuICAgICAgICAgICAgLy8gV2UgdmFsaWRhdGUgd2l0aCBlbmNvZGVVUklDb21wb25lbnQsIHdoaWNoIGFwcGVhcnMgdG8gYmUgdGhlIGZhc3Rlc3Qgd2lkZWx5IGF2YWlsYWJsZSBvcHRpb24uXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChqc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBVVEY4XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICAgIC8vIGJ5dGVzOiBKU09OIHZhbHVlIHdpbGwgYmUgdGhlIGRhdGEgZW5jb2RlZCBhcyBhIHN0cmluZyB1c2luZyBzdGFuZGFyZCBiYXNlNjQgZW5jb2Rpbmcgd2l0aCBwYWRkaW5ncy5cbiAgICAgICAgLy8gRWl0aGVyIHN0YW5kYXJkIG9yIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZyB3aXRoL3dpdGhvdXQgcGFkZGluZ3MgYXJlIGFjY2VwdGVkLlxuICAgICAgICBjYXNlIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLlNjYWxhclR5cGUgKi8gLncuQllURVM6XG4gICAgICAgICAgICBpZiAoanNvbiA9PT0gbnVsbCB8fCBqc29uID09PSBcIlwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHJldHVybiBfcHJvdG9fYmFzZTY0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18vKiAucHJvdG9CYXNlNjQgKi8gLlcuZGVjKGpzb24pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbn1cbmZ1bmN0aW9uIHJlYWRFbnVtKHR5cGUsIGpzb24sIGlnbm9yZVVua25vd25GaWVsZHMpIHtcbiAgICBpZiAoanNvbiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBwcm90bzMgcmVxdWlyZXMgMCB0byBiZSBkZWZhdWx0IHZhbHVlIGZvciBhbGwgZW51bXNcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrXG4gICAgc3dpdGNoICh0eXBlb2YganNvbikge1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihqc29uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdHlwZS5maW5kTmFtZShqc29uKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLW51bGxpc2gtY29hbGVzY2luZ1xuICAgICAgICAgICAgaWYgKHZhbHVlIHx8IGlnbm9yZVVua25vd25GaWVsZHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLm5vO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSBlbnVtICR7dHlwZS50eXBlTmFtZX0gZnJvbSBKU09OOiAke2RlYnVnSnNvblZhbHVlKGpzb24pfWApO1xufVxuZnVuY3Rpb24gd3JpdGVFbnVtKHR5cGUsIHZhbHVlLCBlbWl0SW50cmluc2ljRGVmYXVsdCwgZW51bUFzSW50ZWdlcikge1xuICAgIHZhciBfYTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gMCAmJiAhZW1pdEludHJpbnNpY0RlZmF1bHQpIHtcbiAgICAgICAgLy8gcHJvdG8zIHJlcXVpcmVzIDAgdG8gYmUgZGVmYXVsdCB2YWx1ZSBmb3IgYWxsIGVudW1zXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChlbnVtQXNJbnRlZ2VyKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGUudHlwZU5hbWUgPT0gXCJnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHZhbCA9IHR5cGUuZmluZE51bWJlcih2YWx1ZSk7XG4gICAgcmV0dXJuIChfYSA9IHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbC5uYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2YWx1ZTsgLy8gaWYgd2UgZG9uJ3Qga25vdyB0aGUgZW51bSB2YWx1ZSwganVzdCByZXR1cm4gdGhlIG51bWJlclxufVxuZnVuY3Rpb24gd3JpdGVTY2FsYXIodHlwZSwgdmFsdWUsIGVtaXRJbnRyaW5zaWNEZWZhdWx0KSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIC8vIGludDMyLCBmaXhlZDMyLCB1aW50MzI6IEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgbnVtYmVyLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICAgICAgY2FzZSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5TY2FsYXJUeXBlICovIC53LklOVDMyOlxuICAgICAgICBjYXNlIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLlNjYWxhclR5cGUgKi8gLncuU0ZJWEVEMzI6XG4gICAgICAgIGNhc2UgX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAuU2NhbGFyVHlwZSAqLyAudy5TSU5UMzI6XG4gICAgICAgIGNhc2UgX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAuU2NhbGFyVHlwZSAqLyAudy5GSVhFRDMyOlxuICAgICAgICBjYXNlIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLlNjYWxhclR5cGUgKi8gLncuVUlOVDMyOlxuICAgICAgICAgICAgKDAsX2Fzc2VydF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLyogLmFzc2VydCAqLyAuaHUpKHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPSAwIHx8IGVtaXRJbnRyaW5zaWNEZWZhdWx0ID8gdmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIGZsb2F0LCBkb3VibGU6IEpTT04gdmFsdWUgd2lsbCBiZSBhIG51bWJlciBvciBvbmUgb2YgdGhlIHNwZWNpYWwgc3RyaW5nIHZhbHVlcyBcIk5hTlwiLCBcIkluZmluaXR5XCIsIGFuZCBcIi1JbmZpbml0eVwiLlxuICAgICAgICAvLyBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC4gRXhwb25lbnQgbm90YXRpb24gaXMgYWxzbyBhY2NlcHRlZC5cbiAgICAgICAgY2FzZSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5TY2FsYXJUeXBlICovIC53LkZMT0FUOlxuICAgICAgICAvLyBhc3NlcnRGbG9hdDMyKHZhbHVlKTtcbiAgICAgICAgY2FzZSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5TY2FsYXJUeXBlICovIC53LkRPVUJMRTogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgKDAsX2Fzc2VydF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLyogLmFzc2VydCAqLyAuaHUpKHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiKTtcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4odmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIk5hTlwiO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiSW5maW5pdHlcIjtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIi1JbmZpbml0eVwiO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSAwIHx8IGVtaXRJbnRyaW5zaWNEZWZhdWx0ID8gdmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIHN0cmluZzpcbiAgICAgICAgY2FzZSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5TY2FsYXJUeXBlICovIC53LlNUUklORzpcbiAgICAgICAgICAgICgwLF9hc3NlcnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy8qIC5hc3NlcnQgKi8gLmh1KSh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIik7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID4gMCB8fCBlbWl0SW50cmluc2ljRGVmYXVsdCA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBib29sOlxuICAgICAgICBjYXNlIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLlNjYWxhclR5cGUgKi8gLncuQk9PTDpcbiAgICAgICAgICAgICgwLF9hc3NlcnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy8qIC5hc3NlcnQgKi8gLmh1KSh0eXBlb2YgdmFsdWUgPT0gXCJib29sZWFuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIHx8IGVtaXRJbnRyaW5zaWNEZWZhdWx0ID8gdmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgc3RyaW5nLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICAgICAgY2FzZSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5TY2FsYXJUeXBlICovIC53LlVJTlQ2NDpcbiAgICAgICAgY2FzZSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5TY2FsYXJUeXBlICovIC53LkZJWEVENjQ6XG4gICAgICAgIGNhc2UgX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAuU2NhbGFyVHlwZSAqLyAudy5JTlQ2NDpcbiAgICAgICAgY2FzZSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5TY2FsYXJUeXBlICovIC53LlNGSVhFRDY0OlxuICAgICAgICBjYXNlIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLlNjYWxhclR5cGUgKi8gLncuU0lOVDY0OlxuICAgICAgICAgICAgKDAsX2Fzc2VydF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLyogLmFzc2VydCAqLyAuaHUpKHR5cGVvZiB2YWx1ZSA9PSBcImJpZ2ludFwiIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIik7XG4gICAgICAgICAgICAvLyBXZSB1c2UgaW1wbGljaXQgY29udmVyc2lvbiB3aXRoIGB2YWx1ZSAhPSAwYCB0byBjYXRjaCBib3RoIDBuIGFuZCBcIjBcIlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuIGVtaXRJbnRyaW5zaWNEZWZhdWx0IHx8IHZhbHVlICE9IDBcbiAgICAgICAgICAgICAgICA/IHZhbHVlLnRvU3RyaW5nKDEwKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBieXRlczogSlNPTiB2YWx1ZSB3aWxsIGJlIHRoZSBkYXRhIGVuY29kZWQgYXMgYSBzdHJpbmcgdXNpbmcgc3RhbmRhcmQgYmFzZTY0IGVuY29kaW5nIHdpdGggcGFkZGluZ3MuXG4gICAgICAgIC8vIEVpdGhlciBzdGFuZGFyZCBvciBVUkwtc2FmZSBiYXNlNjQgZW5jb2Rpbmcgd2l0aC93aXRob3V0IHBhZGRpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICAgICAgY2FzZSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5TY2FsYXJUeXBlICovIC53LkJZVEVTOlxuICAgICAgICAgICAgKDAsX2Fzc2VydF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLyogLmFzc2VydCAqLyAuaHUpKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSk7XG4gICAgICAgICAgICByZXR1cm4gZW1pdEludHJpbnNpY0RlZmF1bHQgfHwgdmFsdWUuYnl0ZUxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICA/IF9wcm90b19iYXNlNjRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy8qIC5wcm90b0Jhc2U2NCAqLyAuVy5lbmModmFsdWUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MDQ6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEdEOiAoKSA9PiAoLyogYmluZGluZyAqLyBzYWZlSWRlbnRpZmllciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFJ6OiAoKSA9PiAoLyogYmluZGluZyAqLyBsb2NhbEZpZWxkTmFtZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFNtOiAoKSA9PiAoLyogYmluZGluZyAqLyBmaW5kRW51bVNoYXJlZFByZWZpeCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGxsOiAoKSA9PiAoLyogYmluZGluZyAqLyBzYWZlT2JqZWN0UHJvcGVydHkpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICByMTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gbG9jYWxOYW1lKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgdUE6ICgpID0+ICgvKiBiaW5kaW5nICovIGxvY2FsT25lb2ZOYW1lKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgeDE6ICgpID0+ICgvKiBiaW5kaW5nICovIGZpZWxkSnNvbk5hbWUpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgYSBwcm90b2J1ZiBlbGVtZW50IGluIGdlbmVyYXRlZCBjb2RlLlxuICpcbiAqIEZpZWxkIG5hbWVzIC0gaW5jbHVkaW5nIG9uZW9mcyAtIGFyZSBjb252ZXJ0ZWQgdG8gbG93ZXJDYW1lbENhc2UuIEZvclxuICogbWVzc2FnZXMsIGVudW1lcmF0aW9ucyBhbmQgc2VydmljZXMsIHRoZSBwYWNrYWdlIG5hbWUgaXMgc3RyaXBwZWQgZnJvbVxuICogdGhlIHR5cGUgbmFtZS4gRm9yIG5lc3RlZCBtZXNzYWdlcyBhbmQgZW51bWVyYXRpb25zLCB0aGUgbmFtZXMgYXJlIGpvaW5lZFxuICogd2l0aCBhbiB1bmRlcnNjb3JlLiBGb3IgbWV0aG9kcywgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyBtYWRlIGxvd2VyY2FzZS5cbiAqL1xuZnVuY3Rpb24gbG9jYWxOYW1lKGRlc2MpIHtcbiAgICBzd2l0Y2ggKGRlc2Mua2luZCkge1xuICAgICAgICBjYXNlIFwiZmllbGRcIjpcbiAgICAgICAgICAgIHJldHVybiBsb2NhbEZpZWxkTmFtZShkZXNjLm5hbWUsIGRlc2Mub25lb2YgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGNhc2UgXCJvbmVvZlwiOlxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsT25lb2ZOYW1lKGRlc2MubmFtZSk7XG4gICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgIGNhc2UgXCJzZXJ2aWNlXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IHBrZyA9IGRlc2MuZmlsZS5wcm90by5wYWNrYWdlO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcGtnID09PSB1bmRlZmluZWQgPyAwIDogcGtnLmxlbmd0aCArIDE7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gZGVzYy50eXBlTmFtZS5zdWJzdHJpbmcob2Zmc2V0KS5yZXBsYWNlKC9cXC4vZywgXCJfXCIpO1xuICAgICAgICAgICAgLy8gRm9yIHNlcnZpY2VzLCB3ZSBvbmx5IGNhcmUgYWJvdXQgc2FmZSBpZGVudGlmaWVycywgbm90IHNhZmUgb2JqZWN0IHByb3BlcnRpZXMsXG4gICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBzaGlwcGVkIHYxIHdpdGggYSBidWcgdGhhdCByZXNwZWN0ZWQgb2JqZWN0IHByb3BlcnRpZXMsIGFuZCB3ZVxuICAgICAgICAgICAgLy8gZG8gbm90IHdhbnQgdG8gaW50cm9kdWNlIGEgYnJlYWtpbmcgY2hhbmdlLCBzbyB3ZSBjb250aW51ZSB0byBlc2NhcGUgZm9yXG4gICAgICAgICAgICAvLyBzYWZlIG9iamVjdCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9idWZidWlsZC9wcm90b2J1Zi1lcy9wdWxsLzM5MVxuICAgICAgICAgICAgcmV0dXJuIHNhZmVPYmplY3RQcm9wZXJ0eShzYWZlSWRlbnRpZmllcihuYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImVudW1fdmFsdWVcIjoge1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkUHJlZml4ID0gZGVzYy5wYXJlbnQuc2hhcmVkUHJlZml4O1xuICAgICAgICAgICAgaWYgKHNoYXJlZFByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBkZXNjLm5hbWUuc3Vic3RyaW5nKHNoYXJlZFByZWZpeC5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHNhZmVPYmplY3RQcm9wZXJ0eShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwicnBjXCI6IHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gZGVzYy5uYW1lO1xuICAgICAgICAgICAgaWYgKG5hbWUubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hbWUgPSBuYW1lWzBdLnRvTG93ZXJDYXNlKCkgKyBuYW1lLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIHJldHVybiBzYWZlT2JqZWN0UHJvcGVydHkobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgYSBmaWVsZCBpbiBnZW5lcmF0ZWQgY29kZS5cbiAqL1xuZnVuY3Rpb24gbG9jYWxGaWVsZE5hbWUocHJvdG9OYW1lLCBpbk9uZW9mKSB7XG4gICAgY29uc3QgbmFtZSA9IHByb3RvQ2FtZWxDYXNlKHByb3RvTmFtZSk7XG4gICAgaWYgKGluT25lb2YpIHtcbiAgICAgICAgLy8gb25lb2YgbWVtYmVyIG5hbWVzIGFyZSBub3QgcHJvcGVydGllcywgYnV0IHZhbHVlcyBvZiB0aGUgYGNhc2VgIHByb3BlcnR5LlxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIHNhZmVPYmplY3RQcm9wZXJ0eShzYWZlTWVzc2FnZVByb3BlcnR5KG5hbWUpKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbmFtZSBvZiBhIG9uZW9mIGdyb3VwIGluIGdlbmVyYXRlZCBjb2RlLlxuICovXG5mdW5jdGlvbiBsb2NhbE9uZW9mTmFtZShwcm90b05hbWUpIHtcbiAgICByZXR1cm4gbG9jYWxGaWVsZE5hbWUocHJvdG9OYW1lLCBmYWxzZSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIEpTT04gbmFtZSBmb3IgYSBwcm90b2J1ZiBmaWVsZCwgZXhhY3RseSBsaWtlIHByb3RvYyBkb2VzLlxuICovXG5jb25zdCBmaWVsZEpzb25OYW1lID0gcHJvdG9DYW1lbENhc2U7XG4vKipcbiAqIEZpbmRzIGEgcHJlZml4IHNoYXJlZCBieSBlbnVtIHZhbHVlcywgZm9yIGV4YW1wbGUgYE1ZX0VOVU1fYCBmb3JcbiAqIGBlbnVtIE15RW51bSB7TVlfRU5VTV9BPTA7IE1ZX0VOVU1fQj0xO31gLlxuICovXG5mdW5jdGlvbiBmaW5kRW51bVNoYXJlZFByZWZpeChlbnVtTmFtZSwgdmFsdWVOYW1lcykge1xuICAgIGNvbnN0IHByZWZpeCA9IGNhbWVsVG9TbmFrZUNhc2UoZW51bU5hbWUpICsgXCJfXCI7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIHZhbHVlTmFtZXMpIHtcbiAgICAgICAgaWYgKCFuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNob3J0TmFtZSA9IG5hbWUuc3Vic3RyaW5nKHByZWZpeC5sZW5ndGgpO1xuICAgICAgICBpZiAoc2hvcnROYW1lLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICgvXlxcZC8udGVzdChzaG9ydE5hbWUpKSB7XG4gICAgICAgICAgICAvLyBpZGVudGlmaWVycyBtdXN0IG5vdCBzdGFydCB3aXRoIG51bWJlcnNcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByZWZpeDtcbn1cbi8qKlxuICogQ29udmVydHMgbG93ZXJDYW1lbENhc2Ugb3IgVXBwZXJDYW1lbENhc2UgaW50byBsb3dlcl9zbmFrZV9jYXNlLlxuICogVGhpcyBpcyB1c2VkIHRvIGZpbmQgc2hhcmVkIHByZWZpeGVzIGluIGFuIGVudW0uXG4gKi9cbmZ1bmN0aW9uIGNhbWVsVG9TbmFrZUNhc2UoY2FtZWwpIHtcbiAgICByZXR1cm4gKGNhbWVsLnN1YnN0cmluZygwLCAxKSArIGNhbWVsLnN1YnN0cmluZygxKS5yZXBsYWNlKC9bQS1aXS9nLCAoYykgPT4gXCJfXCIgKyBjKSkudG9Mb3dlckNhc2UoKTtcbn1cbi8qKlxuICogQ29udmVydHMgc25ha2VfY2FzZSB0byBwcm90b0NhbWVsQ2FzZSBhY2NvcmRpbmcgdG8gdGhlIGNvbnZlbnRpb25cbiAqIHVzZWQgYnkgcHJvdG9jIHRvIGNvbnZlcnQgYSBmaWVsZCBuYW1lIHRvIGEgSlNPTiBuYW1lLlxuICovXG5mdW5jdGlvbiBwcm90b0NhbWVsQ2FzZShzbmFrZUNhc2UpIHtcbiAgICBsZXQgY2FwTmV4dCA9IGZhbHNlO1xuICAgIGNvbnN0IGIgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNuYWtlQ2FzZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYyA9IHNuYWtlQ2FzZS5jaGFyQXQoaSk7XG4gICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgY2FzZSBcIl9cIjpcbiAgICAgICAgICAgICAgICBjYXBOZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgICAgICBjYXNlIFwiMVwiOlxuICAgICAgICAgICAgY2FzZSBcIjJcIjpcbiAgICAgICAgICAgIGNhc2UgXCIzXCI6XG4gICAgICAgICAgICBjYXNlIFwiNFwiOlxuICAgICAgICAgICAgY2FzZSBcIjVcIjpcbiAgICAgICAgICAgIGNhc2UgXCI2XCI6XG4gICAgICAgICAgICBjYXNlIFwiN1wiOlxuICAgICAgICAgICAgY2FzZSBcIjhcIjpcbiAgICAgICAgICAgIGNhc2UgXCI5XCI6XG4gICAgICAgICAgICAgICAgYi5wdXNoKGMpO1xuICAgICAgICAgICAgICAgIGNhcE5leHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGNhcE5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FwTmV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjID0gYy50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiLnB1c2goYyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGIuam9pbihcIlwiKTtcbn1cbi8qKlxuICogTmFtZXMgdGhhdCBjYW5ub3QgYmUgdXNlZCBmb3IgaWRlbnRpZmllcnMsIHN1Y2ggYXMgY2xhc3MgbmFtZXMsXG4gKiBidXQgX2Nhbl8gYmUgdXNlZCBmb3Igb2JqZWN0IHByb3BlcnRpZXMuXG4gKi9cbmNvbnN0IHJlc2VydmVkSWRlbnRpZmllcnMgPSBuZXcgU2V0KFtcbiAgICAvLyBFQ01BU2NyaXB0IDIwMTUga2V5d29yZHNcbiAgICBcImJyZWFrXCIsXG4gICAgXCJjYXNlXCIsXG4gICAgXCJjYXRjaFwiLFxuICAgIFwiY2xhc3NcIixcbiAgICBcImNvbnN0XCIsXG4gICAgXCJjb250aW51ZVwiLFxuICAgIFwiZGVidWdnZXJcIixcbiAgICBcImRlZmF1bHRcIixcbiAgICBcImRlbGV0ZVwiLFxuICAgIFwiZG9cIixcbiAgICBcImVsc2VcIixcbiAgICBcImV4cG9ydFwiLFxuICAgIFwiZXh0ZW5kc1wiLFxuICAgIFwiZmFsc2VcIixcbiAgICBcImZpbmFsbHlcIixcbiAgICBcImZvclwiLFxuICAgIFwiZnVuY3Rpb25cIixcbiAgICBcImlmXCIsXG4gICAgXCJpbXBvcnRcIixcbiAgICBcImluXCIsXG4gICAgXCJpbnN0YW5jZW9mXCIsXG4gICAgXCJuZXdcIixcbiAgICBcIm51bGxcIixcbiAgICBcInJldHVyblwiLFxuICAgIFwic3VwZXJcIixcbiAgICBcInN3aXRjaFwiLFxuICAgIFwidGhpc1wiLFxuICAgIFwidGhyb3dcIixcbiAgICBcInRydWVcIixcbiAgICBcInRyeVwiLFxuICAgIFwidHlwZW9mXCIsXG4gICAgXCJ2YXJcIixcbiAgICBcInZvaWRcIixcbiAgICBcIndoaWxlXCIsXG4gICAgXCJ3aXRoXCIsXG4gICAgXCJ5aWVsZFwiLFxuICAgIC8vIEVDTUFTY3JpcHQgMjAxNSBmdXR1cmUgcmVzZXJ2ZWQga2V5d29yZHNcbiAgICBcImVudW1cIixcbiAgICBcImltcGxlbWVudHNcIixcbiAgICBcImludGVyZmFjZVwiLFxuICAgIFwibGV0XCIsXG4gICAgXCJwYWNrYWdlXCIsXG4gICAgXCJwcml2YXRlXCIsXG4gICAgXCJwcm90ZWN0ZWRcIixcbiAgICBcInB1YmxpY1wiLFxuICAgIFwic3RhdGljXCIsXG4gICAgLy8gQ2xhc3MgbmFtZSBjYW5ub3QgYmUgJ09iamVjdCcgd2hlbiB0YXJnZXRpbmcgRVM1IHdpdGggbW9kdWxlIENvbW1vbkpTXG4gICAgXCJPYmplY3RcIixcbiAgICAvLyBUeXBlU2NyaXB0IGtleXdvcmRzIHRoYXQgY2Fubm90IGJlIHVzZWQgZm9yIHR5cGVzIChhcyBvcHBvc2VkIHRvIHZhcmlhYmxlcylcbiAgICBcImJpZ2ludFwiLFxuICAgIFwibnVtYmVyXCIsXG4gICAgXCJib29sZWFuXCIsXG4gICAgXCJzdHJpbmdcIixcbiAgICBcIm9iamVjdFwiLFxuICAgIC8vIElkZW50aWZpZXJzIHJlc2VydmVkIGZvciB0aGUgcnVudGltZSwgc28gd2UgY2FuIGdlbmVyYXRlIGxlZ2libGUgY29kZVxuICAgIFwiZ2xvYmFsVGhpc1wiLFxuICAgIFwiVWludDhBcnJheVwiLFxuICAgIFwiUGFydGlhbFwiLFxuXSk7XG4vKipcbiAqIE5hbWVzIHRoYXQgY2Fubm90IGJlIHVzZWQgZm9yIG9iamVjdCBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBhcmUgcmVzZXJ2ZWRcbiAqIGJ5IGJ1aWx0LWluIEphdmFTY3JpcHQgcHJvcGVydGllcy5cbiAqL1xuY29uc3QgcmVzZXJ2ZWRPYmplY3RQcm9wZXJ0aWVzID0gbmV3IFNldChbXG4gICAgLy8gbmFtZXMgcmVzZXJ2ZWQgYnkgSmF2YVNjcmlwdFxuICAgIFwiY29uc3RydWN0b3JcIixcbiAgICBcInRvU3RyaW5nXCIsXG4gICAgXCJ0b0pTT05cIixcbiAgICBcInZhbHVlT2ZcIixcbl0pO1xuLyoqXG4gKiBOYW1lcyB0aGF0IGNhbm5vdCBiZSB1c2VkIGZvciBvYmplY3QgcHJvcGVydGllcyBiZWNhdXNlIHRoZXkgYXJlIHJlc2VydmVkXG4gKiBieSB0aGUgcnVudGltZS5cbiAqL1xuY29uc3QgcmVzZXJ2ZWRNZXNzYWdlUHJvcGVydGllcyA9IG5ldyBTZXQoW1xuICAgIC8vIG5hbWVzIHJlc2VydmVkIGJ5IHRoZSBydW50aW1lXG4gICAgXCJnZXRUeXBlXCIsXG4gICAgXCJjbG9uZVwiLFxuICAgIFwiZXF1YWxzXCIsXG4gICAgXCJmcm9tQmluYXJ5XCIsXG4gICAgXCJmcm9tSnNvblwiLFxuICAgIFwiZnJvbUpzb25TdHJpbmdcIixcbiAgICBcInRvQmluYXJ5XCIsXG4gICAgXCJ0b0pzb25cIixcbiAgICBcInRvSnNvblN0cmluZ1wiLFxuICAgIC8vIG5hbWVzIHJlc2VydmVkIGJ5IHRoZSBydW50aW1lIGZvciB0aGUgZnV0dXJlXG4gICAgXCJ0b09iamVjdFwiLFxuXSk7XG5jb25zdCBmYWxsYmFjayA9IChuYW1lKSA9PiBgJHtuYW1lfSRgO1xuLyoqXG4gKiBXaWxsIHdyYXAgbmFtZXMgdGhhdCBhcmUgT2JqZWN0IHByb3RvdHlwZSBwcm9wZXJ0aWVzIG9yIG5hbWVzIHJlc2VydmVkXG4gKiBmb3IgYE1lc3NhZ2Vgcy5cbiAqL1xuY29uc3Qgc2FmZU1lc3NhZ2VQcm9wZXJ0eSA9IChuYW1lKSA9PiB7XG4gICAgaWYgKHJlc2VydmVkTWVzc2FnZVByb3BlcnRpZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFjayhuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59O1xuLyoqXG4gKiBOYW1lcyB0aGF0IGNhbm5vdCBiZSB1c2VkIGZvciBvYmplY3QgcHJvcGVydGllcyBiZWNhdXNlIHRoZXkgYXJlIHJlc2VydmVkXG4gKiBieSBidWlsdC1pbiBKYXZhU2NyaXB0IHByb3BlcnRpZXMuXG4gKi9cbmNvbnN0IHNhZmVPYmplY3RQcm9wZXJ0eSA9IChuYW1lKSA9PiB7XG4gICAgaWYgKHJlc2VydmVkT2JqZWN0UHJvcGVydGllcy5oYXMobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn07XG4vKipcbiAqIE5hbWVzIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGlkZW50aWZpZXJzIG9yIGNsYXNzIHByb3BlcnRpZXNcbiAqL1xuY29uc3Qgc2FmZUlkZW50aWZpZXIgPSAobmFtZSkgPT4ge1xuICAgIGlmIChyZXNlcnZlZElkZW50aWZpZXJzLmhhcyhuYW1lKSkge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2sobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDkzOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4gIEY6ICgpID0+ICgvKiBiaW5kaW5nICovIG1ha2VQcm90b1J1bnRpbWUpXG59KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9lbnVtLmpzXG52YXIgcHJpdmF0ZV9lbnVtID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MDkpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vbWVzc2FnZS5qc1xudmFyIG1lc3NhZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2MSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3ByaXZhdGUvbWVzc2FnZS10eXBlLmpzXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBtZXNzYWdlIHR5cGUgdXNpbmcgdGhlIGdpdmVuIHJ1bnRpbWUuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNZXNzYWdlVHlwZShydW50aW1lLCB0eXBlTmFtZSwgZmllbGRzLCBvcHQpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbG9jYWxOYW1lID0gKF9hID0gb3B0ID09PSBudWxsIHx8IG9wdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0LmxvY2FsTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHlwZU5hbWUuc3Vic3RyaW5nKHR5cGVOYW1lLmxhc3RJbmRleE9mKFwiLlwiKSArIDEpO1xuICAgIGNvbnN0IHR5cGUgPSB7XG4gICAgICAgIFtsb2NhbE5hbWVdOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgcnVudGltZS51dGlsLmluaXRGaWVsZHModGhpcyk7XG4gICAgICAgICAgICBydW50aW1lLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gICAgICAgIH0sXG4gICAgfVtsb2NhbE5hbWVdO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0eXBlLnByb3RvdHlwZSwgbmV3IG1lc3NhZ2UvKiBNZXNzYWdlICovLnYoKSk7XG4gICAgT2JqZWN0LmFzc2lnbih0eXBlLCB7XG4gICAgICAgIHJ1bnRpbWUsXG4gICAgICAgIHR5cGVOYW1lLFxuICAgICAgICBmaWVsZHM6IHJ1bnRpbWUudXRpbC5uZXdGaWVsZExpc3QoZmllbGRzKSxcbiAgICAgICAgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0eXBlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0eXBlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0eXBlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVxdWFscyhhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gcnVudGltZS51dGlsLmVxdWFscyh0eXBlLCBhLCBiKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gdHlwZTtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL3Byb3RvLXJ1bnRpbWUuanNcbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cblxuZnVuY3Rpb24gbWFrZVByb3RvUnVudGltZShzeW50YXgsIGpzb24sIGJpbiwgdXRpbCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN5bnRheCxcbiAgICAgICAganNvbixcbiAgICAgICAgYmluLFxuICAgICAgICB1dGlsLFxuICAgICAgICBtYWtlTWVzc2FnZVR5cGUodHlwZU5hbWUsIGZpZWxkcywgb3B0KSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZU1lc3NhZ2VUeXBlKHRoaXMsIHR5cGVOYW1lLCBmaWVsZHMsIG9wdCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1ha2VFbnVtOiBwcml2YXRlX2VudW0vKiBtYWtlRW51bSAqLy51dCxcbiAgICAgICAgbWFrZUVudW1UeXBlOiBwcml2YXRlX2VudW0vKiBtYWtlRW51bVR5cGUgKi8uYmUsXG4gICAgICAgIGdldEVudW1UeXBlOiBwcml2YXRlX2VudW0vKiBnZXRFbnVtVHlwZSAqLy5WMyxcbiAgICB9O1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3ODE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEFBOiAoKSA9PiAoLyogYmluZGluZyAqLyBzY2FsYXJFcXVhbHMpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBUMTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gc2NhbGFyVHlwZUluZm8pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBrWTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gc2NhbGFyRGVmYXVsdFZhbHVlKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2NSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JpbmFyeV9lbmNvZGluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3Byb3RvX2ludDY0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxMCk7XG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYm90aCBzY2FsYXIgdmFsdWVzIGFyZSBlcXVhbC5cbiAqL1xuZnVuY3Rpb24gc2NhbGFyRXF1YWxzKHR5cGUsIGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAvLyBUaGlzIGNvcnJlY3RseSBtYXRjaGVzIGVxdWFsIHZhbHVlcyBleGNlcHQgQllURVMgYW5kIChwb3NzaWJseSkgNjQtYml0IGludGVnZXJzLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gU3BlY2lhbCBjYXNlIEJZVEVTIC0gd2UgbmVlZCB0byBjb21wYXJlIGVhY2ggYnl0ZSBpbmRpdmlkdWFsbHlcbiAgICBpZiAodHlwZSA9PSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5TY2FsYXJUeXBlICovIC53LkJZVEVTKSB7XG4gICAgICAgIGlmICghKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB8fCAhKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBTcGVjaWFsIGNhc2UgNjQtYml0IGludGVnZXJzIC0gd2Ugc3VwcG9ydCBudW1iZXIsIHN0cmluZyBhbmQgYmlnaW50IHJlcHJlc2VudGF0aW9uLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAuU2NhbGFyVHlwZSAqLyAudy5VSU5UNjQ6XG4gICAgICAgIGNhc2UgX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAuU2NhbGFyVHlwZSAqLyAudy5GSVhFRDY0OlxuICAgICAgICBjYXNlIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLlNjYWxhclR5cGUgKi8gLncuSU5UNjQ6XG4gICAgICAgIGNhc2UgX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAuU2NhbGFyVHlwZSAqLyAudy5TRklYRUQ2NDpcbiAgICAgICAgY2FzZSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5TY2FsYXJUeXBlICovIC53LlNJTlQ2NDpcbiAgICAgICAgICAgIC8vIExvb3NlIGNvbXBhcmlzb24gd2lsbCBtYXRjaCBiZXR3ZWVuIDBuLCAwIGFuZCBcIjBcIi5cbiAgICAgICAgICAgIHJldHVybiBhID09IGI7XG4gICAgfVxuICAgIC8vIEFueXRoaW5nIHRoYXQgaGFzbid0IGJlZW4gY2F1Z2h0IGJ5IHN0cmljdCBjb21wYXJpc29uIG9yIHNwZWNpYWwgY2FzZWRcbiAgICAvLyBCWVRFUyBhbmQgNjQtYml0IGludGVnZXJzIGlzIG5vdCBlcXVhbC5cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBnaXZlbiBzY2FsYXIgdHlwZSwgZm9sbG93aW5nXG4gKiBwcm90bzMgc2VtYW50aWNzLlxuICovXG5mdW5jdGlvbiBzY2FsYXJEZWZhdWx0VmFsdWUodHlwZSwgbG9uZ1R5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5TY2FsYXJUeXBlICovIC53LkJPT0w6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNhc2UgX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAuU2NhbGFyVHlwZSAqLyAudy5VSU5UNjQ6XG4gICAgICAgIGNhc2UgX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAuU2NhbGFyVHlwZSAqLyAudy5GSVhFRDY0OlxuICAgICAgICBjYXNlIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLlNjYWxhclR5cGUgKi8gLncuSU5UNjQ6XG4gICAgICAgIGNhc2UgX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAuU2NhbGFyVHlwZSAqLyAudy5TRklYRUQ2NDpcbiAgICAgICAgY2FzZSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5TY2FsYXJUeXBlICovIC53LlNJTlQ2NDpcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvbiAtLSBhY2NlcHRhYmxlIHNpbmNlIGl0J3MgY292ZXJlZCBieSB0ZXN0c1xuICAgICAgICAgICAgcmV0dXJuIGxvbmdUeXBlID09IDAgPyBfcHJvdG9faW50NjRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5wcm90b0ludDY0ICovIC5xLnplcm8gOiBcIjBcIjtcbiAgICAgICAgY2FzZSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5TY2FsYXJUeXBlICovIC53LkRPVUJMRTpcbiAgICAgICAgY2FzZSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5TY2FsYXJUeXBlICovIC53LkZMT0FUOlxuICAgICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgY2FzZSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5TY2FsYXJUeXBlICovIC53LkJZVEVTOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICBjYXNlIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLlNjYWxhclR5cGUgKi8gLncuU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBIYW5kbGVzIElOVDMyLCBVSU5UMzIsIFNJTlQzMiwgRklYRUQzMiwgU0ZJWEVEMzIuXG4gICAgICAgICAgICAvLyBXZSBkbyBub3QgdXNlIGluZGl2aWR1YWwgY2FzZXMgdG8gc2F2ZSBhIGZldyBieXRlcyBjb2RlIHNpemUuXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG4vKipcbiAqIEdldCBpbmZvcm1hdGlvbiBmb3Igd3JpdGluZyBhIHNjYWxhciB2YWx1ZS5cbiAqXG4gKiBSZXR1cm5zIHR1cGxlOlxuICogWzBdOiBhcHByb3ByaWF0ZSBXaXJlVHlwZVxuICogWzFdOiBuYW1lIG9mIHRoZSBhcHByb3ByaWF0ZSBtZXRob2Qgb2YgSUJpbmFyeVdyaXRlclxuICogWzJdOiB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGRlZmF1bHQgdmFsdWUgZm9yIHByb3RvMyBzZW1hbnRpY3NcbiAqXG4gKiBJZiBhcmd1bWVudCBgdmFsdWVgIGlzIG9taXR0ZWQsIFsyXSBpcyBhbHdheXMgZmFsc2UuXG4gKi9cbmZ1bmN0aW9uIHNjYWxhclR5cGVJbmZvKHR5cGUsIHZhbHVlKSB7XG4gICAgY29uc3QgaXNVbmRlZmluZWQgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuICAgIGxldCB3aXJlVHlwZSA9IF9iaW5hcnlfZW5jb2RpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy8qIC5XaXJlVHlwZSAqLyAuVEQuVmFyaW50O1xuICAgIGxldCBpc0ludHJpbnNpY0RlZmF1bHQgPSB2YWx1ZSA9PT0gMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVjayAtLSBJTlQzMiwgVUlOVDMyLCBTSU5UMzIgYXJlIGNvdmVyZWQgYnkgdGhlIGRlZmF1bHRzXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAuU2NhbGFyVHlwZSAqLyAudy5TVFJJTkc6XG4gICAgICAgICAgICBpc0ludHJpbnNpY0RlZmF1bHQgPSBpc1VuZGVmaW5lZCB8fCAhdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgd2lyZVR5cGUgPSBfYmluYXJ5X2VuY29kaW5nX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18vKiAuV2lyZVR5cGUgKi8gLlRELkxlbmd0aERlbGltaXRlZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLlNjYWxhclR5cGUgKi8gLncuQk9PTDpcbiAgICAgICAgICAgIGlzSW50cmluc2ljRGVmYXVsdCA9IHZhbHVlID09PSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLlNjYWxhclR5cGUgKi8gLncuRE9VQkxFOlxuICAgICAgICAgICAgd2lyZVR5cGUgPSBfYmluYXJ5X2VuY29kaW5nX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18vKiAuV2lyZVR5cGUgKi8gLlRELkJpdDY0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAuU2NhbGFyVHlwZSAqLyAudy5GTE9BVDpcbiAgICAgICAgICAgIHdpcmVUeXBlID0gX2JpbmFyeV9lbmNvZGluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLyogLldpcmVUeXBlICovIC5URC5CaXQzMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLlNjYWxhclR5cGUgKi8gLncuSU5UNjQ6XG4gICAgICAgICAgICBpc0ludHJpbnNpY0RlZmF1bHQgPSBpc1VuZGVmaW5lZCB8fCB2YWx1ZSA9PSAwOyAvLyBMb29zZSBjb21wYXJpc29uIG1hdGNoZXMgMG4sIDAgYW5kIFwiMFwiXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5TY2FsYXJUeXBlICovIC53LlVJTlQ2NDpcbiAgICAgICAgICAgIGlzSW50cmluc2ljRGVmYXVsdCA9IGlzVW5kZWZpbmVkIHx8IHZhbHVlID09IDA7IC8vIExvb3NlIGNvbXBhcmlzb24gbWF0Y2hlcyAwbiwgMCBhbmQgXCIwXCJcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLlNjYWxhclR5cGUgKi8gLncuRklYRUQ2NDpcbiAgICAgICAgICAgIGlzSW50cmluc2ljRGVmYXVsdCA9IGlzVW5kZWZpbmVkIHx8IHZhbHVlID09IDA7IC8vIExvb3NlIGNvbXBhcmlzb24gbWF0Y2hlcyAwbiwgMCBhbmQgXCIwXCJcbiAgICAgICAgICAgIHdpcmVUeXBlID0gX2JpbmFyeV9lbmNvZGluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLyogLldpcmVUeXBlICovIC5URC5CaXQ2NDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLlNjYWxhclR5cGUgKi8gLncuQllURVM6XG4gICAgICAgICAgICBpc0ludHJpbnNpY0RlZmF1bHQgPSBpc1VuZGVmaW5lZCB8fCAhdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIHdpcmVUeXBlID0gX2JpbmFyeV9lbmNvZGluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLyogLldpcmVUeXBlICovIC5URC5MZW5ndGhEZWxpbWl0ZWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5TY2FsYXJUeXBlICovIC53LkZJWEVEMzI6XG4gICAgICAgICAgICB3aXJlVHlwZSA9IF9iaW5hcnlfZW5jb2RpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy8qIC5XaXJlVHlwZSAqLyAuVEQuQml0MzI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5TY2FsYXJUeXBlICovIC53LlNGSVhFRDMyOlxuICAgICAgICAgICAgd2lyZVR5cGUgPSBfYmluYXJ5X2VuY29kaW5nX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18vKiAuV2lyZVR5cGUgKi8gLlRELkJpdDMyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAuU2NhbGFyVHlwZSAqLyAudy5TRklYRUQ2NDpcbiAgICAgICAgICAgIGlzSW50cmluc2ljRGVmYXVsdCA9IGlzVW5kZWZpbmVkIHx8IHZhbHVlID09IDA7XG4gICAgICAgICAgICB3aXJlVHlwZSA9IF9iaW5hcnlfZW5jb2RpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy8qIC5XaXJlVHlwZSAqLyAuVEQuQml0NjQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5TY2FsYXJUeXBlICovIC53LlNJTlQ2NDpcbiAgICAgICAgICAgIGlzSW50cmluc2ljRGVmYXVsdCA9IGlzVW5kZWZpbmVkIHx8IHZhbHVlID09IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgbWV0aG9kID0gX2ZpZWxkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAuU2NhbGFyVHlwZSAqLyAud1t0eXBlXS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBbd2lyZVR5cGUsIG1ldGhvZCwgaXNVbmRlZmluZWQgfHwgaXNJbnRyaW5zaWNEZWZhdWx0XTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDMzOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBmOiAoKSA9PiAoLyogYmluZGluZyAqLyBtYWtlVXRpbENvbW1vbilcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lbnVtX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwOSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21lc3NhZ2VfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNTYxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDY1KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2NhbGFyc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3ODEpO1xuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuXG5cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQsbm8tY2FzZS1kZWNsYXJhdGlvbnMgKi9cbmZ1bmN0aW9uIG1ha2VVdGlsQ29tbW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNldEVudW1UeXBlOiBfZW51bV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLnNldEVudW1UeXBlICovIC56ZyxcbiAgICAgICAgaW5pdFBhcnRpYWwoc291cmNlLCB0YXJnZXQpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB0YXJnZXQuZ2V0VHlwZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdHlwZS5maWVsZHMuYnlNZW1iZXIoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsTmFtZSA9IG1lbWJlci5sb2NhbE5hbWUsIHQgPSB0YXJnZXQsIHMgPSBzb3VyY2U7XG4gICAgICAgICAgICAgICAgaWYgKHNbbG9jYWxOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1lbWJlci5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvbmVvZlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2sgPSBzW2xvY2FsTmFtZV0uY2FzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VGaWVsZCA9IG1lbWJlci5maW5kRmllbGQoc2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IHNbbG9jYWxOYW1lXS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VGaWVsZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUZpZWxkLmtpbmQgPT0gXCJtZXNzYWdlXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKHZhbCBpbnN0YW5jZW9mIHNvdXJjZUZpZWxkLlQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gbmV3IHNvdXJjZUZpZWxkLlQodmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNvdXJjZUZpZWxkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlRmllbGQua2luZCA9PT0gXCJzY2FsYXJcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUZpZWxkLlQgPT09IF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLlNjYWxhclR5cGUgKi8gLncuQllURVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB0b1U4QXJyKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSB7IGNhc2U6IHNrLCB2YWx1ZTogdmFsIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvcHkgPSBzW2xvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVtYmVyLlQgPT09IF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLlNjYWxhclR5cGUgKi8gLncuQllURVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5ID0gbWVtYmVyLnJlcGVhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY29weS5tYXAodG9VOEFycilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0b1U4QXJyKGNvcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0gY29weTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1lbWJlci5WLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlci5WLlQgPT09IF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLlNjYWxhclR5cGUgKi8gLncuQllURVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHNbbG9jYWxOYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV1ba10gPSB0b1U4QXJyKHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0W2xvY2FsTmFtZV0sIHNbbG9jYWxOYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBtZW1iZXIuVi5UO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXMoc1tsb2NhbE5hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IHNbbG9jYWxOYW1lXVtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSB0YWtlIHBhcnRpYWwgaW5wdXQgZm9yIG1lc3NhZ2VzIHRoYXQgYXJlIG5vdCBhIHdyYXBwZXIgdHlwZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3IgdGhvc2UgbWVzc2FnZXMsIHdlIHJlY3Vyc2l2ZWx5IG5vcm1hbGl6ZSB0aGUgcGFydGlhbCBpbnB1dC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBuZXcgbWVzc2FnZVR5cGUodmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRbbG9jYWxOYW1lXVtrXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbXQgPSBtZW1iZXIuVDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZW1iZXIucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSBzW2xvY2FsTmFtZV0ubWFwKCh2YWwpID0+IHZhbCBpbnN0YW5jZW9mIG10ID8gdmFsIDogbmV3IG10KHZhbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc1tsb2NhbE5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBzW2xvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG10LmZpZWxkV3JhcHBlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbid0IHVzZSBCeXRlc1ZhbHVlLnR5cGVOYW1lIGFzIHRoYXQgd2lsbCBjcmVhdGUgYSBjaXJjdWxhciBpbXBvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXQudHlwZU5hbWUgPT09IFwiZ29vZ2xlLnByb3RvYnVmLkJ5dGVzVmFsdWVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0gdG9VOEFycih2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSB2YWwgaW5zdGFuY2VvZiBtdCA/IHZhbCA6IG5ldyBtdCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXF1YWxzKHR5cGUsIGEsIGIpIHtcbiAgICAgICAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWEgfHwgIWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZS5maWVsZHMuYnlNZW1iZXIoKS5ldmVyeSgobSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhID0gYVttLmxvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgY29uc3QgdmIgPSBiW20ubG9jYWxOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAobS5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmEubGVuZ3RoICE9PSB2Yi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVjayAtLSByZXBlYXRlZCBmaWVsZHMgYXJlIG5ldmVyIFwibWFwXCJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhLmV2ZXJ5KChhLCBpKSA9PiBtLlQuZXF1YWxzKGEsIHZiW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhLmV2ZXJ5KChhLCBpKSA9PiAoMCxfc2NhbGFyc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLyogLnNjYWxhckVxdWFscyAqLyAuQUEpKG0uVCwgYSwgdmJbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhLmV2ZXJ5KChhLCBpKSA9PiAoMCxfc2NhbGFyc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLyogLnNjYWxhckVxdWFscyAqLyAuQUEpKF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLlNjYWxhclR5cGUgKi8gLncuSU5UMzIsIGEsIHZiW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByZXBlYXRlZCBjYW5ub3QgY29udGFpbiAke20ua2luZH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChtLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtLlQuZXF1YWxzKHZhLCB2Yik7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsX3NjYWxhcnNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy8qIC5zY2FsYXJFcXVhbHMgKi8gLkFBKShfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5TY2FsYXJUeXBlICovIC53LklOVDMyLCB2YSwgdmIpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsX3NjYWxhcnNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy8qIC5zY2FsYXJFcXVhbHMgKi8gLkFBKShtLlQsIHZhLCB2Yik7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvbmVvZlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhLmNhc2UgIT09IHZiLmNhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzID0gbS5maW5kRmllbGQodmEuY2FzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVjayAtLSBvbmVvZiBmaWVsZHMgYXJlIG5ldmVyIFwibWFwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocy5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMuVC5lcXVhbHModmEudmFsdWUsIHZiLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsX3NjYWxhcnNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy8qIC5zY2FsYXJFcXVhbHMgKi8gLkFBKShfZmllbGRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5TY2FsYXJUeXBlICovIC53LklOVDMyLCB2YS52YWx1ZSwgdmIudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLF9zY2FsYXJzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18vKiAuc2NhbGFyRXF1YWxzICovIC5BQSkocy5ULCB2YS52YWx1ZSwgdmIudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvbmVvZiBjYW5ub3QgY29udGFpbiAke3Mua2luZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhKS5jb25jYXQoT2JqZWN0LmtleXModmIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobS5WLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlVHlwZSA9IG0uVi5UO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5ldmVyeSgoaykgPT4gbWVzc2FnZVR5cGUuZXF1YWxzKHZhW2tdLCB2YltrXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmV2ZXJ5KChrKSA9PiAoMCxfc2NhbGFyc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLyogLnNjYWxhckVxdWFscyAqLyAuQUEpKF9maWVsZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLlNjYWxhclR5cGUgKi8gLncuSU5UMzIsIHZhW2tdLCB2YltrXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NhbGFyVHlwZSA9IG0uVi5UO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5ldmVyeSgoaykgPT4gKDAsX3NjYWxhcnNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy8qIC5zY2FsYXJFcXVhbHMgKi8gLkFBKShzY2FsYXJUeXBlLCB2YVtrXSwgdmJba10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjbG9uZShtZXNzYWdlKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5nZXRUeXBlKCksIHRhcmdldCA9IG5ldyB0eXBlKCksIGFueSA9IHRhcmdldDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIHR5cGUuZmllbGRzLmJ5TWVtYmVyKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBtZXNzYWdlW21lbWJlci5sb2NhbE5hbWVdO1xuICAgICAgICAgICAgICAgIGxldCBjb3B5O1xuICAgICAgICAgICAgICAgIGlmIChtZW1iZXIucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29weSA9IHNvdXJjZS5tYXAoY2xvbmVTaW5ndWxhckZpZWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWVtYmVyLmtpbmQgPT0gXCJtYXBcIikge1xuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gYW55W21lbWJlci5sb2NhbE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZdIG9mIE9iamVjdC5lbnRyaWVzKHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlba2V5XSA9IGNsb25lU2luZ3VsYXJGaWVsZCh2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtZW1iZXIua2luZCA9PSBcIm9uZW9mXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZiA9IG1lbWJlci5maW5kRmllbGQoc291cmNlLmNhc2UpO1xuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gZlxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7IGNhc2U6IHNvdXJjZS5jYXNlLCB2YWx1ZTogY2xvbmVTaW5ndWxhckZpZWxkKHNvdXJjZS52YWx1ZSkgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7IGNhc2U6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29weSA9IGNsb25lU2luZ3VsYXJGaWVsZChzb3VyY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbnlbbWVtYmVyLmxvY2FsTmFtZV0gPSBjb3B5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8gY2xvbmUgYSBzaW5nbGUgZmllbGQgdmFsdWUgLSBpLmUuIHRoZSBlbGVtZW50IHR5cGUgb2YgcmVwZWF0ZWQgZmllbGRzLCB0aGUgdmFsdWUgdHlwZSBvZiBtYXBzXG5mdW5jdGlvbiBjbG9uZVNpbmd1bGFyRmllbGQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIF9tZXNzYWdlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18vKiAuTWVzc2FnZSAqLyAudikge1xuICAgICAgICByZXR1cm4gdmFsdWUuY2xvbmUoKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBjb25zdCBjID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGMuc2V0KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8vIGNvbnZlcnRzIGFueSBBcnJheUxpa2U8bnVtYmVyPiB0byBVaW50OEFycmF5IGlmIG5lY2Vzc2FyeS5cbmZ1bmN0aW9uIHRvVThBcnIoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gaW5wdXQgOiBuZXcgVWludDhBcnJheShpbnB1dCk7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDIzNjpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19fX3dlYnBhY2tfbW9kdWxlX18sIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gcHJvdG9CYXNlNjQpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb24sIHByZWZlci1jb25zdCAqL1xuLy8gbG9va3VwIHRhYmxlIGZyb20gYmFzZTY0IGNoYXJhY3RlciB0byBieXRlXG5sZXQgZW5jVGFibGUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIi5zcGxpdChcIlwiKTtcbi8vIGxvb2t1cCB0YWJsZSBmcm9tIGJhc2U2NCBjaGFyYWN0ZXIgKmNvZGUqIHRvIGJ5dGUgYmVjYXVzZSBsb29rdXAgYnkgbnVtYmVyIGlzIGZhc3RcbmxldCBkZWNUYWJsZSA9IFtdO1xuZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNUYWJsZS5sZW5ndGg7IGkrKylcbiAgICBkZWNUYWJsZVtlbmNUYWJsZVtpXS5jaGFyQ29kZUF0KDApXSA9IGk7XG4vLyBzdXBwb3J0IGJhc2U2NHVybCB2YXJpYW50c1xuZGVjVGFibGVbXCItXCIuY2hhckNvZGVBdCgwKV0gPSBlbmNUYWJsZS5pbmRleE9mKFwiK1wiKTtcbmRlY1RhYmxlW1wiX1wiLmNoYXJDb2RlQXQoMCldID0gZW5jVGFibGUuaW5kZXhPZihcIi9cIik7XG5jb25zdCBwcm90b0Jhc2U2NCA9IHtcbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGEgYmFzZTY0IHN0cmluZyB0byBhIGJ5dGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiAtIGlnbm9yZXMgd2hpdGUtc3BhY2UsIGluY2x1ZGluZyBsaW5lIGJyZWFrcyBhbmQgdGFic1xuICAgICAqIC0gYWxsb3dzIGlubmVyIHBhZGRpbmcgKGNhbiBkZWNvZGUgY29uY2F0ZW5hdGVkIGJhc2U2NCBzdHJpbmdzKVxuICAgICAqIC0gZG9lcyBub3QgcmVxdWlyZSBwYWRkaW5nXG4gICAgICogLSB1bmRlcnN0YW5kcyBiYXNlNjR1cmwgZW5jb2Rpbmc6XG4gICAgICogICBcIi1cIiBpbnN0ZWFkIG9mIFwiK1wiLFxuICAgICAqICAgXCJfXCIgaW5zdGVhZCBvZiBcIi9cIixcbiAgICAgKiAgIG5vIHBhZGRpbmdcbiAgICAgKi9cbiAgICBkZWMoYmFzZTY0U3RyKSB7XG4gICAgICAgIC8vIGVzdGltYXRlIGJ5dGUgc2l6ZSwgbm90IGFjY291bnRpbmcgZm9yIGlubmVyIHBhZGRpbmcgYW5kIHdoaXRlc3BhY2VcbiAgICAgICAgbGV0IGVzID0gKGJhc2U2NFN0ci5sZW5ndGggKiAzKSAvIDQ7XG4gICAgICAgIGlmIChiYXNlNjRTdHJbYmFzZTY0U3RyLmxlbmd0aCAtIDJdID09IFwiPVwiKVxuICAgICAgICAgICAgZXMgLT0gMjtcbiAgICAgICAgZWxzZSBpZiAoYmFzZTY0U3RyW2Jhc2U2NFN0ci5sZW5ndGggLSAxXSA9PSBcIj1cIilcbiAgICAgICAgICAgIGVzIC09IDE7XG4gICAgICAgIGxldCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGVzKSwgYnl0ZVBvcyA9IDAsIC8vIHBvc2l0aW9uIGluIGJ5dGUgYXJyYXlcbiAgICAgICAgZ3JvdXBQb3MgPSAwLCAvLyBwb3NpdGlvbiBpbiBiYXNlNjQgZ3JvdXBcbiAgICAgICAgYiwgLy8gY3VycmVudCBieXRlXG4gICAgICAgIHAgPSAwOyAvLyBwcmV2aW91cyBieXRlXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFzZTY0U3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBiID0gZGVjVGFibGVbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSldO1xuICAgICAgICAgICAgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYmFzZTY0U3RyW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgVFM3MDI5OiBGYWxsdGhyb3VnaCBjYXNlIGluIHN3aXRjaFxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiPVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBQb3MgPSAwOyAvLyByZXNldCBzdGF0ZSB3aGVuIHBhZGRpbmcgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBUUzcwMjk6IEZhbGx0aHJvdWdoIGNhc2UgaW4gc3dpdGNoXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJcXG5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlxcclwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXFx0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCIgXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCB3aGl0ZS1zcGFjZSwgYW5kIHBhZGRpbmdcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaW52YWxpZCBiYXNlNjQgc3RyaW5nLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGdyb3VwUG9zKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBwID0gYjtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBQb3MgPSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzW2J5dGVQb3MrK10gPSAocCA8PCAyKSB8ICgoYiAmIDQ4KSA+PiA0KTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IGI7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBieXRlc1tieXRlUG9zKytdID0gKChwICYgMTUpIDw8IDQpIHwgKChiICYgNjApID4+IDIpO1xuICAgICAgICAgICAgICAgICAgICBwID0gYjtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBQb3MgPSAzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzW2J5dGVQb3MrK10gPSAoKHAgJiAzKSA8PCA2KSB8IGI7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwUG9zID09IDEpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgYmFzZTY0IHN0cmluZy5cIik7XG4gICAgICAgIHJldHVybiBieXRlcy5zdWJhcnJheSgwLCBieXRlUG9zKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuY29kZSBhIGJ5dGUgYXJyYXkgdG8gYSBiYXNlNjQgc3RyaW5nLlxuICAgICAqL1xuICAgIGVuYyhieXRlcykge1xuICAgICAgICBsZXQgYmFzZTY0ID0gXCJcIiwgZ3JvdXBQb3MgPSAwLCAvLyBwb3NpdGlvbiBpbiBiYXNlNjQgZ3JvdXBcbiAgICAgICAgYiwgLy8gY3VycmVudCBieXRlXG4gICAgICAgIHAgPSAwOyAvLyBjYXJyeSBvdmVyIGZyb20gcHJldmlvdXMgYnl0ZVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBiID0gYnl0ZXNbaV07XG4gICAgICAgICAgICBzd2l0Y2ggKGdyb3VwUG9zKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbYiA+PiAyXTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IChiICYgMykgPDwgNDtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBQb3MgPSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtwIHwgKGIgPj4gNCldO1xuICAgICAgICAgICAgICAgICAgICBwID0gKGIgJiAxNSkgPDwgMjtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBQb3MgPSAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtwIHwgKGIgPj4gNildO1xuICAgICAgICAgICAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbYiAmIDYzXTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBQb3MgPSAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgb3V0cHV0IHBhZGRpbmdcbiAgICAgICAgaWYgKGdyb3VwUG9zKSB7XG4gICAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbcF07XG4gICAgICAgICAgICBiYXNlNjQgKz0gXCI9XCI7XG4gICAgICAgICAgICBpZiAoZ3JvdXBQb3MgPT0gMSlcbiAgICAgICAgICAgICAgICBiYXNlNjQgKz0gXCI9XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2U2NDtcbiAgICB9LFxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjEwOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBxOiAoKSA9PiAoLyogYmluZGluZyAqLyBwcm90b0ludDY0KVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3ByaXZhdGVfYXNzZXJ0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dvb2dsZV92YXJpbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oODE4KTtcbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cblxuZnVuY3Rpb24gbWFrZUludDY0U3VwcG9ydCgpIHtcbiAgICBjb25zdCBkdiA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoOCkpO1xuICAgIC8vIG5vdGUgdGhhdCBTYWZhcmkgMTQgaW1wbGVtZW50cyBCaWdJbnQsIGJ1dCBub3QgdGhlIERhdGFWaWV3IG1ldGhvZHNcbiAgICBjb25zdCBvayA9IHR5cGVvZiBCaWdJbnQgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2YgZHYuZ2V0QmlnSW50NjQgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2YgZHYuZ2V0QmlnVWludDY0ID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgdHlwZW9mIGR2LnNldEJpZ0ludDY0ID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgdHlwZW9mIGR2LnNldEJpZ1VpbnQ2NCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICh0eXBlb2YgcHJvY2VzcyAhPSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICB0eXBlb2YgcHJvY2Vzcy5lbnYgIT0gXCJvYmplY3RcIiB8fFxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuQlVGX0JJR0lOVF9ESVNBQkxFICE9PSBcIjFcIik7XG4gICAgaWYgKG9rKSB7XG4gICAgICAgIGNvbnN0IE1JTiA9IEJpZ0ludChcIi05MjIzMzcyMDM2ODU0Nzc1ODA4XCIpLCBNQVggPSBCaWdJbnQoXCI5MjIzMzcyMDM2ODU0Nzc1ODA3XCIpLCBVTUlOID0gQmlnSW50KFwiMFwiKSwgVU1BWCA9IEJpZ0ludChcIjE4NDQ2NzQ0MDczNzA5NTUxNjE1XCIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgemVybzogQmlnSW50KDApLFxuICAgICAgICAgICAgc3VwcG9ydGVkOiB0cnVlLFxuICAgICAgICAgICAgcGFyc2UodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiaSA9IHR5cGVvZiB2YWx1ZSA9PSBcImJpZ2ludFwiID8gdmFsdWUgOiBCaWdJbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChiaSA+IE1BWCB8fCBiaSA8IE1JTikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludDY0IGludmFsaWQ6ICR7dmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiaTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1UGFyc2UodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiaSA9IHR5cGVvZiB2YWx1ZSA9PSBcImJpZ2ludFwiID8gdmFsdWUgOiBCaWdJbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChiaSA+IFVNQVggfHwgYmkgPCBVTUlOKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdWludDY0IGludmFsaWQ6ICR7dmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiaTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmModmFsdWUpIHtcbiAgICAgICAgICAgICAgICBkdi5zZXRCaWdJbnQ2NCgwLCB0aGlzLnBhcnNlKHZhbHVlKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbG86IGR2LmdldEludDMyKDAsIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICBoaTogZHYuZ2V0SW50MzIoNCwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1RW5jKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZHYuc2V0QmlnSW50NjQoMCwgdGhpcy51UGFyc2UodmFsdWUpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBsbzogZHYuZ2V0SW50MzIoMCwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgIGhpOiBkdi5nZXRJbnQzMig0LCB0cnVlKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlYyhsbywgaGkpIHtcbiAgICAgICAgICAgICAgICBkdi5zZXRJbnQzMigwLCBsbywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZHYuc2V0SW50MzIoNCwgaGksIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkdi5nZXRCaWdJbnQ2NCgwLCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1RGVjKGxvLCBoaSkge1xuICAgICAgICAgICAgICAgIGR2LnNldEludDMyKDAsIGxvLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBkdi5zZXRJbnQzMig0LCBoaSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGR2LmdldEJpZ1VpbnQ2NCgwLCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGFzc2VydEludDY0U3RyaW5nID0gKHZhbHVlKSA9PiAoMCxfcHJpdmF0ZV9hc3NlcnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5hc3NlcnQgKi8gLmh1KSgvXi0/WzAtOV0rJC8udGVzdCh2YWx1ZSksIGBpbnQ2NCBpbnZhbGlkOiAke3ZhbHVlfWApO1xuICAgIGNvbnN0IGFzc2VydFVJbnQ2NFN0cmluZyA9ICh2YWx1ZSkgPT4gKDAsX3ByaXZhdGVfYXNzZXJ0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAuYXNzZXJ0ICovIC5odSkoL15bMC05XSskLy50ZXN0KHZhbHVlKSwgYHVpbnQ2NCBpbnZhbGlkOiAke3ZhbHVlfWApO1xuICAgIHJldHVybiB7XG4gICAgICAgIHplcm86IFwiMFwiLFxuICAgICAgICBzdXBwb3J0ZWQ6IGZhbHNlLFxuICAgICAgICBwYXJzZSh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0SW50NjRTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB1UGFyc2UodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydFVJbnQ2NFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVuYyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0SW50NjRTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuICgwLF9nb29nbGVfdmFyaW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18vKiAuaW50NjRGcm9tU3RyaW5nICovIC5DWikodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICB1RW5jKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRVSW50NjRTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuICgwLF9nb29nbGVfdmFyaW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18vKiAuaW50NjRGcm9tU3RyaW5nICovIC5DWikodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBkZWMobG8sIGhpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsX2dvb2dsZV92YXJpbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5pbnQ2NFRvU3RyaW5nICovIC5BaykobG8sIGhpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdURlYyhsbywgaGkpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCxfZ29vZ2xlX3ZhcmludF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLnVJbnQ2NFRvU3RyaW5nICovIC5GZCkobG8sIGhpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuY29uc3QgcHJvdG9JbnQ2NCA9IG1ha2VJbnQ2NFN1cHBvcnQoKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODUwOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4gIHc6ICgpID0+ICgvKiBiaW5kaW5nICovIHByb3RvMylcbn0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL3Byb3RvLXJ1bnRpbWUuanMgKyAxIG1vZHVsZXNcbnZhciBwcm90b19ydW50aW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTMpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vZmllbGQuanNcbnZhciBlc21fZmllbGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2NSk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL2JpbmFyeS1mb3JtYXQtY29tbW9uLmpzXG52YXIgYmluYXJ5X2Zvcm1hdF9jb21tb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0NCk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3ByaXZhdGUvYmluYXJ5LWZvcm1hdC1wcm90bzMuanNcbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb24sIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9ucywgcHJlZmVyLWNvbnN0LCBuby1jYXNlLWRlY2xhcmF0aW9ucyAqL1xuZnVuY3Rpb24gbWFrZUJpbmFyeUZvcm1hdFByb3RvMygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoMCxiaW5hcnlfZm9ybWF0X2NvbW1vbi8qIG1ha2VCaW5hcnlGb3JtYXRDb21tb24gKi8uZ1kpKCkpLCB7IHdyaXRlTWVzc2FnZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBtZXNzYWdlLmdldFR5cGUoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZS5maWVsZHMuYnlOdW1iZXIoKSkge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSwgLy8gdGhpcyB3aWxsIGJlIG91ciBmaWVsZCB2YWx1ZSwgd2hldGhlciBpdCBpcyBtZW1iZXIgb2YgYSBvbmVvZiBvciByZWd1bGFyIGZpZWxkXG4gICAgICAgICAgICAgICAgcmVwZWF0ZWQgPSBmaWVsZC5yZXBlYXRlZCwgbG9jYWxOYW1lID0gZmllbGQubG9jYWxOYW1lO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5vbmVvZikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbmVvZiA9IG1lc3NhZ2VbZmllbGQub25lb2YubG9jYWxOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uZW9mLmNhc2UgIT09IGxvY2FsTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIGZpZWxkIGlzIG5vdCBzZWxlY3RlZCwgc2tpcFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb25lb2YudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1lc3NhZ2VbbG9jYWxOYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzY2FsYXJUeXBlID0gZmllbGQua2luZCA9PSBcImVudW1cIiA/IGVzbV9maWVsZC8qIFNjYWxhclR5cGUgKi8udy5JTlQzMiA6IGZpZWxkLlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQucGFja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLGJpbmFyeV9mb3JtYXRfY29tbW9uLyogd3JpdGVQYWNrZWQgKi8uSmopKHdyaXRlciwgc2NhbGFyVHlwZSwgZmllbGQubm8sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsYmluYXJ5X2Zvcm1hdF9jb21tb24vKiB3cml0ZVNjYWxhciAqLy5OTikod3JpdGVyLCBzY2FsYXJUeXBlLCBmaWVsZC5ubywgaXRlbSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCxiaW5hcnlfZm9ybWF0X2NvbW1vbi8qIHdyaXRlU2NhbGFyICovLk5OKSh3cml0ZXIsIHNjYWxhclR5cGUsIGZpZWxkLm5vLCB2YWx1ZSwgISFmaWVsZC5vbmVvZiB8fCBmaWVsZC5vcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLGJpbmFyeV9mb3JtYXRfY29tbW9uLyogd3JpdGVNZXNzYWdlRmllbGQgKi8ub1EpKHdyaXRlciwgb3B0aW9ucywgZmllbGQsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLGJpbmFyeV9mb3JtYXRfY29tbW9uLyogd3JpdGVNZXNzYWdlRmllbGQgKi8ub1EpKHdyaXRlciwgb3B0aW9ucywgZmllbGQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsYmluYXJ5X2Zvcm1hdF9jb21tb24vKiB3cml0ZU1hcEVudHJ5ICovLmdRKSh3cml0ZXIsIG9wdGlvbnMsIGZpZWxkLCBrZXksIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy53cml0ZVVua25vd25GaWVsZHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlVW5rbm93bkZpZWxkcyhtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfSB9KTtcbn1cblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9maWVsZC13cmFwcGVyLmpzXG52YXIgZmllbGRfd3JhcHBlciA9IF9fd2VicGFja19yZXF1aXJlX18oNDMyKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3ByaXZhdGUvYXNzZXJ0LmpzXG52YXIgYXNzZXJ0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjApO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9qc29uLWZvcm1hdC1jb21tb24uanNcbnZhciBqc29uX2Zvcm1hdF9jb21tb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxNCk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3ByaXZhdGUvanNvbi1mb3JtYXQtcHJvdG8zLmpzXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tY2FzZS1kZWNsYXJhdGlvbnMsIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzLEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm4sQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCAqL1xuZnVuY3Rpb24gbWFrZUpzb25Gb3JtYXRQcm90bzMoKSB7XG4gICAgcmV0dXJuICgwLGpzb25fZm9ybWF0X2NvbW1vbi8qIG1ha2VKc29uRm9ybWF0Q29tbW9uICovLmIpKCh3cml0ZUVudW0sIHdyaXRlU2NhbGFyKSA9PiB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB3cml0ZUZpZWxkKGZpZWxkLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGZpZWxkLmtpbmQgPT0gXCJtYXBcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGpzb25PYmogPSB7fTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtlbnRyeUtleSwgZW50cnlWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gd3JpdGVTY2FsYXIoZmllbGQuVi5ULCBlbnRyeVZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCxhc3NlcnQvKiBhc3NlcnQgKi8uaHUpKHZhbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uT2JqW2VudHJ5S2V5LnRvU3RyaW5nKCldID0gdmFsOyAvLyBKU09OIHN0YW5kYXJkIGFsbG93cyBvbmx5IChkb3VibGUgcXVvdGVkKSBzdHJpbmcgYXMgcHJvcGVydHkga2V5XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2VudHJ5S2V5LCBlbnRyeVZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBKU09OIHN0YW5kYXJkIGFsbG93cyBvbmx5IChkb3VibGUgcXVvdGVkKSBzdHJpbmcgYXMgcHJvcGVydHkga2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbk9ialtlbnRyeUtleS50b1N0cmluZygpXSA9IGVudHJ5VmFsdWUudG9Kc29uKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnVtVHlwZSA9IGZpZWxkLlYuVDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2VudHJ5S2V5LCBlbnRyeVZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCxhc3NlcnQvKiBhc3NlcnQgKi8uaHUpKGVudHJ5VmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgZW50cnlWYWx1ZSA9PSBcIm51bWJlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSB3cml0ZUVudW0oZW51bVR5cGUsIGVudHJ5VmFsdWUsIHRydWUsIG9wdGlvbnMuZW51bUFzSW50ZWdlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsYXNzZXJ0LyogYXNzZXJ0ICovLmh1KSh2YWwgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbk9ialtlbnRyeUtleS50b1N0cmluZygpXSA9IHZhbDsgLy8gSlNPTiBzdGFuZGFyZCBhbGxvd3Mgb25seSAoZG91YmxlIHF1b3RlZCkgc3RyaW5nIGFzIHByb3BlcnR5IGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzIHx8IE9iamVjdC5rZXlzKGpzb25PYmopLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyBqc29uT2JqXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBqc29uQXJyID0gW107XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uQXJyLnB1c2god3JpdGVTY2FsYXIoZmllbGQuVCwgdmFsdWVbaV0sIHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25BcnIucHVzaCh3cml0ZUVudW0oZmllbGQuVCwgdmFsdWVbaV0sIHRydWUsIG9wdGlvbnMuZW51bUFzSW50ZWdlcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbkFyci5wdXNoKCgwLGZpZWxkX3dyYXBwZXIvKiB3cmFwRmllbGQgKi8uRSkoZmllbGQuVCwgdmFsdWVbaV0pLnRvSnNvbihvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZW1pdERlZmF1bHRWYWx1ZXMgfHwganNvbkFyci5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgICAgID8ganNvbkFyclxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JpdGVTY2FsYXIoZmllbGQuVCwgdmFsdWUsICEhZmllbGQub25lb2YgfHwgZmllbGQub3B0IHx8IG9wdGlvbnMuZW1pdERlZmF1bHRWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlRW51bShmaWVsZC5ULCB2YWx1ZSwgISFmaWVsZC5vbmVvZiB8fCBmaWVsZC5vcHQgfHwgb3B0aW9ucy5lbWl0RGVmYXVsdFZhbHVlcywgb3B0aW9ucy5lbnVtQXNJbnRlZ2VyKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoMCxmaWVsZF93cmFwcGVyLyogd3JhcEZpZWxkICovLkUpKGZpZWxkLlQsIHZhbHVlKS50b0pzb24ob3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3ByaXZhdGUvdXRpbC1jb21tb24uanNcbnZhciB1dGlsX2NvbW1vbiA9IF9fd2VicGFja19yZXF1aXJlX18oNDMzKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3ByaXZhdGUvZmllbGQtbGlzdC5qc1xudmFyIGZpZWxkX2xpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwMSk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL3NjYWxhcnMuanNcbnZhciBzY2FsYXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3ODEpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9maWVsZC5qc1xudmFyIHByaXZhdGVfZmllbGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxNSk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL25hbWVzLmpzXG52YXIgbmFtZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwNCk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3Byb3RvMy5qc1xuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuXG5cblxuXG5cblxuXG5cbi8qKlxuICogUHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgbWVzc2FnZXMgZGVmaW5lZCB3aXRoIHRoZSBwcm90bzMgc3ludGF4LlxuICovXG5jb25zdCBwcm90bzMgPSAoMCxwcm90b19ydW50aW1lLyogbWFrZVByb3RvUnVudGltZSAqLy5GKShcInByb3RvM1wiLCBtYWtlSnNvbkZvcm1hdFByb3RvMygpLCBtYWtlQmluYXJ5Rm9ybWF0UHJvdG8zKCksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKDAsdXRpbF9jb21tb24vKiBtYWtlVXRpbENvbW1vbiAqLy5mKSgpKSwgeyBuZXdGaWVsZExpc3QoZmllbGRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgZmllbGRfbGlzdC8qIEludGVybmFsRmllbGRMaXN0ICovLmkoZmllbGRzLCBub3JtYWxpemVGaWVsZEluZm9zUHJvdG8zKTtcbiAgICB9LFxuICAgIGluaXRGaWVsZHModGFyZ2V0KSB7XG4gICAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIHRhcmdldC5nZXRUeXBlKCkuZmllbGRzLmJ5TWVtYmVyKCkpIHtcbiAgICAgICAgICAgIGlmIChtZW1iZXIub3B0KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbWVtYmVyLmxvY2FsTmFtZSwgdCA9IHRhcmdldDtcbiAgICAgICAgICAgIGlmIChtZW1iZXIucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICB0W25hbWVdID0gW107XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKG1lbWJlci5raW5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm9uZW9mXCI6XG4gICAgICAgICAgICAgICAgICAgIHRbbmFtZV0gPSB7IGNhc2U6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICB0W25hbWVdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgICAgICAgICB0W25hbWVdID0ge307XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgdFtuYW1lXSA9ICgwLHNjYWxhcnMvKiBzY2FsYXJEZWZhdWx0VmFsdWUgKi8ua1kpKG1lbWJlci5ULCBtZW1iZXIuTCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgIC8vIG1lc3NhZ2UgZmllbGRzIGFyZSBhbHdheXMgb3B0aW9uYWwgaW4gcHJvdG8zXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSB9KSk7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRmllbGRJbmZvc1Byb3RvMyhmaWVsZEluZm9zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGNvbnN0IHIgPSBbXTtcbiAgICBsZXQgbztcbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVvZiBmaWVsZEluZm9zID09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IGZpZWxkSW5mb3MoKVxuICAgICAgICA6IGZpZWxkSW5mb3MpIHtcbiAgICAgICAgY29uc3QgZiA9IGZpZWxkO1xuICAgICAgICBmLmxvY2FsTmFtZSA9ICgwLG5hbWVzLyogbG9jYWxGaWVsZE5hbWUgKi8uUnopKGZpZWxkLm5hbWUsIGZpZWxkLm9uZW9mICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBmLmpzb25OYW1lID0gKF9hID0gZmllbGQuanNvbk5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICgwLG5hbWVzLyogZmllbGRKc29uTmFtZSAqLy54MSkoZmllbGQubmFtZSk7XG4gICAgICAgIGYucmVwZWF0ZWQgPSAoX2IgPSBmaWVsZC5yZXBlYXRlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgICAgIGlmIChmaWVsZC5raW5kID09IFwic2NhbGFyXCIpIHtcbiAgICAgICAgICAgIGYuTCA9IChfYyA9IGZpZWxkLkwpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGVzbV9maWVsZC8qIExvbmdUeXBlICovLnAuQklHSU5UO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGRvIG5vdCBzdXJmYWNlIG9wdGlvbnMgYXQgdGhpcyB0aW1lXG4gICAgICAgIC8vIGYub3B0aW9ucyA9IGZpZWxkLm9wdGlvbnMgPz8gZW1wdHlSZWFkb25seU9iamVjdDtcbiAgICAgICAgaWYgKGZpZWxkLm9uZW9mICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9vbmFtZSA9IHR5cGVvZiBmaWVsZC5vbmVvZiA9PSBcInN0cmluZ1wiID8gZmllbGQub25lb2YgOiBmaWVsZC5vbmVvZi5uYW1lO1xuICAgICAgICAgICAgaWYgKCFvIHx8IG8ubmFtZSAhPSBvb25hbWUpIHtcbiAgICAgICAgICAgICAgICBvID0gbmV3IHByaXZhdGVfZmllbGQvKiBJbnRlcm5hbE9uZW9mSW5mbyAqLy5vKG9vbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmLm9uZW9mID0gbztcbiAgICAgICAgICAgIG8uYWRkRmllbGQoZik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJvdG8zIHNwZWNpZmljOlxuICAgICAgICBpZiAoZmllbGQua2luZCA9PSBcIm1lc3NhZ2VcIikge1xuICAgICAgICAgICAgZi5kZWxpbWl0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGcm9tIHRoZSBwcm90bzMgbGFuZ3VhZ2UgZ3VpZGU6XG4gICAgICAgIC8vID4gSW4gcHJvdG8zLCByZXBlYXRlZCBmaWVsZHMgb2Ygc2NhbGFyIG51bWVyaWMgdHlwZXMgYXJlIHBhY2tlZCBieSBkZWZhdWx0LlxuICAgICAgICAvLyBUaGlzIGluZm9ybWF0aW9uIGlzIGluY29tcGxldGUgLSBhY2NvcmRpbmcgdG8gdGhlIGNvbmZvcm1hbmNlIHRlc3RzLCBCT09MXG4gICAgICAgIC8vIGFuZCBFTlVNIGFyZSBwYWNrZWQgYnkgZGVmYXVsdCBhcyB3ZWxsLiBUaGlzIG1lYW5zIG9ubHkgU1RSSU5HIGFuZCBCWVRFU1xuICAgICAgICAvLyBhcmUgbm90IHBhY2tlZCBieSBkZWZhdWx0LCB3aGljaCBtYWtlcyBzZW5zZSBiZWNhdXNlIHRoZXkgYXJlIGxlbmd0aC1kZWxpbWl0ZWQuXG4gICAgICAgIGYucGFja2VkID1cbiAgICAgICAgICAgIChfZCA9IGZpZWxkLnBhY2tlZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogKGZpZWxkLmtpbmQgPT0gXCJlbnVtXCIgfHxcbiAgICAgICAgICAgICAgICAoZmllbGQua2luZCA9PSBcInNjYWxhclwiICYmXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLlQgIT0gZXNtX2ZpZWxkLyogU2NhbGFyVHlwZSAqLy53LkJZVEVTICYmXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLlQgIT0gZXNtX2ZpZWxkLyogU2NhbGFyVHlwZSAqLy53LlNUUklORykpO1xuICAgICAgICByLnB1c2goZik7XG4gICAgfVxuICAgIHJldHVybiByO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzMjg6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHQ6ICgpID0+ICgvKiBiaW5kaW5nICovIE1ldGhvZEtpbmQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICB3OiAoKSA9PiAoLyogYmluZGluZyAqLyBNZXRob2RJZGVtcG90ZW5jeSlcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogTWV0aG9kS2luZCByZXByZXNlbnRzIHRoZSBmb3VyIG1ldGhvZCB0eXBlcyB0aGF0IGNhbiBiZSBkZWNsYXJlZCBpblxuICogcHJvdG9idWYgd2l0aCB0aGUgYHN0cmVhbWAga2V5d29yZDpcbiAqXG4gKiAxLiBVbmFyeTogICAgICAgICAgIHJwYyAoSW5wdXQpIHJldHVybnMgKE91dHB1dClcbiAqIDIuIFNlcnZlclN0cmVhbWluZzogcnBjIChJbnB1dCkgcmV0dXJucyAoc3RyZWFtIE91dHB1dClcbiAqIDMuIENsaWVudFN0cmVhbWluZzogcnBjIChzdHJlYW0gSW5wdXQpIHJldHVybnMgKE91dHB1dClcbiAqIDQuIEJpRGlTdHJlYW1pbmc6ICAgcnBjIChzdHJlYW0gSW5wdXQpIHJldHVybnMgKHN0cmVhbSBPdXRwdXQpXG4gKi9cbnZhciBNZXRob2RLaW5kO1xuKGZ1bmN0aW9uIChNZXRob2RLaW5kKSB7XG4gICAgTWV0aG9kS2luZFtNZXRob2RLaW5kW1wiVW5hcnlcIl0gPSAwXSA9IFwiVW5hcnlcIjtcbiAgICBNZXRob2RLaW5kW01ldGhvZEtpbmRbXCJTZXJ2ZXJTdHJlYW1pbmdcIl0gPSAxXSA9IFwiU2VydmVyU3RyZWFtaW5nXCI7XG4gICAgTWV0aG9kS2luZFtNZXRob2RLaW5kW1wiQ2xpZW50U3RyZWFtaW5nXCJdID0gMl0gPSBcIkNsaWVudFN0cmVhbWluZ1wiO1xuICAgIE1ldGhvZEtpbmRbTWV0aG9kS2luZFtcIkJpRGlTdHJlYW1pbmdcIl0gPSAzXSA9IFwiQmlEaVN0cmVhbWluZ1wiO1xufSkoTWV0aG9kS2luZCB8fCAoTWV0aG9kS2luZCA9IHt9KSk7XG4vKipcbiAqIElzIHRoaXMgbWV0aG9kIHNpZGUtZWZmZWN0LWZyZWUgKG9yIHNhZmUgaW4gSFRUUCBwYXJsYW5jZSksIG9yIGp1c3RcbiAqIGlkZW1wb3RlbnQsIG9yIG5laXRoZXI/IEhUVFAgYmFzZWQgUlBDIGltcGxlbWVudGF0aW9uIG1heSBjaG9vc2UgR0VUIHZlcmJcbiAqIGZvciBzYWZlIG1ldGhvZHMsIGFuZCBQVVQgdmVyYiBmb3IgaWRlbXBvdGVudCBtZXRob2RzIGluc3RlYWQgb2YgdGhlXG4gKiBkZWZhdWx0IFBPU1QuXG4gKlxuICogVGhpcyBlbnVtIG1hdGNoZXMgdGhlIHByb3RvYnVmIGVudW0gZ29vZ2xlLnByb3RvYnVmLk1ldGhvZE9wdGlvbnMuSWRlbXBvdGVuY3lMZXZlbCxcbiAqIGRlZmluZWQgaW4gdGhlIHdlbGwta25vd24gdHlwZSBnb29nbGUvcHJvdG9idWYvZGVzY3JpcHRvci5wcm90bywgYnV0XG4gKiBkcm9wcyBVTktOT1dOLlxuICovXG52YXIgTWV0aG9kSWRlbXBvdGVuY3k7XG4oZnVuY3Rpb24gKE1ldGhvZElkZW1wb3RlbmN5KSB7XG4gICAgLyoqXG4gICAgICogSWRlbXBvdGVudCwgbm8gc2lkZSBlZmZlY3RzLlxuICAgICAqL1xuICAgIE1ldGhvZElkZW1wb3RlbmN5W01ldGhvZElkZW1wb3RlbmN5W1wiTm9TaWRlRWZmZWN0c1wiXSA9IDFdID0gXCJOb1NpZGVFZmZlY3RzXCI7XG4gICAgLyoqXG4gICAgICogSWRlbXBvdGVudCwgYnV0IG1heSBoYXZlIHNpZGUgZWZmZWN0cy5cbiAgICAgKi9cbiAgICBNZXRob2RJZGVtcG90ZW5jeVtNZXRob2RJZGVtcG90ZW5jeVtcIklkZW1wb3RlbnRcIl0gPSAyXSA9IFwiSWRlbXBvdGVudFwiO1xufSkoTWV0aG9kSWRlbXBvdGVuY3kgfHwgKE1ldGhvZElkZW1wb3RlbmN5ID0ge30pKTtcblxuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcbi8qKioqKiovIFx0XHRcdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG4vKioqKioqLyBcdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcbi8qKioqKiovIFx0XHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKVxuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuLyoqKioqKi8gXHRcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IHt9O1xuLy8gVGhpcyBlbnRyeSBuZWVkIHRvIGJlIHdyYXBwZWQgaW4gYW4gSUlGRSBiZWNhdXNlIGl0IG5lZWQgdG8gYmUgaXNvbGF0ZWQgYWdhaW5zdCBvdGhlciBtb2R1bGVzIGluIHRoZSBjaHVuay5cbigoKSA9PiB7XG4vLyBFU00gQ09NUEFUIEZMQUdcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbiAgQ2hhbmdlOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ2hhbmdlKSxcbiAgQ2xpZW50OiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ2xpZW50KSxcbiAgQ2xpZW50RXZlbnRUeXBlOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ2xpZW50RXZlbnRUeXBlKSxcbiAgQ2xpZW50U3RhdHVzOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ2xpZW50U3RhdHVzKSxcbiAgQ291bnRlcjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvdW50ZXIpLFxuICBEb2NFdmVudFR5cGU6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBEb2NFdmVudFR5cGUpLFxuICBEb2N1bWVudDogKCkgPT4gKC8qIHJlZXhwb3J0ICovIERvY3VtZW50KSxcbiAgRG9jdW1lbnRTeW5jUmVzdWx0VHlwZTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIERvY3VtZW50U3luY1Jlc3VsdFR5cGUpLFxuICBQcmltaXRpdmU6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQcmltaXRpdmUpLFxuICBTdHJlYW1Db25uZWN0aW9uU3RhdHVzOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU3RyZWFtQ29ubmVjdGlvblN0YXR1cyksXG4gIFN5bmNNb2RlOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU3luY01vZGUpLFxuICBUZXh0OiAoKSA9PiAoLyogcmVleHBvcnQgKi8gVGV4dCksXG4gIFRpbWVUaWNrZXQ6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBUaW1lVGlja2V0KSxcbiAgVHJlZTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFRyZWUpLFxuICBjb252ZXJ0ZXI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBjb252ZXJ0ZXIpLFxuICBcImRlZmF1bHRcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gc3JjX3lvcmtpZSlcbn0pO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9sb2dnZXIudHNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgTG9nTGV2ZWw7XG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJUcml2aWFsXCJdID0gMF0gPSBcIlRyaXZpYWxcIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkRlYnVnXCJdID0gMV0gPSBcIkRlYnVnXCI7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJJbmZvXCJdID0gMl0gPSBcIkluZm9cIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIldhcm5cIl0gPSAzXSA9IFwiV2FyblwiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRXJyb3JcIl0gPSA0XSA9IFwiRXJyb3JcIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkZhdGFsXCJdID0gNV0gPSBcIkZhdGFsXCI7XG59KShMb2dMZXZlbCB8fCAoTG9nTGV2ZWwgPSB7fSkpO1xubGV0IGxldmVsID0gTG9nTGV2ZWwuSW5mbztcbi8qKlxuICogYHNldExvZ0xldmVsYCBzZXRzIGxvZyBsZXZlbC5cbiAqL1xuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobCkge1xuICAgIGxldmVsID0gbDtcbn1cbmNvbnN0IGxvZ2dlciA9IHtcbiAgICB0cml2aWFsOiAoLi4ubWVzc2FnZXMpID0+IHtcbiAgICAgICAgaWYgKGxldmVsID4gTG9nTGV2ZWwuVHJpdmlhbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1lPUktJRSBUOicsIC4uLm1lc3NhZ2VzKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGVidWc6ICguLi5tZXNzYWdlcykgPT4ge1xuICAgICAgICBpZiAobGV2ZWwgPiBMb2dMZXZlbC5EZWJ1Zykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1lPUktJRSBEOicsIC4uLm1lc3NhZ2VzKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaW5mbzogKC4uLm1lc3NhZ2VzKSA9PiB7XG4gICAgICAgIGlmIChsZXZlbCA+IExvZ0xldmVsLkluZm8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdZT1JLSUUgSTonLCAuLi5tZXNzYWdlcyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHdhcm46ICguLi5tZXNzYWdlcykgPT4ge1xuICAgICAgICBpZiAobGV2ZWwgPiBMb2dMZXZlbC5XYXJuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUud2FybiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1lPUktJRSBXOicsIC4uLm1lc3NhZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdZT1JLSUUgVzonLCAuLi5tZXNzYWdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGVycm9yOiAoLi4ubWVzc2FnZXMpID0+IHtcbiAgICAgICAgaWYgKGxldmVsID4gTG9nTGV2ZWwuRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZS5lcnJvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdZT1JLSUUgRTonLCAuLi5tZXNzYWdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnWU9SS0lFIEU6JywgLi4ubWVzc2FnZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBmYXRhbDogKG1lc3NhZ2UsIC4uLm1lc3NhZ2VzKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLmVycm9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1lPUktJRSBGOicsIC4uLm1lc3NhZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdZT1JLSUUgRjonLCAuLi5tZXNzYWdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZT1JLSUUgRjogJHttZXNzYWdlfWApO1xuICAgIH0sXG4gICAgaXNFbmFibGVkOiAobCkgPT4ge1xuICAgICAgICByZXR1cm4gbGV2ZWwgPD0gbDtcbiAgICB9LFxufTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvdXVpZC50c1xuLypcbiAqIENvcHlyaWdodCAyMDIwIFRoZSBZb3JraWUgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogYHV1aWRgIGdlbmVyYXRlcyB1dWlkIHN0cmluZ1xuICogQHNlZSBodHRwOi8vd3d3LmlldGYub3JnL3JmYy9yZmM0MTIyLnR4dFxuICovXG5mdW5jdGlvbiB1dWlkKCkge1xuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4eS14eHh4LXh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIChjKSA9PiB7XG4gICAgICAgIGNvbnN0IHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2KSB8IDA7XG4gICAgICAgIGNvbnN0IHYgPSBjID09PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4O1xuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgfSk7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL29ic2VydmFibGUudHNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuY29uc3QgTm9vcCA9ICgpID0+IHtcbiAgICAvLyBEbyBub3RoaW5nXG59O1xuLyoqXG4gKiBgT2JzZXJ2ZXJQcm94eWAgaXMgcHJveHkgb2YgYE9ic2VydmVyYC5cbiAqL1xuY2xhc3MgT2JzZXJ2ZXJQcm94eSB7XG4gICAgY29uc3RydWN0b3IoZXhlY3V0b3IpIHtcbiAgICAgICAgdGhpcy5maW5hbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGV4ZWN1dG9yKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogYG5leHRgIGl0ZXJhdGVzIG5leHQgb2JzZXJ2ZXIgc3luY2hyb25vdXNseS5cbiAgICAgKi9cbiAgICBuZXh0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZm9yRWFjaE9ic2VydmVyKChvYnNlcnZlcikgPT4ge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZXJyb3JgIGludm9rZSBlcnJvci5cbiAgICAgKi9cbiAgICBlcnJvcihlcnJvcikge1xuICAgICAgICB0aGlzLmZvckVhY2hPYnNlcnZlcigob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2xvc2UoZXJyb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgY29tcGxldGVgIGNvbXBsZXRlcyBvYnNlcnZlci5cbiAgICAgKi9cbiAgICBjb21wbGV0ZSgpIHtcbiAgICAgICAgdGhpcy5mb3JFYWNoT2JzZXJ2ZXIoKG9ic2VydmVyKSA9PiB7XG4gICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgc3Vic2NyaWJlYCBpcyBhIGZ1bmN0aW9uIGZvciBzdWJzY3JpYmluZyBvYnNlcnZlci5cbiAgICAgKi9cbiAgICBzdWJzY3JpYmUobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICBsZXQgb2JzZXJ2ZXI7XG4gICAgICAgIGlmICghbmV4dE9yT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGxvZ2dlci5mYXRhbCgnbWlzc2luZyBvYnNlcnZlcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xuICAgICAgICAgICAgbG9nZ2VyLmZhdGFsKCdvYnNlcnZhYmxlIGlzIGZpbmFsaXplZCBkdWUgdG8gcHJldmlvdXMgZXJyb3InKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG5leHRPck9ic2VydmVyID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgb2JzZXJ2ZXIgPSBuZXh0T3JPYnNlcnZlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9ic2VydmVyID0ge1xuICAgICAgICAgICAgICAgIG5leHQ6IG5leHRPck9ic2VydmVyLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JzZXJ2ZXIubmV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0ID0gTm9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JzZXJ2ZXIuZXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IgPSBOb29wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYnNlcnZlci5jb21wbGV0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSA9IE5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWQgPSB1dWlkKCk7XG4gICAgICAgIGNvbnN0IHVuc3ViID0gdGhpcy51bnN1YnNjcmliZU9uZS5iaW5kKHRoaXMsIGlkKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaCh7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25JRDogaWQsXG4gICAgICAgICAgICBvYnNlcnZlcjogb2JzZXJ2ZXIsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluYWxFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcih0aGlzLmZpbmFsRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90aGluZ1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuc3ViO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZU9uZShpZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gKF9hID0gdGhpcy5vYnNlcnZlcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maWx0ZXIoKGl0KSA9PiBpdC5zdWJzY3JpcHRpb25JRCAhPT0gaWQpO1xuICAgIH1cbiAgICBmb3JFYWNoT2JzZXJ2ZXIoZm4pIHtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9ic2VydmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5zZW5kT25lKGksIGZuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kT25lKGksIGZuKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVycyAhPT0gdW5kZWZpbmVkICYmIHRoaXMub2JzZXJ2ZXJzW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm4odGhpcy5vYnNlcnZlcnNbaV0ub2JzZXJ2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNsb3NlKGVycikge1xuICAgICAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmFsaXplZCA9IHRydWU7XG4gICAgICAgIGlmIChlcnIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5maW5hbEVycm9yID0gZXJyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKlxuICogYGNyZWF0ZU9ic2VydmFibGVgIGNyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgT2JzZXJ2ZXJQcm94eVxuICogYW5kIHN1YnNjcmliZSB0aGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmFibGUoZXhlY3V0b3IpIHtcbiAgICBjb25zdCBwcm94eSA9IG5ldyBPYnNlcnZlclByb3h5KGV4ZWN1dG9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzY3JpYmU6IHByb3h5LnN1YnNjcmliZS5iaW5kKHByb3h5KSxcbiAgICAgICAgZ2V0UHJveHk6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBwcm94eTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9zZXJ2aWNlLXR5cGUuanNcbnZhciBzZXJ2aWNlX3R5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyOCk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9hbnktY2xpZW50LmpzXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBDcmVhdGUgYW55IGNsaWVudCBmb3IgdGhlIGdpdmVuIHNlcnZpY2UuXG4gKlxuICogVGhlIGdpdmVuIGNyZWF0ZU1ldGhvZCBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIGVhY2ggbWV0aG9kIGRlZmluaXRpb25cbiAqIG9mIHRoZSBzZXJ2aWNlLiBUaGUgZnVuY3Rpb24gaXQgcmV0dXJucyBpcyBhZGRlZCB0byB0aGUgY2xpZW50IG9iamVjdFxuICogYXMgYSBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIG1ha2VBbnlDbGllbnQoc2VydmljZSwgY3JlYXRlTWV0aG9kKSB7XG4gICAgY29uc3QgY2xpZW50ID0ge307XG4gICAgZm9yIChjb25zdCBbbG9jYWxOYW1lLCBtZXRob2RJbmZvXSBvZiBPYmplY3QuZW50cmllcyhzZXJ2aWNlLm1ldGhvZHMpKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGNyZWF0ZU1ldGhvZChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1ldGhvZEluZm8pLCB7IGxvY2FsTmFtZSxcbiAgICAgICAgICAgIHNlcnZpY2UgfSkpO1xuICAgICAgICBpZiAobWV0aG9kICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNsaWVudFtsb2NhbE5hbWVdID0gbWV0aG9kO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbGllbnQ7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL2NvZGUuanNcbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIENvbm5lY3QgcmVwcmVzZW50cyBjYXRlZ29yaWVzIG9mIGVycm9ycyBhcyBjb2RlcywgYW5kIGVhY2ggY29kZSBtYXBzIHRvIGFcbiAqIHNwZWNpZmljIEhUVFAgc3RhdHVzIGNvZGUuIFRoZSBjb2RlcyBhbmQgdGhlaXIgc2VtYW50aWNzIHdlcmUgY2hvc2VuIHRvXG4gKiBtYXRjaCBnUlBDLiBPbmx5IHRoZSBjb2RlcyBiZWxvdyBhcmUgdmFsaWQg4oCUIHRoZXJlIGFyZSBubyB1c2VyLWRlZmluZWRcbiAqIGNvZGVzLlxuICpcbiAqIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBhdCBodHRwczovL2Nvbm5lY3RycGMuY29tL2RvY3MvcHJvdG9jb2wjZXJyb3ItY29kZXNcbiAqIGZvciBkZXRhaWxzLlxuICovXG52YXIgY29kZV9Db2RlO1xuKGZ1bmN0aW9uIChDb2RlKSB7XG4gICAgLyoqXG4gICAgICogQ2FuY2VsZWQsIHVzdWFsbHkgYmUgdGhlIHVzZXJcbiAgICAgKi9cbiAgICBDb2RlW0NvZGVbXCJDYW5jZWxlZFwiXSA9IDFdID0gXCJDYW5jZWxlZFwiO1xuICAgIC8qKlxuICAgICAqIFVua25vd24gZXJyb3JcbiAgICAgKi9cbiAgICBDb2RlW0NvZGVbXCJVbmtub3duXCJdID0gMl0gPSBcIlVua25vd25cIjtcbiAgICAvKipcbiAgICAgKiBBcmd1bWVudCBpbnZhbGlkIHJlZ2FyZGxlc3Mgb2Ygc3lzdGVtIHN0YXRlXG4gICAgICovXG4gICAgQ29kZVtDb2RlW1wiSW52YWxpZEFyZ3VtZW50XCJdID0gM10gPSBcIkludmFsaWRBcmd1bWVudFwiO1xuICAgIC8qKlxuICAgICAqIE9wZXJhdGlvbiBleHBpcmVkLCBtYXkgb3IgbWF5IG5vdCBoYXZlIGNvbXBsZXRlZC5cbiAgICAgKi9cbiAgICBDb2RlW0NvZGVbXCJEZWFkbGluZUV4Y2VlZGVkXCJdID0gNF0gPSBcIkRlYWRsaW5lRXhjZWVkZWRcIjtcbiAgICAvKipcbiAgICAgKiBFbnRpdHkgbm90IGZvdW5kLlxuICAgICAqL1xuICAgIENvZGVbQ29kZVtcIk5vdEZvdW5kXCJdID0gNV0gPSBcIk5vdEZvdW5kXCI7XG4gICAgLyoqXG4gICAgICogRW50aXR5IGFscmVhZHkgZXhpc3RzLlxuICAgICAqL1xuICAgIENvZGVbQ29kZVtcIkFscmVhZHlFeGlzdHNcIl0gPSA2XSA9IFwiQWxyZWFkeUV4aXN0c1wiO1xuICAgIC8qKlxuICAgICAqIE9wZXJhdGlvbiBub3QgYXV0aG9yaXplZC5cbiAgICAgKi9cbiAgICBDb2RlW0NvZGVbXCJQZXJtaXNzaW9uRGVuaWVkXCJdID0gN10gPSBcIlBlcm1pc3Npb25EZW5pZWRcIjtcbiAgICAvKipcbiAgICAgKiBRdW90YSBleGhhdXN0ZWQuXG4gICAgICovXG4gICAgQ29kZVtDb2RlW1wiUmVzb3VyY2VFeGhhdXN0ZWRcIl0gPSA4XSA9IFwiUmVzb3VyY2VFeGhhdXN0ZWRcIjtcbiAgICAvKipcbiAgICAgKiBBcmd1bWVudCBpbnZhbGlkIGluIGN1cnJlbnQgc3lzdGVtIHN0YXRlLlxuICAgICAqL1xuICAgIENvZGVbQ29kZVtcIkZhaWxlZFByZWNvbmRpdGlvblwiXSA9IDldID0gXCJGYWlsZWRQcmVjb25kaXRpb25cIjtcbiAgICAvKipcbiAgICAgKiBPcGVyYXRpb24gYWJvcnRlZC5cbiAgICAgKi9cbiAgICBDb2RlW0NvZGVbXCJBYm9ydGVkXCJdID0gMTBdID0gXCJBYm9ydGVkXCI7XG4gICAgLyoqXG4gICAgICogT3V0IG9mIGJvdW5kcywgdXNlIGluc3RlYWQgb2YgRmFpbGVkUHJlY29uZGl0aW9uLlxuICAgICAqL1xuICAgIENvZGVbQ29kZVtcIk91dE9mUmFuZ2VcIl0gPSAxMV0gPSBcIk91dE9mUmFuZ2VcIjtcbiAgICAvKipcbiAgICAgKiBPcGVyYXRpb24gbm90IGltcGxlbWVudGVkIG9yIGRpc2FibGVkLlxuICAgICAqL1xuICAgIENvZGVbQ29kZVtcIlVuaW1wbGVtZW50ZWRcIl0gPSAxMl0gPSBcIlVuaW1wbGVtZW50ZWRcIjtcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBlcnJvciwgcmVzZXJ2ZWQgZm9yIFwic2VyaW91cyBlcnJvcnNcIi5cbiAgICAgKi9cbiAgICBDb2RlW0NvZGVbXCJJbnRlcm5hbFwiXSA9IDEzXSA9IFwiSW50ZXJuYWxcIjtcbiAgICAvKipcbiAgICAgKiBVbmF2YWlsYWJsZSwgY2xpZW50IHNob3VsZCBiYWNrIG9mZiBhbmQgcmV0cnkuXG4gICAgICovXG4gICAgQ29kZVtDb2RlW1wiVW5hdmFpbGFibGVcIl0gPSAxNF0gPSBcIlVuYXZhaWxhYmxlXCI7XG4gICAgLyoqXG4gICAgICogVW5yZWNvdmVyYWJsZSBkYXRhIGxvc3Mgb3IgY29ycnVwdGlvbi5cbiAgICAgKi9cbiAgICBDb2RlW0NvZGVbXCJEYXRhTG9zc1wiXSA9IDE1XSA9IFwiRGF0YUxvc3NcIjtcbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGlzbid0IGF1dGhlbnRpY2F0ZWQuXG4gICAgICovXG4gICAgQ29kZVtDb2RlW1wiVW5hdXRoZW50aWNhdGVkXCJdID0gMTZdID0gXCJVbmF1dGhlbnRpY2F0ZWRcIjtcbn0pKGNvZGVfQ29kZSB8fCAoY29kZV9Db2RlID0ge30pKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vbWVzc2FnZS5qc1xudmFyIGVzbV9tZXNzYWdlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NjEpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvdG9jb2wtY29ubmVjdC9jb2RlLXN0cmluZy5qc1xuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuLyoqXG4gKiBjb2RlVG9TdHJpbmcgcmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgQ29kZS5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZnVuY3Rpb24gY29kZVRvU3RyaW5nKHZhbHVlKSB7XG4gICAgY29uc3QgbmFtZSA9IGNvZGVfQ29kZVt2YWx1ZV07XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiAobmFtZVswXS50b0xvd2VyQ2FzZSgpICtcbiAgICAgICAgbmFtZS5zdWJzdHJpbmcoMSkucmVwbGFjZSgvW0EtWl0vZywgKGMpID0+IFwiX1wiICsgYy50b0xvd2VyQ2FzZSgpKSk7XG59XG5sZXQgc3RyaW5nVG9Db2RlO1xuLyoqXG4gKiBjb2RlRnJvbVN0cmluZyBwYXJzZXMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIENvZGUgaW4gc25ha2VfY2FzZS5cbiAqIEZvciBleGFtcGxlLCB0aGUgc3RyaW5nIFwicGVybWlzc2lvbl9kZW5pZWRcIiBwYXJzZXMgaW50byBDb2RlLlBlcm1pc3Npb25EZW5pZWQuXG4gKlxuICogSWYgdGhlIGdpdmVuIHN0cmluZyBjYW5ub3QgYmUgcGFyc2VkLCB0aGUgZnVuY3Rpb24gcmV0dXJucyB1bmRlZmluZWQuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmZ1bmN0aW9uIGNvZGVGcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgaWYgKCFzdHJpbmdUb0NvZGUpIHtcbiAgICAgICAgc3RyaW5nVG9Db2RlID0ge307XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgT2JqZWN0LnZhbHVlcyhDb2RlKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJpbmdUb0NvZGVbY29kZVRvU3RyaW5nKHZhbHVlKV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nVG9Db2RlW3ZhbHVlXTtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vY29ubmVjdC1lcnJvci5qc1xuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuXG5cbi8qKlxuICogQ29ubmVjdEVycm9yIGNhcHR1cmVzIGZvdXIgcGllY2VzIG9mIGluZm9ybWF0aW9uOiBhIENvZGUsIGFuIGVycm9yXG4gKiBtZXNzYWdlLCBhbiBvcHRpb25hbCBjYXVzZSBvZiB0aGUgZXJyb3IsIGFuZCBhbiBvcHRpb25hbCBjb2xsZWN0aW9uIG9mXG4gKiBhcmJpdHJhcnkgUHJvdG9idWYgbWVzc2FnZXMgY2FsbGVkICBcImRldGFpbHNcIi5cbiAqXG4gKiBCZWNhdXNlIGRldmVsb3BlciB0b29scyB0eXBpY2FsbHkgc2hvdyBqdXN0IHRoZSBlcnJvciBtZXNzYWdlLCB3ZSBwcmVmaXhcbiAqIGl0IHdpdGggdGhlIHN0YXR1cyBjb2RlLCBzbyB0aGF0IHRoZSBtb3N0IGltcG9ydGFudCBpbmZvcm1hdGlvbiBpcyBhbHdheXNcbiAqIHZpc2libGUgaW1tZWRpYXRlbHkuXG4gKlxuICogRXJyb3IgZGV0YWlscyBhcmUgd3JhcHBlZCB3aXRoIGdvb2dsZS5wcm90b2J1Zi5Bbnkgb24gdGhlIHdpcmUsIHNvIHRoYXRcbiAqIGEgc2VydmVyIG9yIG1pZGRsZXdhcmUgY2FuIGF0dGFjaCBhcmJpdHJhcnkgZGF0YSB0byBhbiBlcnJvci4gVXNlIHRoZVxuICogbWV0aG9kIGZpbmREZXRhaWxzKCkgdG8gcmV0cmlldmUgdGhlIGRldGFpbHMuXG4gKi9cbmNsYXNzIGNvbm5lY3RfZXJyb3JfQ29ubmVjdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBDb25uZWN0RXJyb3IuXG4gICAgICogSWYgbm8gY29kZSBpcyBwcm92aWRlZCwgY29kZSBcInVua25vd25cIiBpcyB1c2VkLlxuICAgICAqIE91dGdvaW5nIGRldGFpbHMgYXJlIG9ubHkgcmVsZXZhbnQgZm9yIHRoZSBzZXJ2ZXIgc2lkZSAtIGEgc2VydmljZSBtYXlcbiAgICAgKiByYWlzZSBhbiBlcnJvciB3aXRoIGRldGFpbHMsIGFuZCBpdCBpcyB1cCB0byB0aGUgcHJvdG9jb2wgaW1wbGVtZW50YXRpb25cbiAgICAgKiB0byBlbmNvZGUgYW5kIHNlbmQgdGhlIGRldGFpbHMgYWxvbmcgd2l0aCBlcnJvci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjb2RlID0gY29kZV9Db2RlLlVua25vd24sIG1ldGFkYXRhLCBvdXRnb2luZ0RldGFpbHMsIGNhdXNlKSB7XG4gICAgICAgIHN1cGVyKGNyZWF0ZU1lc3NhZ2UobWVzc2FnZSwgY29kZSkpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkNvbm5lY3RFcnJvclwiO1xuICAgICAgICAvLyBzZWUgaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svcmVsZWFzZS1ub3Rlcy90eXBlc2NyaXB0LTItMi5odG1sI2V4YW1wbGVcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICAgICAgdGhpcy5yYXdNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG5ldyBIZWFkZXJzKG1ldGFkYXRhICE9PSBudWxsICYmIG1ldGFkYXRhICE9PSB2b2lkIDAgPyBtZXRhZGF0YSA6IHt9KTtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gb3V0Z29pbmdEZXRhaWxzICE9PSBudWxsICYmIG91dGdvaW5nRGV0YWlscyAhPT0gdm9pZCAwID8gb3V0Z29pbmdEZXRhaWxzIDogW107XG4gICAgICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhbnkgdmFsdWUgLSB0eXBpY2FsbHkgYSBjYXVnaHQgZXJyb3IgaW50byBhIENvbm5lY3RFcnJvcixcbiAgICAgKiBmb2xsb3dpbmcgdGhlc2UgcnVsZXM6XG4gICAgICogLSBJZiB0aGUgdmFsdWUgaXMgYWxyZWFkeSBhIENvbm5lY3RFcnJvciwgcmV0dXJuIGl0IGFzIGlzLlxuICAgICAqIC0gSWYgdGhlIHZhbHVlIGlzIGFuIEFib3J0RXJyb3IgZnJvbSB0aGUgZmV0Y2ggQVBJLCByZXR1cm4gdGhlIG1lc3NhZ2VcbiAgICAgKiAgIG9mIHRoZSBBYm9ydEVycm9yIHdpdGggY29kZSBDYW5jZWxlZC5cbiAgICAgKiAtIEZvciBvdGhlciBFcnJvcnMsIHJldHVybiB0aGUgZXJyb3IgbWVzc2FnZSB3aXRoIGNvZGUgVW5rbm93biBieSBkZWZhdWx0LlxuICAgICAqIC0gRm9yIG90aGVyIHZhbHVlcywgcmV0dXJuIHRoZSB2YWx1ZXMgU3RyaW5nIHJlcHJlc2VudGF0aW9uIGFzIGEgbWVzc2FnZSxcbiAgICAgKiAgIHdpdGggdGhlIGNvZGUgVW5rbm93biBieSBkZWZhdWx0LlxuICAgICAqIFRoZSBvcmlnaW5hbCB2YWx1ZSB3aWxsIGJlIHVzZWQgZm9yIHRoZSBcImNhdXNlXCIgcHJvcGVydHkgZm9yIHRoZSBuZXdcbiAgICAgKiBDb25uZWN0RXJyb3IuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ocmVhc29uLCBjb2RlID0gY29kZV9Db2RlLlVua25vd24pIHtcbiAgICAgICAgaWYgKHJlYXNvbiBpbnN0YW5jZW9mIGNvbm5lY3RfZXJyb3JfQ29ubmVjdEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhc29uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWFzb24gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgaWYgKHJlYXNvbi5uYW1lID09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgLy8gRmV0Y2ggcmVxdWVzdHMgY2FuIG9ubHkgYmUgY2FuY2VsZWQgd2l0aCBhbiBBYm9ydENvbnRyb2xsZXIuXG4gICAgICAgICAgICAgICAgLy8gV2UgZGV0ZWN0IHRoYXQgY29uZGl0aW9uIGJ5IGxvb2tpbmcgYXQgdGhlIG5hbWUgb2YgdGhlIHJhaXNlZFxuICAgICAgICAgICAgICAgIC8vIGVycm9yIG9iamVjdCwgYW5kIHRyYW5zbGF0ZSB0byB0aGUgYXBwcm9wcmlhdGUgc3RhdHVzIGNvZGUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBjb25uZWN0X2Vycm9yX0Nvbm5lY3RFcnJvcihyZWFzb24ubWVzc2FnZSwgY29kZV9Db2RlLkNhbmNlbGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgY29ubmVjdF9lcnJvcl9Db25uZWN0RXJyb3IocmVhc29uLm1lc3NhZ2UsIGNvZGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCByZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgY29ubmVjdF9lcnJvcl9Db25uZWN0RXJyb3IoU3RyaW5nKHJlYXNvbiksIGNvZGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCByZWFzb24pO1xuICAgIH1cbiAgICBmaW5kRGV0YWlscyh0eXBlT3JSZWdpc3RyeSkge1xuICAgICAgICBjb25zdCByZWdpc3RyeSA9IFwidHlwZU5hbWVcIiBpbiB0eXBlT3JSZWdpc3RyeVxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgZmluZE1lc3NhZ2U6ICh0eXBlTmFtZSkgPT4gdHlwZU5hbWUgPT09IHR5cGVPclJlZ2lzdHJ5LnR5cGVOYW1lID8gdHlwZU9yUmVnaXN0cnkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHR5cGVPclJlZ2lzdHJ5O1xuICAgICAgICBjb25zdCBkZXRhaWxzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZGF0YSBvZiB0aGlzLmRldGFpbHMpIHtcbiAgICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgZXNtX21lc3NhZ2UvKiBNZXNzYWdlICovLnYpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVnaXN0cnkuZmluZE1lc3NhZ2UoZGF0YS5nZXRUeXBlKCkudHlwZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHMucHVzaChkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gcmVnaXN0cnkuZmluZE1lc3NhZ2UoZGF0YS50eXBlKTtcbiAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5wdXNoKHR5cGUuZnJvbUJpbmFyeShkYXRhLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHNpbGVudGx5IGdpdmUgdXAgaWYgd2UgYXJlIHVuYWJsZSB0byBwYXJzZSB0aGUgZGV0YWlsLCBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgYXBwZWFycyB0byBiZSB0aGUgbGVhc3Qgd29yc3QgYmVoYXZpb3IuXG4gICAgICAgICAgICAgICAgICAgIC8vIEl0IGlzIHZlcnkgdW5saWtlbHkgdGhhdCBhIHVzZXIgc3Vycm91bmRzIGEgY2F0Y2ggYm9keSBoYW5kbGluZyB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXJyb3Igd2l0aCBhbm90aGVyIHRyeS1jYXRjaCBzdGF0ZW1lbnQsIGFuZCB3ZSBkbyBub3Qgd2FudCB0b1xuICAgICAgICAgICAgICAgICAgICAvLyByZWNvbW1lbmQgZG9pbmcgc28uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlIGFuIGVycm9yIG1lc3NhZ2UsIHByZWZpeGluZyB0aGUgZ2l2ZW4gY29kZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWVzc2FnZShtZXNzYWdlLCBjb2RlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UubGVuZ3RoXG4gICAgICAgID8gYFske2NvZGVUb1N0cmluZyhjb2RlKX1dICR7bWVzc2FnZX1gXG4gICAgICAgIDogYFske2NvZGVUb1N0cmluZyhjb2RlKX1dYDtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvdG9jb2wvYXN5bmMtaXRlcmFibGUuanNcbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG52YXIgX19hc3luY1ZhbHVlcyA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXN5bmNWYWx1ZXMpIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxufTtcbnZhciBfX2F3YWl0ID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdCkgfHwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7IH1cbnZhciBfX2FzeW5jR2VuZXJhdG9yID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hc3luY0dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxufTtcbnZhciBfX2FzeW5jRGVsZWdhdG9yID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hc3luY0RlbGVnYXRvcikgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICB2YXIgaSwgcDtcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IGZhbHNlIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XG59O1xuXG5cblxuXG5mdW5jdGlvbiBwaXBlVG8oc291cmNlLCAuLi5yZXN0KSB7XG4gICAgY29uc3QgW3RyYW5zZm9ybXMsIHNpbmssIG9wdF0gPSBwaWNrVHJhbnNmb3Jtc0FuZFNpbmsocmVzdCk7XG4gICAgbGV0IGl0ZXJhYmxlID0gc291cmNlO1xuICAgIGxldCBhYm9ydGFibGU7XG4gICAgaWYgKChvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQucHJvcGFnYXRlRG93blN0cmVhbUVycm9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICBpdGVyYWJsZSA9IGFib3J0YWJsZSA9IG1ha2VJdGVyYWJsZUFib3J0YWJsZShpdGVyYWJsZSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaXRlcmFibGUgPSBwaXBlKGl0ZXJhYmxlLCAuLi50cmFuc2Zvcm1zLCB7IHByb3BhZ2F0ZURvd25TdHJlYW1FcnJvcjogZmFsc2UgfSk7XG4gICAgcmV0dXJuIHNpbmsoaXRlcmFibGUpLmNhdGNoKChyZWFzb24pID0+IHtcbiAgICAgICAgaWYgKGFib3J0YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFib3J0YWJsZS5hYm9ydChyZWFzb24pLnRoZW4oKCkgPT4gUHJvbWlzZS5yZWplY3QocmVhc29uKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gICAgfSk7XG59XG4vLyBwaWNrIHRyYW5zZm9ybXMsIHRoZSBzaW5rLCBhbmQgb3B0aW9ucyBmcm9tIHRoZSBwaXBlVG8oKSByZXN0IHBhcmFtZXRlclxuZnVuY3Rpb24gcGlja1RyYW5zZm9ybXNBbmRTaW5rKHJlc3QpIHtcbiAgICBsZXQgb3B0O1xuICAgIGlmICh0eXBlb2YgcmVzdFtyZXN0Lmxlbmd0aCAtIDFdICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBvcHQgPSByZXN0LnBvcCgpO1xuICAgIH1cbiAgICBjb25zdCBzaW5rID0gcmVzdC5wb3AoKTtcbiAgICByZXR1cm4gW3Jlc3QsIHNpbmssIG9wdF07XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gQXN5bmNJdGVyYWJsZVNpbmsgdGhhdCBjb25jYXRlbmF0ZXMgYWxsIGVsZW1lbnRzIGZyb20gdGhlIGlucHV0LlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5mdW5jdGlvbiBzaW5rQWxsKCkge1xuICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgdmFyIF9hLCBlXzEsIF9iLCBfYztcbiAgICAgICAgY29uc3QgYWxsID0gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIGl0ZXJhYmxlXzEgPSBfX2FzeW5jVmFsdWVzKGl0ZXJhYmxlKSwgaXRlcmFibGVfMV8xOyBpdGVyYWJsZV8xXzEgPSBhd2FpdCBpdGVyYWJsZV8xLm5leHQoKSwgX2EgPSBpdGVyYWJsZV8xXzEuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICBfYyA9IGl0ZXJhYmxlXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2M7XG4gICAgICAgICAgICAgICAgYWxsLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBpdGVyYWJsZV8xLnJldHVybikpIGF3YWl0IF9iLmNhbGwoaXRlcmFibGVfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsbDtcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIEFzeW5jSXRlcmFibGVTaW5rIHRoYXQgY29uY2F0ZW5hdGVzIGFsbCBjaHVua3MgZnJvbSB0aGUgaW5wdXQgaW50b1xuICogYSBzaW5nbGUgVWludDhBcnJheS5cbiAqXG4gKiBUaGUgaXRlcmFibGUgcmFpc2VzIGFuIGVycm9yIGlmIHRoZSBtb3JlIHRoYW4gcmVhZE1heEJ5dGVzIGFyZSByZWFkLlxuICpcbiAqIEFuIG9wdGlvbmFsIGxlbmd0aCBoaW50IGNhbiBiZSBwcm92aWRlZCB0byBvcHRpbWl6ZSBhbGxvY2F0aW9uIGFuZCB2YWxpZGF0aW9uLlxuICogSWYgbW9yZSBvciBsZXNzIGJ5dGVzIGFyZSBwcmVzZW50IGluIHRoZSBzb3VyY2UgdGhhdCB0aGUgbGVuZ3RoIGhpbnQgaW5kaWNhdGVzLFxuICogYW5kIGVycm9yIGlzIHJhaXNlZC5cbiAqIElmIHRoZSBsZW5ndGggaGludCBpcyBsYXJnZXIgdGhhbiByZWFkTWF4Qnl0ZXMsIGFuIGVycm9yIGlzIHJhaXNlZC5cbiAqIElmIHRoZSBsZW5ndGggaGludCBpcyBub3QgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBpdCBpcyBpZ25vcmVkLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5mdW5jdGlvbiBzaW5rQWxsQnl0ZXMocmVhZE1heEJ5dGVzLCBsZW5ndGhIaW50KSB7XG4gICAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVhZEFsbEJ5dGVzKGl0ZXJhYmxlLCByZWFkTWF4Qnl0ZXMsIGxlbmd0aEhpbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBwaXBlKHNvdXJjZSwgLi4ucmVzdCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBwaXBlXzEoKSB7XG4gICAgICAgIGNvbnN0IFt0cmFuc2Zvcm1zLCBvcHRdID0gcGlja1RyYW5zZm9ybXMocmVzdCk7XG4gICAgICAgIGxldCBhYm9ydGFibGU7XG4gICAgICAgIGNvbnN0IHNvdXJjZUl0ID0gc291cmNlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgICAgICBjb25zdCBjYWNoZWRTb3VyY2UgPSB7XG4gICAgICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2VJdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGxldCBpdGVyYWJsZSA9IGNhY2hlZFNvdXJjZTtcbiAgICAgICAgaWYgKChvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQucHJvcGFnYXRlRG93blN0cmVhbUVycm9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaXRlcmFibGUgPSBhYm9ydGFibGUgPSBtYWtlSXRlcmFibGVBYm9ydGFibGUoaXRlcmFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdCBvZiB0cmFuc2Zvcm1zKSB7XG4gICAgICAgICAgICBpdGVyYWJsZSA9IHQoaXRlcmFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IHlpZWxkIF9fYXdhaXQoaXQubmV4dCgpKTtcbiAgICAgICAgICAgICAgICBpZiAoci5kb25lID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWFib3J0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHIudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgX19hd2FpdChhYm9ydGFibGUuYWJvcnQoZSkpOyAvLyBwcm9wYWdhdGUgZG93bnN0cmVhbSBlcnJvciB0byB0aGUgc291cmNlXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKChvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQucHJvcGFnYXRlRG93blN0cmVhbUVycm9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIENhbGwgcmV0dXJuIG9uIHRoZSBzb3VyY2UgaXRlcmFibGUgdG8gaW5kaWNhdGVcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHdlIHdpbGwgbm8gbG9uZ2VyIGNvbnN1bWUgaXQgYW5kIGl0IHNob3VsZFxuICAgICAgICAgICAgICAgIC8vIGNsZWFudXAgYW55IGFsbG9jYXRlZCByZXNvdXJjZXMuXG4gICAgICAgICAgICAgICAgKF9hID0gc291cmNlSXQucmV0dXJuKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzb3VyY2VJdCkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gcmV0dXJucyBhIHByb21pc2UsIHdoaWNoIHdlIGRvbid0IGNhcmUgYWJvdXQuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIFVuY2F1Z2h0IHByb21pc2VzIGFyZSB0aHJvd24gYXQgc29tZXRpbWUvc29tZXdoZXJlIGJ5IHRoZSBldmVudCBsb29wLFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRvIGVuc3VyZSBlcnJvciBpcyBjYXVnaHQgYW5kIGlnbm9yZWQuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHBpY2tUcmFuc2Zvcm1zKHJlc3QpIHtcbiAgICBsZXQgb3B0O1xuICAgIGlmICh0eXBlb2YgcmVzdFtyZXN0Lmxlbmd0aCAtIDFdICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBvcHQgPSByZXN0LnBvcCgpO1xuICAgIH1cbiAgICByZXR1cm4gW3Jlc3QsIG9wdF07XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gQXN5bmNJdGVyYWJsZVRyYW5zZm9ybSB0aGF0IGNhdGNoZXMgYW55IGVycm9yIGZyb20gdGhlIGlucHV0LCBhbmRcbiAqIHBhc3NlcyBpdCB0byB0aGUgZ2l2ZW4gY2F0Y2hFcnJvciBmdW5jdGlvbi5cbiAqXG4gKiBUaGUgY2F0Y2hFcnJvciBmdW5jdGlvbiBtYXkgcmV0dXJuIGEgZmluYWwgdmFsdWUuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybUNhdGNoKGNhdGNoRXJyb3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIHdlIGRlbGliZXJhdGUgYXZvaWQgYSBmb3ItYXdhaXQgbG9vcCBiZWNhdXNlIHdlIG9ubHkgd2FudCB0byBjYXRjaCB1cHN0cmVhbVxuICAgICAgICAgICAgLy8gZXJyb3JzLCBub3QgZG93bnN0cmVhbSBlcnJvcnMgKHlpZWxkKS5cbiAgICAgICAgICAgIGNvbnN0IGl0ID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IHI7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgciA9IHlpZWxkIF9fYXdhaXQoaXQubmV4dCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2F1Z2h0ID0geWllbGQgX19hd2FpdChjYXRjaEVycm9yKGUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhdWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KGNhdWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyLmRvbmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoci52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gQXN5bmNJdGVyYWJsZVRyYW5zZm9ybSB0aGF0IGNhdGNoZXMgYW55IGVycm9yIGZyb20gdGhlIGlucHV0LCBhbmRcbiAqIHBhc3NlcyBpdCB0byB0aGUgZ2l2ZW4gZnVuY3Rpb24uIFVubGlrZSB0cmFuc2Zvcm1DYXRjaCgpLCB0aGUgZ2l2ZW4gZnVuY3Rpb25cbiAqIGlzIGFsc28gY2FsbGVkIHdoZW4gbm8gZXJyb3IgaXMgcmFpc2VkLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1DYXRjaEZpbmFsbHkoY2F0Y2hGaW5hbGx5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyB3ZSBkZWxpYmVyYXRlIGF2b2lkIGEgZm9yLWF3YWl0IGxvb3AgYmVjYXVzZSB3ZSBvbmx5IHdhbnQgdG8gY2F0Y2ggdXBzdHJlYW1cbiAgICAgICAgICAgIC8vIGVycm9ycywgbm90IGRvd25zdHJlYW0gZXJyb3JzICh5aWVsZCkuXG4gICAgICAgICAgICBsZXQgZXJyO1xuICAgICAgICAgICAgY29uc3QgaXQgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBsZXQgcjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByID0geWllbGQgX19hd2FpdChpdC5uZXh0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnIgPSBlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHIuZG9uZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChyLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhdWdodCA9IHlpZWxkIF9fYXdhaXQoY2F0Y2hGaW5hbGx5KGVycikpO1xuICAgICAgICAgICAgaWYgKGNhdWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChjYXVnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIEFzeW5jSXRlcmFibGVUcmFuc2Zvcm0gdGhhdCBhcHBlbmRzIGEgdmFsdWUuXG4gKlxuICogVGhlIGVsZW1lbnQgdG8gYXBwZW5kIGlzIHByb3ZpZGVkIGJ5IGEgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zXG4gKiB1bmRlZmluZWQsIG5vIGVsZW1lbnQgaXMgYXBwZW5kZWQuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybUFwcGVuZChwcm92aWRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIGVfMiwgX2IsIF9jO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIGl0ZXJhYmxlXzIgPSBfX2FzeW5jVmFsdWVzKGl0ZXJhYmxlKSwgaXRlcmFibGVfMl8xOyBpdGVyYWJsZV8yXzEgPSB5aWVsZCBfX2F3YWl0KGl0ZXJhYmxlXzIubmV4dCgpKSwgX2EgPSBpdGVyYWJsZV8yXzEuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX2MgPSBpdGVyYWJsZV8yXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2M7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoY2h1bmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBpdGVyYWJsZV8yLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChpdGVyYWJsZV8yKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwcGVuZCA9IHlpZWxkIF9fYXdhaXQocHJvdmlkZSgpKTtcbiAgICAgICAgICAgIGlmIChhcHBlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoYXBwZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBBc3luY0l0ZXJhYmxlVHJhbnNmb3JtIHRoYXQgcHJlcGVuZHMgYW4gZWxlbWVudC5cbiAqXG4gKiBUaGUgZWxlbWVudCB0byBwcmVwZW5kIGlzIHByb3ZpZGVkIGJ5IGEgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zXG4gKiB1bmRlZmluZWQsIG5vIGVsZW1lbnQgaXMgYXBwZW5kZWQuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVByZXBlbmQocHJvdmlkZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBlXzMsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IHByZXBlbmQgPSB5aWVsZCBfX2F3YWl0KHByb3ZpZGUoKSk7XG4gICAgICAgICAgICBpZiAocHJlcGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChwcmVwZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBpdGVyYWJsZV8zID0gX19hc3luY1ZhbHVlcyhpdGVyYWJsZSksIGl0ZXJhYmxlXzNfMTsgaXRlcmFibGVfM18xID0geWllbGQgX19hd2FpdChpdGVyYWJsZV8zLm5leHQoKSksIF9hID0gaXRlcmFibGVfM18xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gaXRlcmFibGVfM18xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IF9jO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KGNodW5rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gaXRlcmFibGVfMy5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9iLmNhbGwoaXRlcmFibGVfMykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gQXN5bmNJdGVyYWJsZVRyYW5zZm9ybSB0aGF0IHJlYWRzIGFsbCBieXRlcyBmcm9tIHRoZSBpbnB1dCwgYW5kXG4gKiBjb25jYXRlbmF0ZXMgdGhlbSB0byBhIHNpbmdsZSBVaW50OEFycmF5LlxuICpcbiAqIFRoZSBpdGVyYWJsZSByYWlzZXMgYW4gZXJyb3IgaWYgdGhlIG1vcmUgdGhhbiByZWFkTWF4Qnl0ZXMgYXJlIHJlYWQuXG4gKlxuICogQW4gb3B0aW9uYWwgbGVuZ3RoIGhpbnQgY2FuIGJlIHByb3ZpZGVkIHRvIG9wdGltaXplIGFsbG9jYXRpb24gYW5kIHZhbGlkYXRpb24uXG4gKiBJZiBtb3JlIG9yIGxlc3MgYnl0ZXMgYXJlIHByZXNlbnQgaW4gdGhlIHNvdXJjZSB0aGF0IHRoZSBsZW5ndGggaGludCBpbmRpY2F0ZXMsXG4gKiBhbmQgZXJyb3IgaXMgcmFpc2VkLlxuICogSWYgdGhlIGxlbmd0aCBoaW50IGlzIGxhcmdlciB0aGFuIHJlYWRNYXhCeXRlcywgYW4gZXJyb3IgaXMgcmFpc2VkLlxuICogSWYgdGhlIGxlbmd0aCBoaW50IGlzIG5vdCBhIHBvc2l0aXZlIGludGVnZXIsIGl0IGlzIGlnbm9yZWQuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVJlYWRBbGxCeXRlcyhyZWFkTWF4Qnl0ZXMsIGxlbmd0aEhpbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoeWllbGQgX19hd2FpdChyZWFkQWxsQnl0ZXMoaXRlcmFibGUsIHJlYWRNYXhCeXRlcywgbGVuZ3RoSGludCkpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybVNlcmlhbGl6ZUVudmVsb3BlKHNlcmlhbGl6YXRpb24sIGVuZFN0cmVhbUZsYWcsIGVuZFNlcmlhbGl6YXRpb24pIHtcbiAgICBpZiAoZW5kU3RyZWFtRmxhZyA9PT0gdW5kZWZpbmVkIHx8IGVuZFNlcmlhbGl6YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBlXzQsIF9iLCBfYztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIGl0ZXJhYmxlXzQgPSBfX2FzeW5jVmFsdWVzKGl0ZXJhYmxlKSwgaXRlcmFibGVfNF8xOyBpdGVyYWJsZV80XzEgPSB5aWVsZCBfX2F3YWl0KGl0ZXJhYmxlXzQubmV4dCgpKSwgX2EgPSBpdGVyYWJsZV80XzEuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jID0gaXRlcmFibGVfNF8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2M7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gc2VyaWFsaXphdGlvbi5zZXJpYWxpemUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdCh7IGZsYWdzOiAwLCBkYXRhIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzRfMSkgeyBlXzQgPSB7IGVycm9yOiBlXzRfMSB9OyB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBpdGVyYWJsZV80LnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChpdGVyYWJsZV80KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgZV81LCBfYiwgX2M7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgaXRlcmFibGVfNSA9IF9fYXN5bmNWYWx1ZXMoaXRlcmFibGUpLCBpdGVyYWJsZV81XzE7IGl0ZXJhYmxlXzVfMSA9IHlpZWxkIF9fYXdhaXQoaXRlcmFibGVfNS5uZXh0KCkpLCBfYSA9IGl0ZXJhYmxlXzVfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfYyA9IGl0ZXJhYmxlXzVfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmbGFncyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVuay5lbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzID0gZmxhZ3MgfCBlbmRTdHJlYW1GbGFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGVuZFNlcmlhbGl6YXRpb24uc2VyaWFsaXplKGNodW5rLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBzZXJpYWxpemF0aW9uLnNlcmlhbGl6ZShjaHVuay52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdCh7IGZsYWdzLCBkYXRhIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzVfMSkgeyBlXzUgPSB7IGVycm9yOiBlXzVfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBpdGVyYWJsZV81LnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChpdGVyYWJsZV81KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV81KSB0aHJvdyBlXzUuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybVBhcnNlRW52ZWxvcGUoc2VyaWFsaXphdGlvbiwgZW5kU3RyZWFtRmxhZywgZW5kU2VyaWFsaXphdGlvbikge1xuICAgIC8vIGNvZGUgcGF0aCBhbHdheXMgeWllbGRzIFBhcnNlZEVudmVsb3BlZE1lc3NhZ2U8VCwgRT5cbiAgICBpZiAoZW5kU2VyaWFsaXphdGlvbiAmJiBlbmRTdHJlYW1GbGFnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgZV82LCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBpdGVyYWJsZV82ID0gX19hc3luY1ZhbHVlcyhpdGVyYWJsZSksIGl0ZXJhYmxlXzZfMTsgaXRlcmFibGVfNl8xID0geWllbGQgX19hd2FpdChpdGVyYWJsZV82Lm5leHQoKSksIF9hID0gaXRlcmFibGVfNl8xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYyA9IGl0ZXJhYmxlXzZfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGZsYWdzLCBkYXRhIH0gPSBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZmxhZ3MgJiBlbmRTdHJlYW1GbGFnKSA9PT0gZW5kU3RyZWFtRmxhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoeyB2YWx1ZTogZW5kU2VyaWFsaXphdGlvbi5wYXJzZShkYXRhKSwgZW5kOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdCh7IHZhbHVlOiBzZXJpYWxpemF0aW9uLnBhcnNlKGRhdGEpLCBlbmQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzZfMSkgeyBlXzYgPSB7IGVycm9yOiBlXzZfMSB9OyB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBpdGVyYWJsZV82LnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChpdGVyYWJsZV82KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzYpIHRocm93IGVfNi5lcnJvcjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBjb2RlIHBhdGggYWx3YXlzIHlpZWxkcyBUXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIGVfNywgX2IsIF9jO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIGl0ZXJhYmxlXzcgPSBfX2FzeW5jVmFsdWVzKGl0ZXJhYmxlKSwgaXRlcmFibGVfN18xOyBpdGVyYWJsZV83XzEgPSB5aWVsZCBfX2F3YWl0KGl0ZXJhYmxlXzcubmV4dCgpKSwgX2EgPSBpdGVyYWJsZV83XzEuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX2MgPSBpdGVyYWJsZV83XzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZmxhZ3MsIGRhdGEgfSA9IF9jO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kU3RyZWFtRmxhZyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoZmxhZ3MgJiBlbmRTdHJlYW1GbGFnKSA9PT0gZW5kU3RyZWFtRmxhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZFNlcmlhbGl6YXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdEVycm9yKFwidW5leHBlY3RlZCBlbmQgZmxhZ1wiLCBDb2RlLkludmFsaWRBcmd1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBza2lwcyBlbmQtb2Ytc3RyZWFtIGVudmVsb3BlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHNlcmlhbGl6YXRpb24ucGFyc2UoZGF0YSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzdfMSkgeyBlXzcgPSB7IGVycm9yOiBlXzdfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBpdGVyYWJsZV83LnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChpdGVyYWJsZV83KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV83KSB0aHJvdyBlXzcuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBBc3luY0l0ZXJhYmxlVHJhbnNmb3JtIHRoYXQgdGFrZXMgZW52ZWxvcGVkIG1lc3NhZ2VzIGFzIGEgc291cmNlLFxuICogYW5kIGNvbXByZXNzZXMgdGhlbSBpZiB0aGV5IGFyZSBsYXJnZXIgdGhhbiBjb21wcmVzc01pbkJ5dGVzLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1Db21wcmVzc0VudmVsb3BlKGNvbXByZXNzaW9uLCBjb21wcmVzc01pbkJ5dGVzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIGVfOCwgX2IsIF9jO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIGl0ZXJhYmxlXzggPSBfX2FzeW5jVmFsdWVzKGl0ZXJhYmxlKSwgaXRlcmFibGVfOF8xOyBpdGVyYWJsZV84XzEgPSB5aWVsZCBfX2F3YWl0KGl0ZXJhYmxlXzgubmV4dCgpKSwgX2EgPSBpdGVyYWJsZV84XzEuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX2MgPSBpdGVyYWJsZV84XzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudiA9IF9jO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHlpZWxkIF9fYXdhaXQoZW52ZWxvcGVDb21wcmVzcyhlbnYsIGNvbXByZXNzaW9uLCBjb21wcmVzc01pbkJ5dGVzKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzhfMSkgeyBlXzggPSB7IGVycm9yOiBlXzhfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBpdGVyYWJsZV84LnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChpdGVyYWJsZV84KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV84KSB0aHJvdyBlXzguZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBBc3luY0l0ZXJhYmxlVHJhbnNmb3JtIHRoYXQgdGFrZXMgZW52ZWxvcGVkIG1lc3NhZ2VzIGFzIGEgc291cmNlLFxuICogYW5kIGRlY29tcHJlc3NlcyB0aGVtIHVzaW5nIHRoZSBnaXZlbiBjb21wcmVzc2lvbi5cbiAqXG4gKiBUaGUgaXRlcmFibGUgcmFpc2VzIGFuIGVycm9yIGlmIHRoZSBkZWNvbXByZXNzZWQgcGF5bG9hZCBvZiBhbiBlbnZlbG9wZWRcbiAqIG1lc3NhZ2UgaXMgbGFyZ2VyIHRoYW4gcmVhZE1heEJ5dGVzLCBvciBpZiBubyBjb21wcmVzc2lvbiBpcyBwcm92aWRlZC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtRGVjb21wcmVzc0VudmVsb3BlKGNvbXByZXNzaW9uLCByZWFkTWF4Qnl0ZXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgZV85LCBfYiwgX2M7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgaXRlcmFibGVfOSA9IF9fYXN5bmNWYWx1ZXMoaXRlcmFibGUpLCBpdGVyYWJsZV85XzE7IGl0ZXJhYmxlXzlfMSA9IHlpZWxkIF9fYXdhaXQoaXRlcmFibGVfOS5uZXh0KCkpLCBfYSA9IGl0ZXJhYmxlXzlfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfYyA9IGl0ZXJhYmxlXzlfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW52ID0gX2M7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoeWllbGQgX19hd2FpdChlbnZlbG9wZURlY29tcHJlc3MoZW52LCBjb21wcmVzc2lvbiwgcmVhZE1heEJ5dGVzKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzlfMSkgeyBlXzkgPSB7IGVycm9yOiBlXzlfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBpdGVyYWJsZV85LnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChpdGVyYWJsZV85KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV85KSB0aHJvdyBlXzkuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIGFuIEFzeW5jSXRlcmFibGVUcmFuc2Zvcm0gdGhhdCB0YWtlcyBlbnZlbG9wZWQgbWVzc2FnZXMgYXMgYSBzb3VyY2UsXG4gKiBhbmQgam9pbnMgdGhlbSBpbnRvIGEgc3RyZWFtIG9mIHJhdyBieXRlcy5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtSm9pbkVudmVsb3BlcygpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgZV8xMCwgX2IsIF9jO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIGl0ZXJhYmxlXzEwID0gX19hc3luY1ZhbHVlcyhpdGVyYWJsZSksIGl0ZXJhYmxlXzEwXzE7IGl0ZXJhYmxlXzEwXzEgPSB5aWVsZCBfX2F3YWl0KGl0ZXJhYmxlXzEwLm5leHQoKSksIF9hID0gaXRlcmFibGVfMTBfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfYyA9IGl0ZXJhYmxlXzEwXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZmxhZ3MsIGRhdGEgfSA9IF9jO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KGVuY29kZUVudmVsb3BlKGZsYWdzLCBkYXRhKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMTBfMSkgeyBlXzEwID0geyBlcnJvcjogZV8xMF8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGl0ZXJhYmxlXzEwLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChpdGVyYWJsZV8xMCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMTApIHRocm93IGVfMTAuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIGFuIEFzeW5jSXRlcmFibGVUcmFuc2Zvcm0gdGhhdCB0YWtlcyByYXcgYnl0ZXMgYXMgYSBzb3VyY2UsIGFuZCBzcGxpdHNcbiAqIHRoZW0gaW50byBlbnZlbG9wZWQgbWVzc2FnZXMuXG4gKlxuICogVGhlIGl0ZXJhYmxlIHJhaXNlcyBhbiBlcnJvclxuICogLSBpZiB0aGUgcGF5bG9hZCBvZiBhbiBlbnZlbG9wZWQgbWVzc2FnZSBpcyBsYXJnZXIgdGhhbiByZWFkTWF4Qnl0ZXMsXG4gKiAtIGlmIHRoZSBzdHJlYW0gZW5kZWQgYmVmb3JlIGFuIGVudmVsb3BlZCBtZXNzYWdlIGZ1bGx5IGFycml2ZWQsXG4gKiAtIG9yIGlmIHRoZSBzdHJlYW0gZW5kZWQgd2l0aCBleHRyYW5lb3VzIGRhdGEuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVNwbGl0RW52ZWxvcGUocmVhZE1heEJ5dGVzKSB7XG4gICAgLy8gYXBwZW5kIGNodW5rIHRvIGJ1ZmZlciwgcmV0dXJuaW5nIHVwZGF0ZWQgYnVmZmVyXG4gICAgZnVuY3Rpb24gYXBwZW5kKGJ1ZmZlciwgY2h1bmspIHtcbiAgICAgICAgY29uc3QgbiA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlci5ieXRlTGVuZ3RoICsgY2h1bmsuYnl0ZUxlbmd0aCk7XG4gICAgICAgIG4uc2V0KGJ1ZmZlcik7XG4gICAgICAgIG4uc2V0KGNodW5rLCBidWZmZXIubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIC8vIHR1cGxlIDA6IGVudmVsb3BlLCBvciB1bmRlZmluZWQgaWYgaW5jb21wbGV0ZVxuICAgIC8vIHR1cGxlIDE6IHJlbWFpbmRlciBvZiB0aGUgYnVmZmVyXG4gICAgZnVuY3Rpb24gc2hpZnRFbnZlbG9wZShidWZmZXIsIGhlYWRlcikge1xuICAgICAgICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGggPCA1ICsgaGVhZGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIGJ1ZmZlcl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgZmxhZ3M6IGhlYWRlci5mbGFncywgZGF0YTogYnVmZmVyLnN1YmFycmF5KDUsIDUgKyBoZWFkZXIubGVuZ3RoKSB9LFxuICAgICAgICAgICAgYnVmZmVyLnN1YmFycmF5KDUgKyBoZWFkZXIubGVuZ3RoKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgLy8gdW5kZWZpbmVkOiBoZWFkZXIgaXMgaW5jb21wbGV0ZVxuICAgIGZ1bmN0aW9uIHBlZWtIZWFkZXIoYnVmZmVyKSB7XG4gICAgICAgIGlmIChidWZmZXIuYnl0ZUxlbmd0aCA8IDUpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIuYnVmZmVyLCBidWZmZXIuYnl0ZU9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSB2aWV3LmdldFVpbnQzMigxKTsgLy8gNCBieXRlcyBtZXNzYWdlIGxlbmd0aFxuICAgICAgICBjb25zdCBmbGFncyA9IHZpZXcuZ2V0VWludDgoMCk7IC8vIGZpcnN0IGJ5dGUgaXMgZmxhZ3NcbiAgICAgICAgcmV0dXJuIHsgbGVuZ3RoLCBmbGFncyB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgZV8xMSwgX2IsIF9jO1xuICAgICAgICAgICAgbGV0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIGl0ZXJhYmxlXzExID0gX19hc3luY1ZhbHVlcyhpdGVyYWJsZSksIGl0ZXJhYmxlXzExXzE7IGl0ZXJhYmxlXzExXzEgPSB5aWVsZCBfX2F3YWl0KGl0ZXJhYmxlXzExLm5leHQoKSksIF9hID0gaXRlcmFibGVfMTFfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfYyA9IGl0ZXJhYmxlXzExXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2M7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGFwcGVuZChidWZmZXIsIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gcGVla0hlYWRlcihidWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydFJlYWRNYXhCeXRlcyhyZWFkTWF4Qnl0ZXMsIGhlYWRlci5sZW5ndGgsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVudjtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtlbnYsIGJ1ZmZlcl0gPSBzaGlmdEVudmVsb3BlKGJ1ZmZlciwgaGVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZW52KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KGVudik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xMV8xKSB7IGVfMTEgPSB7IGVycm9yOiBlXzExXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gaXRlcmFibGVfMTEucmV0dXJuKSkgeWllbGQgX19hd2FpdChfYi5jYWxsKGl0ZXJhYmxlXzExKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xMSkgdGhyb3cgZV8xMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJ1ZmZlci5ieXRlTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlciA9IHBlZWtIZWFkZXIoYnVmZmVyKTtcbiAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9IFwicHJvdG9jb2wgZXJyb3I6IGluY29tcGxldGUgZW52ZWxvcGVcIjtcbiAgICAgICAgICAgICAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgcHJvdG9jb2wgZXJyb3I6IHByb21pc2VkICR7aGVhZGVyLmxlbmd0aH0gYnl0ZXMgaW4gZW52ZWxvcGVkIG1lc3NhZ2UsIGdvdCAke2J1ZmZlci5ieXRlTGVuZ3RoIC0gNX0gYnl0ZXNgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdEVycm9yKG1lc3NhZ2UsIENvZGUuSW52YWxpZEFyZ3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbi8qKlxuICogUmVhZHMgYWxsIGJ5dGVzIGZyb20gdGhlIHNvdXJjZSwgYW5kIGNvbmNhdGVuYXRlcyB0aGVtIHRvIGEgc2luZ2xlIFVpbnQ4QXJyYXkuXG4gKlxuICogUmFpc2VzIGFuIGVycm9yIGlmOlxuICogLSBtb3JlIHRoYW4gcmVhZE1heEJ5dGVzIGFyZSByZWFkXG4gKiAtIGxlbmd0aEhpbnQgaXMgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBidXQgbGFyZ2VyIHRoYW4gcmVhZE1heEJ5dGVzXG4gKiAtIGxlbmd0aEhpbnQgaXMgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBhbmQgdGhlIHNvdXJjZSBjb250YWlucyBtb3JlIG9yIGxlc3MgYnl0ZXNcbiAqICAgdGhhbiBwcm9taXNlZFxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5hc3luYyBmdW5jdGlvbiByZWFkQWxsQnl0ZXMoaXRlcmFibGUsIHJlYWRNYXhCeXRlcywgbGVuZ3RoSGludCkge1xuICAgIHZhciBfYSwgZV8xMiwgX2IsIF9jLCBfZCwgZV8xMywgX2UsIF9mO1xuICAgIGNvbnN0IFtvaywgaGludF0gPSBwYXJzZUxlbmd0aEhpbnQobGVuZ3RoSGludCk7XG4gICAgaWYgKG9rKSB7XG4gICAgICAgIGlmIChoaW50ID4gcmVhZE1heEJ5dGVzKSB7XG4gICAgICAgICAgICBhc3NlcnRSZWFkTWF4Qnl0ZXMocmVhZE1heEJ5dGVzLCBoaW50LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShoaW50KTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfZyA9IHRydWUsIGl0ZXJhYmxlXzEyID0gX19hc3luY1ZhbHVlcyhpdGVyYWJsZSksIGl0ZXJhYmxlXzEyXzE7IGl0ZXJhYmxlXzEyXzEgPSBhd2FpdCBpdGVyYWJsZV8xMi5uZXh0KCksIF9hID0gaXRlcmFibGVfMTJfMS5kb25lLCAhX2E7IF9nID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF9jID0gaXRlcmFibGVfMTJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBfZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2M7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCArIGNodW5rLmJ5dGVMZW5ndGggPiBoaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0RXJyb3IoYHByb3RvY29sIGVycm9yOiBwcm9taXNlZCAke2hpbnR9IGJ5dGVzLCByZWNlaXZlZCAke29mZnNldCArIGNodW5rLmJ5dGVMZW5ndGh9YCwgQ29kZS5JbnZhbGlkQXJndW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWZmZXIuc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzEyXzEpIHsgZV8xMiA9IHsgZXJyb3I6IGVfMTJfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIV9nICYmICFfYSAmJiAoX2IgPSBpdGVyYWJsZV8xMi5yZXR1cm4pKSBhd2FpdCBfYi5jYWxsKGl0ZXJhYmxlXzEyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xMikgdGhyb3cgZV8xMi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgPCBoaW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdEVycm9yKGBwcm90b2NvbCBlcnJvcjogcHJvbWlzZWQgJHtoaW50fSBieXRlcywgcmVjZWl2ZWQgJHtvZmZzZXR9YCwgQ29kZS5JbnZhbGlkQXJndW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2ggPSB0cnVlLCBpdGVyYWJsZV8xMyA9IF9fYXN5bmNWYWx1ZXMoaXRlcmFibGUpLCBpdGVyYWJsZV8xM18xOyBpdGVyYWJsZV8xM18xID0gYXdhaXQgaXRlcmFibGVfMTMubmV4dCgpLCBfZCA9IGl0ZXJhYmxlXzEzXzEuZG9uZSwgIV9kOyBfaCA9IHRydWUpIHtcbiAgICAgICAgICAgIF9mID0gaXRlcmFibGVfMTNfMS52YWx1ZTtcbiAgICAgICAgICAgIF9oID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IF9mO1xuICAgICAgICAgICAgY291bnQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGFzc2VydFJlYWRNYXhCeXRlcyhyZWFkTWF4Qnl0ZXMsIGNvdW50KTtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV8xM18xKSB7IGVfMTMgPSB7IGVycm9yOiBlXzEzXzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfaCAmJiAhX2QgJiYgKF9lID0gaXRlcmFibGVfMTMucmV0dXJuKSkgYXdhaXQgX2UuY2FsbChpdGVyYWJsZV8xMyk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzEzKSB0aHJvdyBlXzEzLmVycm9yOyB9XG4gICAgfVxuICAgIGNvbnN0IGFsbCA9IG5ldyBVaW50OEFycmF5KGNvdW50KTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBjaHVuayA9IGNodW5rcy5zaGlmdCgpOyBjaHVuazsgY2h1bmsgPSBjaHVua3Muc2hpZnQoKSkge1xuICAgICAgICBhbGwuc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGFsbDtcbn1cbi8vIHBhcnNlIHRoZSBsZW5ndGhIaW50IGFyZ3VtZW50IG9mIHJlYWRBbGxCeXRlcygpXG5mdW5jdGlvbiBwYXJzZUxlbmd0aEhpbnQobGVuZ3RoSGludCkge1xuICAgIGlmIChsZW5ndGhIaW50ID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoSGludCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW2ZhbHNlLCAwXTtcbiAgICB9XG4gICAgY29uc3QgbiA9IHR5cGVvZiBsZW5ndGhIaW50ID09IFwic3RyaW5nXCIgPyBwYXJzZUludChsZW5ndGhIaW50LCAxMCkgOiBsZW5ndGhIaW50O1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApIHtcbiAgICAgICAgcmV0dXJuIFtmYWxzZSwgbl07XG4gICAgfVxuICAgIHJldHVybiBbdHJ1ZSwgbl07XG59XG4vKipcbiAqIFdhaXQgZm9yIHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGl0ZXJhYmxlIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBpdGVyYWJsZS5cbiAqIFRoaXMgY29uc3VtZXMgdGhlIGZpcnN0IGVsZW1lbnQsIGJ1dCBwdXNoZXMgaXQgYmFjayBvbiB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHVudGlsRmlyc3QoaXRlcmFibGUpIHtcbiAgICBjb25zdCBpdCA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgIGxldCBmaXJzdCA9IGF3YWl0IGl0Lm5leHQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgY29uc3QgdyA9IHtcbiAgICAgICAgICAgICAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBmaXJzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBpdC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaXQudGhyb3cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uIC0tIGNhbid0IGhhbmRsZSBtdXRhdGVkIG9iamVjdCBzZW5zaWJseVxuICAgICAgICAgICAgICAgIHcudGhyb3cgPSAoZSkgPT4gaXQudGhyb3coZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXQucmV0dXJuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvbixAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55IC0tIGNhbid0IGhhbmRsZSBtdXRhdGVkIG9iamVjdCBzZW5zaWJseVxuICAgICAgICAgICAgICAgIHcucmV0dXJuID0gKHZhbHVlKSA9PiBpdC5yZXR1cm4odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHc7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogV3JhcCB0aGUgZ2l2ZW4gaXRlcmFibGUgYW5kIHJldHVybiBhbiBpdGVyYWJsZSB3aXRoIGFuIGFib3J0KCkgbWV0aG9kLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZXhpc3RzIHB1cmVseSBmb3IgY29udmVuaWVuY2UuIFdoZXJlIG9uZSB3b3VsZCB0eXBpY2FsbHkgaGF2ZVxuICogdG8gYWNjZXNzIHRoZSBpdGVyYXRvciBkaXJlY3RseSwgYWR2YW5jZSB0aHJvdWdoIGFsbCBlbGVtZW50cywgYW5kIGNhbGxcbiAqIEFzeW5jSXRlcmF0b3IudGhyb3coKSB0byBub3RpZnkgdGhlIHVwc3RyZWFtIGl0ZXJhYmxlLCB0aGlzIGZ1bmN0aW9uIGFsbG93c1xuICogdG8gdXNlIGNvbnZlbmllbnQgZm9yLWF3YWl0IGxvb3BzIGFuZCBzdGlsbCBub3RpZnkgdGhlIHVwc3RyZWFtIGl0ZXJhYmxlOlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBhYm9ydGFibGUgPSBtYWtlSXRlcmFibGVBYm9ydGFibGUoaXRlcmFibGUpO1xuICogZm9yIGF3YWl0IChjb25zdCBlbGUgb2YgYWJvcnRhYmxlKSB7XG4gKiAgIGF3YWl0IGFib3J0YWJsZS5hYm9ydChcIkVSUlwiKTtcbiAqIH1cbiAqIGBgYFxuICogVGhlcmUgYXJlIGEgY291cGxlIG9mIGxpbWl0YXRpb25zIG9mIHRoaXMgZnVuY3Rpb246XG4gKiAtIHRoZSBnaXZlbiBhc3luYyBpdGVyYWJsZSBtdXN0IGltcGxlbWVudCB0aHJvd1xuICogLSB0aGUgYXN5bmMgaXRlcmFibGUgY2Fubm90IGJlIHJlLXVzZVxuICogLSBpZiBzb3VyY2UgY2F0Y2hlcyBlcnJvcnMgYW5kIHlpZWxkcyB2YWx1ZXMgZm9yIHRoZW0sIHRoZXkgYXJlIGlnbm9yZWQsIGFuZFxuICogICB0aGUgc291cmNlIG1heSBzdGlsbCBkYW5nbGVcbiAqXG4gKiBUaGVyZSBhcmUgZm91ciBwb3NzaWJsZSB3YXlzIGFuIGFzeW5jIGZ1bmN0aW9uKiBjYW4gaGFuZGxlIHlpZWxkIGVycm9yczpcbiAqIDEuIGRvbid0IGNhdGNoIGVycm9ycyBhdCBhbGwgLSBBYm9ydGFibGUuYWJvcnQoKSB3aWxsIHJlc29sdmUgXCJyZXRocm93blwiXG4gKiAyLiBjYXRjaCBlcnJvcnMgYW5kIHJldGhyb3cgLSBBYm9ydGFibGUuYWJvcnQoKSB3aWxsIHJlc29sdmUgXCJyZXRocm93blwiXG4gKiAzLiBjYXRjaCBlcnJvcnMgYW5kIHJldHVybiAtIEFib3J0YWJsZS5hYm9ydCgpIHdpbGwgcmVzb2x2ZSBcImNvbXBsZXRlZFwiXG4gKiA0LiBjYXRjaCBlcnJvcnMgYW5kIHlpZWxkIGEgdmFsdWUgLSBBYm9ydGFibGUuYWJvcnQoKSB3aWxsIHJlc29sdmUgXCJjYXVnaHRcIlxuICpcbiAqIE5vdGUgdGhhdCBjYXRjaGluZyBlcnJvcnMgYW5kIHlpZWxkaW5nIGEgdmFsdWUgaXMgcHJvYmxlbWF0aWMsIGFuZCBpdCBzaG91bGRcbiAqIGJlIGRvY3VtZW50ZWQgdGhhdCB0aGlzIG1heSBsZWF2ZSB0aGUgc291cmNlIGluIGEgZGFuZ2xpbmcgc3RhdGUuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmZ1bmN0aW9uIG1ha2VJdGVyYWJsZUFib3J0YWJsZShpdGVyYWJsZSkge1xuICAgIGNvbnN0IGlubmVyQ2FuZGlkYXRlID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgaWYgKGlubmVyQ2FuZGlkYXRlLnRocm93ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXN5bmNJdGVyYWJsZSBkb2VzIG5vdCBpbXBsZW1lbnQgdGhyb3dcIik7XG4gICAgfVxuICAgIGNvbnN0IGlubmVyID0gaW5uZXJDYW5kaWRhdGU7XG4gICAgbGV0IGFib3J0ZWQ7XG4gICAgbGV0IHJlc3VsdFByb21pc2U7XG4gICAgbGV0IGl0ID0ge1xuICAgICAgICBuZXh0KCkge1xuICAgICAgICAgICAgcmVzdWx0UHJvbWlzZSA9IGlubmVyLm5leHQoKS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXN1bHRQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0UHJvbWlzZTtcbiAgICAgICAgfSxcbiAgICAgICAgdGhyb3coZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlubmVyLnRocm93KGUpO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgaWYgKGlubmVyQ2FuZGlkYXRlLnJldHVybiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGl0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpdCksIHsgcmV0dXJuKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyLnJldHVybih2YWx1ZSk7XG4gICAgICAgICAgICB9IH0pO1xuICAgIH1cbiAgICBsZXQgdXNlZCA9IGZhbHNlO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFib3J0KHJlYXNvbikge1xuICAgICAgICAgICAgaWYgKGFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWJvcnRlZC5zdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGYgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyLnRocm93KHJlYXNvbikudGhlbigocikgPT4gKHIuZG9uZSA9PT0gdHJ1ZSA/IFwiY29tcGxldGVkXCIgOiBcImNhdWdodFwiKSwgKCkgPT4gXCJyZXRocm93blwiKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocmVzdWx0UHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGFib3J0ZWQgPSB7IHJlYXNvbiwgc3RhdGU6IHJlc3VsdFByb21pc2UudGhlbihmLCBmKSB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBhYm9ydGVkLnN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWJvcnRlZCA9IHsgcmVhc29uLCBzdGF0ZTogZigpIH07XG4gICAgICAgICAgICByZXR1cm4gYWJvcnRlZC5zdGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgIGlmICh1c2VkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXN5bmNJdGVyYWJsZSBjYW5ub3QgYmUgcmUtdXNlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGl0O1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBXcml0YWJsZUl0ZXJhYmxlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVXcml0YWJsZUl0ZXJhYmxlKCkge1xuICAgIC8vIFdlIHN0YXJ0IHdpdGggdHdvIHF1ZXVlcyB0byBjYXB0dXJlIHRoZSByZWFkIGFuZCB3cml0ZSBhdHRlbXB0cy5cbiAgICAvL1xuICAgIC8vIFRoZSB3cml0ZXMgYW5kIHJlYWRzIGVhY2ggY2hlY2sgb2YgdGhlaXIgY291bnRlcnBhcnQgaXNcbiAgICAvLyBhbHJlYWR5IGF2YWlsYWJsZSBhbmQgZWl0aGVyIGludGVyYWN0L2FkZCB0aGVtc2VsdmVzIHRvIHRoZSBxdWV1ZS5cbiAgICBjb25zdCByZWFkUXVldWUgPSBbXTtcbiAgICBjb25zdCB3cml0ZVF1ZXVlID0gW107XG4gICAgbGV0IGVyciA9IHVuZGVmaW5lZDtcbiAgICBsZXQgbmV4dFJlc29sdmU7XG4gICAgbGV0IG5leHRSZWplY3Q7XG4gICAgbGV0IG5leHRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBuZXh0UmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIG5leHRSZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG4gICAgbGV0IGNsb3NlZCA9IGZhbHNlO1xuICAgIC8vIGRyYWluIHRoZSByZWFkUXVldWUgaW4gY2FzZSBvZiBlcnJvci93cml0ZXIgaXMgY2xvc2VkIGJ5IHNlbmRpbmcgYVxuICAgIC8vIGRvbmUgcmVzdWx0LlxuICAgIGZ1bmN0aW9uIGRyYWluKCkge1xuICAgICAgICBmb3IgKGNvbnN0IG5leHQgb2YgcmVhZFF1ZXVlLnNwbGljZSgwLCByZWFkUXVldWUubGVuZ3RoKSkge1xuICAgICAgICAgICAgbmV4dCh7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgZHJhaW4oKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgd3JpdGUocGF5bG9hZCkge1xuICAgICAgICAgICAgaWYgKGNsb3NlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IGVyciAhPT0gbnVsbCAmJiBlcnIgIT09IHZvaWQgMCA/IGVyciA6IG5ldyBFcnJvcihcImNhbm5vdCB3cml0ZSwgV3JpdGFibGVJdGVyYWJsZSBhbHJlYWR5IGNsb3NlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlYWQgPSByZWFkUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChyZWFkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBkaWRuJ3QgZmluZCBhIHBlbmRpbmcgcmVhZCBzbyB3ZSBhZGQgdGhlIHBheWxvYWQgdG8gdGhlIHdyaXRlIHF1ZXVlLlxuICAgICAgICAgICAgICAgIHdyaXRlUXVldWUucHVzaChwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIGEgcGVuZGluZyByZWFkIHNvIHdlIHJlc3BvbmQgd2l0aCB0aGUgcGF5bG9hZC5cbiAgICAgICAgICAgICAgICByZWFkKHsgZG9uZTogZmFsc2UsIHZhbHVlOiBwYXlsb2FkIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZWFkUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbW9yZSBpbiB0aGUgcmVhZCBxdWV1ZSB3ZSBjYW4gbWFyayB0aGUgd3JpdGUgYXMgY29tcGxldGUuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIHRoZSBlcnJvciByZXBvcnRpbmcgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgc2VxdWVudGlhbCBhbmQgdGhlcmVmb3JlIGNhbm5vdFxuICAgICAgICAgICAgICAgICAgICAvLyB0byBsaW5rZWQgdG8gYSBzcGVjaWZpYyB3cml0ZS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGF3YWl0IHRoZSBuZXh0IGNhbGwgZm9yIGFzIG1hbnkgdGltZXMgYXMgdGhlcmUgYXJlIGl0ZW1zIGluIHRoZSBxdWV1ZSArIDFcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gaXRlbXMgaW4gdGhlIHdyaXRlIHF1ZXVlIHRoYXQgbWVhbnMgd3JpdGUgaGFwcGVuZWQgYW5kIHdlIGp1c3QgaGF2ZVxuICAgICAgICAgICAgLy8gdG8gd2FpdCBmb3Igb25lIG1vcmUgY2FsbCBsaWtld2lzZSBpZiB3ZSBhcmUgdGhlIG50aCB3cml0ZSBpbiB0aGUgcXVldWUgd2VcbiAgICAgICAgICAgIC8vIGhhdmUgdG8gd2FpdCBmb3IgbiB3cml0ZXMgdG8gY29tcGxldGUgYW5kIG9uZSBtb3JlLlxuICAgICAgICAgICAgY29uc3QgbGltaXQgPSB3cml0ZVF1ZXVlLmxlbmd0aCArIDE7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbWl0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBuZXh0UHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmV4dCgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzb2x2ZSB0aGUgbmV4dFByb21pc2UgdG8gaW5kaWNhdGVcbiAgICAgICAgICAgICAgICAgICAgLy8gcGVuZGluZyB3cml0ZXMgdGhhdCBhIHJlYWQgYXR0ZW1wdCBoYXMgYmVlbiBtYWRlXG4gICAgICAgICAgICAgICAgICAgIC8vIGFmdGVyIHRoZWlyIHdyaXRlLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhbHNvIG5lZWQgdG8gcmVzZXQgdGhlIHByb21pc2UgZm9yIGZ1dHVyZSB3cml0ZXMuXG4gICAgICAgICAgICAgICAgICAgIG5leHRSZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdyaXRlID0gd3JpdGVRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAod3JpdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZm91bmQgYSBwZW5kaW5nIHdyaXRlIHNvIHJlc3BvbnNlIHdpdGggdGhlIHBheWxvYWQuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgZG9uZTogZmFsc2UsIHZhbHVlOiB3cml0ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBXZSByZXR1cm4gYSBwcm9taXNlIGltbWVkaWF0ZWx5IHRoYXQgaXMgZWl0aGVyIHJlc29sdmVkL3JlamVjdGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIHdyaXRlcyBoYXBwZW4uXG4gICAgICAgICAgICAgICAgICAgIGxldCByZWFkUmVzb2x2ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVhZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gKHJlYWRSZXNvbHZlID0gcmVzb2x2ZSkpO1xuICAgICAgICAgICAgICAgICAgICByZWFkUXVldWUucHVzaChyZWFkUmVzb2x2ZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZFByb21pc2U7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aHJvdyh0aHJvd0Vycikge1xuICAgICAgICAgICAgICAgICAgICBlcnIgPSB0aHJvd0VycjtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVRdWV1ZS5zcGxpY2UoMCwgd3JpdGVRdWV1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0UHJvbWlzZS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUbyBtYWtlIHN1cmUgdGhhdCB0aGUgbmV4dFByb21pc2UgaXMgYWx3YXlzIHJlc29sdmVkLlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHJlamVjdCBhbGwgcGVuZGluZyB3cml0ZXMuXG4gICAgICAgICAgICAgICAgICAgIG5leHRSZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgZHJhaW4oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXR1cm4oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlUXVldWUuc3BsaWNlKDAsIHdyaXRlUXVldWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzb2x2ZSBvbmNlIGZvciB0aGUgd3JpdGUgYXdhaXRpbmcgY29uZmlybWF0aW9uLlxuICAgICAgICAgICAgICAgICAgICBuZXh0UmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWplY3QgYWxsIGZ1dHVyZSB3cml0ZXMuXG4gICAgICAgICAgICAgICAgICAgIG5leHRQcm9taXNlID0gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiY2Fubm90IHdyaXRlLCBjb25zdW1lciBjYWxsZWQgcmV0dXJuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFByb21pc2UuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVG8gbWFrZSBzdXJlIHRoYXQgdGhlIG5leHRQcm9taXNlIGlzIGFsd2F5cyByZXNvbHZlZC5cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRyYWluKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZSBhbiBhc3luY2hyb25vdXMgaXRlcmFibGUgZnJvbSBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXF1aXJlLWF3YWl0XG5mdW5jdGlvbiBjcmVhdGVBc3luY0l0ZXJhYmxlKGl0ZW1zKSB7XG4gICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogY3JlYXRlQXN5bmNJdGVyYWJsZV8xKCkge1xuICAgICAgICB5aWVsZCBfX2F3YWl0KHlpZWxkKiBfX2FzeW5jRGVsZWdhdG9yKF9fYXN5bmNWYWx1ZXMoaXRlbXMpKSk7XG4gICAgfSk7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb21pc2UtY2xpZW50LmpzXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIHByb21pc2VfY2xpZW50X2FzeW5jVmFsdWVzID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hc3luY1ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XG59O1xudmFyIHByb21pc2VfY2xpZW50X2F3YWl0ID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdCkgfHwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBwcm9taXNlX2NsaWVudF9hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBwcm9taXNlX2NsaWVudF9hd2FpdCh2KTsgfVxudmFyIHByb21pc2VfY2xpZW50X2FzeW5jRGVsZWdhdG9yID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hc3luY0RlbGVnYXRvcikgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICB2YXIgaSwgcDtcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IHByb21pc2VfY2xpZW50X2F3YWl0KG9bbl0odikpLCBkb25lOiBmYWxzZSB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxufTtcbnZhciBwcm9taXNlX2NsaWVudF9hc3luY0dlbmVyYXRvciA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXN5bmNHZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIHByb21pc2VfY2xpZW50X2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XG59O1xuXG5cblxuXG5cbi8qKlxuICogQ3JlYXRlIGEgUHJvbWlzZUNsaWVudCBmb3IgdGhlIGdpdmVuIHNlcnZpY2UsIGludm9raW5nIFJQQ3MgdGhyb3VnaCB0aGVcbiAqIGdpdmVuIHRyYW5zcG9ydC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUHJvbWlzZUNsaWVudChzZXJ2aWNlLCB0cmFuc3BvcnQpIHtcbiAgICByZXR1cm4gbWFrZUFueUNsaWVudChzZXJ2aWNlLCAobWV0aG9kKSA9PiB7XG4gICAgICAgIHN3aXRjaCAobWV0aG9kLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2Ugc2VydmljZV90eXBlLyogTWV0aG9kS2luZCAqLy50LlVuYXJ5OlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVVbmFyeUZuKHRyYW5zcG9ydCwgc2VydmljZSwgbWV0aG9kKTtcbiAgICAgICAgICAgIGNhc2Ugc2VydmljZV90eXBlLyogTWV0aG9kS2luZCAqLy50LlNlcnZlclN0cmVhbWluZzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlU2VydmVyU3RyZWFtaW5nRm4odHJhbnNwb3J0LCBzZXJ2aWNlLCBtZXRob2QpO1xuICAgICAgICAgICAgY2FzZSBzZXJ2aWNlX3R5cGUvKiBNZXRob2RLaW5kICovLnQuQ2xpZW50U3RyZWFtaW5nOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDbGllbnRTdHJlYW1pbmdGbih0cmFuc3BvcnQsIHNlcnZpY2UsIG1ldGhvZCk7XG4gICAgICAgICAgICBjYXNlIHNlcnZpY2VfdHlwZS8qIE1ldGhvZEtpbmQgKi8udC5CaURpU3RyZWFtaW5nOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVCaURpU3RyZWFtaW5nRm4odHJhbnNwb3J0LCBzZXJ2aWNlLCBtZXRob2QpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlVW5hcnlGbih0cmFuc3BvcnQsIHNlcnZpY2UsIG1ldGhvZCkge1xuICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0cmFuc3BvcnQudW5hcnkoc2VydmljZSwgbWV0aG9kLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGltZW91dE1zLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycywgaW5wdXQsIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jb250ZXh0VmFsdWVzKTtcbiAgICAgICAgKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9uSGVhZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCByZXNwb25zZS5oZWFkZXIpO1xuICAgICAgICAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25UcmFpbGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChvcHRpb25zLCByZXNwb25zZS50cmFpbGVyKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm1lc3NhZ2U7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlcnZlclN0cmVhbWluZ0ZuKHRyYW5zcG9ydCwgc2VydmljZSwgbWV0aG9kKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gaGFuZGxlU3RyZWFtUmVzcG9uc2UodHJhbnNwb3J0LnN0cmVhbShzZXJ2aWNlLCBtZXRob2QsIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduYWwsIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50aW1lb3V0TXMsIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzLCBjcmVhdGVBc3luY0l0ZXJhYmxlKFtpbnB1dF0pLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY29udGV4dFZhbHVlcyksIG9wdGlvbnMpO1xuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVDbGllbnRTdHJlYW1pbmdGbih0cmFuc3BvcnQsIHNlcnZpY2UsIG1ldGhvZCkge1xuICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiAocmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIGVfMSwgX2IsIF9jO1xuICAgICAgICB2YXIgX2QsIF9lO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRyYW5zcG9ydC5zdHJlYW0oc2VydmljZSwgbWV0aG9kLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGltZW91dE1zLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycywgcmVxdWVzdCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNvbnRleHRWYWx1ZXMpO1xuICAgICAgICAoX2QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25IZWFkZXIpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKG9wdGlvbnMsIHJlc3BvbnNlLmhlYWRlcik7XG4gICAgICAgIGxldCBzaW5nbGVNZXNzYWdlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2YgPSB0cnVlLCBfZyA9IHByb21pc2VfY2xpZW50X2FzeW5jVmFsdWVzKHJlc3BvbnNlLm1lc3NhZ2UpLCBfaDsgX2ggPSBhd2FpdCBfZy5uZXh0KCksIF9hID0gX2guZG9uZSwgIV9hOyBfZiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICBfYyA9IF9oLnZhbHVlO1xuICAgICAgICAgICAgICAgIF9mID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IF9jO1xuICAgICAgICAgICAgICAgIHNpbmdsZU1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIV9mICYmICFfYSAmJiAoX2IgPSBfZy5yZXR1cm4pKSBhd2FpdCBfYi5jYWxsKF9nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNpbmdsZU1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBjb25uZWN0X2Vycm9yX0Nvbm5lY3RFcnJvcihcInByb3RvY29sIGVycm9yOiBtaXNzaW5nIHJlc3BvbnNlIG1lc3NhZ2VcIiwgY29kZV9Db2RlLkludGVybmFsKTtcbiAgICAgICAgfVxuICAgICAgICAoX2UgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25UcmFpbGVyKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuY2FsbChvcHRpb25zLCByZXNwb25zZS50cmFpbGVyKTtcbiAgICAgICAgcmV0dXJuIHNpbmdsZU1lc3NhZ2U7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJpRGlTdHJlYW1pbmdGbih0cmFuc3BvcnQsIHNlcnZpY2UsIG1ldGhvZCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAocmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gaGFuZGxlU3RyZWFtUmVzcG9uc2UodHJhbnNwb3J0LnN0cmVhbShzZXJ2aWNlLCBtZXRob2QsIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduYWwsIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50aW1lb3V0TXMsIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzLCByZXF1ZXN0LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY29udGV4dFZhbHVlcyksIG9wdGlvbnMpO1xuICAgIH07XG59XG5mdW5jdGlvbiBoYW5kbGVTdHJlYW1SZXNwb25zZShzdHJlYW0sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBpdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBwcm9taXNlX2NsaWVudF9hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHByb21pc2VfY2xpZW50X2F3YWl0KHN0cmVhbSk7XG4gICAgICAgICAgICAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25IZWFkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMsIHJlc3BvbnNlLmhlYWRlcik7XG4gICAgICAgICAgICB5aWVsZCBwcm9taXNlX2NsaWVudF9hd2FpdCh5aWVsZCogcHJvbWlzZV9jbGllbnRfYXN5bmNEZWxlZ2F0b3IocHJvbWlzZV9jbGllbnRfYXN5bmNWYWx1ZXMocmVzcG9uc2UubWVzc2FnZSkpKTtcbiAgICAgICAgICAgIChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vblRyYWlsZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKG9wdGlvbnMsIHJlc3BvbnNlLnRyYWlsZXIpO1xuICAgICAgICB9KTtcbiAgICB9KSgpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgIC8vIENyZWF0ZSBhIG5ldyBpdGVyYWJsZSB0byBvbWl0IHRocm93L3JldHVybi5cbiAgICByZXR1cm4ge1xuICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdOiAoKSA9PiAoe1xuICAgICAgICAgICAgbmV4dDogKCkgPT4gaXQubmV4dCgpLFxuICAgICAgICB9KSxcbiAgICB9O1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9jb250ZXh0LXZhbHVlcy5qc1xuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogY3JlYXRlQ29udGV4dFZhbHVlcyBjcmVhdGVzIGEgbmV3IENvbnRleHRWYWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHRWYWx1ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0KGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGtleS5pZCBpbiB0aGlzID8gdGhpc1trZXkuaWRdIDoga2V5LmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXNba2V5LmlkXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzW2tleS5pZF07XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBjcmVhdGVDb250ZXh0S2V5IGNyZWF0ZXMgYSBuZXcgQ29udGV4dEtleS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29udGV4dEtleShkZWZhdWx0VmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4geyBpZDogU3ltYm9sKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZXNjcmlwdGlvbiksIGRlZmF1bHRWYWx1ZSB9O1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC9zZXJpYWxpemF0aW9uLmpzXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5cblxuLyoqXG4gKiBTZXRzIGRlZmF1bHQgSlNPTiBzZXJpYWxpemF0aW9uIG9wdGlvbnMgZm9yIGNvbm5lY3QtZXMuXG4gKlxuICogV2l0aCBzdGFuZGFyZCBwcm90b2J1ZiBKU09OIHNlcmlhbGl6YXRpb24sIHVua25vd24gSlNPTiBmaWVsZHMgYXJlXG4gKiByZWplY3RlZCBieSBkZWZhdWx0LiBJbiBjb25uZWN0LWVzLCB1bmtub3duIEpTT04gZmllbGRzIGFyZSBpZ25vcmVkXG4gKiBieSBkZWZhdWx0LlxuICovXG5mdW5jdGlvbiBnZXRKc29uT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IG8gPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICAoX2EgPSBvLmlnbm9yZVVua25vd25GaWVsZHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChvLmlnbm9yZVVua25vd25GaWVsZHMgPSB0cnVlKTtcbiAgICByZXR1cm4gbztcbn1cbi8qKlxuICogQ3JlYXRlIGFuIG9iamVjdCB0aGF0IHByb3ZpZGVzIGNvbnZlbmllbnQgYWNjZXNzIHRvIHJlcXVlc3QgYW5kIHJlc3BvbnNlXG4gKiBtZXNzYWdlIHNlcmlhbGl6YXRpb24gZm9yIGEgZ2l2ZW4gbWV0aG9kLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5mdW5jdGlvbiBjcmVhdGVNZXRob2RTZXJpYWxpemF0aW9uTG9va3VwKG1ldGhvZCwgYmluYXJ5T3B0aW9ucywganNvbk9wdGlvbnMsIGxpbWl0T3B0aW9ucykge1xuICAgIGNvbnN0IGlucHV0QmluYXJ5ID0gbGltaXRTZXJpYWxpemF0aW9uKGNyZWF0ZUJpbmFyeVNlcmlhbGl6YXRpb24obWV0aG9kLkksIGJpbmFyeU9wdGlvbnMpLCBsaW1pdE9wdGlvbnMpO1xuICAgIGNvbnN0IGlucHV0SnNvbiA9IGxpbWl0U2VyaWFsaXphdGlvbihjcmVhdGVKc29uU2VyaWFsaXphdGlvbihtZXRob2QuSSwganNvbk9wdGlvbnMpLCBsaW1pdE9wdGlvbnMpO1xuICAgIGNvbnN0IG91dHB1dEJpbmFyeSA9IGxpbWl0U2VyaWFsaXphdGlvbihjcmVhdGVCaW5hcnlTZXJpYWxpemF0aW9uKG1ldGhvZC5PLCBiaW5hcnlPcHRpb25zKSwgbGltaXRPcHRpb25zKTtcbiAgICBjb25zdCBvdXRwdXRKc29uID0gbGltaXRTZXJpYWxpemF0aW9uKGNyZWF0ZUpzb25TZXJpYWxpemF0aW9uKG1ldGhvZC5PLCBqc29uT3B0aW9ucyksIGxpbWl0T3B0aW9ucyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0SSh1c2VCaW5hcnlGb3JtYXQpIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VCaW5hcnlGb3JtYXQgPyBpbnB1dEJpbmFyeSA6IGlucHV0SnNvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Tyh1c2VCaW5hcnlGb3JtYXQpIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VCaW5hcnlGb3JtYXQgPyBvdXRwdXRCaW5hcnkgOiBvdXRwdXRKc29uO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIFJldHVybnMgZnVuY3Rpb25zIHRvIG5vcm1hbGl6ZSBhbmQgc2VyaWFsaXplIHRoZSBpbnB1dCBtZXNzYWdlXG4gKiBvZiBhbiBSUEMsIGFuZCB0byBwYXJzZSB0aGUgb3V0cHV0IG1lc3NhZ2Ugb2YgYW4gUlBDLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDbGllbnRNZXRob2RTZXJpYWxpemVycyhtZXRob2QsIHVzZUJpbmFyeUZvcm1hdCwganNvbk9wdGlvbnMsIGJpbmFyeU9wdGlvbnMpIHtcbiAgICBjb25zdCBpbnB1dCA9IHVzZUJpbmFyeUZvcm1hdFxuICAgICAgICA/IGNyZWF0ZUJpbmFyeVNlcmlhbGl6YXRpb24obWV0aG9kLkksIGJpbmFyeU9wdGlvbnMpXG4gICAgICAgIDogY3JlYXRlSnNvblNlcmlhbGl6YXRpb24obWV0aG9kLkksIGpzb25PcHRpb25zKTtcbiAgICBjb25zdCBvdXRwdXQgPSB1c2VCaW5hcnlGb3JtYXRcbiAgICAgICAgPyBjcmVhdGVCaW5hcnlTZXJpYWxpemF0aW9uKG1ldGhvZC5PLCBiaW5hcnlPcHRpb25zKVxuICAgICAgICA6IGNyZWF0ZUpzb25TZXJpYWxpemF0aW9uKG1ldGhvZC5PLCBqc29uT3B0aW9ucyk7XG4gICAgcmV0dXJuIHsgcGFyc2U6IG91dHB1dC5wYXJzZSwgc2VyaWFsaXplOiBpbnB1dC5zZXJpYWxpemUgfTtcbn1cbi8qKlxuICogQXBwbHkgSS9PIGxpbWl0cyB0byBhIFNlcmlhbGl6YXRpb24gb2JqZWN0LCByZXR1cm5pbmcgYSBuZXcgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5mdW5jdGlvbiBsaW1pdFNlcmlhbGl6YXRpb24oc2VyaWFsaXphdGlvbiwgbGltaXRPcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2VyaWFsaXplKGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gc2VyaWFsaXphdGlvbi5zZXJpYWxpemUoZGF0YSk7XG4gICAgICAgICAgICBhc3NlcnRXcml0ZU1heEJ5dGVzKGxpbWl0T3B0aW9ucy53cml0ZU1heEJ5dGVzLCBieXRlcy5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBieXRlcztcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2UoZGF0YSkge1xuICAgICAgICAgICAgYXNzZXJ0UmVhZE1heEJ5dGVzKGxpbWl0T3B0aW9ucy5yZWFkTWF4Qnl0ZXMsIGRhdGEuYnl0ZUxlbmd0aCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXphdGlvbi5wYXJzZShkYXRhKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgU2VyaWFsaXphdGlvbiBvYmplY3QgZm9yIHNlcmlhbGl6aW5nIHRoZSBnaXZlbiBwcm90b2J1ZiBtZXNzYWdlXG4gKiB3aXRoIHRoZSBwcm90b2J1ZiBiaW5hcnkgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBjcmVhdGVCaW5hcnlTZXJpYWxpemF0aW9uKG1lc3NhZ2VUeXBlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGFyc2UoZGF0YSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZVR5cGUuZnJvbUJpbmFyeShkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFN0cmluZyhlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29ubmVjdF9lcnJvcl9Db25uZWN0RXJyb3IoYHBhcnNlIGJpbmFyeTogJHttfWAsIGNvZGVfQ29kZS5JbnZhbGlkQXJndW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXJpYWxpemUoZGF0YSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS50b0JpbmFyeShvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFN0cmluZyhlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29ubmVjdF9lcnJvcl9Db25uZWN0RXJyb3IoYHNlcmlhbGl6ZSBiaW5hcnk6ICR7bX1gLCBjb2RlX0NvZGUuSW50ZXJuYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBTZXJpYWxpemF0aW9uIG9iamVjdCBmb3Igc2VyaWFsaXppbmcgdGhlIGdpdmVuIHByb3RvYnVmIG1lc3NhZ2VcbiAqIHdpdGggdGhlIHByb3RvYnVmIGNhbm9uaWNhbCBKU09OIGVuY29kaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHVua25vd24gZmllbGRzIGFyZSBpZ25vcmVkLlxuICovXG5mdW5jdGlvbiBjcmVhdGVKc29uU2VyaWFsaXphdGlvbihtZXNzYWdlVHlwZSwgb3B0aW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgdGV4dEVuY29kZXIgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGV4dEVuY29kZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IHRleHREZWNvZGVyID0gKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRleHREZWNvZGVyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgVGV4dERlY29kZXIoKTtcbiAgICBjb25zdCBvID0gZ2V0SnNvbk9wdGlvbnMob3B0aW9ucyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGFyc2UoZGF0YSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBqc29uID0gdGV4dERlY29kZXIuZGVjb2RlKGRhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlVHlwZS5mcm9tSnNvblN0cmluZyhqc29uLCBvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY29ubmVjdF9lcnJvcl9Db25uZWN0RXJyb3IuZnJvbShlLCBjb2RlX0NvZGUuSW52YWxpZEFyZ3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2VyaWFsaXplKGRhdGEpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QganNvbiA9IGRhdGEudG9Kc29uU3RyaW5nKG8pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0RW5jb2Rlci5lbmNvZGUoanNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IGNvbm5lY3RfZXJyb3JfQ29ubmVjdEVycm9yLmZyb20oZSwgY29kZV9Db2RlLkludGVybmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC9zaWduYWxzLmpzXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5cbi8qKlxuICogQ3JlYXRlIGFuIEFib3J0Q29udHJvbGxlciB0aGF0IGlzIGF1dG9tYXRpY2FsbHkgYWJvcnRlZCBpZiBvbmUgb2YgdGhlIGdpdmVuXG4gKiBzaWduYWxzIGlzIGFib3J0ZWQuXG4gKlxuICogRm9yIGNvbnZlbmllbmNlLCB0aGUgbGlua2VkIEFib3J0U2lnbmFscyBjYW4gYmUgdW5kZWZpbmVkLlxuICpcbiAqIElmIHRoZSBjb250cm9sbGVyIG9yIGFueSBvZiB0aGUgc2lnbmFscyBpcyBhYm9ydGVkLCBhbGwgZXZlbnQgbGlzdGVuZXJzIGFyZVxuICogcmVtb3ZlZC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTGlua2VkQWJvcnRDb250cm9sbGVyKC4uLnNpZ25hbHMpIHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNhID0gc2lnbmFsc1xuICAgICAgICAuZmlsdGVyKChzKSA9PiBzICE9PSB1bmRlZmluZWQpXG4gICAgICAgIC5jb25jYXQoY29udHJvbGxlci5zaWduYWwpO1xuICAgIGZvciAoY29uc3Qgc2lnbmFsIG9mIHNhKSB7XG4gICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgb25BYm9ydC5hcHBseShzaWduYWwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25BYm9ydCgpIHtcbiAgICAgICAgaWYgKCFjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KGdldEFib3J0U2lnbmFsUmVhc29uKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHNpZ25hbCBvZiBzYSkge1xuICAgICAgICAgICAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udHJvbGxlcjtcbn1cbi8qKlxuICogQ3JlYXRlIGEgZGVhZGxpbmUgc2lnbmFsLiBUaGUgcmV0dXJuZWQgb2JqZWN0IGNvbnRhaW5zIGFuIEFib3J0U2lnbmFsLCBidXRcbiAqIGFsc28gYSBjbGVhbnVwIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIHRpbWVyLCB3aGljaCBtdXN0IGJlIGNhbGxlZCBvbmNlIHRoZVxuICogY2FsbGluZyBjb2RlIGlzIG5vIGxvbmdlciBpbnRlcmVzdGVkIGluIHRoZSBzaWduYWwuXG4gKlxuICogSWRlYWxseSwgd2Ugd291bGQgc2ltcGx5IHVzZSBBYm9ydFNpZ25hbC50aW1lb3V0KCksIGJ1dCBpdCBpcyBub3Qgd2lkZWx5XG4gKiBhdmFpbGFibGUgeWV0LlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5mdW5jdGlvbiBjcmVhdGVEZWFkbGluZVNpZ25hbCh0aW1lb3V0TXMpIHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IGxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmFib3J0KG5ldyBjb25uZWN0X2Vycm9yX0Nvbm5lY3RFcnJvcihcInRoZSBvcGVyYXRpb24gdGltZWQgb3V0XCIsIGNvZGVfQ29kZS5EZWFkbGluZUV4Y2VlZGVkKSk7XG4gICAgfTtcbiAgICBsZXQgdGltZW91dElkO1xuICAgIGlmICh0aW1lb3V0TXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodGltZW91dE1zIDw9IDApXG4gICAgICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGxpc3RlbmVyLCB0aW1lb3V0TXMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICBjbGVhbnVwOiAoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dElkKSxcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZWFzb24gd2h5IGFuIEFib3J0U2lnbmFsIHdhcyBhYm9ydGVkLiBSZXR1cm5zIHVuZGVmaW5lZCBpZiB0aGVcbiAqIHNpZ25hbCBoYXMgbm90IGJlZW4gYWJvcnRlZC5cbiAqXG4gKiBUaGUgcHJvcGVydHkgQWJvcnRTaWduYWwucmVhc29uIGlzIG5vdCB3aWRlbHkgYXZhaWxhYmxlLiBUaGlzIGZ1bmN0aW9uXG4gKiByZXR1cm5zIGFuIEFib3J0RXJyb3IgaWYgdGhlIHNpZ25hbCBpcyBhYm9ydGVkLCBidXQgcmVhc29uIGlzIHVuZGVmaW5lZC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWJvcnRTaWduYWxSZWFzb24oc2lnbmFsKSB7XG4gICAgaWYgKCFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoc2lnbmFsLnJlYXNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzaWduYWwucmVhc29uO1xuICAgIH1cbiAgICAvLyBBYm9ydFNpZ25hbC5yZWFzb24gaXMgYXZhaWxhYmxlIGluIE5vZGUuanMgdjE2LCB2MTgsIGFuZCBsYXRlcixcbiAgICAvLyBhbmQgaW4gYWxsIGJyb3dzZXJzIHNpbmNlIGVhcmx5IDIwMjIuXG4gICAgY29uc3QgZSA9IG5ldyBFcnJvcihcIlRoaXMgb3BlcmF0aW9uIHdhcyBhYm9ydGVkXCIpO1xuICAgIGUubmFtZSA9IFwiQWJvcnRFcnJvclwiO1xuICAgIHJldHVybiBlO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC9ub3JtYWxpemUuanNcbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbi8qKlxuICogIFRha2VzIGEgcGFydGlhbCBwcm90b2J1ZiBtZXNzYWdlcyBvZiB0aGVcbiAqICBzcGVjaWZpZWQgbWVzc2FnZSB0eXBlIGFzIGlucHV0LCBhbmQgcmV0dXJucyBmdWxsIGluc3RhbmNlcy5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKHR5cGUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbWVzc2FnZSBpbnN0YW5jZW9mIGVzbV9tZXNzYWdlLyogTWVzc2FnZSAqLy52ID8gbWVzc2FnZSA6IG5ldyB0eXBlKG1lc3NhZ2UpO1xufVxuLyoqXG4gKiBUYWtlcyBhbiBBc3luY0l0ZXJhYmxlIG9mIHBhcnRpYWwgcHJvdG9idWYgbWVzc2FnZXMgb2YgdGhlXG4gKiBzcGVjaWZpZWQgbWVzc2FnZSB0eXBlIGFzIGlucHV0LCBhbmQgeWllbGRzIGZ1bGwgaW5zdGFuY2VzLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJdGVyYWJsZShtZXNzYWdlVHlwZSwgaW5wdXQpIHtcbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0ocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQuZG9uZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogcmVzdWx0LmRvbmUsXG4gICAgICAgICAgICB2YWx1ZTogbm9ybWFsaXplKG1lc3NhZ2VUeXBlLCByZXN1bHQudmFsdWUpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgY29uc3QgaXQgPSBpbnB1dFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgICAgICAgICAgICBuZXh0OiAoKSA9PiBpdC5uZXh0KCkudGhlbih0cmFuc2Zvcm0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpdC50aHJvdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzLnRocm93ID0gKGUpID0+IGl0LnRocm93KGUpLnRoZW4odHJhbnNmb3JtKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXQucmV0dXJuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXMucmV0dXJuID0gKHYpID0+IGl0LnJldHVybih2KS50aGVuKHRyYW5zZm9ybSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC9ydW4tY2FsbC5qc1xuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuXG5cbi8qKlxuICogUnVucyBhIHVuYXJ5IG1ldGhvZCB3aXRoIHRoZSBnaXZlbiBpbnRlcmNlcHRvcnMuIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uXG4gKiBpcyBvbmx5IHVzZWQgd2hlbiBpbXBsZW1lbnRpbmcgYSBUcmFuc3BvcnQuXG4gKi9cbmZ1bmN0aW9uIHJ1blVuYXJ5Q2FsbChvcHQpIHtcbiAgICBjb25zdCBuZXh0ID0gYXBwbHlJbnRlcmNlcHRvcnMob3B0Lm5leHQsIG9wdC5pbnRlcmNlcHRvcnMpO1xuICAgIGNvbnN0IFtzaWduYWwsIGFib3J0LCBkb25lXSA9IHNldHVwU2lnbmFsKG9wdCk7XG4gICAgY29uc3QgcmVxID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHQucmVxKSwgeyBtZXNzYWdlOiBub3JtYWxpemUob3B0LnJlcS5tZXRob2QuSSwgb3B0LnJlcS5tZXNzYWdlKSwgc2lnbmFsIH0pO1xuICAgIHJldHVybiBuZXh0KHJlcSkudGhlbigocmVzKSA9PiB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LCBhYm9ydCk7XG59XG4vKipcbiAqIFJ1bnMgYSBzZXJ2ZXItc3RyZWFtaW5nIG1ldGhvZCB3aXRoIHRoZSBnaXZlbiBpbnRlcmNlcHRvcnMuIE5vdGUgdGhhdCB0aGlzXG4gKiBmdW5jdGlvbiBpcyBvbmx5IHVzZWQgd2hlbiBpbXBsZW1lbnRpbmcgYSBUcmFuc3BvcnQuXG4gKi9cbmZ1bmN0aW9uIHJ1blN0cmVhbWluZ0NhbGwob3B0KSB7XG4gICAgY29uc3QgbmV4dCA9IGFwcGx5SW50ZXJjZXB0b3JzKG9wdC5uZXh0LCBvcHQuaW50ZXJjZXB0b3JzKTtcbiAgICBjb25zdCBbc2lnbmFsLCBhYm9ydCwgZG9uZV0gPSBzZXR1cFNpZ25hbChvcHQpO1xuICAgIGNvbnN0IHJlcSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0LnJlcSksIHsgbWVzc2FnZTogbm9ybWFsaXplSXRlcmFibGUob3B0LnJlcS5tZXRob2QuSSwgb3B0LnJlcS5tZXNzYWdlKSwgc2lnbmFsIH0pO1xuICAgIGxldCBkb25lQ2FsbGVkID0gZmFsc2U7XG4gICAgLy8gQ2FsbCByZXR1cm4gb24gdGhlIHJlcXVlc3QgaXRlcmFibGUgdG8gaW5kaWNhdGVcbiAgICAvLyB0aGF0IHdlIHdpbGwgbm8gbG9uZ2VyIGNvbnN1bWUgaXQgYW5kIGl0IHNob3VsZFxuICAgIC8vIGNsZWFudXAgYW55IGFsbG9jYXRlZCByZXNvdXJjZXMuXG4gICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGl0ID0gb3B0LnJlcS5tZXNzYWdlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgICAgICAvLyBJZiB0aGUgc2lnbmFsIGlzIGFib3J0ZWQgZHVlIHRvIGFuIGVycm9yLCB3ZSB3YW50IHRvIHRocm93XG4gICAgICAgIC8vIHRoZSBlcnJvciB0byB0aGUgcmVxdWVzdCBpdGVyYXRvci5cbiAgICAgICAgaWYgKCFkb25lQ2FsbGVkKSB7XG4gICAgICAgICAgICAoX2EgPSBpdC50aHJvdykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoaXQsIHRoaXMucmVhc29uKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgcmV0dXJucyBhIHByb21pc2UsIHdoaWNoIHdlIGRvbid0IGNhcmUgYWJvdXQuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBVbmNhdWdodCBwcm9taXNlcyBhcmUgdGhyb3duIGF0IHNvbWV0aW1lL3NvbWV3aGVyZSBieSB0aGUgZXZlbnQgbG9vcCxcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRvIGVuc3VyZSBlcnJvciBpcyBjYXVnaHQgYW5kIGlnbm9yZWQuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAoX2IgPSBpdC5yZXR1cm4pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGl0KS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAvLyByZXR1cm4gcmV0dXJucyBhIHByb21pc2UsIHdoaWNoIHdlIGRvbid0IGNhcmUgYWJvdXQuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVW5jYXVnaHQgcHJvbWlzZXMgYXJlIHRocm93biBhdCBzb21ldGltZS9zb21ld2hlcmUgYnkgdGhlIGV2ZW50IGxvb3AsXG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRvIGVuc3VyZSBlcnJvciBpcyBjYXVnaHQgYW5kIGlnbm9yZWQuXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXh0KHJlcSkudGhlbigocmVzKSA9PiB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcyksIHsgbWVzc2FnZToge1xuICAgICAgICAgICAgICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ID0gcmVzLm1lc3NhZ2VbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdC5uZXh0KCkudGhlbigocikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5kb25lID09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmVDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGFib3J0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBkZWxpYmVyYXRlbHkgb21pdCB0aHJvdy9yZXR1cm4uXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0gfSk7XG4gICAgfSwgYWJvcnQpO1xufVxuLyoqXG4gKiBDcmVhdGUgYW4gQWJvcnRTaWduYWwgZm9yIFRyYW5zcG9ydCBpbXBsZW1lbnRhdGlvbnMuIFRoZSBzaWduYWwgaXMgYXZhaWxhYmxlXG4gKiBpbiBVbmFyeVJlcXVlc3QgYW5kIFN0cmVhbWluZ1JlcXVlc3QsIGFuZCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgY2FsbCBpc1xuICogYWJvcnRlZCAodmlhIGEgdGltZW91dCBvciBleHBsaWNpdCBjYW5jZWxsYXRpb24pLCBlcnJvcmVkIChlLmcuIHdoZW4gcmVhZGluZ1xuICogYW4gZXJyb3IgZnJvbSB0aGUgc2VydmVyIGZyb20gdGhlIHdpcmUpLCBvciBmaW5pc2hlZCBzdWNjZXNzZnVsbHkuXG4gKlxuICogVHJhbnNwb3J0IGltcGxlbWVudGF0aW9ucyBjYW4gcGFzcyB0aGUgc2lnbmFsIHRvIEhUVFAgY2xpZW50cyB0byBlbnN1cmUgdGhhdFxuICogdGhlcmUgYXJlIG5vIHVudXNlZCBjb25uZWN0aW9ucyBsZWFrLlxuICpcbiAqIFJldHVybnMgYSB0dXBsZTpcbiAqIFswXTogVGhlIHNpZ25hbCwgd2hpY2ggaXMgYWxzbyBhYm9ydGVkIGlmIHRoZSBvcHRpb25hbCBkZWFkbGluZSBpcyByZWFjaGVkLlxuICogWzFdOiBGdW5jdGlvbiB0byBjYWxsIGlmIHRoZSBUcmFuc3BvcnQgZW5jb3VudGVyZWQgYW4gZXJyb3IuXG4gKiBbMl06IEZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhlIFRyYW5zcG9ydCBmaW5pc2hlZCB3aXRob3V0IGFuIGVycm9yLlxuICovXG5mdW5jdGlvbiBzZXR1cFNpZ25hbChvcHQpIHtcbiAgICBjb25zdCB7IHNpZ25hbCwgY2xlYW51cCB9ID0gY3JlYXRlRGVhZGxpbmVTaWduYWwob3B0LnRpbWVvdXRNcyk7XG4gICAgY29uc3QgY29udHJvbGxlciA9IGNyZWF0ZUxpbmtlZEFib3J0Q29udHJvbGxlcihvcHQuc2lnbmFsLCBzaWduYWwpO1xuICAgIHJldHVybiBbXG4gICAgICAgIGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICBmdW5jdGlvbiBhYm9ydChyZWFzb24pIHtcbiAgICAgICAgICAgIC8vIFdlIHBlZWsgYXQgdGhlIGRlYWRsaW5lIHNpZ25hbCBiZWNhdXNlIGZldGNoKCkgd2lsbCB0aHJvdyBhbiBlcnJvciBvblxuICAgICAgICAgICAgLy8gYWJvcnQgdGhhdCBkaXNjYXJkcyB0aGUgc2lnbmFsIHJlYXNvbi5cbiAgICAgICAgICAgIGNvbnN0IGUgPSBjb25uZWN0X2Vycm9yX0Nvbm5lY3RFcnJvci5mcm9tKHNpZ25hbC5hYm9ydGVkID8gZ2V0QWJvcnRTaWduYWxSZWFzb24oc2lnbmFsKSA6IHJlYXNvbik7XG4gICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KGUpO1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9LFxuICAgIF07XG59XG4vKipcbiAqIGFwcGx5SW50ZXJjZXB0b3JzIHRha2VzIHRoZSBnaXZlbiBVbmFyeUZuIG9yIFNlcnZlclN0cmVhbWluZ0ZuLCBhbmQgd3JhcHNcbiAqIGl0IHdpdGggZWFjaCBvZiB0aGUgZ2l2ZW4gaW50ZXJjZXB0b3JzLCByZXR1cm5pbmcgYSBuZXcgVW5hcnlGbiBvclxuICogU2VydmVyU3RyZWFtaW5nRm4uXG4gKi9cbmZ1bmN0aW9uIGFwcGx5SW50ZXJjZXB0b3JzKG5leHQsIGludGVyY2VwdG9ycykge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IGludGVyY2VwdG9ycyA9PT0gbnVsbCB8fCBpbnRlcmNlcHRvcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdG9ycy5jb25jYXQoKS5yZXZlcnNlKCkucmVkdWNlKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgKG4sIGkpID0+IGkobiksIG5leHQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXh0KTtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvdG9jb2wvY3JlYXRlLW1ldGhvZC11cmwuanNcbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIENyZWF0ZSBhIFVSTCBmb3IgdGhlIGdpdmVuIFJQQy4gVGhpcyBzaW1wbHkgYWRkcyB0aGUgcXVhbGlmaWVkXG4gKiBzZXJ2aWNlIG5hbWUsIGEgc2xhc2gsIGFuZCB0aGUgbWV0aG9kIG5hbWUgdG8gdGhlIHBhdGggb2YgdGhlIGdpdmVuXG4gKiBiYXNlVXJsLlxuICpcbiAqIEZvciBleGFtcGxlLCB0aGUgYmFzZVVyaSBodHRwczovL2V4YW1wbGUuY29tIGFuZCBtZXRob2QgXCJTYXlcIiBmcm9tXG4gKiB0aGUgc2VydmljZSBleGFtcGxlLkVsaXphU2VydmljZSByZXN1bHRzIGluOlxuICogaHR0cHM6Ly9leGFtcGxlLmNvbS9leGFtcGxlLkVsaXphU2VydmljZS9TYXlcbiAqXG4gKiBUaGlzIGZvcm1hdCBpcyB1c2VkIGJ5IHRoZSBwcm90b2NvbHMgQ29ubmVjdCwgZ1JQQyBhbmQgVHdpcnAuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gYWxzbyBhY2NlcHRzIGEgcHJvdG9jb2wtcmVsYXRpdmUgYmFzZVVybC5cbiAqIElmIGdpdmVuIGFuIGVtcHR5IHN0cmluZyBvciBcIi9cIiBhcyBhIGJhc2VVcmwsIGl0IHJldHVybnMganVzdCB0aGVcbiAqIHBhdGguXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1ldGhvZFVybChiYXNlVXJsLCBzZXJ2aWNlLCBtZXRob2QpIHtcbiAgICBjb25zdCBzID0gdHlwZW9mIHNlcnZpY2UgPT0gXCJzdHJpbmdcIiA/IHNlcnZpY2UgOiBzZXJ2aWNlLnR5cGVOYW1lO1xuICAgIGNvbnN0IG0gPSB0eXBlb2YgbWV0aG9kID09IFwic3RyaW5nXCIgPyBtZXRob2QgOiBtZXRob2QubmFtZTtcbiAgICByZXR1cm4gYmFzZVVybC50b1N0cmluZygpLnJlcGxhY2UoL1xcLz8kLywgYC8ke3N9LyR7bX1gKTtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvdG9jb2wvZW52ZWxvcGUuanNcbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cblxuXG4vKipcbiAqIENyZWF0ZSBhIFdIQVRXRyBSZWFkYWJsZVN0cmVhbSBvZiBlbnZlbG9wZWQgbWVzc2FnZXMgZnJvbSBhIFJlYWRhYmxlU3RyZWFtXG4gKiBvZiBieXRlcy5cbiAqXG4gKiBJZGVhbGx5LCB0aGlzIHdvdWxkIHNpbXBseSBiZSBhIFRyYW5zZm9ybVN0cmVhbSwgYnV0IFJlYWRhYmxlU3RyZWFtLnBpcGVUaHJvdWdoXG4gKiBkb2VzIG5vdCBoYXZlIHRoZSBuZWNlc3NhcnkgYXZhaWxhYmlsaXR5IGF0IHRoaXMgdGltZS5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW52ZWxvcGVSZWFkYWJsZVN0cmVhbShzdHJlYW0pIHtcbiAgICBsZXQgcmVhZGVyO1xuICAgIGxldCBidWZmZXIgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgICBmdW5jdGlvbiBhcHBlbmQoY2h1bmspIHtcbiAgICAgICAgY29uc3QgbiA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlci5sZW5ndGggKyBjaHVuay5sZW5ndGgpO1xuICAgICAgICBuLnNldChidWZmZXIpO1xuICAgICAgICBuLnNldChjaHVuaywgYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgIGJ1ZmZlciA9IG47XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBzdGFydCgpIHtcbiAgICAgICAgICAgIHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBsZXQgaGVhZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChoZWFkZXIgPT09IHVuZGVmaW5lZCAmJiBidWZmZXIuYnl0ZUxlbmd0aCA+PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCA8PCA4KSArIGJ1ZmZlcltpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBoZWFkZXIgPSB7IGZsYWdzOiBidWZmZXJbMF0sIGxlbmd0aCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGVhZGVyICE9PSB1bmRlZmluZWQgJiYgYnVmZmVyLmJ5dGVMZW5ndGggPj0gaGVhZGVyLmxlbmd0aCArIDUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcHBlbmQocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChidWZmZXIuYnl0ZUxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKG5ldyBjb25uZWN0X2Vycm9yX0Nvbm5lY3RFcnJvcihcInByZW1hdHVyZSBlbmQgb2Ygc3RyZWFtXCIsIGNvZGVfQ29kZS5EYXRhTG9zcykpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBidWZmZXIuc3ViYXJyYXkoNSwgNSArIGhlYWRlci5sZW5ndGgpO1xuICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnN1YmFycmF5KDUgKyBoZWFkZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgZmxhZ3M6IGhlYWRlci5mbGFncyxcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIENvbXByZXNzIGFuIEVudmVsb3BlZE1lc3NhZ2UuXG4gKlxuICogUmFpc2VzIEludGVybmFsIGlmIGFuIGVudmVsb3BlZCBtZXNzYWdlIGlzIGFscmVhZHkgY29tcHJlc3NlZC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZW52ZWxvcGVfZW52ZWxvcGVDb21wcmVzcyhlbnZlbG9wZSwgY29tcHJlc3Npb24sIGNvbXByZXNzTWluQnl0ZXMpIHtcbiAgICBsZXQgeyBmbGFncywgZGF0YSB9ID0gZW52ZWxvcGU7XG4gICAgaWYgKChmbGFncyAmIGNvbXByZXNzZWRGbGFnKSA9PT0gY29tcHJlc3NlZEZsYWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IENvbm5lY3RFcnJvcihcImludmFsaWQgZW52ZWxvcGUsIGFscmVhZHkgY29tcHJlc3NlZFwiLCBDb2RlLkludGVybmFsKTtcbiAgICB9XG4gICAgaWYgKGNvbXByZXNzaW9uICYmIGRhdGEuYnl0ZUxlbmd0aCA+PSBjb21wcmVzc01pbkJ5dGVzKSB7XG4gICAgICAgIGRhdGEgPSBhd2FpdCBjb21wcmVzc2lvbi5jb21wcmVzcyhkYXRhKTtcbiAgICAgICAgZmxhZ3MgPSBmbGFncyB8IGNvbXByZXNzZWRGbGFnO1xuICAgIH1cbiAgICByZXR1cm4geyBkYXRhLCBmbGFncyB9O1xufVxuLyoqXG4gKiBEZWNvbXByZXNzIGFuIEVudmVsb3BlZE1lc3NhZ2UuXG4gKlxuICogUmFpc2VzIEludmFsaWRBcmd1bWVudCBpZiBhbiBlbnZlbG9wZSBpcyBjb21wcmVzc2VkLCBidXQgY29tcHJlc3Npb24gaXMgbnVsbC5cbiAqXG4gKiBSZWxpZXMgb24gdGhlIHByb3ZpZGVkIENvbXByZXNzaW9uIHRvIHJhaXNlIFJlc291cmNlRXhoYXVzdGVkIGlmIHRoZVxuICogKmRlY29tcHJlc3NlZCogbWVzc2FnZSBzaXplIGlzIGxhcmdlciB0aGFuIHJlYWRNYXhCeXRlcy4gSWYgdGhlIGVudmVsb3BlIGlzXG4gKiBub3QgY29tcHJlc3NlZCwgcmVhZE1heEJ5dGVzIGlzIG5vdCBob25vcmVkLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5hc3luYyBmdW5jdGlvbiBlbnZlbG9wZV9lbnZlbG9wZURlY29tcHJlc3MoZW52ZWxvcGUsIGNvbXByZXNzaW9uLCByZWFkTWF4Qnl0ZXMpIHtcbiAgICBsZXQgeyBmbGFncywgZGF0YSB9ID0gZW52ZWxvcGU7XG4gICAgaWYgKChmbGFncyAmIGNvbXByZXNzZWRGbGFnKSA9PT0gY29tcHJlc3NlZEZsYWcpIHtcbiAgICAgICAgaWYgKCFjb21wcmVzc2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3RFcnJvcihcInJlY2VpdmVkIGNvbXByZXNzZWQgZW52ZWxvcGUsIGJ1dCBkbyBub3Qga25vdyBob3cgdG8gZGVjb21wcmVzc1wiLCBDb2RlLkludmFsaWRBcmd1bWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IGF3YWl0IGNvbXByZXNzaW9uLmRlY29tcHJlc3MoZGF0YSwgcmVhZE1heEJ5dGVzKTtcbiAgICAgICAgZmxhZ3MgPSBmbGFncyBeIGNvbXByZXNzZWRGbGFnO1xuICAgIH1cbiAgICByZXR1cm4geyBkYXRhLCBmbGFncyB9O1xufVxuLyoqXG4gKiBFbmNvZGUgYSBzaW5nbGUgZW52ZWxvcGVkIG1lc3NhZ2UuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmZ1bmN0aW9uIGVudmVsb3BlX2VuY29kZUVudmVsb3BlKGZsYWdzLCBkYXRhKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCArIDUpO1xuICAgIGJ5dGVzLnNldChkYXRhLCA1KTtcbiAgICBjb25zdCB2ID0gbmV3IERhdGFWaWV3KGJ5dGVzLmJ1ZmZlciwgYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZUxlbmd0aCk7XG4gICAgdi5zZXRVaW50OCgwLCBmbGFncyk7IC8vIGZpcnN0IGJ5dGUgaXMgZmxhZ3NcbiAgICB2LnNldFVpbnQzMigxLCBkYXRhLmxlbmd0aCk7IC8vIDQgYnl0ZXMgbWVzc2FnZSBsZW5ndGhcbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vKipcbiAqIEVuY29kZSBhIHNldCBvZiBlbnZlbG9wZWQgbWVzc2FnZXMuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZUVudmVsb3BlcyguLi5lbnZlbG9wZXMpIHtcbiAgICBjb25zdCBsZW4gPSBlbnZlbG9wZXMucmVkdWNlKChwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUpID0+IHByZXZpb3VzVmFsdWUgKyBjdXJyZW50VmFsdWUuZGF0YS5sZW5ndGggKyA1LCAwKTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgY29uc3QgdiA9IG5ldyBEYXRhVmlldyhieXRlcy5idWZmZXIpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAoY29uc3QgZSBvZiBlbnZlbG9wZXMpIHtcbiAgICAgICAgdi5zZXRVaW50OChvZmZzZXQsIGUuZmxhZ3MpOyAvLyBmaXJzdCBieXRlIGlzIGZsYWdzXG4gICAgICAgIHYuc2V0VWludDMyKG9mZnNldCArIDEsIGUuZGF0YS5sZW5ndGgpOyAvLyA0IGJ5dGVzIG1lc3NhZ2UgbGVuZ3RoXG4gICAgICAgIGJ5dGVzLnNldChlLmRhdGEsIG9mZnNldCArIDUpO1xuICAgICAgICBvZmZzZXQgKz0gZS5kYXRhLmxlbmd0aCArIDU7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvdG9jb2wtZ3JwYy9oZWFkZXJzLmpzXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuY29uc3QgaGVhZGVyQ29udGVudFR5cGUgPSBcIkNvbnRlbnQtVHlwZVwiO1xuY29uc3QgaGVhZGVyc19oZWFkZXJFbmNvZGluZyA9IFwiR3JwYy1FbmNvZGluZ1wiO1xuY29uc3QgaGVhZGVyc19oZWFkZXJBY2NlcHRFbmNvZGluZyA9IFwiR3JwYy1BY2NlcHQtRW5jb2RpbmdcIjtcbmNvbnN0IGhlYWRlclRpbWVvdXQgPSBcIkdycGMtVGltZW91dFwiO1xuY29uc3QgaGVhZGVyc19oZWFkZXJHcnBjU3RhdHVzID0gXCJHcnBjLVN0YXR1c1wiO1xuY29uc3QgaGVhZGVyc19oZWFkZXJHcnBjTWVzc2FnZSA9IFwiR3JwYy1NZXNzYWdlXCI7XG5jb25zdCBoZWFkZXJzX2hlYWRlclN0YXR1c0RldGFpbHNCaW4gPSBcIkdycGMtU3RhdHVzLURldGFpbHMtQmluXCI7XG5jb25zdCBoZWFkZXJNZXNzYWdlVHlwZSA9IFwiR3JwYy1NZXNzYWdlLVR5cGVcIjtcbmNvbnN0IGhlYWRlclVzZXJBZ2VudCA9IFwiVXNlci1BZ2VudFwiO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC1ncnBjLXdlYi9oZWFkZXJzLmpzXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuXG4vKipcbiAqIGdSUEMtd2ViIGRvZXMgbm90IHVzZSB0aGUgc3RhbmRhcmQgaGVhZGVyIFVzZXItQWdlbnQuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmNvbnN0IGhlYWRlclhVc2VyQWdlbnQgPSBcIlgtVXNlci1BZ2VudFwiO1xuLyoqXG4gKiBUaGUgY2Fub25pY2FsIGdycGMvZ3JwYy13ZWIgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBzZXRzXG4gKiB0aGlzIHJlcXVlc3QgaGVhZGVyIHdpdGggdmFsdWUgXCIxXCIuXG4gKiBTb21lIHNlcnZlcnMgbWF5IHJlbHkgb24gdGhlIGhlYWRlciB0byBpZGVudGlmeSBnUlBDLXdlYlxuICogcmVxdWVzdHMuIEZvciBleGFtcGxlIHRoZSBwcm94eSBieSBpbXByb2JhYmxlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ltcHJvYmFibGUtZW5nL2dycGMtd2ViL2Jsb2IvNTNhYWY0Y2RjMGZlZGU3MTAzYzFiMDZmMGNmYzU2MGMwMDNhNWM0MS9nby9ncnBjd2ViL3dyYXBwZXIuZ28jTDIzMVxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5jb25zdCBoZWFkZXJYR3JwY1dlYiA9IFwiWC1HcnBjLVdlYlwiO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC1ncnBjLXdlYi9jb250ZW50LXR5cGUuanNcbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIFJlZ3VsYXIgRXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgYW55IHZhbGlkIGdSUEMtd2ViIENvbnRlbnQtVHlwZSBoZWFkZXIgdmFsdWUuXG4gKiBOb3RlIHRoYXQgdGhpcyBpbmNsdWRlcyBhcHBsaWNhdGlvbi9ncnBjLXdlYi10ZXh0IHdpdGggdGhlIGFkZGl0aW9uYWwgYmFzZTY0XG4gKiBlbmNvZGluZy5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuY29uc3QgY29udGVudFR5cGVSZWdFeHAgPSAvXmFwcGxpY2F0aW9uXFwvZ3JwYy13ZWIoLXRleHQpPyg/OlxcKyg/Oihqc29uKSg/OjsgP2NoYXJzZXQ9dXRmLT84KT98cHJvdG8pKT8kL2k7XG5jb25zdCBjb250ZW50VHlwZVByb3RvID0gXCJhcHBsaWNhdGlvbi9ncnBjLXdlYitwcm90b1wiO1xuY29uc3QgY29udGVudFR5cGVKc29uID0gXCJhcHBsaWNhdGlvbi9ncnBjLXdlYitqc29uXCI7XG4vKipcbiAqIFBhcnNlIGEgZ1JQQy13ZWIgQ29udGVudC1UeXBlIGhlYWRlciB2YWx1ZS5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZnVuY3Rpb24gcGFyc2VDb250ZW50VHlwZShjb250ZW50VHlwZSkge1xuICAgIGNvbnN0IG1hdGNoID0gY29udGVudFR5cGUgPT09IG51bGwgfHwgY29udGVudFR5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRlbnRUeXBlLm1hdGNoKGNvbnRlbnRUeXBlUmVnRXhwKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHRleHQgPSAhIW1hdGNoWzFdO1xuICAgIGNvbnN0IGJpbmFyeSA9ICFtYXRjaFsyXTtcbiAgICByZXR1cm4geyB0ZXh0LCBiaW5hcnkgfTtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvdG9jb2wtZ3JwYy13ZWIvcmVxdWVzdC1oZWFkZXIuanNcbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cblxuLyoqXG4gKiBDcmVhdGVzIGhlYWRlcnMgZm9yIGEgZ1JQQy13ZWIgcmVxdWVzdC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZnVuY3Rpb24gcmVxdWVzdEhlYWRlcih1c2VCaW5hcnlGb3JtYXQsIHRpbWVvdXRNcywgdXNlclByb3ZpZGVkSGVhZGVycywgc2V0VXNlckFnZW50KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IEhlYWRlcnModXNlclByb3ZpZGVkSGVhZGVycyAhPT0gbnVsbCAmJiB1c2VyUHJvdmlkZWRIZWFkZXJzICE9PSB2b2lkIDAgPyB1c2VyUHJvdmlkZWRIZWFkZXJzIDoge30pO1xuICAgIC8vIE5vdGUgdGhhdCB3ZSBkbyBub3Qgc3VwcG9ydCB0aGUgZ3JwYy13ZWItdGV4dCBmb3JtYXQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy9ibG9iL21hc3Rlci9kb2MvUFJPVE9DT0wtV0VCLm1kI3Byb3RvY29sLWRpZmZlcmVuY2VzLXZzLWdycGMtb3Zlci1odHRwMlxuICAgIHJlc3VsdC5zZXQoaGVhZGVyQ29udGVudFR5cGUsIHVzZUJpbmFyeUZvcm1hdCA/IGNvbnRlbnRUeXBlUHJvdG8gOiBjb250ZW50VHlwZUpzb24pO1xuICAgIHJlc3VsdC5zZXQoaGVhZGVyWEdycGNXZWIsIFwiMVwiKTtcbiAgICAvLyBOb3RlIHRoYXQgd2UgZG8gbm90IHN0cmljdGx5IGNvbXBseSB3aXRoIGdSUEMgdXNlciBhZ2VudHMuXG4gICAgLy8gV2UgdXNlIFwiY29ubmVjdC1lcy8xLjIuM1wiIHdoZXJlIGdSUEMgd291bGQgdXNlIFwiZ3JwYy1lcy8xLjIuM1wiLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjL2Jsb2IvYzQ2MmJiOGQ0ODVmYzE0MzRlY2ZhZTQzODgyM2NhOGQxNGNmMzE1NC9kb2MvUFJPVE9DT0wtSFRUUDIubWQjdXNlci1hZ2VudHNcbiAgICByZXN1bHQuc2V0KGhlYWRlclhVc2VyQWdlbnQsIFwiY29ubmVjdC1lcy8xLjIuMFwiKTtcbiAgICBpZiAoc2V0VXNlckFnZW50KSB7XG4gICAgICAgIHJlc3VsdC5zZXQoaGVhZGVyVXNlckFnZW50LCBcImNvbm5lY3QtZXMvMS4yLjBcIik7XG4gICAgfVxuICAgIGlmICh0aW1lb3V0TXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQuc2V0KGhlYWRlclRpbWVvdXQsIGAke3RpbWVvdXRNc31tYCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIENyZWF0ZXMgaGVhZGVycyBmb3IgYSBnUlBDLXdlYiByZXF1ZXN0IHdpdGggY29tcHJlc3Npb24uXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmZ1bmN0aW9uIHJlcXVlc3RIZWFkZXJXaXRoQ29tcHJlc3Npb24odXNlQmluYXJ5Rm9ybWF0LCB0aW1lb3V0TXMsIHVzZXJQcm92aWRlZEhlYWRlcnMsIGFjY2VwdENvbXByZXNzaW9uLCBzZW5kQ29tcHJlc3Npb24sIHNldFVzZXJBZ2VudCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHJlcXVlc3RIZWFkZXIodXNlQmluYXJ5Rm9ybWF0LCB0aW1lb3V0TXMsIHVzZXJQcm92aWRlZEhlYWRlcnMsIHNldFVzZXJBZ2VudCk7XG4gICAgaWYgKHNlbmRDb21wcmVzc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHJlc3VsdC5zZXQoaGVhZGVyRW5jb2RpbmcsIHNlbmRDb21wcmVzc2lvbi5uYW1lKTtcbiAgICB9XG4gICAgaWYgKGFjY2VwdENvbXByZXNzaW9uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzdWx0LnNldChoZWFkZXJBY2NlcHRFbmNvZGluZywgYWNjZXB0Q29tcHJlc3Npb24ubWFwKChjKSA9PiBjLm5hbWUpLmpvaW4oXCIsXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvdG9jb2wtZ3JwYy9odHRwLXN0YXR1cy5qc1xuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGdSUEMtd2ViIGVycm9yIGNvZGUgZm9yIHRoZSBnaXZlbiBIVFRQIHN0YXR1cyBjb2RlLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL2dycGMvYmxvYi9tYXN0ZXIvZG9jL2h0dHAtZ3JwYy1zdGF0dXMtbWFwcGluZy5tZC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZnVuY3Rpb24gY29kZUZyb21IdHRwU3RhdHVzKGh0dHBTdGF0dXMpIHtcbiAgICBzd2l0Y2ggKGh0dHBTdGF0dXMpIHtcbiAgICAgICAgY2FzZSA0MDA6IC8vIEJhZCBSZXF1ZXN0XG4gICAgICAgICAgICByZXR1cm4gY29kZV9Db2RlLkludGVybmFsO1xuICAgICAgICBjYXNlIDQwMTogLy8gVW5hdXRob3JpemVkXG4gICAgICAgICAgICByZXR1cm4gY29kZV9Db2RlLlVuYXV0aGVudGljYXRlZDtcbiAgICAgICAgY2FzZSA0MDM6IC8vIEZvcmJpZGRlblxuICAgICAgICAgICAgcmV0dXJuIGNvZGVfQ29kZS5QZXJtaXNzaW9uRGVuaWVkO1xuICAgICAgICBjYXNlIDQwNDogLy8gTm90IEZvdW5kXG4gICAgICAgICAgICByZXR1cm4gY29kZV9Db2RlLlVuaW1wbGVtZW50ZWQ7XG4gICAgICAgIGNhc2UgNDI5OiAvLyBUb28gTWFueSBSZXF1ZXN0c1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVfQ29kZS5VbmF2YWlsYWJsZTtcbiAgICAgICAgY2FzZSA1MDI6IC8vIEJhZCBHYXRld2F5XG4gICAgICAgICAgICByZXR1cm4gY29kZV9Db2RlLlVuYXZhaWxhYmxlO1xuICAgICAgICBjYXNlIDUwMzogLy8gU2VydmljZSBVbmF2YWlsYWJsZVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVfQ29kZS5VbmF2YWlsYWJsZTtcbiAgICAgICAgY2FzZSA1MDQ6IC8vIEdhdGV3YXkgVGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNvZGVfQ29kZS5VbmF2YWlsYWJsZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIDIwMCBpcyBVTktOT1dOIGJlY2F1c2UgdGhlcmUgc2hvdWxkIGJlIGEgZ3JwYy1zdGF0dXMgaW4gY2FzZSBvZiB0cnVseSBPSyByZXNwb25zZS5cbiAgICAgICAgICAgIHJldHVybiBjb2RlX0NvZGUuVW5rbm93bjtcbiAgICB9XG59XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3Byb3RvMy5qcyArIDIgbW9kdWxlc1xudmFyIHByb3RvMyA9IF9fd2VicGFja19yZXF1aXJlX18oODUwKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL2dvb2dsZS9wcm90b2J1Zi9hbnlfcGIuanNcbnZhciBhbnlfcGIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczMyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC1ncnBjL2dlbi9zdGF0dXNfcGIuanNcbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbi8qKlxuICogVGhlIGBTdGF0dXNgIHR5cGUgZGVmaW5lcyBhIGxvZ2ljYWwgZXJyb3IgbW9kZWwgdGhhdCBpcyBzdWl0YWJsZSBmb3IgZGlmZmVyZW50XG4gKiBwcm9ncmFtbWluZyBlbnZpcm9ubWVudHMsIGluY2x1ZGluZyBSRVNUIEFQSXMgYW5kIFJQQyBBUElzLiBJdCBpcyB1c2VkIGJ5XG4gKiBbZ1JQQ10oaHR0cHM6Ly9naXRodWIuY29tL2dycGMpLiBUaGUgZXJyb3IgbW9kZWwgaXMgZGVzaWduZWQgdG8gYmU6XG4gKlxuICogLSBTaW1wbGUgdG8gdXNlIGFuZCB1bmRlcnN0YW5kIGZvciBtb3N0IHVzZXJzXG4gKiAtIEZsZXhpYmxlIGVub3VnaCB0byBtZWV0IHVuZXhwZWN0ZWQgbmVlZHNcbiAqXG4gKiAjIE92ZXJ2aWV3XG4gKlxuICogVGhlIGBTdGF0dXNgIG1lc3NhZ2UgY29udGFpbnMgdGhyZWUgcGllY2VzIG9mIGRhdGE6IGVycm9yIGNvZGUsIGVycm9yIG1lc3NhZ2UsXG4gKiBhbmQgZXJyb3IgZGV0YWlscy4gVGhlIGVycm9yIGNvZGUgc2hvdWxkIGJlIGFuIGVudW0gdmFsdWUgb2ZcbiAqIFtnb29nbGUucnBjLkNvZGVdW2dvb2dsZS5ycGMuQ29kZV0sIGJ1dCBpdCBtYXkgYWNjZXB0IGFkZGl0aW9uYWwgZXJyb3IgY29kZXMgaWYgbmVlZGVkLiAgVGhlXG4gKiBlcnJvciBtZXNzYWdlIHNob3VsZCBiZSBhIGRldmVsb3Blci1mYWNpbmcgRW5nbGlzaCBtZXNzYWdlIHRoYXQgaGVscHNcbiAqIGRldmVsb3BlcnMgKnVuZGVyc3RhbmQqIGFuZCAqcmVzb2x2ZSogdGhlIGVycm9yLiBJZiBhIGxvY2FsaXplZCB1c2VyLWZhY2luZ1xuICogZXJyb3IgbWVzc2FnZSBpcyBuZWVkZWQsIHB1dCB0aGUgbG9jYWxpemVkIG1lc3NhZ2UgaW4gdGhlIGVycm9yIGRldGFpbHMgb3JcbiAqIGxvY2FsaXplIGl0IGluIHRoZSBjbGllbnQuIFRoZSBvcHRpb25hbCBlcnJvciBkZXRhaWxzIG1heSBjb250YWluIGFyYml0cmFyeVxuICogaW5mb3JtYXRpb24gYWJvdXQgdGhlIGVycm9yLiBUaGVyZSBpcyBhIHByZWRlZmluZWQgc2V0IG9mIGVycm9yIGRldGFpbCB0eXBlc1xuICogaW4gdGhlIHBhY2thZ2UgYGdvb2dsZS5ycGNgIHdoaWNoIGNhbiBiZSB1c2VkIGZvciBjb21tb24gZXJyb3IgY29uZGl0aW9ucy5cbiAqXG4gKiAjIExhbmd1YWdlIG1hcHBpbmdcbiAqXG4gKiBUaGUgYFN0YXR1c2AgbWVzc2FnZSBpcyB0aGUgbG9naWNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZXJyb3IgbW9kZWwsIGJ1dCBpdFxuICogaXMgbm90IG5lY2Vzc2FyaWx5IHRoZSBhY3R1YWwgd2lyZSBmb3JtYXQuIFdoZW4gdGhlIGBTdGF0dXNgIG1lc3NhZ2UgaXNcbiAqIGV4cG9zZWQgaW4gZGlmZmVyZW50IGNsaWVudCBsaWJyYXJpZXMgYW5kIGRpZmZlcmVudCB3aXJlIHByb3RvY29scywgaXQgY2FuIGJlXG4gKiBtYXBwZWQgZGlmZmVyZW50bHkuIEZvciBleGFtcGxlLCBpdCB3aWxsIGxpa2VseSBiZSBtYXBwZWQgdG8gc29tZSBleGNlcHRpb25zXG4gKiBpbiBKYXZhLCBidXQgbW9yZSBsaWtlbHkgbWFwcGVkIHRvIHNvbWUgZXJyb3IgY29kZXMgaW4gQy5cbiAqXG4gKiAjIE90aGVyIHVzZXNcbiAqXG4gKiBUaGUgZXJyb3IgbW9kZWwgYW5kIHRoZSBgU3RhdHVzYCBtZXNzYWdlIGNhbiBiZSB1c2VkIGluIGEgdmFyaWV0eSBvZlxuICogZW52aXJvbm1lbnRzLCBlaXRoZXIgd2l0aCBvciB3aXRob3V0IEFQSXMsIHRvIHByb3ZpZGUgYVxuICogY29uc2lzdGVudCBkZXZlbG9wZXIgZXhwZXJpZW5jZSBhY3Jvc3MgZGlmZmVyZW50IGVudmlyb25tZW50cy5cbiAqXG4gKiBFeGFtcGxlIHVzZXMgb2YgdGhpcyBlcnJvciBtb2RlbCBpbmNsdWRlOlxuICpcbiAqIC0gUGFydGlhbCBlcnJvcnMuIElmIGEgc2VydmljZSBuZWVkcyB0byByZXR1cm4gcGFydGlhbCBlcnJvcnMgdG8gdGhlIGNsaWVudCxcbiAqICAgICBpdCBtYXkgZW1iZWQgdGhlIGBTdGF0dXNgIGluIHRoZSBub3JtYWwgcmVzcG9uc2UgdG8gaW5kaWNhdGUgdGhlIHBhcnRpYWxcbiAqICAgICBlcnJvcnMuXG4gKlxuICogLSBXb3JrZmxvdyBlcnJvcnMuIEEgdHlwaWNhbCB3b3JrZmxvdyBoYXMgbXVsdGlwbGUgc3RlcHMuIEVhY2ggc3RlcCBtYXlcbiAqICAgICBoYXZlIGEgYFN0YXR1c2AgbWVzc2FnZSBmb3IgZXJyb3IgcmVwb3J0aW5nIHB1cnBvc2UuXG4gKlxuICogLSBCYXRjaCBvcGVyYXRpb25zLiBJZiBhIGNsaWVudCB1c2VzIGJhdGNoIHJlcXVlc3QgYW5kIGJhdGNoIHJlc3BvbnNlLCB0aGVcbiAqICAgICBgU3RhdHVzYCBtZXNzYWdlIHNob3VsZCBiZSB1c2VkIGRpcmVjdGx5IGluc2lkZSBiYXRjaCByZXNwb25zZSwgb25lIGZvclxuICogICAgIGVhY2ggZXJyb3Igc3ViLXJlc3BvbnNlLlxuICpcbiAqIC0gQXN5bmNocm9ub3VzIG9wZXJhdGlvbnMuIElmIGFuIEFQSSBjYWxsIGVtYmVkcyBhc3luY2hyb25vdXMgb3BlcmF0aW9uXG4gKiAgICAgcmVzdWx0cyBpbiBpdHMgcmVzcG9uc2UsIHRoZSBzdGF0dXMgb2YgdGhvc2Ugb3BlcmF0aW9ucyBzaG91bGQgYmVcbiAqICAgICByZXByZXNlbnRlZCBkaXJlY3RseSB1c2luZyB0aGUgYFN0YXR1c2AgbWVzc2FnZS5cbiAqXG4gKiAtIExvZ2dpbmcuIElmIHNvbWUgQVBJIGVycm9ycyBhcmUgc3RvcmVkIGluIGxvZ3MsIHRoZSBtZXNzYWdlIGBTdGF0dXNgIGNvdWxkXG4gKiAgICAgYmUgdXNlZCBkaXJlY3RseSBhZnRlciBhbnkgc3RyaXBwaW5nIG5lZWRlZCBmb3Igc2VjdXJpdHkvcHJpdmFjeSByZWFzb25zLlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGdvb2dsZS5ycGMuU3RhdHVzXG4gKi9cbmNsYXNzIHN0YXR1c19wYl9TdGF0dXMgZXh0ZW5kcyBlc21fbWVzc2FnZS8qIE1lc3NhZ2UgKi8udiB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHN0YXR1cyBjb2RlLCB3aGljaCBzaG91bGQgYmUgYW4gZW51bSB2YWx1ZSBvZiBbZ29vZ2xlLnJwYy5Db2RlXVtnb29nbGUucnBjLkNvZGVdLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDMyIGNvZGUgPSAxO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2RlID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZGV2ZWxvcGVyLWZhY2luZyBlcnJvciBtZXNzYWdlLCB3aGljaCBzaG91bGQgYmUgaW4gRW5nbGlzaC4gQW55XG4gICAgICAgICAqIHVzZXItZmFjaW5nIGVycm9yIG1lc3NhZ2Ugc2hvdWxkIGJlIGxvY2FsaXplZCBhbmQgc2VudCBpbiB0aGVcbiAgICAgICAgICogW2dvb2dsZS5ycGMuU3RhdHVzLmRldGFpbHNdW2dvb2dsZS5ycGMuU3RhdHVzLmRldGFpbHNdIGZpZWxkLCBvciBsb2NhbGl6ZWQgYnkgdGhlIGNsaWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbWVzc2FnZSA9IDI7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIlwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIG1lc3NhZ2VzIHRoYXQgY2FycnkgdGhlIGVycm9yIGRldGFpbHMuICBUaGVyZSB3aWxsIGJlIGFcbiAgICAgICAgICogY29tbW9uIHNldCBvZiBtZXNzYWdlIHR5cGVzIGZvciBBUElzIHRvIHVzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBnb29nbGUucHJvdG9idWYuQW55IGRldGFpbHMgPSAzO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZXRhaWxzID0gW107XG4gICAgICAgIHByb3RvMy8qIHByb3RvMyAqLy53LnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgc3RhdHVzX3BiX1N0YXR1cygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgc3RhdHVzX3BiX1N0YXR1cygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgc3RhdHVzX3BiX1N0YXR1cygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvMy8qIHByb3RvMyAqLy53LnV0aWwuZXF1YWxzKHN0YXR1c19wYl9TdGF0dXMsIGEsIGIpO1xuICAgIH1cbn1cbnN0YXR1c19wYl9TdGF0dXMucnVudGltZSA9IHByb3RvMy8qIHByb3RvMyAqLy53O1xuc3RhdHVzX3BiX1N0YXR1cy50eXBlTmFtZSA9IFwiZ29vZ2xlLnJwYy5TdGF0dXNcIjtcbnN0YXR1c19wYl9TdGF0dXMuZmllbGRzID0gcHJvdG8zLyogcHJvdG8zICovLncudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiY29kZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIm1lc3NhZ2VcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiZGV0YWlsc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogYW55X3BiLyogQW55ICovLkksIHJlcGVhdGVkOiB0cnVlIH0sXG5dKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJvdG8tYmFzZTY0LmpzXG52YXIgcHJvdG9fYmFzZTY0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMzYpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vaHR0cC1oZWFkZXJzLmpzXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5cblxuLyoqXG4gKiBFbmNvZGUgYSBzaW5nbGUgYmluYXJ5IGhlYWRlciB2YWx1ZSBhY2NvcmRpbmcgdG8gdGhlIENvbm5lY3RcbiAqIGFuZCBnUlBDIHNwZWNpZmljYXRpb25zLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyByYXcgYmluYXJ5IGRhdGEgZnJvbSBhIGJ1ZmZlciwgYSBzdHJpbmdcbiAqIHdpdGggVVRGLTggdGV4dCwgb3IgYSBwcm90b2J1ZiBtZXNzYWdlLiBJdCBlbmNvZGVzIHRoZSBpbnB1dFxuICogd2l0aCB1bnBhZGRlZCBiYXNlNjQgYW5kIHJldHVybnMgYSBzdHJpbmcgdGhhdCBjYW4gYmUgdXNlZCBmb3JcbiAqIGEgaGVhZGVyIHdob3NlIG5hbWUgZW5kcyB3aXRoIGAtYmluYC5cbiAqL1xuZnVuY3Rpb24gaHR0cF9oZWFkZXJzX2VuY29kZUJpbmFyeUhlYWRlcih2YWx1ZSkge1xuICAgIGxldCBieXRlcztcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNZXNzYWdlKSB7XG4gICAgICAgIGJ5dGVzID0gdmFsdWUudG9CaW5hcnkoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgYnl0ZXMgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYnl0ZXMgPSB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyB2YWx1ZSA6IG5ldyBVaW50OEFycmF5KHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3RvQmFzZTY0LmVuYyhieXRlcykucmVwbGFjZSgvPSskLywgXCJcIik7XG59XG5mdW5jdGlvbiBkZWNvZGVCaW5hcnlIZWFkZXIodmFsdWUsIHR5cGUsIG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBieXRlcyA9IHByb3RvX2Jhc2U2NC8qIHByb3RvQmFzZTY0ICovLlcuZGVjKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgY29ubmVjdF9lcnJvcl9Db25uZWN0RXJyb3IuZnJvbShlLCBjb2RlX0NvZGUuRGF0YUxvc3MpO1xuICAgIH1cbn1cbi8qKlxuICogTWVyZ2UgdHdvIG9yIG1vcmUgSGVhZGVycyBvYmplY3RzIGJ5IGFwcGVuZGluZyBhbGwgZmllbGRzIGZyb21cbiAqIGFsbCBpbnB1dHMgdG8gYSBuZXcgSGVhZGVycyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFwcGVuZEhlYWRlcnMoLi4uaGVhZGVycykge1xuICAgIGNvbnN0IGggPSBuZXcgSGVhZGVycygpO1xuICAgIGZvciAoY29uc3QgZSBvZiBoZWFkZXJzKSB7XG4gICAgICAgIGUuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgaC5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaDtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvdG9jb2wtZ3JwYy90cmFpbGVyLXN0YXR1cy5qc1xuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuXG5cblxuXG5cbi8qKlxuICogVGhlIHZhbHVlIG9mIHRoZSBHcnBjLVN0YXR1cyBoZWFkZXIgb3IgdHJhaWxlciBpbiBjYXNlIG9mIHN1Y2Nlc3MuXG4gKiBVc2VkIGJ5IHRoZSBnUlBDIGFuZCBnUlBDLXdlYiBwcm90b2NvbHMuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmNvbnN0IGdycGNTdGF0dXNPayA9IFwiMFwiO1xuLyoqXG4gKiBTZXRzIHRoZSBmaWVsZHMgXCJncnBjLXN0YXR1c1wiIGFuZCBcImdycGMtbWVzc2FnZVwiIGluIHRoZSBnaXZlblxuICogSGVhZGVycyBvYmplY3QuXG4gKiBJZiBhbiBlcnJvciBpcyBnaXZlbiBhbmQgY29udGFpbnMgZXJyb3IgZGV0YWlscywgdGhlIGZ1bmN0aW9uXG4gKiB3aWxsIGFsc28gc2V0IHRoZSBmaWVsZCBcImdycGMtc3RhdHVzLWRldGFpbHMtYmluXCIgd2l0aCBhbiBlbmNvZGVkXG4gKiBnb29nbGUucnBjLlN0YXR1cyBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZXJyb3IgZGV0YWlscy5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZnVuY3Rpb24gc2V0VHJhaWxlclN0YXR1cyh0YXJnZXQsIGVycm9yKSB7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHRhcmdldC5zZXQoaGVhZGVyR3JwY1N0YXR1cywgZXJyb3IuY29kZS50b1N0cmluZygxMCkpO1xuICAgICAgICB0YXJnZXQuc2V0KGhlYWRlckdycGNNZXNzYWdlLCBlbmNvZGVVUklDb21wb25lbnQoZXJyb3IucmF3TWVzc2FnZSkpO1xuICAgICAgICBpZiAoZXJyb3IuZGV0YWlscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgU3RhdHVzKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBlcnJvci5jb2RlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLnJhd01lc3NhZ2UsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogZXJyb3IuZGV0YWlscy5tYXAoKHZhbHVlKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIE1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgPyBBbnkucGFjayh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgOiBuZXcgQW55KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVVcmw6IGB0eXBlLmdvb2dsZWFwaXMuY29tLyR7dmFsdWUudHlwZX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRhcmdldC5zZXQoaGVhZGVyU3RhdHVzRGV0YWlsc0JpbiwgZW5jb2RlQmluYXJ5SGVhZGVyKHN0YXR1cykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0YXJnZXQuc2V0KGhlYWRlckdycGNTdGF0dXMsIGdycGNTdGF0dXNPay50b1N0cmluZygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbi8qKlxuICogRmluZCBhbiBlcnJvciBzdGF0dXMgaW4gdGhlIGdpdmVuIEhlYWRlcnMgb2JqZWN0LCB3aGljaCBjYW4gYmUgZWl0aGVyXG4gKiBhIHRyYWlsZXIsIG9yIGEgaGVhZGVyIChhcyBhbGxvd2VkIGZvciBzby1jYWxsZWQgdHJhaWxlcnMtb25seSByZXNwb25zZXMpLlxuICogVGhlIGZpZWxkIFwiZ3JwYy1zdGF0dXMtZGV0YWlscy1iaW5cIiBpcyBpbnNwZWN0ZWQsIGFuZCBpZiBub3QgcHJlc2VudCxcbiAqIHRoZSBmaWVsZHMgXCJncnBjLXN0YXR1c1wiIGFuZCBcImdycGMtbWVzc2FnZVwiIGFyZSB1c2VkLlxuICogUmV0dXJucyBhbiBlcnJvciBvbmx5IGlmIHRoZSBnUlBDIHN0YXR1cyBjb2RlIGlzID4gMC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZnVuY3Rpb24gZmluZFRyYWlsZXJFcnJvcihoZWFkZXJPclRyYWlsZXIpIHtcbiAgICAvLyBUT0RPXG4gICAgLy8gbGV0IGNvZGU6IENvZGU7XG4gICAgLy8gbGV0IG1lc3NhZ2U6IHN0cmluZyA9IFwiXCI7XG4gICAgdmFyIF9hO1xuICAgIC8vIFByZWZlciB0aGUgcHJvdG9idWYtZW5jb2RlZCBkYXRhIHRvIHRoZSBncnBjLXN0YXR1cyBoZWFkZXIuXG4gICAgY29uc3Qgc3RhdHVzQnl0ZXMgPSBoZWFkZXJPclRyYWlsZXIuZ2V0KGhlYWRlcnNfaGVhZGVyU3RhdHVzRGV0YWlsc0Jpbik7XG4gICAgaWYgKHN0YXR1c0J5dGVzICE9IG51bGwpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gZGVjb2RlQmluYXJ5SGVhZGVyKHN0YXR1c0J5dGVzLCBzdGF0dXNfcGJfU3RhdHVzKTtcbiAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgY29ubmVjdF9lcnJvcl9Db25uZWN0RXJyb3Ioc3RhdHVzLm1lc3NhZ2UsIHN0YXR1cy5jb2RlLCBoZWFkZXJPclRyYWlsZXIpO1xuICAgICAgICBlcnJvci5kZXRhaWxzID0gc3RhdHVzLmRldGFpbHMubWFwKChhbnkpID0+ICh7XG4gICAgICAgICAgICB0eXBlOiBhbnkudHlwZVVybC5zdWJzdHJpbmcoYW55LnR5cGVVcmwubGFzdEluZGV4T2YoXCIvXCIpICsgMSksXG4gICAgICAgICAgICB2YWx1ZTogYW55LnZhbHVlLFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgY29uc3QgZ3JwY1N0YXR1cyA9IGhlYWRlck9yVHJhaWxlci5nZXQoaGVhZGVyc19oZWFkZXJHcnBjU3RhdHVzKTtcbiAgICBpZiAoZ3JwY1N0YXR1cyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChncnBjU3RhdHVzID09PSBncnBjU3RhdHVzT2spIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZSA9IHBhcnNlSW50KGdycGNTdGF0dXMsIDEwKTtcbiAgICAgICAgaWYgKGNvZGUgaW4gY29kZV9Db2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNvbm5lY3RfZXJyb3JfQ29ubmVjdEVycm9yKGRlY29kZVVSSUNvbXBvbmVudCgoX2EgPSBoZWFkZXJPclRyYWlsZXIuZ2V0KGhlYWRlcnNfaGVhZGVyR3JwY01lc3NhZ2UpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiKSwgY29kZSwgaGVhZGVyT3JUcmFpbGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGNvbm5lY3RfZXJyb3JfQ29ubmVjdEVycm9yKGBpbnZhbGlkIGdycGMtc3RhdHVzOiAke2dycGNTdGF0dXN9YCwgY29kZV9Db2RlLkludGVybmFsLCBoZWFkZXJPclRyYWlsZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC1ncnBjLXdlYi92YWxpZGF0ZS1yZXNwb25zZS5qc1xuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuXG5cblxuXG4vKipcbiAqIFZhbGlkYXRlcyByZXNwb25zZSBzdGF0dXMgYW5kIGhlYWRlciBmb3IgdGhlIGdSUEMtd2ViIHByb3RvY29sLlxuICpcbiAqIFRocm93cyBhIENvbm5lY3RFcnJvciBpZiB0aGUgaGVhZGVyIGNvbnRhaW5zIGFuIGVycm9yIHN0YXR1cyxcbiAqIG9yIGlmIHRoZSBIVFRQIHN0YXR1cyBpbmRpY2F0ZXMgYW4gZXJyb3IuXG4gKlxuICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciBhIGdSUEMgc3RhdHVzIHdhcyBmb3VuZFxuICogaW4gdGhlIHJlc3BvbnNlIGhlYWRlci4gSW4gdGhpcyBjYXNlLCBjbGllbnRzIGNhbiBub3QgZXhwZWN0IGFcbiAqIHRyYWlsZXIuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUmVzcG9uc2Uoc3RhdHVzLCBoZWFkZXJzKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIEZvciBjb21wYXRpYmlsaXR5IHdpdGggdGhlIGBncnBjLXdlYmAgcGFja2FnZSwgd2UgdHJlYXQgYWxsIEhUVFAgc3RhdHVzXG4gICAgLy8gY29kZXMgaW4gdGhlIDIwMCByYW5nZSBhcyB2YWxpZCwgbm90IGp1c3QgSFRUUCAyMDAuXG4gICAgaWYgKHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IGZpbmRUcmFpbGVyRXJyb3IoaGVhZGVycyk7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmb3VuZFN0YXR1czogaGVhZGVycy5oYXMoaGVhZGVyc19oZWFkZXJHcnBjU3RhdHVzKSB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgY29ubmVjdF9lcnJvcl9Db25uZWN0RXJyb3IoZGVjb2RlVVJJQ29tcG9uZW50KChfYSA9IGhlYWRlcnMuZ2V0KGhlYWRlcnNfaGVhZGVyR3JwY01lc3NhZ2UpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBgSFRUUCAke3N0YXR1c31gKSwgY29kZUZyb21IdHRwU3RhdHVzKHN0YXR1cyksIGhlYWRlcnMpO1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgcmVzcG9uc2Ugc3RhdHVzIGFuZCBoZWFkZXIgZm9yIHRoZSBnUlBDLXdlYiBwcm90b2NvbC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgaWRlbnRpY2FsIHRvIHZhbGlkYXRlUmVzcG9uc2UoKSwgYnV0IGFsc28gdmVyaWZpZXNcbiAqIHRoYXQgYSBnaXZlbiBlbmNvZGluZyBoZWFkZXIgaXMgYWNjZXB0YWJsZS5cbiAqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSByZXNwb25zZSBjb21wcmVzc2lvbiwgYW5kIGEgYm9vbGVhblxuICogaW5kaWNhdGluZyB3aGV0aGVyIGEgZ1JQQyBzdGF0dXMgd2FzIGZvdW5kIGluIHRoZSByZXNwb25zZSBoZWFkZXJcbiAqIChpbiB0aGlzIGNhc2UsIGNsaWVudHMgY2FuIG5vdCBleHBlY3QgYSB0cmFpbGVyKS5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVSZXNwb25zZVdpdGhDb21wcmVzc2lvbihhY2NlcHRDb21wcmVzc2lvbiwgc3RhdHVzLCBoZWFkZXJzKSB7XG4gICAgY29uc3QgeyBmb3VuZFN0YXR1cyB9ID0gdmFsaWRhdGVSZXNwb25zZShzdGF0dXMsIGhlYWRlcnMpO1xuICAgIGxldCBjb21wcmVzc2lvbjtcbiAgICBjb25zdCBlbmNvZGluZyA9IGhlYWRlcnMuZ2V0KGhlYWRlckVuY29kaW5nKTtcbiAgICBpZiAoZW5jb2RpbmcgIT09IG51bGwgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSAhPT0gXCJpZGVudGl0eVwiKSB7XG4gICAgICAgIGNvbXByZXNzaW9uID0gYWNjZXB0Q29tcHJlc3Npb24uZmluZCgoYykgPT4gYy5uYW1lID09PSBlbmNvZGluZyk7XG4gICAgICAgIGlmICghY29tcHJlc3Npb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0RXJyb3IoYHVuc3VwcG9ydGVkIHJlc3BvbnNlIGVuY29kaW5nIFwiJHtlbmNvZGluZ31cImAsIENvZGUuSW52YWxpZEFyZ3VtZW50LCBoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBmb3VuZFN0YXR1cyxcbiAgICAgICAgY29tcHJlc3Npb24sXG4gICAgfTtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvdG9jb2wtZ3JwYy13ZWIvdHJhaWxlci5qc1xuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogdHJhaWxlckZsYWcgaW5kaWNhdGVzIHRoYXQgdGhlIGRhdGEgaW4gYSBFbnZlbG9wZWRNZXNzYWdlXG4gKiBpcyBhIHNldCBvZiB0cmFpbGVycyBvZiB0aGUgZ1JQQy13ZWIgcHJvdG9jb2wuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmNvbnN0IHRyYWlsZXJGbGFnID0gMGIxMDAwMDAwMDtcbi8qKlxuICogUGFyc2UgYSBnUlBDLXdlYiB0cmFpbGVyLCBhIHNldCBvZiBoZWFkZXIgZmllbGRzIHNlcGFyYXRlZCBieSBDUkxGLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5mdW5jdGlvbiB0cmFpbGVyUGFyc2UoZGF0YSkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIGNvbnN0IGxpbmVzID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRhdGEpLnNwbGl0KFwiXFxyXFxuXCIpO1xuICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgICBpZiAobGluZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaSA9IGxpbmUuaW5kZXhPZihcIjpcIik7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGxpbmUuc3Vic3RyaW5nKDAsIGkpLnRyaW0oKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbGluZS5zdWJzdHJpbmcoaSArIDEpLnRyaW0oKTtcbiAgICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycztcbn1cbi8qKlxuICogU2VyaWFsaXplIGEgSGVhZGVycyBvYmplY3QgYXMgYSBnUlBDLXdlYiB0cmFpbGVyLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5mdW5jdGlvbiB0cmFpbGVyU2VyaWFsaXplKHRyYWlsZXIpIHtcbiAgICBjb25zdCBsaW5lcyA9IFtdO1xuICAgIHRyYWlsZXIuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBsaW5lcy5wdXNoKGAke2tleX06ICR7dmFsdWV9XFxyXFxuYCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShsaW5lcy5qb2luKFwiXCIpKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgU2VyaWFsaXphdGlvbiBvYmplY3QgdGhhdCBzZXJpYWxpemVzIGEgZ1JQQy13ZWIgdHJhaWxlciwgYSBIZWFkZXJzXG4gKiBvYmplY3QgdGhhdCBpcyBzZXJpYWxpemVkIGFzIGEgc2V0IG9mIGhlYWRlciBmaWVsZHMsIHNlcGFyYXRlZCBieSBDUkxGLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5mdW5jdGlvbiBjcmVhdGVUcmFpbGVyU2VyaWFsaXphdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZXJpYWxpemU6IHRyYWlsZXJTZXJpYWxpemUsXG4gICAgICAgIHBhcnNlOiB0cmFpbGVyUGFyc2UsXG4gICAgfTtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvdG9jb2wtZ3JwYy92YWxpZGF0ZS10cmFpbGVyLmpzXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKipcbiAqIFZhbGlkYXRlcyBhIHRyYWlsZXIgZm9yIHRoZSBnUlBDIGFuZCB0aGUgZ1JQQy13ZWIgcHJvdG9jb2wuXG4gKiBUaHJvd3MgYSBDb25uZWN0RXJyb3IgaWYgdGhlIHRyYWlsZXIgY29udGFpbnMgYW4gZXJyb3Igc3RhdHVzLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVRyYWlsZXIodHJhaWxlciwgaGVhZGVyKSB7XG4gICAgY29uc3QgZXJyID0gZmluZFRyYWlsZXJFcnJvcih0cmFpbGVyKTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICAgIGhlYWRlci5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBlcnIubWV0YWRhdGEuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3Qtd2ViL2Rpc3QvZXNtL2Fzc2VydC1mZXRjaC1hcGkuanNcbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUgZmV0Y2ggQVBJIGlzIGF2YWlsYWJsZS5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0RmV0Y2hBcGkoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IEhlYWRlcnMoKTtcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29ubmVjdC13ZWIgcmVxdWlyZXMgdGhlIGZldGNoIEFQSS4gQXJlIHlvdSBydW5uaW5nIG9uIGFuIG9sZCB2ZXJzaW9uIG9mIE5vZGUuanM/IE5vZGUuanMgaXMgbm90IHN1cHBvcnRlZCBpbiBDb25uZWN0IGZvciBXZWIgLSBwbGVhc2Ugc3RheSB0dW5lZCBmb3IgQ29ubmVjdCBmb3IgTm9kZS5cIik7XG4gICAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC13ZWIvZGlzdC9lc20vZ3JwYy13ZWItdHJhbnNwb3J0LmpzXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIGdycGNfd2ViX3RyYW5zcG9ydF9hd2FpdCA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXdhaXQpIHx8IGZ1bmN0aW9uICh2KSB7IHJldHVybiB0aGlzIGluc3RhbmNlb2YgZ3JwY193ZWJfdHJhbnNwb3J0X2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IGdycGNfd2ViX3RyYW5zcG9ydF9hd2FpdCh2KTsgfVxudmFyIGdycGNfd2ViX3RyYW5zcG9ydF9hc3luY0dlbmVyYXRvciA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXN5bmNHZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIGdycGNfd2ViX3RyYW5zcG9ydF9hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxufTtcblxuXG5cblxuXG4vKipcbiAqIENyZWF0ZSBhIFRyYW5zcG9ydCBmb3IgdGhlIGdSUEMtd2ViIHByb3RvY29sLiBUaGUgcHJvdG9jb2wgZW5jb2Rlc1xuICogdHJhaWxlcnMgaW4gdGhlIHJlc3BvbnNlIGJvZHkgYW5kIG1ha2VzIHVuYXJ5IGFuZCBzZXJ2ZXItc3RyZWFtaW5nXG4gKiBtZXRob2RzIGF2YWlsYWJsZSB0byB3ZWIgYnJvd3NlcnMuIEl0IHVzZXMgdGhlIGZldGNoIEFQSSB0byBtYWtlXG4gKiBIVFRQIHJlcXVlc3RzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIHRyYW5zcG9ydCBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGdycGMtd2ViLXRleHQgZm9ybWF0LFxuICogd2hpY2ggYXBwbGllcyBiYXNlNjQgZW5jb2RpbmcgdG8gdGhlIHJlcXVlc3QgYW5kIHJlc3BvbnNlIGJvZGllcyB0b1xuICogc3VwcG9ydCByZWFkaW5nIHN0cmVhbWluZyByZXNwb25zZXMgZnJvbSBhbiBYTUxIdHRwUmVxdWVzdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlR3JwY1dlYlRyYW5zcG9ydChvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGFzc2VydEZldGNoQXBpKCk7XG4gICAgY29uc3QgdXNlQmluYXJ5Rm9ybWF0ID0gKF9hID0gb3B0aW9ucy51c2VCaW5hcnlGb3JtYXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWU7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXN5bmMgdW5hcnkoc2VydmljZSwgbWV0aG9kLCBzaWduYWwsIHRpbWVvdXRNcywgaGVhZGVyLCBtZXNzYWdlLCBjb250ZXh0VmFsdWVzKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCB7IHNlcmlhbGl6ZSwgcGFyc2UgfSA9IGNyZWF0ZUNsaWVudE1ldGhvZFNlcmlhbGl6ZXJzKG1ldGhvZCwgdXNlQmluYXJ5Rm9ybWF0LCBvcHRpb25zLmpzb25PcHRpb25zLCBvcHRpb25zLmJpbmFyeU9wdGlvbnMpO1xuICAgICAgICAgICAgdGltZW91dE1zID1cbiAgICAgICAgICAgICAgICB0aW1lb3V0TXMgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IG9wdGlvbnMuZGVmYXVsdFRpbWVvdXRNc1xuICAgICAgICAgICAgICAgICAgICA6IHRpbWVvdXRNcyA8PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aW1lb3V0TXM7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcnVuVW5hcnlDYWxsKHtcbiAgICAgICAgICAgICAgICBpbnRlcmNlcHRvcnM6IG9wdGlvbnMuaW50ZXJjZXB0b3JzLFxuICAgICAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgICAgICAgICB0aW1lb3V0TXMsXG4gICAgICAgICAgICAgICAgcmVxOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBjcmVhdGVNZXRob2RVcmwob3B0aW9ucy5iYXNlVXJsLCBzZXJ2aWNlLCBtZXRob2QpLFxuICAgICAgICAgICAgICAgICAgICBpbml0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbHM6IChfYSA9IG9wdGlvbnMuY3JlZGVudGlhbHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwic2FtZS1vcmlnaW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0OiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiBcImNvcnNcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyOiByZXF1ZXN0SGVhZGVyKHVzZUJpbmFyeUZvcm1hdCwgdGltZW91dE1zLCBoZWFkZXIsIGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dFZhbHVlczogY29udGV4dFZhbHVlcyAhPT0gbnVsbCAmJiBjb250ZXh0VmFsdWVzICE9PSB2b2lkIDAgPyBjb250ZXh0VmFsdWVzIDogY3JlYXRlQ29udGV4dFZhbHVlcygpLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbmV4dDogYXN5bmMgKHJlcSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZldGNoID0gKF9hID0gb3B0aW9ucy5mZXRjaCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZ2xvYmFsVGhpcy5mZXRjaDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXEudXJsLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcS5pbml0KSwgeyBoZWFkZXJzOiByZXEuaGVhZGVyLCBzaWduYWw6IHJlcS5zaWduYWwsIGJvZHk6IGVudmVsb3BlX2VuY29kZUVudmVsb3BlKDAsIHNlcmlhbGl6ZShyZXEubWVzc2FnZSkpIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVSZXNwb25zZShyZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLmhlYWRlcnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwibWlzc2luZyByZXNwb25zZSBib2R5XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gY3JlYXRlRW52ZWxvcGVSZWFkYWJsZVN0cmVhbShyZXNwb25zZS5ib2R5KS5nZXRSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyYWlsZXI7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZmxhZ3MsIGRhdGEgfSA9IHIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MgPT09IHRyYWlsZXJGbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWlsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcImV4dHJhIHRyYWlsZXJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVW5hcnkgcmVzcG9uc2VzIHJlcXVpcmUgZXhhY3RseSBvbmUgcmVzcG9uc2UgbWVzc2FnZSwgYnV0IGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSBvZiBhbiBlcnJvciwgaXQgaXMgcGVyZmVjdGx5IHZhbGlkIHRvIGhhdmUgYSByZXNwb25zZSBib2R5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCBvbmx5IGNvbnRhaW5zIGVycm9yIHRyYWlsZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsZXIgPSB0cmFpbGVyUGFyc2UoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJleHRyYSBtZXNzYWdlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gcGFyc2UoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWlsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJtaXNzaW5nIHRyYWlsZXJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZVRyYWlsZXIodHJhaWxlciwgcmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwibWlzc2luZyBtZXNzYWdlXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXI6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxlcixcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIHN0cmVhbShzZXJ2aWNlLCBtZXRob2QsIHNpZ25hbCwgdGltZW91dE1zLCBoZWFkZXIsIGlucHV0LCBjb250ZXh0VmFsdWVzKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCB7IHNlcmlhbGl6ZSwgcGFyc2UgfSA9IGNyZWF0ZUNsaWVudE1ldGhvZFNlcmlhbGl6ZXJzKG1ldGhvZCwgdXNlQmluYXJ5Rm9ybWF0LCBvcHRpb25zLmpzb25PcHRpb25zLCBvcHRpb25zLmJpbmFyeU9wdGlvbnMpO1xuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VSZXNwb25zZUJvZHkoYm9keSwgZm91bmRTdGF0dXMsIHRyYWlsZXJUYXJnZXQsIGhlYWRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBncnBjX3dlYl90cmFuc3BvcnRfYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogcGFyc2VSZXNwb25zZUJvZHlfMSgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gY3JlYXRlRW52ZWxvcGVSZWFkYWJsZVN0cmVhbShib2R5KS5nZXRSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBIGdycGMtc3RhdHVzOiAwIHJlc3BvbnNlIGhlYWRlciB3YXMgcHJlc2VudC4gVGhpcyBpcyBhIFwidHJhaWxlcnMtb25seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXNwb25zZSAoYSByZXNwb25zZSB3aXRob3V0IGEgYm9keSBhbmQgbm8gdHJhaWxlcnMpLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBzcGVjIHNlZW1zIHRvIGRpc2FsbG93IGEgdHJhaWxlcnMtb25seSByZXNwb25zZSBmb3Igc3RhdHVzIDAgLSB3ZSBhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxlbmllbnQgYW5kIG9ubHkgdmVyaWZ5IHRoYXQgdGhlIGJvZHkgaXMgZW1wdHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gPiBbLi4uXSBUcmFpbGVycy1Pbmx5IGlzIHBlcm1pdHRlZCBmb3IgY2FsbHMgdGhhdCBwcm9kdWNlIGFuIGltbWVkaWF0ZSBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjL2Jsb2IvbWFzdGVyL2RvYy9QUk9UT0NPTC1IVFRQMi5tZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoeWllbGQgZ3JwY193ZWJfdHJhbnNwb3J0X2F3YWl0KHJlYWRlci5yZWFkKCkpKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJleHRyYSBkYXRhIGZvciB0cmFpbGVycy1vbmx5XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgZ3JwY193ZWJfdHJhbnNwb3J0X2F3YWl0KHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyYWlsZXJSZWNlaXZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBncnBjX3dlYl90cmFuc3BvcnRfYXdhaXQocmVhZGVyLnJlYWQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZmxhZ3MsIGRhdGEgfSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZmxhZ3MgJiB0cmFpbGVyRmxhZykgPT09IHRyYWlsZXJGbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWlsZXJSZWNlaXZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcImV4dHJhIHRyYWlsZXJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxlclJlY2VpdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFpbGVyID0gdHJhaWxlclBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlVHJhaWxlcih0cmFpbGVyLCBoZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsZXIuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gdHJhaWxlclRhcmdldC5zZXQoa2V5LCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWlsZXJSZWNlaXZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwiZXh0cmEgbWVzc2FnZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgZ3JwY193ZWJfdHJhbnNwb3J0X2F3YWl0KHBhcnNlKGRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHJhaWxlclJlY2VpdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIm1pc3NpbmcgdHJhaWxlclwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3luYyBmdW5jdGlvbiBjcmVhdGVSZXF1ZXN0Qm9keShpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmIChtZXRob2Qua2luZCAhPSBzZXJ2aWNlX3R5cGUvKiBNZXRob2RLaW5kICovLnQuU2VydmVyU3RyZWFtaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwiVGhlIGZldGNoIEFQSSBkb2VzIG5vdCBzdXBwb3J0IHN0cmVhbWluZyByZXF1ZXN0IGJvZGllc1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByID0gYXdhaXQgaW5wdXRbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkubmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChyLmRvbmUgPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIm1pc3NpbmcgcmVxdWVzdCBtZXNzYWdlXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlbnZlbG9wZV9lbmNvZGVFbnZlbG9wZSgwLCBzZXJpYWxpemUoci52YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltZW91dE1zID1cbiAgICAgICAgICAgICAgICB0aW1lb3V0TXMgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IG9wdGlvbnMuZGVmYXVsdFRpbWVvdXRNc1xuICAgICAgICAgICAgICAgICAgICA6IHRpbWVvdXRNcyA8PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aW1lb3V0TXM7XG4gICAgICAgICAgICByZXR1cm4gcnVuU3RyZWFtaW5nQ2FsbCh7XG4gICAgICAgICAgICAgICAgaW50ZXJjZXB0b3JzOiBvcHRpb25zLmludGVyY2VwdG9ycyxcbiAgICAgICAgICAgICAgICBzaWduYWwsXG4gICAgICAgICAgICAgICAgdGltZW91dE1zLFxuICAgICAgICAgICAgICAgIHJlcToge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW06IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBjcmVhdGVNZXRob2RVcmwob3B0aW9ucy5iYXNlVXJsLCBzZXJ2aWNlLCBtZXRob2QpLFxuICAgICAgICAgICAgICAgICAgICBpbml0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbHM6IChfYSA9IG9wdGlvbnMuY3JlZGVudGlhbHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwic2FtZS1vcmlnaW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0OiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiBcImNvcnNcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyOiByZXF1ZXN0SGVhZGVyKHVzZUJpbmFyeUZvcm1hdCwgdGltZW91dE1zLCBoZWFkZXIsIGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dFZhbHVlczogY29udGV4dFZhbHVlcyAhPT0gbnVsbCAmJiBjb250ZXh0VmFsdWVzICE9PSB2b2lkIDAgPyBjb250ZXh0VmFsdWVzIDogY3JlYXRlQ29udGV4dFZhbHVlcygpLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBpbnB1dCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5leHQ6IGFzeW5jIChyZXEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmZXRjaCA9IChfYSA9IG9wdGlvbnMuZmV0Y2gpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGdsb2JhbFRoaXMuZmV0Y2g7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZSZXMgPSBhd2FpdCBmZXRjaChyZXEudXJsLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcS5pbml0KSwgeyBoZWFkZXJzOiByZXEuaGVhZGVyLCBzaWduYWw6IHJlcS5zaWduYWwsIGJvZHk6IGF3YWl0IGNyZWF0ZVJlcXVlc3RCb2R5KHJlcS5tZXNzYWdlKSB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZm91bmRTdGF0dXMgfSA9IHZhbGlkYXRlUmVzcG9uc2UoZlJlcy5zdGF0dXMsIGZSZXMuaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZlJlcy5ib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIm1pc3NpbmcgcmVzcG9uc2UgYm9keVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYWlsZXIgPSBuZXcgSGVhZGVycygpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcSksIHsgaGVhZGVyOiBmUmVzLmhlYWRlcnMsIHRyYWlsZXIsIG1lc3NhZ2U6IHBhcnNlUmVzcG9uc2VCb2R5KGZSZXMuYm9keSwgZm91bmRTdGF0dXMsIHRyYWlsZXIsIGZSZXMuaGVhZGVycykgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG59XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvYXBpL3lvcmtpZS92MS95b3JraWVfY29ubmVjdC5qc1xudmFyIHlvcmtpZV9jb25uZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOTUpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9hcGkveW9ya2llL3YxL3Jlc291cmNlc19wYi5qc1xudmFyIHJlc291cmNlc19wYiA9IF9fd2VicGFja19yZXF1aXJlX18oNjQ2KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9sb25nL2luZGV4LmpzXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAwOSBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnNcbiAqIENvcHlyaWdodCAyMDIwIERhbmllbCBXaXJ0eiAvIFRoZSBsb25nLmpzIEF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuLy8gV2ViQXNzZW1ibHkgb3B0aW1pemF0aW9ucyB0byBkbyBuYXRpdmUgaTY0IG11bHRpcGxpY2F0aW9uIGFuZCBkaXZpZGVcbnZhciB3YXNtID0gbnVsbDtcbnRyeSB7XG4gIHdhc20gPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheShbXG4gICAgMCwgOTcsIDExNSwgMTA5LCAxLCAwLCAwLCAwLCAxLCAxMywgMiwgOTYsIDAsIDEsIDEyNywgOTYsIDQsIDEyNywgMTI3LCAxMjcsIDEyNywgMSwgMTI3LCAzLCA3LCA2LCAwLCAxLCAxLCAxLCAxLCAxLCA2LCA2LCAxLCAxMjcsIDEsIDY1LCAwLCAxMSwgNywgNTAsIDYsIDMsIDEwOSwgMTE3LCAxMDgsIDAsIDEsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTUsIDAsIDIsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTcsIDAsIDMsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTUsIDAsIDQsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTcsIDAsIDUsIDgsIDEwMywgMTAxLCAxMTYsIDk1LCAxMDQsIDEwNSwgMTAzLCAxMDQsIDAsIDAsIDEwLCAxOTEsIDEsIDYsIDQsIDAsIDM1LCAwLCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI2LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjcsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyOCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI5LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMzAsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTFcbiAgXSkpLCB7fSkuZXhwb3J0cztcbn0gY2F0Y2ggKGUpIHtcbiAgLy8gbm8gd2FzbSBzdXBwb3J0IDooXG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIDY0IGJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIsIGdpdmVuIGl0cyBsb3cgYW5kIGhpZ2ggMzIgYml0IHZhbHVlcyBhcyAqc2lnbmVkKiBpbnRlZ2Vycy5cbiAqICBTZWUgdGhlIGZyb20qIGZ1bmN0aW9ucyBiZWxvdyBmb3IgbW9yZSBjb252ZW5pZW50IHdheXMgb2YgY29uc3RydWN0aW5nIExvbmdzLlxuICogQGV4cG9ydHMgTG9uZ1xuICogQGNsYXNzIEEgTG9uZyBjbGFzcyBmb3IgcmVwcmVzZW50aW5nIGEgNjQgYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3cgVGhlIGxvdyAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaCBUaGUgaGlnaCAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTG9uZyhsb3csIGhpZ2gsIHVuc2lnbmVkKSB7XG5cbiAgLyoqXG4gICAqIFRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMubG93ID0gbG93IHwgMDtcblxuICAvKipcbiAgICogVGhlIGhpZ2ggMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMuaGlnaCA9IGhpZ2ggfCAwO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB0aGlzLnVuc2lnbmVkID0gISF1bnNpZ25lZDtcbn1cblxuLy8gVGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGEgbG9uZyBpcyB0aGUgdHdvIGdpdmVuIHNpZ25lZCwgMzItYml0IHZhbHVlcy5cbi8vIFdlIHVzZSAzMi1iaXQgcGllY2VzIGJlY2F1c2UgdGhlc2UgYXJlIHRoZSBzaXplIG9mIGludGVnZXJzIG9uIHdoaWNoXG4vLyBKYXZhc2NyaXB0IHBlcmZvcm1zIGJpdC1vcGVyYXRpb25zLiAgRm9yIG9wZXJhdGlvbnMgbGlrZSBhZGRpdGlvbiBhbmRcbi8vIG11bHRpcGxpY2F0aW9uLCB3ZSBzcGxpdCBlYWNoIG51bWJlciBpbnRvIDE2IGJpdCBwaWVjZXMsIHdoaWNoIGNhbiBlYXNpbHkgYmVcbi8vIG11bHRpcGxpZWQgd2l0aGluIEphdmFzY3JpcHQncyBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbiB3aXRob3V0IG92ZXJmbG93XG4vLyBvciBjaGFuZ2UgaW4gc2lnbi5cbi8vXG4vLyBJbiB0aGUgYWxnb3JpdGhtcyBiZWxvdywgd2UgZnJlcXVlbnRseSByZWR1Y2UgdGhlIG5lZ2F0aXZlIGNhc2UgdG8gdGhlXG4vLyBwb3NpdGl2ZSBjYXNlIGJ5IG5lZ2F0aW5nIHRoZSBpbnB1dChzKSBhbmQgdGhlbiBwb3N0LXByb2Nlc3NpbmcgdGhlIHJlc3VsdC5cbi8vIE5vdGUgdGhhdCB3ZSBtdXN0IEFMV0FZUyBjaGVjayBzcGVjaWFsbHkgd2hldGhlciB0aG9zZSB2YWx1ZXMgYXJlIE1JTl9WQUxVRVxuLy8gKC0yXjYzKSBiZWNhdXNlIC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFIChzaW5jZSAyXjYzIGNhbm5vdCBiZSByZXByZXNlbnRlZCBhc1xuLy8gYSBwb3NpdGl2ZSBudW1iZXIsIGl0IG92ZXJmbG93cyBiYWNrIGludG8gYSBuZWdhdGl2ZSkuICBOb3QgaGFuZGxpbmcgdGhpc1xuLy8gY2FzZSB3b3VsZCBvZnRlbiByZXN1bHQgaW4gaW5maW5pdGUgcmVjdXJzaW9uLlxuLy9cbi8vIENvbW1vbiBjb25zdGFudCB2YWx1ZXMgWkVSTywgT05FLCBORUdfT05FLCBldGMuIGFyZSBkZWZpbmVkIGJlbG93IHRoZSBmcm9tKlxuLy8gbWV0aG9kcyBvbiB3aGljaCB0aGV5IGRlcGVuZC5cblxuLyoqXG4gKiBBbiBpbmRpY2F0b3IgdXNlZCB0byByZWxpYWJseSBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgTG9uZyBvciBub3QuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBjb25zdFxuICogQHByaXZhdGVcbiAqL1xuTG9uZy5wcm90b3R5cGUuX19pc0xvbmdfXztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExvbmcucHJvdG90eXBlLCBcIl9faXNMb25nX19cIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAaW5uZXJcbiAqL1xuZnVuY3Rpb24gaXNMb25nKG9iaikge1xuICByZXR1cm4gKG9iaiAmJiBvYmpbXCJfX2lzTG9uZ19fXCJdKSA9PT0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgbnVtYmVyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICogQGlubmVyXG4gKi9cbmZ1bmN0aW9uIGN0ejMyKHZhbHVlKSB7XG4gIHZhciBjID0gTWF0aC5jbHozMih2YWx1ZSAmIC12YWx1ZSk7XG4gIHJldHVybiB2YWx1ZSA/IDMxIC0gYyA6IGM7XG59XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgaXMgYSBMb25nLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyp9IG9iaiBPYmplY3RcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nLmlzTG9uZyA9IGlzTG9uZztcblxuLyoqXG4gKiBBIGNhY2hlIG9mIHRoZSBMb25nIHJlcHJlc2VudGF0aW9ucyBvZiBzbWFsbCBpbnRlZ2VyIHZhbHVlcy5cbiAqIEB0eXBlIHshT2JqZWN0fVxuICogQGlubmVyXG4gKi9cbnZhciBJTlRfQ0FDSEUgPSB7fTtcblxuLyoqXG4gKiBBIGNhY2hlIG9mIHRoZSBMb25nIHJlcHJlc2VudGF0aW9ucyBvZiBzbWFsbCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy5cbiAqIEB0eXBlIHshT2JqZWN0fVxuICogQGlubmVyXG4gKi9cbnZhciBVSU5UX0NBQ0hFID0ge307XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxuICogQHJldHVybnMgeyFMb25nfVxuICogQGlubmVyXG4gKi9cbmZ1bmN0aW9uIGZyb21JbnQodmFsdWUsIHVuc2lnbmVkKSB7XG4gIHZhciBvYmosIGNhY2hlZE9iaiwgY2FjaGU7XG4gIGlmICh1bnNpZ25lZCkge1xuICAgIHZhbHVlID4+Pj0gMDtcbiAgICBpZiAoY2FjaGUgPSAoMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1NikpIHtcbiAgICAgIGNhY2hlZE9iaiA9IFVJTlRfQ0FDSEVbdmFsdWVdO1xuICAgICAgaWYgKGNhY2hlZE9iailcbiAgICAgICAgcmV0dXJuIGNhY2hlZE9iajtcbiAgICB9XG4gICAgb2JqID0gZnJvbUJpdHModmFsdWUsIDAsIHRydWUpO1xuICAgIGlmIChjYWNoZSlcbiAgICAgIFVJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xuICAgIHJldHVybiBvYmo7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgfD0gMDtcbiAgICBpZiAoY2FjaGUgPSAoLTEyOCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDEyOCkpIHtcbiAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRVt2YWx1ZV07XG4gICAgICBpZiAoY2FjaGVkT2JqKVxuICAgICAgICByZXR1cm4gY2FjaGVkT2JqO1xuICAgIH1cbiAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgdmFsdWUgPCAwID8gLTEgOiAwLCBmYWxzZSk7XG4gICAgaWYgKGNhY2hlKVxuICAgICAgSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcbiAgICByZXR1cm4gb2JqO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiAzMiBiaXQgaW50ZWdlciB2YWx1ZS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSAzMiBiaXQgaW50ZWdlciBpbiBxdWVzdGlvblxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gKi9cbkxvbmcuZnJvbUludCA9IGZyb21JbnQ7XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxuICogQHJldHVybnMgeyFMb25nfVxuICogQGlubmVyXG4gKi9cbmZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIHVuc2lnbmVkKSB7XG4gIGlmIChpc05hTih2YWx1ZSkpXG4gICAgcmV0dXJuIHVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xuICBpZiAodW5zaWduZWQpIHtcbiAgICBpZiAodmFsdWUgPCAwKVxuICAgICAgcmV0dXJuIFVaRVJPO1xuICAgIGlmICh2YWx1ZSA+PSBUV09fUFdSXzY0X0RCTClcbiAgICAgIHJldHVybiBNQVhfVU5TSUdORURfVkFMVUU7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbHVlIDw9IC1UV09fUFdSXzYzX0RCTClcbiAgICAgIHJldHVybiBNSU5fVkFMVUU7XG4gICAgaWYgKHZhbHVlICsgMSA+PSBUV09fUFdSXzYzX0RCTClcbiAgICAgIHJldHVybiBNQVhfVkFMVUU7XG4gIH1cbiAgaWYgKHZhbHVlIDwgMClcbiAgICByZXR1cm4gZnJvbU51bWJlcigtdmFsdWUsIHVuc2lnbmVkKS5uZWcoKTtcbiAgcmV0dXJuIGZyb21CaXRzKCh2YWx1ZSAlIFRXT19QV1JfMzJfREJMKSB8IDAsICh2YWx1ZSAvIFRXT19QV1JfMzJfREJMKSB8IDAsIHVuc2lnbmVkKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIHZhbHVlLCBwcm92aWRlZCB0aGF0IGl0IGlzIGEgZmluaXRlIG51bWJlci4gT3RoZXJ3aXNlLCB6ZXJvIGlzIHJldHVybmVkLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIG51bWJlciBpbiBxdWVzdGlvblxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gKi9cbkxvbmcuZnJvbU51bWJlciA9IGZyb21OdW1iZXI7XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0c1xuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcbiAqIEByZXR1cm5zIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG5mdW5jdGlvbiBmcm9tQml0cyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpIHtcbiAgcmV0dXJuIG5ldyBMb25nKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSA2NCBiaXQgaW50ZWdlciB0aGF0IGNvbWVzIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIGdpdmVuIGxvdyBhbmQgaGlnaCBiaXRzLiBFYWNoIGlzXG4gKiAgYXNzdW1lZCB0byB1c2UgMzIgYml0cy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHMgVGhlIGxvdyAzMiBiaXRzXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHMgVGhlIGhpZ2ggMzIgYml0c1xuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gKi9cbkxvbmcuZnJvbUJpdHMgPSBmcm9tQml0cztcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlXG4gKiBAcGFyYW0ge251bWJlcn0gZXhwb25lbnRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKiBAaW5uZXJcbiAqL1xudmFyIHBvd19kYmwgPSBNYXRoLnBvdzsgLy8gVXNlZCA0IHRpbWVzICg0KjggdG8gMTUrNClcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZFxuICogQHBhcmFtIHtudW1iZXI9fSByYWRpeFxuICogQHJldHVybnMgeyFMb25nfVxuICogQGlubmVyXG4gKi9cbmZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyLCB1bnNpZ25lZCwgcmFkaXgpIHtcbiAgaWYgKHN0ci5sZW5ndGggPT09IDApXG4gICAgdGhyb3cgRXJyb3IoJ2VtcHR5IHN0cmluZycpO1xuICBpZiAodHlwZW9mIHVuc2lnbmVkID09PSAnbnVtYmVyJykge1xuICAgIC8vIEZvciBnb29nLm1hdGgubG9uZyBjb21wYXRpYmlsaXR5XG4gICAgcmFkaXggPSB1bnNpZ25lZDtcbiAgICB1bnNpZ25lZCA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHVuc2lnbmVkID0gISF1bnNpZ25lZDtcbiAgfVxuICBpZiAoc3RyID09PSBcIk5hTlwiIHx8IHN0ciA9PT0gXCJJbmZpbml0eVwiIHx8IHN0ciA9PT0gXCIrSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiLUluZmluaXR5XCIpXG4gICAgcmV0dXJuIHVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xuICByYWRpeCA9IHJhZGl4IHx8IDEwO1xuICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXG4gICAgdGhyb3cgUmFuZ2VFcnJvcigncmFkaXgnKTtcblxuICB2YXIgcDtcbiAgaWYgKChwID0gc3RyLmluZGV4T2YoJy0nKSkgPiAwKVxuICAgIHRocm93IEVycm9yKCdpbnRlcmlvciBoeXBoZW4nKTtcbiAgZWxzZSBpZiAocCA9PT0gMCkge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHN0ci5zdWJzdHJpbmcoMSksIHVuc2lnbmVkLCByYWRpeCkubmVnKCk7XG4gIH1cblxuICAvLyBEbyBzZXZlcmFsICg4KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXG4gIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxuICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCA4KSk7XG5cbiAgdmFyIHJlc3VsdCA9IFpFUk87XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSA4KSB7XG4gICAgdmFyIHNpemUgPSBNYXRoLm1pbig4LCBzdHIubGVuZ3RoIC0gaSksXG4gICAgICB2YWx1ZSA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoaSwgaSArIHNpemUpLCByYWRpeCk7XG4gICAgaWYgKHNpemUgPCA4KSB7XG4gICAgICB2YXIgcG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIHNpemUpKTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocG93ZXIpLmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocmFkaXhUb1Bvd2VyKTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZnJvbU51bWJlcih2YWx1ZSkpO1xuICAgIH1cbiAgfVxuICByZXN1bHQudW5zaWduZWQgPSB1bnNpZ25lZDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gc3RyaW5nLCB3cml0dGVuIHVzaW5nIHRoZSBzcGVjaWZpZWQgcmFkaXguXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHRleHR1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIExvbmdcbiAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggVGhlIHJhZGl4IGluIHdoaWNoIHRoZSB0ZXh0IGlzIHdyaXR0ZW4gKDItMzYpLCBkZWZhdWx0cyB0byAxMFxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gKi9cbkxvbmcuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbFxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcbiAqIEByZXR1cm5zIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG5mdW5jdGlvbiBmcm9tVmFsdWUodmFsLCB1bnNpZ25lZCkge1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpXG4gICAgcmV0dXJuIGZyb21OdW1iZXIodmFsLCB1bnNpZ25lZCk7XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJylcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWwsIHVuc2lnbmVkKTtcbiAgLy8gVGhyb3dzIGZvciBub24tb2JqZWN0cywgY29udmVydHMgbm9uLWluc3RhbmNlb2YgTG9uZzpcbiAgcmV0dXJuIGZyb21CaXRzKHZhbC5sb3csIHZhbC5oaWdoLCB0eXBlb2YgdW5zaWduZWQgPT09ICdib29sZWFuJyA/IHVuc2lnbmVkIDogdmFsLnVuc2lnbmVkKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgc3BlY2lmaWVkIHZhbHVlIHRvIGEgTG9uZyB1c2luZyB0aGUgYXBwcm9wcmlhdGUgZnJvbSogZnVuY3Rpb24gZm9yIGl0cyB0eXBlLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbCBWYWx1ZVxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICogQHJldHVybnMgeyFMb25nfVxuICovXG5Mb25nLmZyb21WYWx1ZSA9IGZyb21WYWx1ZTtcblxuLy8gTk9URTogdGhlIGNvbXBpbGVyIHNob3VsZCBpbmxpbmUgdGhlc2UgY29uc3RhbnQgdmFsdWVzIGJlbG93IGFuZCB0aGVuIHJlbW92ZSB0aGVzZSB2YXJpYWJsZXMsIHNvIHRoZXJlIHNob3VsZCBiZVxuLy8gbm8gcnVudGltZSBwZW5hbHR5IGZvciB0aGVzZS5cblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0XG4gKiBAaW5uZXJcbiAqL1xudmFyIFRXT19QV1JfMTZfREJMID0gMSA8PCAxNjtcblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0XG4gKiBAaW5uZXJcbiAqL1xudmFyIFRXT19QV1JfMjRfREJMID0gMSA8PCAyNDtcblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0XG4gKiBAaW5uZXJcbiAqL1xudmFyIFRXT19QV1JfMzJfREJMID0gVFdPX1BXUl8xNl9EQkwgKiBUV09fUFdSXzE2X0RCTDtcblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0XG4gKiBAaW5uZXJcbiAqL1xudmFyIFRXT19QV1JfNjRfREJMID0gVFdPX1BXUl8zMl9EQkwgKiBUV09fUFdSXzMyX0RCTDtcblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0XG4gKiBAaW5uZXJcbiAqL1xudmFyIFRXT19QV1JfNjNfREJMID0gVFdPX1BXUl82NF9EQkwgLyAyO1xuXG4vKipcbiAqIEB0eXBlIHshTG9uZ31cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKi9cbnZhciBUV09fUFdSXzI0ID0gZnJvbUludChUV09fUFdSXzI0X0RCTCk7XG5cbi8qKlxuICogQHR5cGUgeyFMb25nfVxuICogQGlubmVyXG4gKi9cbnZhciBaRVJPID0gZnJvbUludCgwKTtcblxuLyoqXG4gKiBTaWduZWQgemVyby5cbiAqIEB0eXBlIHshTG9uZ31cbiAqL1xuTG9uZy5aRVJPID0gWkVSTztcblxuLyoqXG4gKiBAdHlwZSB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xudmFyIFVaRVJPID0gZnJvbUludCgwLCB0cnVlKTtcblxuLyoqXG4gKiBVbnNpZ25lZCB6ZXJvLlxuICogQHR5cGUgeyFMb25nfVxuICovXG5Mb25nLlVaRVJPID0gVVpFUk87XG5cbi8qKlxuICogQHR5cGUgeyFMb25nfVxuICogQGlubmVyXG4gKi9cbnZhciBPTkUgPSBmcm9tSW50KDEpO1xuXG4vKipcbiAqIFNpZ25lZCBvbmUuXG4gKiBAdHlwZSB7IUxvbmd9XG4gKi9cbkxvbmcuT05FID0gT05FO1xuXG4vKipcbiAqIEB0eXBlIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG52YXIgVU9ORSA9IGZyb21JbnQoMSwgdHJ1ZSk7XG5cbi8qKlxuICogVW5zaWduZWQgb25lLlxuICogQHR5cGUgeyFMb25nfVxuICovXG5Mb25nLlVPTkUgPSBVT05FO1xuXG4vKipcbiAqIEB0eXBlIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG52YXIgTkVHX09ORSA9IGZyb21JbnQoLTEpO1xuXG4vKipcbiAqIFNpZ25lZCBuZWdhdGl2ZSBvbmUuXG4gKiBAdHlwZSB7IUxvbmd9XG4gKi9cbkxvbmcuTkVHX09ORSA9IE5FR19PTkU7XG5cbi8qKlxuICogQHR5cGUgeyFMb25nfVxuICogQGlubmVyXG4gKi9cbnZhciBNQVhfVkFMVUUgPSBmcm9tQml0cygweEZGRkZGRkZGIHwgMCwgMHg3RkZGRkZGRiB8IDAsIGZhbHNlKTtcblxuLyoqXG4gKiBNYXhpbXVtIHNpZ25lZCB2YWx1ZS5cbiAqIEB0eXBlIHshTG9uZ31cbiAqL1xuTG9uZy5NQVhfVkFMVUUgPSBNQVhfVkFMVUU7XG5cbi8qKlxuICogQHR5cGUgeyFMb25nfVxuICogQGlubmVyXG4gKi9cbnZhciBNQVhfVU5TSUdORURfVkFMVUUgPSBmcm9tQml0cygweEZGRkZGRkZGIHwgMCwgMHhGRkZGRkZGRiB8IDAsIHRydWUpO1xuXG4vKipcbiAqIE1heGltdW0gdW5zaWduZWQgdmFsdWUuXG4gKiBAdHlwZSB7IUxvbmd9XG4gKi9cbkxvbmcuTUFYX1VOU0lHTkVEX1ZBTFVFID0gTUFYX1VOU0lHTkVEX1ZBTFVFO1xuXG4vKipcbiAqIEB0eXBlIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG52YXIgTUlOX1ZBTFVFID0gZnJvbUJpdHMoMCwgMHg4MDAwMDAwMCB8IDAsIGZhbHNlKTtcblxuLyoqXG4gKiBNaW5pbXVtIHNpZ25lZCB2YWx1ZS5cbiAqIEB0eXBlIHshTG9uZ31cbiAqL1xuTG9uZy5NSU5fVkFMVUUgPSBNSU5fVkFMVUU7XG5cbi8qKlxuICogQGFsaWFzIExvbmcucHJvdG90eXBlXG4gKiBAaW5uZXJcbiAqL1xudmFyIExvbmdQcm90b3R5cGUgPSBMb25nLnByb3RvdHlwZTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIDMyIGJpdCBpbnRlZ2VyLCBhc3N1bWluZyBpdCBpcyBhIDMyIGJpdCBpbnRlZ2VyLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS50b0ludCA9IGZ1bmN0aW9uIHRvSW50KCkge1xuICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IHRoaXMubG93ID4+PiAwIDogdGhpcy5sb3c7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgdGhlIG5lYXJlc3QgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2YWx1ZSAoZG91YmxlLCA1MyBiaXQgbWFudGlzc2EpLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKCkge1xuICBpZiAodGhpcy51bnNpZ25lZClcbiAgICByZXR1cm4gKCh0aGlzLmhpZ2ggPj4+IDApICogVFdPX1BXUl8zMl9EQkwpICsgKHRoaXMubG93ID4+PiAwKTtcbiAgcmV0dXJuIHRoaXMuaGlnaCAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhlIExvbmcgdG8gYSBzdHJpbmcgd3JpdHRlbiBpbiB0aGUgc3BlY2lmaWVkIHJhZGl4LlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBSYWRpeCAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICogQG92ZXJyaWRlXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgcmFkaXhgIGlzIG91dCBvZiByYW5nZVxuICovXG5Mb25nUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcocmFkaXgpIHtcbiAgcmFkaXggPSByYWRpeCB8fCAxMDtcbiAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KVxuICAgIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XG4gIGlmICh0aGlzLmlzWmVybygpKVxuICAgIHJldHVybiAnMCc7XG4gIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgeyAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcbiAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoYW5nZSB0aGUgTG9uZyB2YWx1ZSBiZWZvcmUgaXQgY2FuIGJlIG5lZ2F0ZWQsIHNvIHdlIHJlbW92ZVxuICAgICAgLy8gdGhlIGJvdHRvbS1tb3N0IGRpZ2l0IGluIHRoaXMgYmFzZSBhbmQgdGhlbiByZWN1cnNlIHRvIGRvIHRoZSByZXN0LlxuICAgICAgdmFyIHJhZGl4TG9uZyA9IGZyb21OdW1iZXIocmFkaXgpLFxuICAgICAgICBkaXYgPSB0aGlzLmRpdihyYWRpeExvbmcpLFxuICAgICAgICByZW0xID0gZGl2Lm11bChyYWRpeExvbmcpLnN1Yih0aGlzKTtcbiAgICAgIHJldHVybiBkaXYudG9TdHJpbmcocmFkaXgpICsgcmVtMS50b0ludCgpLnRvU3RyaW5nKHJhZGl4KTtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiAnLScgKyB0aGlzLm5lZygpLnRvU3RyaW5nKHJhZGl4KTtcbiAgfVxuXG4gIC8vIERvIHNldmVyYWwgKDYpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cbiAgLy8gbWluaW1pemUgdGhlIGNhbGxzIHRvIHRoZSB2ZXJ5IGV4cGVuc2l2ZSBlbXVsYXRlZCBkaXYuXG4gIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDYpLCB0aGlzLnVuc2lnbmVkKSxcbiAgICByZW0gPSB0aGlzO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIHJlbURpdiA9IHJlbS5kaXYocmFkaXhUb1Bvd2VyKSxcbiAgICAgIGludHZhbCA9IHJlbS5zdWIocmVtRGl2Lm11bChyYWRpeFRvUG93ZXIpKS50b0ludCgpID4+PiAwLFxuICAgICAgZGlnaXRzID0gaW50dmFsLnRvU3RyaW5nKHJhZGl4KTtcbiAgICByZW0gPSByZW1EaXY7XG4gICAgaWYgKHJlbS5pc1plcm8oKSlcbiAgICAgIHJldHVybiBkaWdpdHMgKyByZXN1bHQ7XG4gICAgZWxzZSB7XG4gICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpXG4gICAgICAgIGRpZ2l0cyA9ICcwJyArIGRpZ2l0cztcbiAgICAgIHJlc3VsdCA9ICcnICsgZGlnaXRzICsgcmVzdWx0O1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgaW50ZWdlci5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBoaWdoIGJpdHNcbiAqL1xuTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0cyA9IGZ1bmN0aW9uIGdldEhpZ2hCaXRzKCkge1xuICByZXR1cm4gdGhpcy5oaWdoO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoaWdoIDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGhpZ2ggYml0c1xuICovXG5Mb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRIaWdoQml0c1Vuc2lnbmVkKCkge1xuICByZXR1cm4gdGhpcy5oaWdoID4+PiAwO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGxvdyBiaXRzXG4gKi9cbkxvbmdQcm90b3R5cGUuZ2V0TG93Qml0cyA9IGZ1bmN0aW9uIGdldExvd0JpdHMoKSB7XG4gIHJldHVybiB0aGlzLmxvdztcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgbG93IDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGxvdyBiaXRzXG4gKi9cbkxvbmdQcm90b3R5cGUuZ2V0TG93Qml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0TG93Qml0c1Vuc2lnbmVkKCkge1xuICByZXR1cm4gdGhpcy5sb3cgPj4+IDA7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBiaXRzIG5lZWRlZCB0byByZXByZXNlbnQgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgTG9uZy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbkxvbmdQcm90b3R5cGUuZ2V0TnVtQml0c0FicyA9IGZ1bmN0aW9uIGdldE51bUJpdHNBYnMoKSB7XG4gIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgLy8gVW5zaWduZWQgTG9uZ3MgYXJlIG5ldmVyIG5lZ2F0aXZlXG4gICAgcmV0dXJuIHRoaXMuZXEoTUlOX1ZBTFVFKSA/IDY0IDogdGhpcy5uZWcoKS5nZXROdW1CaXRzQWJzKCk7XG4gIHZhciB2YWwgPSB0aGlzLmhpZ2ggIT0gMCA/IHRoaXMuaGlnaCA6IHRoaXMubG93O1xuICBmb3IgKHZhciBiaXQgPSAzMTsgYml0ID4gMDsgYml0LS0pXG4gICAgaWYgKCh2YWwgJiAoMSA8PCBiaXQpKSAhPSAwKVxuICAgICAgYnJlYWs7XG4gIHJldHVybiB0aGlzLmhpZ2ggIT0gMCA/IGJpdCArIDMzIDogYml0ICsgMTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHplcm8uXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8oKSB7XG4gIHJldHVybiB0aGlzLmhpZ2ggPT09IDAgJiYgdGhpcy5sb3cgPT09IDA7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB6ZXJvLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2lzWmVyb30uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5lcXogPSBMb25nUHJvdG90eXBlLmlzWmVybztcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBuZWdhdGl2ZS5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiBpc05lZ2F0aXZlKCkge1xuICByZXR1cm4gIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoIDwgMDtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgcG9zaXRpdmUgb3IgemVyby5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiBpc1Bvc2l0aXZlKCkge1xuICByZXR1cm4gdGhpcy51bnNpZ25lZCB8fCB0aGlzLmhpZ2ggPj0gMDtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgb2RkLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCgpIHtcbiAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAxO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBldmVuLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuKCkge1xuICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDA7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgaWYgKCFpc0xvbmcob3RoZXIpKVxuICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcbiAgaWYgKHRoaXMudW5zaWduZWQgIT09IG90aGVyLnVuc2lnbmVkICYmICh0aGlzLmhpZ2ggPj4+IDMxKSA9PT0gMSAmJiAob3RoZXIuaGlnaCA+Pj4gMzEpID09PSAxKVxuICAgIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gb3RoZXIuaGlnaCAmJiB0aGlzLmxvdyA9PT0gb3RoZXIubG93O1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2VxdWFsc30uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmVxID0gTG9uZ1Byb3RvdHlwZS5lcXVhbHM7XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLm5vdEVxdWFscyA9IGZ1bmN0aW9uIG5vdEVxdWFscyhvdGhlcikge1xuICByZXR1cm4gIXRoaXMuZXEoLyogdmFsaWRhdGVzICovIG90aGVyKTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNub3RFcXVhbHN9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5uZXEgPSBMb25nUHJvdG90eXBlLm5vdEVxdWFscztcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLm5lID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmxlc3NUaGFuID0gZnVuY3Rpb24gbGVzc1RoYW4ob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpIDwgMDtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbn0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmx0ID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbjtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsID0gZnVuY3Rpb24gbGVzc1RoYW5PckVxdWFsKG90aGVyKSB7XG4gIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA8PSAwO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmx0ZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsO1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW5PckVxdWFsfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUubGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCdzLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW4gPSBmdW5jdGlvbiBncmVhdGVyVGhhbihvdGhlcikge1xuICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPiAwO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFufS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUuZ3QgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuO1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBncmVhdGVyVGhhbk9yRXF1YWwob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpID49IDA7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUuZ3RlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbk9yRXF1YWx9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5nZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xuXG4vKipcbiAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyIGFuZCAtMVxuICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxuICovXG5Mb25nUHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKG90aGVyKSB7XG4gIGlmICghaXNMb25nKG90aGVyKSlcbiAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gIGlmICh0aGlzLmVxKG90aGVyKSlcbiAgICByZXR1cm4gMDtcbiAgdmFyIHRoaXNOZWcgPSB0aGlzLmlzTmVnYXRpdmUoKSxcbiAgICBvdGhlck5lZyA9IG90aGVyLmlzTmVnYXRpdmUoKTtcbiAgaWYgKHRoaXNOZWcgJiYgIW90aGVyTmVnKVxuICAgIHJldHVybiAtMTtcbiAgaWYgKCF0aGlzTmVnICYmIG90aGVyTmVnKVxuICAgIHJldHVybiAxO1xuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBzaWduIGJpdHMgYXJlIHRoZSBzYW1lXG4gIGlmICghdGhpcy51bnNpZ25lZClcbiAgICByZXR1cm4gdGhpcy5zdWIob3RoZXIpLmlzTmVnYXRpdmUoKSA/IC0xIDogMTtcbiAgLy8gQm90aCBhcmUgcG9zaXRpdmUgaWYgYXQgbGVhc3Qgb25lIGlzIHVuc2lnbmVkXG4gIHJldHVybiAob3RoZXIuaGlnaCA+Pj4gMCkgPiAodGhpcy5oaWdoID4+PiAwKSB8fCAob3RoZXIuaGlnaCA9PT0gdGhpcy5oaWdoICYmIChvdGhlci5sb3cgPj4+IDApID4gKHRoaXMubG93ID4+PiAwKSkgPyAtMSA6IDE7XG59O1xuXG4vKipcbiAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2NvbXBhcmV9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCAxIGlmIHRoZSB0aGlzIGlzIGdyZWF0ZXIgYW5kIC0xXG4gKiAgaWYgdGhlIGdpdmVuIG9uZSBpcyBncmVhdGVyXG4gKi9cbkxvbmdQcm90b3R5cGUuY29tcCA9IExvbmdQcm90b3R5cGUuY29tcGFyZTtcblxuLyoqXG4gKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMgeyFMb25nfSBOZWdhdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiBuZWdhdGUoKSB7XG4gIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmVxKE1JTl9WQUxVRSkpXG4gICAgcmV0dXJuIE1JTl9WQUxVRTtcbiAgcmV0dXJuIHRoaXMubm90KCkuYWRkKE9ORSk7XG59O1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbmVnYXRlfS5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMgeyFMb25nfSBOZWdhdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5uZWcgPSBMb25nUHJvdG90eXBlLm5lZ2F0ZTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdW0gb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBhZGRlbmQgQWRkZW5kXG4gKiBAcmV0dXJucyB7IUxvbmd9IFN1bVxuICovXG5Mb25nUHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChhZGRlbmQpIHtcbiAgaWYgKCFpc0xvbmcoYWRkZW5kKSlcbiAgICBhZGRlbmQgPSBmcm9tVmFsdWUoYWRkZW5kKTtcblxuICAvLyBEaXZpZGUgZWFjaCBudW1iZXIgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBzdW0gdGhlIGNodW5rcy5cblxuICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcbiAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4RkZGRjtcbiAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjtcbiAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xuXG4gIHZhciBiNDggPSBhZGRlbmQuaGlnaCA+Pj4gMTY7XG4gIHZhciBiMzIgPSBhZGRlbmQuaGlnaCAmIDB4RkZGRjtcbiAgdmFyIGIxNiA9IGFkZGVuZC5sb3cgPj4+IDE2O1xuICB2YXIgYjAwID0gYWRkZW5kLmxvdyAmIDB4RkZGRjtcblxuICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcbiAgYzAwICs9IGEwMCArIGIwMDtcbiAgYzE2ICs9IGMwMCA+Pj4gMTY7XG4gIGMwMCAmPSAweEZGRkY7XG4gIGMxNiArPSBhMTYgKyBiMTY7XG4gIGMzMiArPSBjMTYgPj4+IDE2O1xuICBjMTYgJj0gMHhGRkZGO1xuICBjMzIgKz0gYTMyICsgYjMyO1xuICBjNDggKz0gYzMyID4+PiAxNjtcbiAgYzMyICY9IDB4RkZGRjtcbiAgYzQ4ICs9IGE0OCArIGI0ODtcbiAgYzQ4ICY9IDB4RkZGRjtcbiAgcmV0dXJuIGZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGRpZmZlcmVuY2Ugb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcbiAqIEByZXR1cm5zIHshTG9uZ30gRGlmZmVyZW5jZVxuICovXG5Mb25nUHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3Qoc3VidHJhaGVuZCkge1xuICBpZiAoIWlzTG9uZyhzdWJ0cmFoZW5kKSlcbiAgICBzdWJ0cmFoZW5kID0gZnJvbVZhbHVlKHN1YnRyYWhlbmQpO1xuICByZXR1cm4gdGhpcy5hZGQoc3VidHJhaGVuZC5uZWcoKSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGRpZmZlcmVuY2Ugb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3N1YnRyYWN0fS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcbiAqIEByZXR1cm5zIHshTG9uZ30gRGlmZmVyZW5jZVxuICovXG5Mb25nUHJvdG90eXBlLnN1YiA9IExvbmdQcm90b3R5cGUuc3VidHJhY3Q7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG11bHRpcGxpZXIgTXVsdGlwbGllclxuICogQHJldHVybnMgeyFMb25nfSBQcm9kdWN0XG4gKi9cbkxvbmdQcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShtdWx0aXBsaWVyKSB7XG4gIGlmICh0aGlzLmlzWmVybygpKVxuICAgIHJldHVybiB0aGlzO1xuICBpZiAoIWlzTG9uZyhtdWx0aXBsaWVyKSlcbiAgICBtdWx0aXBsaWVyID0gZnJvbVZhbHVlKG11bHRpcGxpZXIpO1xuXG4gIC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxuICBpZiAod2FzbSkge1xuICAgIHZhciBsb3cgPSB3YXNtW1wibXVsXCJdKHRoaXMubG93LFxuICAgICAgdGhpcy5oaWdoLFxuICAgICAgbXVsdGlwbGllci5sb3csXG4gICAgICBtdWx0aXBsaWVyLmhpZ2gpO1xuICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc21bXCJnZXRfaGlnaFwiXSgpLCB0aGlzLnVuc2lnbmVkKTtcbiAgfVxuXG4gIGlmIChtdWx0aXBsaWVyLmlzWmVybygpKVxuICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xuICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKVxuICAgIHJldHVybiBtdWx0aXBsaWVyLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xuICBpZiAobXVsdGlwbGllci5lcShNSU5fVkFMVUUpKVxuICAgIHJldHVybiB0aGlzLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xuXG4gIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSlcbiAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyLm5lZygpKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllcikubmVnKCk7XG4gIH0gZWxzZSBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXG4gICAgcmV0dXJuIHRoaXMubXVsKG11bHRpcGxpZXIubmVnKCkpLm5lZygpO1xuXG4gIC8vIElmIGJvdGggbG9uZ3MgYXJlIHNtYWxsLCB1c2UgZmxvYXQgbXVsdGlwbGljYXRpb25cbiAgaWYgKHRoaXMubHQoVFdPX1BXUl8yNCkgJiYgbXVsdGlwbGllci5sdChUV09fUFdSXzI0KSlcbiAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLnRvTnVtYmVyKCkgKiBtdWx0aXBsaWVyLnRvTnVtYmVyKCksIHRoaXMudW5zaWduZWQpO1xuXG4gIC8vIERpdmlkZSBlYWNoIGxvbmcgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBhZGQgdXAgNHg0IHByb2R1Y3RzLlxuICAvLyBXZSBjYW4gc2tpcCBwcm9kdWN0cyB0aGF0IHdvdWxkIG92ZXJmbG93LlxuXG4gIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xuICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhGRkZGO1xuICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xuICB2YXIgYTAwID0gdGhpcy5sb3cgJiAweEZGRkY7XG5cbiAgdmFyIGI0OCA9IG11bHRpcGxpZXIuaGlnaCA+Pj4gMTY7XG4gIHZhciBiMzIgPSBtdWx0aXBsaWVyLmhpZ2ggJiAweEZGRkY7XG4gIHZhciBiMTYgPSBtdWx0aXBsaWVyLmxvdyA+Pj4gMTY7XG4gIHZhciBiMDAgPSBtdWx0aXBsaWVyLmxvdyAmIDB4RkZGRjtcblxuICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcbiAgYzAwICs9IGEwMCAqIGIwMDtcbiAgYzE2ICs9IGMwMCA+Pj4gMTY7XG4gIGMwMCAmPSAweEZGRkY7XG4gIGMxNiArPSBhMTYgKiBiMDA7XG4gIGMzMiArPSBjMTYgPj4+IDE2O1xuICBjMTYgJj0gMHhGRkZGO1xuICBjMTYgKz0gYTAwICogYjE2O1xuICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgYzE2ICY9IDB4RkZGRjtcbiAgYzMyICs9IGEzMiAqIGIwMDtcbiAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gIGMzMiAmPSAweEZGRkY7XG4gIGMzMiArPSBhMTYgKiBiMTY7XG4gIGM0OCArPSBjMzIgPj4+IDE2O1xuICBjMzIgJj0gMHhGRkZGO1xuICBjMzIgKz0gYTAwICogYjMyO1xuICBjNDggKz0gYzMyID4+PiAxNjtcbiAgYzMyICY9IDB4RkZGRjtcbiAgYzQ4ICs9IGE0OCAqIGIwMCArIGEzMiAqIGIxNiArIGExNiAqIGIzMiArIGEwMCAqIGI0ODtcbiAgYzQ4ICY9IDB4RkZGRjtcbiAgcmV0dXJuIGZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI211bHRpcGx5fS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBtdWx0aXBsaWVyIE11bHRpcGxpZXJcbiAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxuICovXG5Mb25nUHJvdG90eXBlLm11bCA9IExvbmdQcm90b3R5cGUubXVsdGlwbHk7XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIExvbmcgZGl2aWRlZCBieSB0aGUgc3BlY2lmaWVkLiBUaGUgcmVzdWx0IGlzIHNpZ25lZCBpZiB0aGlzIExvbmcgaXMgc2lnbmVkIG9yXG4gKiAgdW5zaWduZWQgaWYgdGhpcyBMb25nIGlzIHVuc2lnbmVkLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcbiAqIEByZXR1cm5zIHshTG9uZ30gUXVvdGllbnRcbiAqL1xuTG9uZ1Byb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiBkaXZpZGUoZGl2aXNvcikge1xuICBpZiAoIWlzTG9uZyhkaXZpc29yKSlcbiAgICBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xuICBpZiAoZGl2aXNvci5pc1plcm8oKSlcbiAgICB0aHJvdyBFcnJvcignZGl2aXNpb24gYnkgemVybycpO1xuXG4gIC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxuICBpZiAod2FzbSkge1xuICAgIC8vIGd1YXJkIGFnYWluc3Qgc2lnbmVkIGRpdmlzaW9uIG92ZXJmbG93OiB0aGUgbGFyZ2VzdFxuICAgIC8vIG5lZ2F0aXZlIG51bWJlciAvIC0xIHdvdWxkIGJlIDEgbGFyZ2VyIHRoYW4gdGhlIGxhcmdlc3RcbiAgICAvLyBwb3NpdGl2ZSBudW1iZXIsIGR1ZSB0byB0d28ncyBjb21wbGVtZW50LlxuICAgIGlmICghdGhpcy51bnNpZ25lZCAmJlxuICAgICAgdGhpcy5oaWdoID09PSAtMHg4MDAwMDAwMCAmJlxuICAgICAgZGl2aXNvci5sb3cgPT09IC0xICYmIGRpdmlzb3IuaGlnaCA9PT0gLTEpIHtcbiAgICAgIC8vIGJlIGNvbnNpc3RlbnQgd2l0aCBub24td2FzbSBjb2RlIHBhdGhcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtW1wiZGl2X3VcIl0gOiB3YXNtW1wiZGl2X3NcIl0pKFxuICAgICAgdGhpcy5sb3csXG4gICAgICB0aGlzLmhpZ2gsXG4gICAgICBkaXZpc29yLmxvdyxcbiAgICAgIGRpdmlzb3IuaGlnaFxuICAgICk7XG4gICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbVtcImdldF9oaWdoXCJdKCksIHRoaXMudW5zaWduZWQpO1xuICB9XG5cbiAgaWYgKHRoaXMuaXNaZXJvKCkpXG4gICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XG4gIHZhciBhcHByb3gsIHJlbSwgcmVzO1xuICBpZiAoIXRoaXMudW5zaWduZWQpIHtcbiAgICAvLyBUaGlzIHNlY3Rpb24gaXMgb25seSByZWxldmFudCBmb3Igc2lnbmVkIGxvbmdzIGFuZCBpcyBkZXJpdmVkIGZyb20gdGhlXG4gICAgLy8gY2xvc3VyZSBsaWJyYXJ5IGFzIGEgd2hvbGUuXG4gICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkge1xuICAgICAgaWYgKGRpdmlzb3IuZXEoT05FKSB8fCBkaXZpc29yLmVxKE5FR19PTkUpKVxuICAgICAgICByZXR1cm4gTUlOX1ZBTFVFOyAgLy8gcmVjYWxsIHRoYXQgLU1JTl9WQUxVRSA9PSBNSU5fVkFMVUVcbiAgICAgIGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSlcbiAgICAgICAgcmV0dXJuIE9ORTtcbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBoYXZlIHxvdGhlcnwgPj0gMiwgc28gfHRoaXMvb3RoZXJ8IDwgfE1JTl9WQUxVRXwuXG4gICAgICAgIHZhciBoYWxmVGhpcyA9IHRoaXMuc2hyKDEpO1xuICAgICAgICBhcHByb3ggPSBoYWxmVGhpcy5kaXYoZGl2aXNvcikuc2hsKDEpO1xuICAgICAgICBpZiAoYXBwcm94LmVxKFpFUk8pKSB7XG4gICAgICAgICAgcmV0dXJuIGRpdmlzb3IuaXNOZWdhdGl2ZSgpID8gT05FIDogTkVHX09ORTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW0gPSB0aGlzLnN1YihkaXZpc29yLm11bChhcHByb3gpKTtcbiAgICAgICAgICByZXMgPSBhcHByb3guYWRkKHJlbS5kaXYoZGl2aXNvcikpO1xuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSlcbiAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgICAgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKVxuICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvci5uZWcoKSk7XG4gICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvcikubmVnKCk7XG4gICAgfSBlbHNlIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSlcbiAgICAgIHJldHVybiB0aGlzLmRpdihkaXZpc29yLm5lZygpKS5uZWcoKTtcbiAgICByZXMgPSBaRVJPO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoZSBhbGdvcml0aG0gYmVsb3cgaGFzIG5vdCBiZWVuIG1hZGUgZm9yIHVuc2lnbmVkIGxvbmdzLiBJdCdzIHRoZXJlZm9yZVxuICAgIC8vIHJlcXVpcmVkIHRvIHRha2Ugc3BlY2lhbCBjYXJlIG9mIHRoZSBNU0IgcHJpb3IgdG8gcnVubmluZyBpdC5cbiAgICBpZiAoIWRpdmlzb3IudW5zaWduZWQpXG4gICAgICBkaXZpc29yID0gZGl2aXNvci50b1Vuc2lnbmVkKCk7XG4gICAgaWYgKGRpdmlzb3IuZ3QodGhpcykpXG4gICAgICByZXR1cm4gVVpFUk87XG4gICAgaWYgKGRpdmlzb3IuZ3QodGhpcy5zaHJ1KDEpKSkgLy8gMTUgPj4+IDEgPSA3IDsgd2l0aCBkaXZpc29yID0gOCA7IHRydWVcbiAgICAgIHJldHVybiBVT05FO1xuICAgIHJlcyA9IFVaRVJPO1xuICB9XG5cbiAgLy8gUmVwZWF0IHRoZSBmb2xsb3dpbmcgdW50aWwgdGhlIHJlbWFpbmRlciBpcyBsZXNzIHRoYW4gb3RoZXI6ICBmaW5kIGFcbiAgLy8gZmxvYXRpbmctcG9pbnQgdGhhdCBhcHByb3hpbWF0ZXMgcmVtYWluZGVyIC8gb3RoZXIgKmZyb20gYmVsb3cqLCBhZGQgdGhpc1xuICAvLyBpbnRvIHRoZSByZXN1bHQsIGFuZCBzdWJ0cmFjdCBpdCBmcm9tIHRoZSByZW1haW5kZXIuICBJdCBpcyBjcml0aWNhbCB0aGF0XG4gIC8vIHRoZSBhcHByb3hpbWF0ZSB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHJlYWwgdmFsdWUgc28gdGhhdCB0aGVcbiAgLy8gcmVtYWluZGVyIG5ldmVyIGJlY29tZXMgbmVnYXRpdmUuXG4gIHJlbSA9IHRoaXM7XG4gIHdoaWxlIChyZW0uZ3RlKGRpdmlzb3IpKSB7XG4gICAgLy8gQXBwcm94aW1hdGUgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbi4gVGhpcyBtYXkgYmUgYSBsaXR0bGUgZ3JlYXRlciBvclxuICAgIC8vIHNtYWxsZXIgdGhhbiB0aGUgYWN0dWFsIHZhbHVlLlxuICAgIGFwcHJveCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IocmVtLnRvTnVtYmVyKCkgLyBkaXZpc29yLnRvTnVtYmVyKCkpKTtcblxuICAgIC8vIFdlIHdpbGwgdHdlYWsgdGhlIGFwcHJveGltYXRlIHJlc3VsdCBieSBjaGFuZ2luZyBpdCBpbiB0aGUgNDgtdGggZGlnaXQgb3JcbiAgICAvLyB0aGUgc21hbGxlc3Qgbm9uLWZyYWN0aW9uYWwgZGlnaXQsIHdoaWNoZXZlciBpcyBsYXJnZXIuXG4gICAgdmFyIGxvZzIgPSBNYXRoLmNlaWwoTWF0aC5sb2coYXBwcm94KSAvIE1hdGguTE4yKSxcbiAgICAgIGRlbHRhID0gKGxvZzIgPD0gNDgpID8gMSA6IHBvd19kYmwoMiwgbG9nMiAtIDQ4KSxcblxuICAgICAgLy8gRGVjcmVhc2UgdGhlIGFwcHJveGltYXRpb24gdW50aWwgaXQgaXMgc21hbGxlciB0aGFuIHRoZSByZW1haW5kZXIuICBOb3RlXG4gICAgICAvLyB0aGF0IGlmIGl0IGlzIHRvbyBsYXJnZSwgdGhlIHByb2R1Y3Qgb3ZlcmZsb3dzIGFuZCBpcyBuZWdhdGl2ZS5cbiAgICAgIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94KSxcbiAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XG4gICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHtcbiAgICAgIGFwcHJveCAtPSBkZWx0YTtcbiAgICAgIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94LCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XG4gICAgfVxuXG4gICAgLy8gV2Uga25vdyB0aGUgYW5zd2VyIGNhbid0IGJlIHplcm8uLi4gYW5kIGFjdHVhbGx5LCB6ZXJvIHdvdWxkIGNhdXNlXG4gICAgLy8gaW5maW5pdGUgcmVjdXJzaW9uIHNpbmNlIHdlIHdvdWxkIG1ha2Ugbm8gcHJvZ3Jlc3MuXG4gICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSlcbiAgICAgIGFwcHJveFJlcyA9IE9ORTtcblxuICAgIHJlcyA9IHJlcy5hZGQoYXBwcm94UmVzKTtcbiAgICByZW0gPSByZW0uc3ViKGFwcHJveFJlbSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIExvbmcgZGl2aWRlZCBieSB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2RpdmlkZX0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gKiBAcmV0dXJucyB7IUxvbmd9IFF1b3RpZW50XG4gKi9cbkxvbmdQcm90b3R5cGUuZGl2ID0gTG9uZ1Byb3RvdHlwZS5kaXZpZGU7XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxuICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcbiAqL1xuTG9uZ1Byb3RvdHlwZS5tb2R1bG8gPSBmdW5jdGlvbiBtb2R1bG8oZGl2aXNvcikge1xuICBpZiAoIWlzTG9uZyhkaXZpc29yKSlcbiAgICBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xuXG4gIC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxuICBpZiAod2FzbSkge1xuICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc21bXCJyZW1fdVwiXSA6IHdhc21bXCJyZW1fc1wiXSkoXG4gICAgICB0aGlzLmxvdyxcbiAgICAgIHRoaXMuaGlnaCxcbiAgICAgIGRpdmlzb3IubG93LFxuICAgICAgZGl2aXNvci5oaWdoXG4gICAgKTtcbiAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtW1wiZ2V0X2hpZ2hcIl0oKSwgdGhpcy51bnNpZ25lZCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5zdWIodGhpcy5kaXYoZGl2aXNvcikubXVsKGRpdmlzb3IpKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXG4gKi9cbkxvbmdQcm90b3R5cGUubW9kID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXG4gKi9cbkxvbmdQcm90b3R5cGUucmVtID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYml0d2lzZSBOT1Qgb2YgdGhpcyBMb25nLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMgeyFMb25nfVxuICovXG5Mb25nUHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uIG5vdCgpIHtcbiAgcmV0dXJuIGZyb21CaXRzKH50aGlzLmxvdywgfnRoaXMuaGlnaCwgdGhpcy51bnNpZ25lZCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgY291bnQgbGVhZGluZyB6ZXJvcyBvZiB0aGlzIExvbmcuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7IW51bWJlcn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5jb3VudExlYWRpbmdaZXJvcyA9IGZ1bmN0aW9uIGNvdW50TGVhZGluZ1plcm9zKCkge1xuICByZXR1cm4gdGhpcy5oaWdoID8gTWF0aC5jbHozMih0aGlzLmhpZ2gpIDogTWF0aC5jbHozMih0aGlzLmxvdykgKyAzMjtcbn07XG5cbi8qKlxuICogUmV0dXJucyBjb3VudCBsZWFkaW5nIHplcm9zLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2NvdW50TGVhZGluZ1plcm9zfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ31cbiAqIEByZXR1cm5zIHshbnVtYmVyfVxuICovXG5Mb25nUHJvdG90eXBlLmNseiA9IExvbmdQcm90b3R5cGUuY291bnRMZWFkaW5nWmVyb3M7XG5cbi8qKlxuICogUmV0dXJucyBjb3VudCB0cmFpbGluZyB6ZXJvcyBvZiB0aGlzIExvbmcuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7IW51bWJlcn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5jb3VudFRyYWlsaW5nWmVyb3MgPSBmdW5jdGlvbiBjb3VudFRyYWlsaW5nWmVyb3MoKSB7XG4gIHJldHVybiB0aGlzLmxvdyA/IGN0ejMyKHRoaXMubG93KSA6IGN0ejMyKHRoaXMuaGlnaCkgKyAzMjtcbn07XG5cbi8qKlxuICogUmV0dXJucyBjb3VudCB0cmFpbGluZyB6ZXJvcy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNjb3VudFRyYWlsaW5nWmVyb3N9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfVxuICogQHJldHVybnMgeyFudW1iZXJ9XG4gKi9cbkxvbmdQcm90b3R5cGUuY3R6ID0gTG9uZ1Byb3RvdHlwZS5jb3VudFRyYWlsaW5nWmVyb3M7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYml0d2lzZSBBTkQgb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXG4gKiBAcmV0dXJucyB7IUxvbmd9XG4gKi9cbkxvbmdQcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kKG90aGVyKSB7XG4gIGlmICghaXNMb25nKG90aGVyKSlcbiAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyAmIG90aGVyLmxvdywgdGhpcy5oaWdoICYgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXG4gKiBAcmV0dXJucyB7IUxvbmd9XG4gKi9cbkxvbmdQcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvcihvdGhlcikge1xuICBpZiAoIWlzTG9uZyhvdGhlcikpXG4gICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgfCBvdGhlci5sb3csIHRoaXMuaGlnaCB8IG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIFhPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBnaXZlbiBvbmUuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcbiAqIEByZXR1cm5zIHshTG9uZ31cbiAqL1xuTG9uZ1Byb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3Iob3RoZXIpIHtcbiAgaWYgKCFpc0xvbmcob3RoZXIpKVxuICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcbiAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IF4gb3RoZXIubG93LCB0aGlzLmhpZ2ggXiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICovXG5Mb25nUHJvdG90eXBlLnNoaWZ0TGVmdCA9IGZ1bmN0aW9uIHNoaWZ0TGVmdChudW1CaXRzKSB7XG4gIGlmIChpc0xvbmcobnVtQml0cykpXG4gICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcbiAgICByZXR1cm4gdGhpcztcbiAgZWxzZSBpZiAobnVtQml0cyA8IDMyKVxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA8PCBudW1CaXRzLCAodGhpcy5oaWdoIDw8IG51bUJpdHMpIHwgKHRoaXMubG93ID4+PiAoMzIgLSBudW1CaXRzKSksIHRoaXMudW5zaWduZWQpO1xuICBlbHNlXG4gICAgcmV0dXJuIGZyb21CaXRzKDAsIHRoaXMubG93IDw8IChudW1CaXRzIC0gMzIpLCB0aGlzLnVuc2lnbmVkKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdExlZnR9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5zaGwgPSBMb25nUHJvdG90eXBlLnNoaWZ0TGVmdDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICovXG5Mb25nUHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0KG51bUJpdHMpIHtcbiAgaWYgKGlzTG9uZyhudW1CaXRzKSlcbiAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKVxuICAgIHJldHVybiB0aGlzO1xuICBlbHNlIGlmIChudW1CaXRzIDwgMzIpXG4gICAgcmV0dXJuIGZyb21CaXRzKCh0aGlzLmxvdyA+Pj4gbnVtQml0cykgfCAodGhpcy5oaWdoIDw8ICgzMiAtIG51bUJpdHMpKSwgdGhpcy5oaWdoID4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xuICBlbHNlXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+PiAobnVtQml0cyAtIDMyKSwgdGhpcy5oaWdoID49IDAgPyAwIDogLTEsIHRoaXMudW5zaWduZWQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0fS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUuc2hyID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICovXG5Mb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHRVbnNpZ25lZChudW1CaXRzKSB7XG4gIGlmIChpc0xvbmcobnVtQml0cykpIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApIHJldHVybiB0aGlzO1xuICBpZiAobnVtQml0cyA8IDMyKSByZXR1cm4gZnJvbUJpdHMoKHRoaXMubG93ID4+PiBudW1CaXRzKSB8ICh0aGlzLmhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLCB0aGlzLmhpZ2ggPj4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xuICBpZiAobnVtQml0cyA9PT0gMzIpIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2gsIDAsIHRoaXMudW5zaWduZWQpO1xuICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoID4+PiAobnVtQml0cyAtIDMyKSwgMCwgdGhpcy51bnNpZ25lZCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0VW5zaWduZWR9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5zaHJ1ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICovXG5Mb25nUHJvdG90eXBlLnNocl91ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHJvdGF0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJvdGF0ZWQgTG9uZ1xuICovXG5Mb25nUHJvdG90eXBlLnJvdGF0ZUxlZnQgPSBmdW5jdGlvbiByb3RhdGVMZWZ0KG51bUJpdHMpIHtcbiAgdmFyIGI7XG4gIGlmIChpc0xvbmcobnVtQml0cykpIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApIHJldHVybiB0aGlzO1xuICBpZiAobnVtQml0cyA9PT0gMzIpIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2gsIHRoaXMubG93LCB0aGlzLnVuc2lnbmVkKTtcbiAgaWYgKG51bUJpdHMgPCAzMikge1xuICAgIGIgPSAoMzIgLSBudW1CaXRzKTtcbiAgICByZXR1cm4gZnJvbUJpdHMoKCh0aGlzLmxvdyA8PCBudW1CaXRzKSB8ICh0aGlzLmhpZ2ggPj4+IGIpKSwgKCh0aGlzLmhpZ2ggPDwgbnVtQml0cykgfCAodGhpcy5sb3cgPj4+IGIpKSwgdGhpcy51bnNpZ25lZCk7XG4gIH1cbiAgbnVtQml0cyAtPSAzMjtcbiAgYiA9ICgzMiAtIG51bUJpdHMpO1xuICByZXR1cm4gZnJvbUJpdHMoKCh0aGlzLmhpZ2ggPDwgbnVtQml0cykgfCAodGhpcy5sb3cgPj4+IGIpKSwgKCh0aGlzLmxvdyA8PCBudW1CaXRzKSB8ICh0aGlzLmhpZ2ggPj4+IGIpKSwgdGhpcy51bnNpZ25lZCk7XG59XG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyByb3RhdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjcm90YXRlTGVmdH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJvdGF0ZWQgTG9uZ1xuICovXG5Mb25nUHJvdG90eXBlLnJvdGwgPSBMb25nUHJvdG90eXBlLnJvdGF0ZUxlZnQ7XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHJvdGF0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICogQHJldHVybnMgeyFMb25nfSBSb3RhdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5yb3RhdGVSaWdodCA9IGZ1bmN0aW9uIHJvdGF0ZVJpZ2h0KG51bUJpdHMpIHtcbiAgdmFyIGI7XG4gIGlmIChpc0xvbmcobnVtQml0cykpIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApIHJldHVybiB0aGlzO1xuICBpZiAobnVtQml0cyA9PT0gMzIpIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2gsIHRoaXMubG93LCB0aGlzLnVuc2lnbmVkKTtcbiAgaWYgKG51bUJpdHMgPCAzMikge1xuICAgIGIgPSAoMzIgLSBudW1CaXRzKTtcbiAgICByZXR1cm4gZnJvbUJpdHMoKCh0aGlzLmhpZ2ggPDwgYikgfCAodGhpcy5sb3cgPj4+IG51bUJpdHMpKSwgKCh0aGlzLmxvdyA8PCBiKSB8ICh0aGlzLmhpZ2ggPj4+IG51bUJpdHMpKSwgdGhpcy51bnNpZ25lZCk7XG4gIH1cbiAgbnVtQml0cyAtPSAzMjtcbiAgYiA9ICgzMiAtIG51bUJpdHMpO1xuICByZXR1cm4gZnJvbUJpdHMoKCh0aGlzLmxvdyA8PCBiKSB8ICh0aGlzLmhpZ2ggPj4+IG51bUJpdHMpKSwgKCh0aGlzLmhpZ2ggPDwgYikgfCAodGhpcy5sb3cgPj4+IG51bUJpdHMpKSwgdGhpcy51bnNpZ25lZCk7XG59XG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyByb3RhdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3JvdGF0ZVJpZ2h0fS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAqIEByZXR1cm5zIHshTG9uZ30gUm90YXRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUucm90ciA9IExvbmdQcm90b3R5cGUucm90YXRlUmlnaHQ7XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIHNpZ25lZC5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHshTG9uZ30gU2lnbmVkIGxvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS50b1NpZ25lZCA9IGZ1bmN0aW9uIHRvU2lnbmVkKCkge1xuICBpZiAoIXRoaXMudW5zaWduZWQpXG4gICAgcmV0dXJuIHRoaXM7XG4gIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byB1bnNpZ25lZC5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHshTG9uZ30gVW5zaWduZWQgbG9uZ1xuICovXG5Mb25nUHJvdG90eXBlLnRvVW5zaWduZWQgPSBmdW5jdGlvbiB0b1Vuc2lnbmVkKCkge1xuICBpZiAodGhpcy51bnNpZ25lZClcbiAgICByZXR1cm4gdGhpcztcbiAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIHRydWUpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGJ5dGUgcmVwcmVzZW50YXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBsZSBXaGV0aGVyIGxpdHRsZSBvciBiaWcgZW5kaWFuLCBkZWZhdWx0cyB0byBiaWcgZW5kaWFuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBCeXRlIHJlcHJlc2VudGF0aW9uXG4gKi9cbkxvbmdQcm90b3R5cGUudG9CeXRlcyA9IGZ1bmN0aW9uIHRvQnl0ZXMobGUpIHtcbiAgcmV0dXJuIGxlID8gdGhpcy50b0J5dGVzTEUoKSA6IHRoaXMudG9CeXRlc0JFKCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgbGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gTGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXG4gKi9cbkxvbmdQcm90b3R5cGUudG9CeXRlc0xFID0gZnVuY3Rpb24gdG9CeXRlc0xFKCkge1xuICB2YXIgaGkgPSB0aGlzLmhpZ2gsXG4gICAgbG8gPSB0aGlzLmxvdztcbiAgcmV0dXJuIFtcbiAgICBsbyAmIDB4ZmYsXG4gICAgbG8gPj4+IDggJiAweGZmLFxuICAgIGxvID4+PiAxNiAmIDB4ZmYsXG4gICAgbG8gPj4+IDI0LFxuICAgIGhpICYgMHhmZixcbiAgICBoaSA+Pj4gOCAmIDB4ZmYsXG4gICAgaGkgPj4+IDE2ICYgMHhmZixcbiAgICBoaSA+Pj4gMjRcbiAgXTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBiaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBCaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cbiAqL1xuTG9uZ1Byb3RvdHlwZS50b0J5dGVzQkUgPSBmdW5jdGlvbiB0b0J5dGVzQkUoKSB7XG4gIHZhciBoaSA9IHRoaXMuaGlnaCxcbiAgICBsbyA9IHRoaXMubG93O1xuICByZXR1cm4gW1xuICAgIGhpID4+PiAyNCxcbiAgICBoaSA+Pj4gMTYgJiAweGZmLFxuICAgIGhpID4+PiA4ICYgMHhmZixcbiAgICBoaSAmIDB4ZmYsXG4gICAgbG8gPj4+IDI0LFxuICAgIGxvID4+PiAxNiAmIDB4ZmYsXG4gICAgbG8gPj4+IDggJiAweGZmLFxuICAgIGxvICYgMHhmZlxuICBdO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgTG9uZyBmcm9tIGl0cyBieXRlIHJlcHJlc2VudGF0aW9uLlxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIEJ5dGUgcmVwcmVzZW50YXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGxlIFdoZXRoZXIgbGl0dGxlIG9yIGJpZyBlbmRpYW4sIGRlZmF1bHRzIHRvIGJpZyBlbmRpYW5cbiAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gKi9cbkxvbmcuZnJvbUJ5dGVzID0gZnVuY3Rpb24gZnJvbUJ5dGVzKGJ5dGVzLCB1bnNpZ25lZCwgbGUpIHtcbiAgcmV0dXJuIGxlID8gTG9uZy5mcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIDogTG9uZy5mcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgTG9uZyBmcm9tIGl0cyBsaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXG4gKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgTGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICovXG5Mb25nLmZyb21CeXRlc0xFID0gZnVuY3Rpb24gZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSB7XG4gIHJldHVybiBuZXcgTG9uZyhcbiAgICBieXRlc1swXSB8XG4gICAgYnl0ZXNbMV0gPDwgOCB8XG4gICAgYnl0ZXNbMl0gPDwgMTYgfFxuICAgIGJ5dGVzWzNdIDw8IDI0LFxuICAgIGJ5dGVzWzRdIHxcbiAgICBieXRlc1s1XSA8PCA4IHxcbiAgICBieXRlc1s2XSA8PCAxNiB8XG4gICAgYnl0ZXNbN10gPDwgMjQsXG4gICAgdW5zaWduZWRcbiAgKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgYmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIEJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAqL1xuTG9uZy5mcm9tQnl0ZXNCRSA9IGZ1bmN0aW9uIGZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCkge1xuICByZXR1cm4gbmV3IExvbmcoXG4gICAgYnl0ZXNbNF0gPDwgMjQgfFxuICAgIGJ5dGVzWzVdIDw8IDE2IHxcbiAgICBieXRlc1s2XSA8PCA4IHxcbiAgICBieXRlc1s3XSxcbiAgICBieXRlc1swXSA8PCAyNCB8XG4gICAgYnl0ZXNbMV0gPDwgMTYgfFxuICAgIGJ5dGVzWzJdIDw8IDggfFxuICAgIGJ5dGVzWzNdLFxuICAgIHVuc2lnbmVkXG4gICk7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IG5vZGVfbW9kdWxlc19sb25nID0gKExvbmcpO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9lcnJvci50c1xuLypcbiAqIENvcHlyaWdodCAyMDIwIFRoZSBZb3JraWUgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBlcnJvcl9Db2RlO1xuKGZ1bmN0aW9uIChDb2RlKSB7XG4gICAgLy8gT2sgaXMgcmV0dXJuZWQgd2hlbiB0aGUgb3BlcmF0aW9uIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG4gICAgQ29kZVtcIk9rXCJdID0gXCJva1wiO1xuICAgIC8vIENsaWVudE5vdEFjdGl2ZSBpcyByZXR1cm5lZCB3aGVuIHRoZSBjbGllbnQgaXMgbm90IGFjdGl2ZS5cbiAgICBDb2RlW1wiQ2xpZW50Tm90QWN0aXZlXCJdID0gXCJjbGllbnQtbm90LWFjdGl2ZVwiO1xuICAgIC8vIFVuaW1wbGVtZW50ZWQgaXMgcmV0dXJuZWQgd2hlbiB0aGUgb3BlcmF0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZC5cbiAgICBDb2RlW1wiVW5pbXBsZW1lbnRlZFwiXSA9IFwidW5pbXBsZW1lbnRlZFwiO1xuICAgIC8vIFVuc3VwcG9ydGVkIGlzIHJldHVybmVkIHdoZW4gdGhlIG9wZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkLlxuICAgIENvZGVbXCJVbnN1cHBvcnRlZFwiXSA9IFwidW5zdXBwb3J0ZWRcIjtcbiAgICAvLyBEb2N1bWVudE5vdEF0dGFjaGVkIGlzIHJldHVybmVkIHdoZW4gdGhlIGRvY3VtZW50IGlzIG5vdCBhdHRhY2hlZC5cbiAgICBDb2RlW1wiRG9jdW1lbnROb3RBdHRhY2hlZFwiXSA9IFwiZG9jdW1lbnQtbm90LWF0dGFjaGVkXCI7XG4gICAgLy8gRG9jdW1lbnROb3REZXRhY2hlZCBpcyByZXR1cm5lZCB3aGVuIHRoZSBkb2N1bWVudCBpcyBub3QgZGV0YWNoZWQuXG4gICAgQ29kZVtcIkRvY3VtZW50Tm90RGV0YWNoZWRcIl0gPSBcImRvY3VtZW50LW5vdC1kZXRhY2hlZFwiO1xuICAgIC8vIERvY3VtZW50UmVtb3ZlZCBpcyByZXR1cm5lZCB3aGVuIHRoZSBkb2N1bWVudCBpcyByZW1vdmVkLlxuICAgIENvZGVbXCJEb2N1bWVudFJlbW92ZWRcIl0gPSBcImRvY3VtZW50LXJlbW92ZWRcIjtcbiAgICAvLyBJbnZhbGlkT2JqZWN0S2V5IGlzIHJldHVybmVkIHdoZW4gdGhlIG9iamVjdCBrZXkgaXMgaW52YWxpZC5cbiAgICBDb2RlW1wiSW52YWxpZE9iamVjdEtleVwiXSA9IFwiaW52YWxpZC1vYmplY3Qta2V5XCI7XG4gICAgLy8gSW52YWxpZEFyZ3VtZW50IGlzIHJldHVybmVkIHdoZW4gdGhlIGFyZ3VtZW50IGlzIGludmFsaWQuXG4gICAgQ29kZVtcIkludmFsaWRBcmd1bWVudFwiXSA9IFwiaW52YWxpZC1hcmd1bWVudFwiO1xufSkoZXJyb3JfQ29kZSB8fCAoZXJyb3JfQ29kZSA9IHt9KSk7XG4vKipcbiAqIGBZb3JraWVFcnJvcmAgaXMgYW4gZXJyb3IgcmV0dXJuZWQgYnkgYSBZb3JraWUgb3BlcmF0aW9uLlxuICovXG5jbGFzcyBZb3JraWVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnWW9ya2llRXJyb3InO1xuICAgICAgICB0aGlzLnRvU3RyaW5nID0gKCkgPT4gYCR7dGhpcy5uYW1lfTogW2NvZGU9JHt0aGlzLmNvZGV9XTogJHt0aGlzLm1lc3NhZ2V9YDtcbiAgICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL29iamVjdC50c1xuLypcbiAqIENvcHlyaWdodCAyMDIzIFRoZSBZb3JraWUgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogYGRlZXBjb3B5YCByZXR1cm5zIGEgZGVlcCBjb3B5IG9mIHRoZSBnaXZlbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZXBjb3B5KG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgY29uc3QgcGFpcnMgPSBBcnJheS5mcm9tKG9iamVjdCk7XG4gICAgICAgIHJldHVybiBuZXcgTWFwKEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocGFpcnMpKSk7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iamVjdCkpO1xufVxuLyoqXG4gYGlzRW1wdHlgIHJldHVybnMgd2hldGhlciBwYXJhbWV0ZXIgb2JqZWN0IGlzIGVtcHR5IG9yIG5vdFxuICovXG5jb25zdCBpc0VtcHR5ID0gKG9iamVjdCkgPT4ge1xuICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqZWN0KS5sZW5ndGggPT09IDA7XG59O1xuLyoqXG4gKiBgc3RyaW5naWZ5T2JqZWN0VmFsdWVzYCBtYWtlcyB2YWx1ZXMgb2YgYXR0cmlidXRlcyB0byBKU09OIHBhcnNhYmxlIHN0cmluZy5cbiAqL1xuY29uc3Qgc3RyaW5naWZ5T2JqZWN0VmFsdWVzID0gKGF0dHJpYnV0ZXMpID0+IHtcbiAgICBjb25zdCBhdHRycyA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIGF0dHJzW2tleV0gPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBhdHRycztcbn07XG4vKipcbiBgcGFyc2VPYmplY3RWYWx1ZXNgIHJldHVybnMgdGhlIEpTT04gcGFyc2FibGUgc3RyaW5nIHZhbHVlcyB0byB0aGUgb3JpZ2luIHN0YXRlcy5cbiAqL1xuY29uc3QgcGFyc2VPYmplY3RWYWx1ZXMgPSAoYXR0cnMpID0+IHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYXR0cnMpKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cmlidXRlcztcbn07XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kb2N1bWVudC9wcmVzZW5jZS9wcmVzZW5jZS50c1xuLypcbiAqIENvcHlyaWdodCAyMDIzIFRoZSBZb3JraWUgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBgUHJlc2VuY2VDaGFuZ2VUeXBlYCByZXByZXNlbnRzIHRoZSB0eXBlIG9mIHByZXNlbmNlIGNoYW5nZS5cbiAqL1xudmFyIFByZXNlbmNlQ2hhbmdlVHlwZTtcbihmdW5jdGlvbiAoUHJlc2VuY2VDaGFuZ2VUeXBlKSB7XG4gICAgUHJlc2VuY2VDaGFuZ2VUeXBlW1wiUHV0XCJdID0gXCJwdXRcIjtcbiAgICBQcmVzZW5jZUNoYW5nZVR5cGVbXCJDbGVhclwiXSA9IFwiY2xlYXJcIjtcbn0pKFByZXNlbmNlQ2hhbmdlVHlwZSB8fCAoUHJlc2VuY2VDaGFuZ2VUeXBlID0ge30pKTtcbi8qKlxuICogYFByZXNlbmNlYCByZXByZXNlbnRzIGEgcHJveHkgZm9yIHRoZSBQcmVzZW5jZSB0byBiZSBtYW5pcHVsYXRlZCBmcm9tIHRoZSBvdXRzaWRlLlxuICovXG5jbGFzcyBQcmVzZW5jZSB7XG4gICAgY29uc3RydWN0b3IoY2hhbmdlQ29udGV4dCwgcHJlc2VuY2UpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY2hhbmdlQ29udGV4dDtcbiAgICAgICAgdGhpcy5wcmVzZW5jZSA9IHByZXNlbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgc2V0YCB1cGRhdGVzIHRoZSBwcmVzZW5jZSBiYXNlZCBvbiB0aGUgcGFydGlhbCBwcmVzZW5jZS5cbiAgICAgKi9cbiAgICBzZXQocHJlc2VuY2UsIG9wdGlvbikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwcmVzZW5jZSkpIHtcbiAgICAgICAgICAgIHRoaXMucHJlc2VuY2Vba2V5XSA9IHByZXNlbmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250ZXh0LnNldFByZXNlbmNlQ2hhbmdlKHtcbiAgICAgICAgICAgIHR5cGU6IFByZXNlbmNlQ2hhbmdlVHlwZS5QdXQsXG4gICAgICAgICAgICBwcmVzZW5jZTogZGVlcGNvcHkodGhpcy5wcmVzZW5jZSksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbnRleHQuc2V0UmV2ZXJzZVByZXNlbmNlKHByZXNlbmNlLCBvcHRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0YCByZXR1cm5zIHRoZSBwcmVzZW5jZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4ga2V5LlxuICAgICAqL1xuICAgIGdldChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlc2VuY2Vba2V5XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGNsZWFyYCBjbGVhcnMgdGhlIHByZXNlbmNlLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnByZXNlbmNlID0ge307XG4gICAgICAgIHRoaXMuY29udGV4dC5zZXRQcmVzZW5jZUNoYW5nZSh7XG4gICAgICAgICAgICB0eXBlOiBQcmVzZW5jZUNoYW5nZVR5cGUuQ2xlYXIsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2RvY3VtZW50L3RpbWUvYWN0b3JfaWQudHNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIGBJbml0aWFsQWN0b3JJRGAgaXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgQWN0b3JJRC5cbiAqL1xuY29uc3QgSW5pdGlhbEFjdG9ySUQgPSAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJztcbi8qKlxuICogYE1heEFjdG9ySURgIGlzIHRoZSBtYXhpbXVtIHZhbHVlIG9mIEFjdG9ySUQuXG4gKi9cbmNvbnN0IE1heEFjdG9ySUQgPSAnRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGJztcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2RvY3VtZW50L3RpbWUvdGlja2V0LnRzXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgVGhlIFlvcmtpZSBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5cbmNvbnN0IFRpY2tldENvbXBhcmF0b3IgPSAocDEsIHAyKSA9PiB7XG4gICAgcmV0dXJuIHAxLmNvbXBhcmUocDIpO1xufTtcbi8qKlxuICogYFRpbWVUaWNrZXRgIGlzIGEgdGltZXN0YW1wIG9mIHRoZSBsb2dpY2FsIGNsb2NrLiBUaWNrZXQgaXMgaW1tdXRhYmxlLlxuICogSXQgaXMgY3JlYXRlZCBieSBgQ2hhbmdlSURgLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgVGltZVRpY2tldCB7XG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cbiAgICBjb25zdHJ1Y3RvcihsYW1wb3J0LCBkZWxpbWl0ZXIsIGFjdG9ySUQpIHtcbiAgICAgICAgdGhpcy5sYW1wb3J0ID0gbGFtcG9ydDtcbiAgICAgICAgdGhpcy5kZWxpbWl0ZXIgPSBkZWxpbWl0ZXI7XG4gICAgICAgIHRoaXMuYWN0b3JJRCA9IGFjdG9ySUQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBvZmAgY3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBUaWNrZXQuXG4gICAgICovXG4gICAgc3RhdGljIG9mKGxhbXBvcnQsIGRlbGltaXRlciwgYWN0b3JJRCkge1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVUaWNrZXQobGFtcG9ydCwgZGVsaW1pdGVyLCBhY3RvcklEKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGZyb21TdHJ1Y3RgIGNyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgVGlja2V0IGZyb20gdGhlIHN0cnVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cnVjdChzdHJ1Y3QpIHtcbiAgICAgICAgcmV0dXJuIFRpbWVUaWNrZXQub2Yobm9kZV9tb2R1bGVzX2xvbmcuZnJvbVN0cmluZyhzdHJ1Y3QubGFtcG9ydCwgdHJ1ZSksIHN0cnVjdC5kZWxpbWl0ZXIsIHN0cnVjdC5hY3RvcklEKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRvSURTdHJpbmdgIHJldHVybnMgdGhlIGxhbXBvcnQgc3RyaW5nIGZvciB0aGlzIFRpY2tldC5cbiAgICAgKi9cbiAgICB0b0lEU3RyaW5nKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0b3JJRCkge1xuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMubGFtcG9ydC50b1N0cmluZygpfTpuaWw6JHt0aGlzLmRlbGltaXRlcn1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmxhbXBvcnQudG9TdHJpbmcoKX06JHt0aGlzLmFjdG9ySUR9OiR7dGhpcy5kZWxpbWl0ZXJ9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRvU3RydWN0YCByZXR1cm5zIHRoZSBzdHJ1Y3R1cmUgb2YgdGhpcyBUaWNrZXQuXG4gICAgICovXG4gICAgdG9TdHJ1Y3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYW1wb3J0OiB0aGlzLmdldExhbXBvcnRBc1N0cmluZygpLFxuICAgICAgICAgICAgZGVsaW1pdGVyOiB0aGlzLmdldERlbGltaXRlcigpLFxuICAgICAgICAgICAgYWN0b3JJRDogdGhpcy5nZXRBY3RvcklEKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0b1Rlc3RTdHJpbmdgIHJldHVybnMgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgbWV0YSBkYXRhIG9mIHRoZSB0aWNrZXRcbiAgICAgKiBmb3IgZGVidWdnaW5nIHB1cnBvc2UuXG4gICAgICovXG4gICAgdG9UZXN0U3RyaW5nKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0b3JJRCkge1xuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMubGFtcG9ydC50b1N0cmluZygpfTpuaWw6JHt0aGlzLmRlbGltaXRlcn1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmxhbXBvcnQudG9TdHJpbmcoKX06JHt0aGlzLmFjdG9ySUQuc2xpY2UoLTIpfToke3RoaXMuZGVsaW1pdGVyfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBzZXRBY3RvcmAgY3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBUaWNrZXQgd2l0aCB0aGUgZ2l2ZW4gYWN0b3JJRC5cbiAgICAgKi9cbiAgICBzZXRBY3RvcihhY3RvcklEKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGltZVRpY2tldCh0aGlzLmxhbXBvcnQsIHRoaXMuZGVsaW1pdGVyLCBhY3RvcklEKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldExhbXBvcnRBc1N0cmluZ2AgcmV0dXJucyB0aGUgbGFtcG9ydCBzdHJpbmcuXG4gICAgICovXG4gICAgZ2V0TGFtcG9ydEFzU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYW1wb3J0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRMYW1wb3J0YCByZXR1cm5zIHRoZSBsYW1wb3J0LlxuICAgICAqL1xuICAgIGdldExhbXBvcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhbXBvcnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXREZWxpbWl0ZXJgIHJldHVybnMgZGVsaW1pdGVyLlxuICAgICAqL1xuICAgIGdldERlbGltaXRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsaW1pdGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0QWN0b3JJRGAgcmV0dXJucyBhY3RvcklELlxuICAgICAqL1xuICAgIGdldEFjdG9ySUQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdG9ySUQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBhZnRlcmAgcmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiB0aWNrZXQgd2FzIGNyZWF0ZWQgbGF0ZXIuXG4gICAgICovXG4gICAgYWZ0ZXIob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZShvdGhlcikgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZXF1YWxzYCByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIHRpY2tldCB3YXMgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZShvdGhlcikgPT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBjb21wYXJlYCByZXR1cm5zIGFuIGludGVnZXIgY29tcGFyaW5nIHR3byBUaWNrZXQuXG4gICAgICogIFRoZSByZXN1bHQgd2lsbCBiZSAwIGlmIGlkPT1vdGhlciwgLTEgaWYgYGlkIDwgb3RoZXJgLCBhbmQgKzEgaWYgYGlkID4gb3RoZXJgLlxuICAgICAqICBJZiB0aGUgcmVjZWl2ZXIgb3IgYXJndW1lbnQgaXMgbmlsLCBpdCB3b3VsZCBwYW5pYyBhdCBydW50aW1lLlxuICAgICAqL1xuICAgIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMubGFtcG9ydC5ncmVhdGVyVGhhbihvdGhlci5sYW1wb3J0KSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3RoZXIubGFtcG9ydC5ncmVhdGVyVGhhbih0aGlzLmxhbXBvcnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcGFyZSA9IHRoaXMuYWN0b3JJRC5sb2NhbGVDb21wYXJlKG90aGVyLmFjdG9ySUQpO1xuICAgICAgICBpZiAoY29tcGFyZSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVsaW1pdGVyID4gb3RoZXIuZGVsaW1pdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdGhlci5kZWxpbWl0ZXIgPiB0aGlzLmRlbGltaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cbmNvbnN0IEluaXRpYWxEZWxpbWl0ZXIgPSAwO1xuY29uc3QgTWF4RGVsZW1pdGVyID0gNDI5NDk2NzI5NTsgLy8gVUludDMyIE1BWF9WQUxVRVxuY29uc3QgTWF4TGFtcG9ydCA9IG5vZGVfbW9kdWxlc19sb25nLk1BWF9WQUxVRTtcbmNvbnN0IEluaXRpYWxUaW1lVGlja2V0ID0gbmV3IFRpbWVUaWNrZXQobm9kZV9tb2R1bGVzX2xvbmcuZnJvbU51bWJlcigwKSwgSW5pdGlhbERlbGltaXRlciwgSW5pdGlhbEFjdG9ySUQpO1xuY29uc3QgTWF4VGltZVRpY2tldCA9IG5ldyBUaW1lVGlja2V0KE1heExhbXBvcnQsIE1heERlbGVtaXRlciwgTWF4QWN0b3JJRCk7XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kb2N1bWVudC9qc29uL3N0cmluZ3MudHNcbi8qKlxuICogYEVzY2FwZVN0cmluZ2AgZXNjYXBlcyB0aGUgZ2l2ZW4gc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXCInXFxcXFxcblxcclxcZlxcYlxcdFxcdTIwMjhcXHUyMDI5XS9nLCBmdW5jdGlvbiAoY2hhcmFjdGVyKSB7XG4gICAgICAgIHN3aXRjaCAoY2hhcmFjdGVyKSB7XG4gICAgICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICBjYXNlICdcXFxcJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xcXFwnICsgY2hhcmFjdGVyO1xuICAgICAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xcXFxuJztcbiAgICAgICAgICAgIGNhc2UgJ1xccic6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXFxccic7XG4gICAgICAgICAgICBjYXNlICdcXGYnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnXFxcXGYnO1xuICAgICAgICAgICAgY2FzZSAnXFxiJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xcXFxiJztcbiAgICAgICAgICAgIGNhc2UgJ1xcdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXFxcdCc7XG4gICAgICAgICAgICBjYXNlICdcXHUyMDI4JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xcXFx1MjAyOCc7XG4gICAgICAgICAgICBjYXNlICdcXHUyMDI5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xcXFx1MjAyOSc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFyYWN0ZXI7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2RvY3VtZW50L2NyZHQvZWxlbWVudC50c1xuLypcbiAqIENvcHlyaWdodCAyMDIwIFRoZSBZb3JraWUgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogYENSRFRFbGVtZW50YCByZXByZXNlbnRzIGFuIGVsZW1lbnQgdGhhdCBoYXMgYFRpbWVUaWNrZXRgcy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgQ1JEVEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNyZWF0ZWRBdCkge1xuICAgICAgICB0aGlzLmNyZWF0ZWRBdCA9IGNyZWF0ZWRBdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldENyZWF0ZWRBdGAgcmV0dXJucyB0aGUgY3JlYXRpb24gdGltZSBvZiB0aGlzIGVsZW1lbnQuXG4gICAgICovXG4gICAgZ2V0Q3JlYXRlZEF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVkQXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRJRGAgcmV0dXJucyB0aGUgY3JlYXRpb24gdGltZSBvZiB0aGlzIGVsZW1lbnQuXG4gICAgICovXG4gICAgZ2V0SUQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZWRBdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldE1vdmVkQXRgIHJldHVybnMgdGhlIG1vdmUgdGltZSBvZiB0aGlzIGVsZW1lbnQuXG4gICAgICovXG4gICAgZ2V0TW92ZWRBdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW92ZWRBdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldFJlbW92ZWRBdGAgcmV0dXJucyB0aGUgcmVtb3ZhbCB0aW1lIG9mIHRoaXMgZWxlbWVudC5cbiAgICAgKi9cbiAgICBnZXRSZW1vdmVkQXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZWRBdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldFBvc2l0aW9uZWRBdGAgcmV0dXJucyB0aGUgdGltZSBvZiB0aGlzIGVsZW1lbnQgd2hlbiBpdCB3YXMgcG9zaXRpb25lZFxuICAgICAqIGluIHRoZSBkb2N1bWVudCBieSB1bmRvL3JlZG8gb3IgbW92ZSBvcGVyYXRpb24uXG4gICAgICovXG4gICAgZ2V0UG9zaXRpb25lZEF0KCkge1xuICAgICAgICBpZiAoIXRoaXMubW92ZWRBdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlZEF0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1vdmVkQXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBzZXRNb3ZlZEF0YCBzZXRzIHRoZSBtb3ZlIHRpbWUgb2YgdGhpcyBlbGVtZW50LlxuICAgICAqL1xuICAgIHNldE1vdmVkQXQobW92ZWRBdCkge1xuICAgICAgICBpZiAoIXRoaXMubW92ZWRBdCB8fCAobW92ZWRBdCAmJiBtb3ZlZEF0LmFmdGVyKHRoaXMubW92ZWRBdCkpKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVkQXQgPSBtb3ZlZEF0O1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgc2V0UmVtb3ZlZEF0YCBzZXRzIHRoZSByZW1vdmUgdGltZSBvZiB0aGlzIGVsZW1lbnQuXG4gICAgICovXG4gICAgc2V0UmVtb3ZlZEF0KHJlbW92ZWRBdCkge1xuICAgICAgICB0aGlzLnJlbW92ZWRBdCA9IHJlbW92ZWRBdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHJlbW92ZWAgcmVtb3ZlcyB0aGlzIGVsZW1lbnQuXG4gICAgICovXG4gICAgcmVtb3ZlKHJlbW92ZWRBdCkge1xuICAgICAgICBpZiAocmVtb3ZlZEF0ICYmXG4gICAgICAgICAgICByZW1vdmVkQXQuYWZ0ZXIodGhpcy5nZXRQb3NpdGlvbmVkQXQoKSkgJiZcbiAgICAgICAgICAgICghdGhpcy5yZW1vdmVkQXQgfHwgcmVtb3ZlZEF0LmFmdGVyKHRoaXMucmVtb3ZlZEF0KSkpIHtcbiAgICAgICAgICAgIC8vIE5PVEUoY2hhY2hhOTEyKTogSWYgaXQncyBhIENSRFRDb250YWluZXIsIHJlbW92ZWRBdCBpcyBtYXJrZWQgb25seSBvblxuICAgICAgICAgICAgLy8gdGhlIHRvcC1sZXZlbCBlbGVtZW50LCB3aXRob3V0IG1hcmtpbmcgYWxsIGRlc2NlbmRhbnQgZWxlbWVudHMuIFRoaXNcbiAgICAgICAgICAgIC8vIGVuaGFuY2VzIHRoZSBzcGVlZCBvZiBkZWxldGlvbi5cbiAgICAgICAgICAgIHRoaXMucmVtb3ZlZEF0ID0gcmVtb3ZlZEF0O1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgaXNSZW1vdmVkYCBjaGVjayBpZiB0aGlzIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gICAgICovXG4gICAgaXNSZW1vdmVkKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnJlbW92ZWRBdDtcbiAgICB9XG59XG4vKipcbiAqXG4gKiBgQ1JEVENvbnRhaW5lcmAgcmVwcmVzZW50cyBDUkRUQXJyYXkgb3IgQ1JEdE9iamVjdC5cbiAqL1xuY2xhc3MgQ1JEVENvbnRhaW5lciBleHRlbmRzIENSRFRFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihjcmVhdGVkQXQpIHtcbiAgICAgICAgc3VwZXIoY3JlYXRlZEF0KTtcbiAgICB9XG59XG4vKipcbiAqIGBDUkRUR0NFbGVtZW50YCByZXByZXNlbnRzIGVsZW1lbnQgd2hpY2ggaGFzIGdhcmJhZ2UgY29sbGVjdGluZyBtZXRob2QuXG4gKi9cbmNsYXNzIENSRFRHQ0VsZW1lbnQgZXh0ZW5kcyBDUkRURWxlbWVudCB7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kb2N1bWVudC9jcmR0L2VsZW1lbnRfcmh0LnRzXG4vKlxuICogQ29weXJpZ2h0IDIwMjMgVGhlIFlvcmtpZSBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIGBFbGVtZW50UkhUTm9kZWAgaXMgYSBub2RlIG9mIEVsZW1lbnRSSFQuXG4gKi9cbmNsYXNzIEVsZW1lbnRSSFROb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihzdHJLZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3RyS2V5ID0gc3RyS2V5O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBvZmAgY3JlYXRlcyBhIGluc3RhbmNlIG9mIEVsZW1lbnRSSFROb2RlLlxuICAgICAqL1xuICAgIHN0YXRpYyBvZihzdHJLZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRWxlbWVudFJIVE5vZGUoc3RyS2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBpc1JlbW92ZWRgIGNoZWNrcyB3aGV0aGVyIHRoaXMgdmFsdWUgd2FzIHJlbW92ZWQuXG4gICAgICovXG4gICAgaXNSZW1vdmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5pc1JlbW92ZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldFN0cktleWAgcmV0dXJucyB0aGUga2V5IG9mIHRoaXMgbm9kZS5cbiAgICAgKi9cbiAgICBnZXRTdHJLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cktleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldFZhbHVlYCByZXR1cm4gdGhlIHZhbHVlKGVsZW1lbnQpIG9mIHRoaXMgbm9kZVxuICAgICAqL1xuICAgIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHJlbW92ZWAgcmVtb3ZlcyBhIHZhbHVlIGJhc2Ugb24gcmVtb3ZpbmcgdGltZS5cbiAgICAgKi9cbiAgICByZW1vdmUocmVtb3ZlZEF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlLnJlbW92ZShyZW1vdmVkQXQpO1xuICAgIH1cbn1cbi8qKlxuICogRWxlbWVudFJIVCBpcyBhIGhhc2h0YWJsZSB3aXRoIGxvZ2ljYWwgY2xvY2soUmVwbGljYXRlZCBoYXNodGFibGUpXG4gKlxuICovXG5jbGFzcyBFbGVtZW50UkhUIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ub2RlTWFwQnlLZXkgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubm9kZU1hcEJ5Q3JlYXRlZEF0ID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgY3JlYXRlYCBjcmVhdGVzIGFuIGluc3RhbmNlIG9mIEVsZW1lbnRSSFQuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50UkhUKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBzZXRgIHNldHMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBrZXkuXG4gICAgICovXG4gICAgc2V0KGtleSwgdmFsdWUsIGV4ZWN1dGVkQXQpIHtcbiAgICAgICAgbGV0IHJlbW92ZWQ7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGVNYXBCeUtleS5nZXQoa2V5KTtcbiAgICAgICAgaWYgKG5vZGUgIT0gbnVsbCAmJiAhbm9kZS5pc1JlbW92ZWQoKSAmJiBub2RlLnJlbW92ZShleGVjdXRlZEF0KSkge1xuICAgICAgICAgICAgcmVtb3ZlZCA9IG5vZGUuZ2V0VmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdOb2RlID0gRWxlbWVudFJIVE5vZGUub2Yoa2V5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMubm9kZU1hcEJ5Q3JlYXRlZEF0LnNldCh2YWx1ZS5nZXRDcmVhdGVkQXQoKS50b0lEU3RyaW5nKCksIG5ld05vZGUpO1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsIHx8IGV4ZWN1dGVkQXQuYWZ0ZXIobm9kZS5nZXRWYWx1ZSgpLmdldFBvc2l0aW9uZWRBdCgpKSkge1xuICAgICAgICAgICAgdGhpcy5ub2RlTWFwQnlLZXkuc2V0KGtleSwgbmV3Tm9kZSk7XG4gICAgICAgICAgICB2YWx1ZS5zZXRNb3ZlZEF0KGV4ZWN1dGVkQXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZGVsZXRlYCBkZWxldGVzIHRoZSBFbGVtZW50IG9mIHRoZSBnaXZlbiBrZXkuXG4gICAgICovXG4gICAgZGVsZXRlKGNyZWF0ZWRBdCwgZXhlY3V0ZWRBdCkge1xuICAgICAgICBpZiAoIXRoaXMubm9kZU1hcEJ5Q3JlYXRlZEF0LmhhcyhjcmVhdGVkQXQudG9JRFN0cmluZygpKSkge1xuICAgICAgICAgICAgbG9nZ2VyLmZhdGFsKGBmYWlsIHRvIGZpbmQgJHtjcmVhdGVkQXQudG9JRFN0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGVNYXBCeUNyZWF0ZWRBdC5nZXQoY3JlYXRlZEF0LnRvSURTdHJpbmcoKSk7XG4gICAgICAgIG5vZGUucmVtb3ZlKGV4ZWN1dGVkQXQpO1xuICAgICAgICByZXR1cm4gbm9kZS5nZXRWYWx1ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgc3ViUGF0aE9mYCByZXR1cm5zIHRoZSBzdWIgcGF0aCBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKi9cbiAgICBzdWJQYXRoT2YoY3JlYXRlZEF0KSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGVNYXBCeUNyZWF0ZWRBdC5nZXQoY3JlYXRlZEF0LnRvSURTdHJpbmcoKSk7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLmdldFN0cktleSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgcHVyZ2VgIHBoeXNpY2FsbHkgcHVyZ2UgY2hpbGQgZWxlbWVudC5cbiAgICAgKi9cbiAgICBwdXJnZShlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGVNYXBCeUNyZWF0ZWRBdC5nZXQoZWxlbWVudC5nZXRDcmVhdGVkQXQoKS50b0lEU3RyaW5nKCkpO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci5mYXRhbChgZmFpbCB0byBmaW5kICR7ZWxlbWVudC5nZXRDcmVhdGVkQXQoKS50b0lEU3RyaW5nKCl9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZUJ5S2V5ID0gdGhpcy5ub2RlTWFwQnlLZXkuZ2V0KG5vZGUuZ2V0U3RyS2V5KCkpO1xuICAgICAgICBpZiAobm9kZSA9PT0gbm9kZUJ5S2V5KSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVNYXBCeUtleS5kZWxldGUobm9kZUJ5S2V5LmdldFN0cktleSgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGVNYXBCeUNyZWF0ZWRBdC5kZWxldGUobm9kZS5nZXRWYWx1ZSgpLmdldENyZWF0ZWRBdCgpLnRvSURTdHJpbmcoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBkZWxldGVCeUtleWAgZGVsZXRlcyB0aGUgRWxlbWVudCBvZiB0aGUgZ2l2ZW4ga2V5IGFuZCByZW1vdmVkIHRpbWUuXG4gICAgICovXG4gICAgZGVsZXRlQnlLZXkoa2V5LCByZW1vdmVkQXQpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZU1hcEJ5S2V5LmdldChrZXkpO1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlLnJlbW92ZShyZW1vdmVkQXQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUuZ2V0VmFsdWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGhhc2AgcmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGV4aXN0cyBvZiB0aGUgZ2l2ZW4ga2V5IG9yIG5vdC5cbiAgICAgKi9cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGVNYXBCeUtleS5nZXQoa2V5KTtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhbm9kZS5pc1JlbW92ZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldEJ5SURgIHJldHVybnMgdGhlIG5vZGUgb2YgdGhlIGdpdmVuIGNyZWF0ZWRBdC5cbiAgICAgKi9cbiAgICBnZXRCeUlEKGNyZWF0ZWRBdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlTWFwQnlDcmVhdGVkQXQuZ2V0KGNyZWF0ZWRBdC50b0lEU3RyaW5nKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0YCByZXR1cm5zIHRoZSBub2RlIG9mIHRoZSBnaXZlbiBrZXkuXG4gICAgICovXG4gICAgZ2V0KGtleSkge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5ub2RlTWFwQnlLZXkuZ2V0KGtleSk7XG4gICAgICAgIGlmICghbm9kZSB8fCBub2RlLmlzUmVtb3ZlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBmb3IgKGNvbnN0IFssIG5vZGVdIG9mIHRoaXMubm9kZU1hcEJ5S2V5KSB7XG4gICAgICAgICAgICB5aWVsZCBub2RlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZG9jdW1lbnQvY3JkdC9vYmplY3QudHNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMyBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuXG4vKipcbiAqIGBDUkRUT2JqZWN0YCByZXByZXNlbnRzIGFuIG9iamVjdCBkYXRhIHR5cGUsIGJ1dCB1bmxpa2UgcmVndWxhciBKU09OLFxuICogaXQgaGFzIGBUaW1lVGlja2V0YHMgd2hpY2ggYXJlIGNyZWF0ZWQgYnkgbG9naWNhbCBjbG9jay5cbiAqXG4gKi9cbmNsYXNzIENSRFRPYmplY3QgZXh0ZW5kcyBDUkRUQ29udGFpbmVyIHtcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xuICAgIGNvbnN0cnVjdG9yKGNyZWF0ZWRBdCwgbWVtYmVyTm9kZXMpIHtcbiAgICAgICAgc3VwZXIoY3JlYXRlZEF0KTtcbiAgICAgICAgdGhpcy5tZW1iZXJOb2RlcyA9IG1lbWJlck5vZGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgY3JlYXRlYCBjcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIENSRFRPYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShjcmVhdGVkQXQsIHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ1JEVE9iamVjdChjcmVhdGVkQXQsIEVsZW1lbnRSSFQuY3JlYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lbWJlck5vZGVzID0gRWxlbWVudFJIVC5jcmVhdGUoKTtcbiAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICBtZW1iZXJOb2Rlcy5zZXQoaywgdi5kZWVwY29weSgpLCB2LmdldENyZWF0ZWRBdCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENSRFRPYmplY3QoY3JlYXRlZEF0LCBtZW1iZXJOb2Rlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBzdWJQYXRoT2ZgIHJldHVybnMgdGhlIHN1YiBwYXRoIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqL1xuICAgIHN1YlBhdGhPZihjcmVhdGVkQXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVtYmVyTm9kZXMuc3ViUGF0aE9mKGNyZWF0ZWRBdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBwdXJnZWAgcGh5c2ljYWxseSBwdXJnZXMgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICovXG4gICAgcHVyZ2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJOb2Rlcy5wdXJnZSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBzZXRgIHNldHMgdGhlIGdpdmVuIGVsZW1lbnQgb2YgdGhlIGdpdmVuIGtleS5cbiAgICAgKi9cbiAgICBzZXQoa2V5LCB2YWx1ZSwgZXhlY3V0ZWRBdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZW1iZXJOb2Rlcy5zZXQoa2V5LCB2YWx1ZSwgZXhlY3V0ZWRBdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBkZWxldGVgIGRlbGV0ZXMgdGhlIGVsZW1lbnQgb2YgdGhlIGdpdmVuIGtleS5cbiAgICAgKi9cbiAgICBkZWxldGUoY3JlYXRlZEF0LCBleGVjdXRlZEF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lbWJlck5vZGVzLmRlbGV0ZShjcmVhdGVkQXQsIGV4ZWN1dGVkQXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZGVsZXRlQnlLZXlgIGRlbGV0ZXMgdGhlIGVsZW1lbnQgb2YgdGhlIGdpdmVuIGtleSBhbmQgZXhlY3V0aW9uIHRpbWUuXG4gICAgICovXG4gICAgZGVsZXRlQnlLZXkoa2V5LCBleGVjdXRlZEF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lbWJlck5vZGVzLmRlbGV0ZUJ5S2V5KGtleSwgZXhlY3V0ZWRBdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRgIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBrZXkuXG4gICAgICovXG4gICAgZ2V0KGtleSkge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5tZW1iZXJOb2Rlcy5nZXQoa2V5KTtcbiAgICAgICAgcmV0dXJuIG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5nZXRWYWx1ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0QnlJRGAgcmV0dXJucyB0aGUgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gY3JlYXRlQXQuXG4gICAgICovXG4gICAgZ2V0QnlJRChjcmVhdGVkQXQpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubWVtYmVyTm9kZXMuZ2V0QnlJRChjcmVhdGVkQXQpO1xuICAgICAgICByZXR1cm4gbm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLmdldFZhbHVlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBoYXNgIHJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBleGlzdHMgb2YgdGhlIGdpdmVuIGtleSBvciBub3QuXG4gICAgICovXG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZW1iZXJOb2Rlcy5oYXMoa2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRvSlNPTmAgcmV0dXJucyB0aGUgSlNPTiBlbmNvZGluZyBvZiB0aGlzIG9iamVjdC5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IGpzb24gPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcykge1xuICAgICAgICAgICAganNvbi5wdXNoKGBcIiR7ZXNjYXBlU3RyaW5nKGtleSl9XCI6JHt2YWx1ZS50b0pTT04oKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYHske2pzb24uam9pbignLCcpfX1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdG9KU2AgcmV0dXJucyB0aGUgSmF2YVNjcmlwdCBvYmplY3Qgb2YgdGhpcyBvYmplY3QuXG4gICAgICovXG4gICAgdG9KUygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy50b0pTT04oKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0b0pTRm9yVGVzdGAgcmV0dXJucyB2YWx1ZSB3aXRoIG1ldGEgZGF0YSBmb3IgdGVzdGluZy5cbiAgICAgKi9cbiAgICB0b0pTRm9yVGVzdCgpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgZWxlbV0gb2YgdGhpcykge1xuICAgICAgICAgICAgY29uc3QgeyBpZCwgdmFsdWUsIHR5cGUgfSA9IGVsZW0udG9KU0ZvclRlc3QoKTtcbiAgICAgICAgICAgIHZhbHVlc1trZXldID0ge1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHRoaXMuZ2V0Q3JlYXRlZEF0KCkudG9UZXN0U3RyaW5nKCksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVzLFxuICAgICAgICAgICAgdHlwZTogJ1lPUktJRV9PQkpFQ1QnLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0S2V5c2AgcmV0dXJucyBhcnJheSBvZiBrZXlzIGluIHRoaXMgb2JqZWN0LlxuICAgICAqL1xuICAgIGdldEtleXMoKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBBcnJheSgpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXldIG9mIHRoaXMpIHtcbiAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdG9Tb3J0ZWRKU09OYCByZXR1cm5zIHRoZSBzb3J0ZWQgSlNPTiBlbmNvZGluZyBvZiB0aGlzIG9iamVjdC5cbiAgICAgKi9cbiAgICB0b1NvcnRlZEpTT04oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qga2V5cyA9IEFycmF5KCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleV0gb2YgdGhpcykge1xuICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QganNvbiA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzLnNvcnQoKSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IChfYSA9IHRoaXMubWVtYmVyTm9kZXMuZ2V0KGtleSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAganNvbi5wdXNoKGBcIiR7ZXNjYXBlU3RyaW5nKGtleSl9XCI6JHtub2RlLnRvU29ydGVkSlNPTigpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgeyR7anNvbi5qb2luKCcsJyl9fWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRSSFRgIFJIVE5vZGVzIHJldHVybnMgdGhlIFJIVFBRTWFwIG5vZGVzLlxuICAgICAqL1xuICAgIGdldFJIVCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVtYmVyTm9kZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBkZWVwY29weWAgY29waWVzIGl0c2VsZiBkZWVwbHkuXG4gICAgICovXG4gICAgZGVlcGNvcHkoKSB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gQ1JEVE9iamVjdC5jcmVhdGUodGhpcy5nZXRDcmVhdGVkQXQoKSk7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLm1lbWJlck5vZGVzKSB7XG4gICAgICAgICAgICBjbG9uZS5tZW1iZXJOb2Rlcy5zZXQobm9kZS5nZXRTdHJLZXkoKSwgbm9kZS5nZXRWYWx1ZSgpLmRlZXBjb3B5KCksIHRoaXMuZ2V0UG9zaXRpb25lZEF0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGNsb25lLnJlbW92ZSh0aGlzLmdldFJlbW92ZWRBdCgpKTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0RGVzY2VuZGFudHNgIHJldHVybnMgdGhlIGRlc2NlbmRhbnRzIG9mIHRoaXMgb2JqZWN0IGJ5IHRyYXZlcnNpbmcuXG4gICAgICovXG4gICAgZ2V0RGVzY2VuZGFudHMoY2FsbGJhY2spIHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMubWVtYmVyTm9kZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBub2RlLmdldFZhbHVlKCk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2soZWxlbWVudCwgdGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIENSRFRDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmdldERlc2NlbmRhbnRzKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgY29uc3Qga2V5U2V0ID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5tZW1iZXJOb2Rlcykge1xuICAgICAgICAgICAgaWYgKCFrZXlTZXQuaGFzKG5vZGUuZ2V0U3RyS2V5KCkpKSB7XG4gICAgICAgICAgICAgICAga2V5U2V0LmFkZChub2RlLmdldFN0cktleSgpKTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUuaXNSZW1vdmVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW25vZGUuZ2V0U3RyS2V5KCksIG5vZGUuZ2V0VmFsdWUoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZG9jdW1lbnQvb3BlcmF0aW9uL29wZXJhdGlvbi50c1xuLypcbiAqIENvcHlyaWdodCAyMDIwIFRoZSBZb3JraWUgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogYE9wU291cmNlYCByZXByZXNlbnRzIHRoZSBzb3VyY2Ugb2YgdGhlIG9wZXJhdGlvbi4gSXQgaXMgdXNlZCB0byBoYW5kbGVcbiAqIGNvcm5lciBjYXNlcyBpbiB0aGUgb3BlcmF0aW9ucyBjcmVhdGVkIGJ5IHVuZG8vcmVkbyBhbGxvdyB0aGUgcmVtb3ZlZFxuICogZWxlbWVudHMgd2hlbiBleGVjdXRpbmcgdGhlbS5cbiAqL1xudmFyIE9wU291cmNlO1xuKGZ1bmN0aW9uIChPcFNvdXJjZSkge1xuICAgIE9wU291cmNlW1wiTG9jYWxcIl0gPSBcImxvY2FsXCI7XG4gICAgT3BTb3VyY2VbXCJSZW1vdGVcIl0gPSBcInJlbW90ZVwiO1xuICAgIE9wU291cmNlW1wiVW5kb1JlZG9cIl0gPSBcInVuZG9yZWRvXCI7XG59KShPcFNvdXJjZSB8fCAoT3BTb3VyY2UgPSB7fSkpO1xuLyoqXG4gKiBgT3BlcmF0aW9uYCByZXByZXNlbnRzIGFuIG9wZXJhdGlvbiB0byBiZSBleGVjdXRlZCBvbiBhIGRvY3VtZW50LlxuICovXG5jbGFzcyBPcGVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudENyZWF0ZWRBdCwgZXhlY3V0ZWRBdCkge1xuICAgICAgICB0aGlzLnBhcmVudENyZWF0ZWRBdCA9IHBhcmVudENyZWF0ZWRBdDtcbiAgICAgICAgdGhpcy5leGVjdXRlZEF0ID0gZXhlY3V0ZWRBdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldFBhcmVudENyZWF0ZWRBdGAgcmV0dXJucyB0aGUgY3JlYXRpb24gdGltZSBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQgdG9cbiAgICAgKiBleGVjdXRlIHRoZSBvcGVyYXRpb24uXG4gICAgICovXG4gICAgZ2V0UGFyZW50Q3JlYXRlZEF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRDcmVhdGVkQXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRFeGVjdXRlZEF0YCByZXR1cm5zIGV4ZWN1dGlvbiB0aW1lIG9mIHRoaXMgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGdldEV4ZWN1dGVkQXQoKSB7XG4gICAgICAgIC8vIE5PVEUoY2hhY2hhOTEyKTogV2hlbiBhbiBvcGVyYXRpb24gaXMgaW4gdGhlIHVuZG8vcmVkbyBzdGFjayxcbiAgICAgICAgLy8gaXQgZG9lc24ndCBoYXZlIGFuIGV4ZWN1dGVkQXQgeWV0LiBUaGUgZXhlY3V0ZWRBdCBpcyBzZXQgd2hlblxuICAgICAgICAvLyB0aGUgb3BlcmF0aW9uIGlzIGV4ZWN1dGVkIHRocm91Z2ggdW5kbyBvciByZWRvLlxuICAgICAgICBpZiAoIXRoaXMuZXhlY3V0ZWRBdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleGVjdXRlZEF0IGhhcyBub3QgYmVlbiBzZXQgeWV0YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZWRBdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHNldEFjdG9yYCBzZXRzIHRoZSBnaXZlbiBhY3RvciB0byB0aGlzIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBzZXRBY3RvcihhY3RvcklEKSB7XG4gICAgICAgIGlmICh0aGlzLmV4ZWN1dGVkQXQpIHtcbiAgICAgICAgICAgIHRoaXMuZXhlY3V0ZWRBdCA9IHRoaXMuZXhlY3V0ZWRBdC5zZXRBY3RvcihhY3RvcklEKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBgc2V0RXhlY3V0ZWRBdGAgc2V0cyB0aGUgZXhlY3V0ZWRBdC5cbiAgICAgKi9cbiAgICBzZXRFeGVjdXRlZEF0KGV4ZWN1dGVkQXQpIHtcbiAgICAgICAgdGhpcy5leGVjdXRlZEF0ID0gZXhlY3V0ZWRBdDtcbiAgICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL3NwbGF5X3RyZWUudHNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogYFNwbGF5Tm9kZWAgaXMgYSBub2RlIG9mIFNwbGF5VHJlZS5cbiAqL1xuY2xhc3MgU3BsYXlOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaW5pdFdlaWdodCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0Tm9kZVN0cmluZ2AgcmV0dXJucyBhIHN0cmluZyBvZiB3ZWlnaHQgYW5kIHZhbHVlIG9mIHRoaXMgbm9kZS5cbiAgICAgKi9cbiAgICBnZXROb2RlU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy53ZWlnaHR9JHt0aGlzLnZhbHVlfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRWYWx1ZWAgcmV0dXJucyB2YWx1ZSBvZiB0aGlzIG5vZGUuXG4gICAgICovXG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0TGVmdFdlaWdodGAgcmV0dXJucyBsZWZ0IHdlaWdodCBvZiB0aGlzIG5vZGUuXG4gICAgICovXG4gICAgZ2V0TGVmdFdlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmhhc0xlZnQoKSA/IDAgOiB0aGlzLmxlZnQuZ2V0V2VpZ2h0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRSaWdodFdlaWdodGAgcmV0dXJucyByaWdodCB3ZWlnaHQgb2YgdGhpcyBub2RlLlxuICAgICAqL1xuICAgIGdldFJpZ2h0V2VpZ2h0KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaGFzUmlnaHQoKSA/IDAgOiB0aGlzLnJpZ2h0LmdldFdlaWdodCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0V2VpZ2h0YCByZXR1cm5zIHdlaWdodCBvZiB0aGlzIG5vZGUuXG4gICAgICovXG4gICAgZ2V0V2VpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy53ZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRMZWZ0YCByZXR1cm5zIGEgbGVmdCBub2RlLlxuICAgICAqL1xuICAgIGdldExlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRSaWdodGAgcmV0dXJucyBhIHJpZ2h0IG5vZGUuXG4gICAgICovXG4gICAgZ2V0UmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0UGFyZW50YCByZXR1cm5zIHBhcmVudCBvZiB0aGlzIG5vZGUuXG4gICAgICovXG4gICAgZ2V0UGFyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBoYXNMZWZ0YCBjaGVjayBpZiB0aGUgbGVmdCBub2RlIGV4aXN0c1xuICAgICAqL1xuICAgIGhhc0xlZnQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMubGVmdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGhhc1JpZ2h0YCBjaGVjayBpZiB0aGUgcmlnaHQgbm9kZSBleGlzdHNcbiAgICAgKi9cbiAgICBoYXNSaWdodCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5yaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGhhc1BhcmVudGAgY2hlY2sgaWYgdGhlIHBhcmVudCBub2RlIGV4aXN0c1xuICAgICAqL1xuICAgIGhhc1BhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5wYXJlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBzZXRMZWZ0YCBzZXRzIGEgbGVmdCBub2RlLlxuICAgICAqL1xuICAgIHNldExlZnQobGVmdCkge1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgc2V0UmlnaHRgIHNldHMgYSByaWdodCBub2RlLlxuICAgICAqL1xuICAgIHNldFJpZ2h0KHJpZ2h0KSB7XG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHNldFBhcmVudGAgc2V0cyBhIHBhcmVudCBub2RlLlxuICAgICAqL1xuICAgIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB1bmxpbmtgIHVubGluayBwYXJlbnQsIHJpZ2h0IGFuZCBsZWZ0IG5vZGUuXG4gICAgICovXG4gICAgdW5saW5rKCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgaGFzTGlua3NgIGNoZWNrcyBpZiBwYXJlbnQsIHJpZ2h0IGFuZCBsZWZ0IG5vZGUgZXhpc3RzLlxuICAgICAqL1xuICAgIGhhc0xpbmtzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNQYXJlbnQoKSB8fCB0aGlzLmhhc0xlZnQoKSB8fCB0aGlzLmhhc1JpZ2h0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBpbmNyZWFzZVdlaWdodGAgaW5jcmVhc2VzIHdlaWdodC5cbiAgICAgKi9cbiAgICBpbmNyZWFzZVdlaWdodCh3ZWlnaHQpIHtcbiAgICAgICAgdGhpcy53ZWlnaHQgKz0gd2VpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgaW5pdFdlaWdodGAgc2V0cyBpbml0aWFsIHdlaWdodCBvZiB0aGlzIG5vZGUuXG4gICAgICovXG4gICAgaW5pdFdlaWdodCgpIHtcbiAgICAgICAgdGhpcy53ZWlnaHQgPSB0aGlzLmdldExlbmd0aCgpO1xuICAgIH1cbn1cbi8qKlxuICogU3BsYXlUcmVlIGlzIHdlaWdodGVkIGJpbmFyeSBzZWFyY2ggdHJlZSB3aGljaCBpcyBiYXNlZCBvbiBTcGxheSB0cmVlLlxuICogb3JpZ2luYWwgcGFwZXIgb24gU3BsYXkgVHJlZXM6XG4gKiBAc2VlIGh0dHBzOi8vd3d3LmNzLmNtdS5lZHUvfnNsZWF0b3IvcGFwZXJzL3NlbGYtYWRqdXN0aW5nLnBkZlxuICovXG5jbGFzcyBTcGxheVRyZWUge1xuICAgIGNvbnN0cnVjdG9yKHJvb3QpIHtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGxlbmd0aGAgcmV0dXJucyB0aGUgc2l6ZSBvZiB0aGlzIHRyZWUuXG4gICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdCA/IHRoaXMucm9vdC5nZXRXZWlnaHQoKSA6IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBmaW5kYCByZXR1cm5zIHRoZSBOb2RlIGFuZCBvZmZzZXQgb2YgdGhlIGdpdmVuIGluZGV4LlxuICAgICAqL1xuICAgIGZpbmQocG9zKSB7XG4gICAgICAgIGlmICghdGhpcy5yb290IHx8IHBvcyA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCAwXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMucm9vdDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKG5vZGUuaGFzTGVmdCgpICYmIHBvcyA8PSBub2RlLmdldExlZnRXZWlnaHQoKSkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmdldExlZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUuaGFzUmlnaHQoKSAmJlxuICAgICAgICAgICAgICAgIG5vZGUuZ2V0TGVmdFdlaWdodCgpICsgbm9kZS5nZXRMZW5ndGgoKSA8IHBvcykge1xuICAgICAgICAgICAgICAgIHBvcyAtPSBub2RlLmdldExlZnRXZWlnaHQoKSArIG5vZGUuZ2V0TGVuZ3RoKCk7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuZ2V0UmlnaHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvcyAtPSBub2RlLmdldExlZnRXZWlnaHQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID4gbm9kZS5nZXRMZW5ndGgoKSkge1xuICAgICAgICAgICAgbG9nZ2VyLmZhdGFsKGBvdXQgb2YgaW5kZXggcmFuZ2U6IHBvczogJHtwb3N9ID4gbm9kZS5sZW5ndGg6ICR7bm9kZS5nZXRMZW5ndGgoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW25vZGUsIHBvc107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBub2RlIGluIEJTVC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlIC0gdGhlIGdpdmVuIG5vZGVcbiAgICAgKiBAcmV0dXJucyB0aGUgaW5kZXggb2YgZ2l2ZW4gbm9kZVxuICAgICAqL1xuICAgIGluZGV4T2Yobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUgfHwgKG5vZGUgIT09IHRoaXMucm9vdCAmJiAhbm9kZS5oYXNMaW5rcygpKSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50ID0gbm9kZTtcbiAgICAgICAgbGV0IHByZXY7XG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICBpZiAoIXByZXYgfHwgcHJldiA9PT0gY3VycmVudC5nZXRSaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggKz1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5nZXRMZW5ndGgoKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoY3VycmVudC5oYXNMZWZ0KCkgPyBjdXJyZW50LmdldExlZnRXZWlnaHQoKSA6IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5nZXRQYXJlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXggLSBub2RlLmdldExlbmd0aCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0Um9vdGAgcmV0dXJucyByb290IG9mIHRoaXMgdHJlZS5cbiAgICAgKi9cbiAgICBnZXRSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgaW5zZXJ0YCBpbnNlcnRzIHRoZSBub2RlIGF0IHRoZSBsYXN0LlxuICAgICAqL1xuICAgIGluc2VydChuZXdOb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydEFmdGVyKHRoaXMucm9vdCwgbmV3Tm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBpbnNlcnRBZnRlcmAgaW5zZXJ0cyB0aGUgbm9kZSBhZnRlciB0aGUgZ2l2ZW4gcHJldmlvdXMgbm9kZS5cbiAgICAgKi9cbiAgICBpbnNlcnRBZnRlcih0YXJnZXQsIG5ld05vZGUpIHtcbiAgICAgICAgLy8gVE9ETyhFaXRoZWEpOiBDb25zaWRlciBtb3ZpbmcgdGhlIGNvZGUgYmVsb3cgdG8gaW5zZXJ0KClcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IG5ld05vZGU7XG4gICAgICAgICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNwbGF5Tm9kZSh0YXJnZXQpO1xuICAgICAgICB0aGlzLnJvb3QgPSBuZXdOb2RlO1xuICAgICAgICBuZXdOb2RlLnNldFJpZ2h0KHRhcmdldC5nZXRSaWdodCgpKTtcbiAgICAgICAgaWYgKHRhcmdldC5oYXNSaWdodCgpKSB7XG4gICAgICAgICAgICB0YXJnZXQuZ2V0UmlnaHQoKS5zZXRQYXJlbnQobmV3Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3Tm9kZS5zZXRMZWZ0KHRhcmdldCk7XG4gICAgICAgIHRhcmdldC5zZXRQYXJlbnQobmV3Tm9kZSk7XG4gICAgICAgIHRhcmdldC5zZXRSaWdodCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVdlaWdodCh0YXJnZXQpO1xuICAgICAgICB0aGlzLnVwZGF0ZVdlaWdodChuZXdOb2RlKTtcbiAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB1cGRhdGVXZWlnaHRgIHJlY2FsY3VsYXRlcyB0aGUgd2VpZ2h0IG9mIHRoaXMgbm9kZSB3aXRoIHRoZSB2YWx1ZSBhbmQgY2hpbGRyZW4uXG4gICAgICovXG4gICAgdXBkYXRlV2VpZ2h0KG5vZGUpIHtcbiAgICAgICAgbm9kZS5pbml0V2VpZ2h0KCk7XG4gICAgICAgIGlmIChub2RlLmhhc0xlZnQoKSkge1xuICAgICAgICAgICAgbm9kZS5pbmNyZWFzZVdlaWdodChub2RlLmdldExlZnRXZWlnaHQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuaGFzUmlnaHQoKSkge1xuICAgICAgICAgICAgbm9kZS5pbmNyZWFzZVdlaWdodChub2RlLmdldFJpZ2h0V2VpZ2h0KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVRyZWVXZWlnaHQobm9kZSkge1xuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVXZWlnaHQobm9kZSk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBgc3BsYXlOb2RlYCBtb3ZlcyB0aGUgZ2l2ZW4gbm9kZSB0byB0aGUgcm9vdC5cbiAgICAgKi9cbiAgICBzcGxheU5vZGUobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0xlZnRDaGlsZChub2RlLmdldFBhcmVudCgpKSAmJiB0aGlzLmlzUmlnaHRDaGlsZChub2RlKSkge1xuICAgICAgICAgICAgICAgIC8vIHppZy16YWdcbiAgICAgICAgICAgICAgICB0aGlzLnJvdGF0ZUxlZnQobm9kZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3RhdGVSaWdodChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNSaWdodENoaWxkKG5vZGUuZ2V0UGFyZW50KCkpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5pc0xlZnRDaGlsZChub2RlKSkge1xuICAgICAgICAgICAgICAgIC8vIHppZy16YWdcbiAgICAgICAgICAgICAgICB0aGlzLnJvdGF0ZVJpZ2h0KG5vZGUpO1xuICAgICAgICAgICAgICAgIHRoaXMucm90YXRlTGVmdChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNMZWZ0Q2hpbGQobm9kZS5nZXRQYXJlbnQoKSkgJiYgdGhpcy5pc0xlZnRDaGlsZChub2RlKSkge1xuICAgICAgICAgICAgICAgIC8vIHppZy16aWdcbiAgICAgICAgICAgICAgICB0aGlzLnJvdGF0ZVJpZ2h0KG5vZGUuZ2V0UGFyZW50KCkpO1xuICAgICAgICAgICAgICAgIHRoaXMucm90YXRlUmlnaHQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzUmlnaHRDaGlsZChub2RlLmdldFBhcmVudCgpKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuaXNSaWdodENoaWxkKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gemlnLXppZ1xuICAgICAgICAgICAgICAgIHRoaXMucm90YXRlTGVmdChub2RlLmdldFBhcmVudCgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJvdGF0ZUxlZnQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB6aWdcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0xlZnRDaGlsZChub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvdGF0ZVJpZ2h0KG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzUmlnaHRDaGlsZChub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvdGF0ZUxlZnQobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlV2VpZ2h0KG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZGVsZXRlYCBkZWxldGVzIHRhcmdldCBub2RlIG9mIHRoaXMgdHJlZS5cbiAgICAgKi9cbiAgICBkZWxldGUobm9kZSkge1xuICAgICAgICB0aGlzLnNwbGF5Tm9kZShub2RlKTtcbiAgICAgICAgY29uc3QgbGVmdFRyZWUgPSBuZXcgU3BsYXlUcmVlKG5vZGUuZ2V0TGVmdCgpKTtcbiAgICAgICAgaWYgKGxlZnRUcmVlLnJvb3QpIHtcbiAgICAgICAgICAgIGxlZnRUcmVlLnJvb3Quc2V0UGFyZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmlnaHRUcmVlID0gbmV3IFNwbGF5VHJlZShub2RlLmdldFJpZ2h0KCkpO1xuICAgICAgICBpZiAocmlnaHRUcmVlLnJvb3QpIHtcbiAgICAgICAgICAgIHJpZ2h0VHJlZS5yb290LnNldFBhcmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0VHJlZS5yb290KSB7XG4gICAgICAgICAgICBjb25zdCByaWdodG1vc3ROb2RlID0gbGVmdFRyZWUuZ2V0UmlnaHRtb3N0KCk7XG4gICAgICAgICAgICBsZWZ0VHJlZS5zcGxheU5vZGUocmlnaHRtb3N0Tm9kZSk7XG4gICAgICAgICAgICBsZWZ0VHJlZS5yb290LnNldFJpZ2h0KHJpZ2h0VHJlZS5yb290KTtcbiAgICAgICAgICAgIGlmIChyaWdodFRyZWUucm9vdCkge1xuICAgICAgICAgICAgICAgIHJpZ2h0VHJlZS5yb290LnNldFBhcmVudChsZWZ0VHJlZS5yb290KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucm9vdCA9IGxlZnRUcmVlLnJvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QgPSByaWdodFRyZWUucm9vdDtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnVubGluaygpO1xuICAgICAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVdlaWdodCh0aGlzLnJvb3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBkZWxldGVSYW5nZWAgc2VwYXJhdGVzIHRoZSByYW5nZSBiZXR3ZWVuIGdpdmVuIDIgYm91bmRhcmllcyBmcm9tIHRoaXMgVHJlZS5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNlcGFyYXRlcyB0aGUgcmFuZ2UgdG8gZGVsZXRlIGFzIGEgc3VidHJlZVxuICAgICAqIGJ5IHNwbGF5aW5nIG91dGVyIGJvdW5kYXJ5IG5vZGVzLlxuICAgICAqIGxlZnRCb3VuZGFyeSBtdXN0IGV4aXN0IGJlY2F1c2Ugb2YgMC1pbmRleGVkIGluaXRpYWwgZHVtbXkgbm9kZSBvZiB0cmVlLFxuICAgICAqIGJ1dCByaWdodEJvdW5kYXJ5IGNhbiBiZSBuaWwgbWVhbnMgcmFuZ2UgdG8gZGVsZXRlIGluY2x1ZGVzIHRoZSBlbmQgb2YgdHJlZS5cbiAgICAgKiBSZWZlciB0byB0aGUgZGVzaWduIGRvY3VtZW50IGluIGh0dHBzOi8vZ2l0aHViLmNvbS95b3JraWUtdGVhbS95b3JraWUvdHJlZS9tYWluL2Rlc2lnblxuICAgICAqL1xuICAgIGRlbGV0ZVJhbmdlKGxlZnRCb3VuZGFyeSwgcmlnaHRCb3VuZGFyeSkge1xuICAgICAgICBpZiAoIXJpZ2h0Qm91bmRhcnkpIHtcbiAgICAgICAgICAgIHRoaXMuc3BsYXlOb2RlKGxlZnRCb3VuZGFyeSk7XG4gICAgICAgICAgICB0aGlzLmN1dE9mZlJpZ2h0KGxlZnRCb3VuZGFyeSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zcGxheU5vZGUobGVmdEJvdW5kYXJ5KTtcbiAgICAgICAgdGhpcy5zcGxheU5vZGUocmlnaHRCb3VuZGFyeSk7XG4gICAgICAgIGlmIChyaWdodEJvdW5kYXJ5LmdldExlZnQoKSAhPSBsZWZ0Qm91bmRhcnkpIHtcbiAgICAgICAgICAgIHRoaXMucm90YXRlUmlnaHQobGVmdEJvdW5kYXJ5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1dE9mZlJpZ2h0KGxlZnRCb3VuZGFyeSk7XG4gICAgfVxuICAgIGN1dE9mZlJpZ2h0KHJvb3QpIHtcbiAgICAgICAgY29uc3Qgbm9kZXNUb0ZyZWVXZWlnaHQgPSBbXTtcbiAgICAgICAgdGhpcy50cmF2ZXJzZVBvc3RvcmRlcihyb290LmdldFJpZ2h0KCksIG5vZGVzVG9GcmVlV2VpZ2h0KTtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzVG9GcmVlV2VpZ2h0KSB7XG4gICAgICAgICAgICBub2RlLmluaXRXZWlnaHQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVRyZWVXZWlnaHQocm9vdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0b1Rlc3RTdHJpbmdgIHJldHVybnMgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgbWV0YSBkYXRhIG9mIHRoZSBOb2RlXG4gICAgICogZm9yIGRlYnVnZ2luZyBwdXJwb3NlLlxuICAgICAqL1xuICAgIHRvVGVzdFN0cmluZygpIHtcbiAgICAgICAgY29uc3QgbWV0YVN0cmluZyA9IFtdO1xuICAgICAgICB0aGlzLnRyYXZlcnNlSW5vcmRlcih0aGlzLnJvb3QsIG1ldGFTdHJpbmcpO1xuICAgICAgICByZXR1cm4gbWV0YVN0cmluZ1xuICAgICAgICAgICAgLm1hcCgobikgPT4gYFske24uZ2V0V2VpZ2h0KCl9LCR7bi5nZXRMZW5ndGgoKX1dJHtuLmdldFZhbHVlKCkgfHwgJyd9YClcbiAgICAgICAgICAgIC5qb2luKCcnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGNoZWNrV2VpZ2h0YCByZXR1cm5zIGZhbHNlIHdoZW4gdGhlcmUgaXMgYW4gaW5jb3JyZWN0IHdlaWdodCBub2RlLlxuICAgICAqIGZvciBkZWJ1Z2dpbmcgcHVycG9zZS5cbiAgICAgKi9cbiAgICBjaGVja1dlaWdodCgpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy50cmF2ZXJzZUlub3JkZXIodGhpcy5yb290LCBub2Rlcyk7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICAgICAgaWYgKG5vZGUuZ2V0V2VpZ2h0KCkgIT1cbiAgICAgICAgICAgICAgICBub2RlLmdldExlbmd0aCgpICsgbm9kZS5nZXRMZWZ0V2VpZ2h0KCkgKyBub2RlLmdldFJpZ2h0V2VpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldFJpZ2h0bW9zdCgpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnJvb3Q7XG4gICAgICAgIHdoaWxlIChub2RlLmhhc1JpZ2h0KCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmdldFJpZ2h0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHRyYXZlcnNlSW5vcmRlcihub2RlLCBzdGFjaykge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYXZlcnNlSW5vcmRlcihub2RlLmdldExlZnQoKSwgc3RhY2spO1xuICAgICAgICBzdGFjay5wdXNoKG5vZGUpO1xuICAgICAgICB0aGlzLnRyYXZlcnNlSW5vcmRlcihub2RlLmdldFJpZ2h0KCksIHN0YWNrKTtcbiAgICB9XG4gICAgdHJhdmVyc2VQb3N0b3JkZXIobm9kZSwgc3RhY2spIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmF2ZXJzZVBvc3RvcmRlcihub2RlLmdldExlZnQoKSwgc3RhY2spO1xuICAgICAgICB0aGlzLnRyYXZlcnNlUG9zdG9yZGVyKG5vZGUuZ2V0UmlnaHQoKSwgc3RhY2spO1xuICAgICAgICBzdGFjay5wdXNoKG5vZGUpO1xuICAgIH1cbiAgICByb3RhdGVMZWZ0KHBpdm90KSB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSBwaXZvdC5nZXRQYXJlbnQoKTtcbiAgICAgICAgaWYgKHJvb3QuaGFzUGFyZW50KCkpIHtcbiAgICAgICAgICAgIGlmIChyb290ID09PSByb290LmdldFBhcmVudCgpLmdldExlZnQoKSkge1xuICAgICAgICAgICAgICAgIHJvb3QuZ2V0UGFyZW50KCkuc2V0TGVmdChwaXZvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByb290LmdldFBhcmVudCgpLnNldFJpZ2h0KHBpdm90KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IHBpdm90O1xuICAgICAgICB9XG4gICAgICAgIHBpdm90LnNldFBhcmVudChyb290LmdldFBhcmVudCgpKTtcbiAgICAgICAgcm9vdC5zZXRSaWdodChwaXZvdC5nZXRMZWZ0KCkpO1xuICAgICAgICBpZiAocm9vdC5oYXNSaWdodCgpKSB7XG4gICAgICAgICAgICByb290LmdldFJpZ2h0KCkuc2V0UGFyZW50KHJvb3QpO1xuICAgICAgICB9XG4gICAgICAgIHBpdm90LnNldExlZnQocm9vdCk7XG4gICAgICAgIHBpdm90LmdldExlZnQoKS5zZXRQYXJlbnQocGl2b3QpO1xuICAgICAgICB0aGlzLnVwZGF0ZVdlaWdodChyb290KTtcbiAgICAgICAgdGhpcy51cGRhdGVXZWlnaHQocGl2b3QpO1xuICAgIH1cbiAgICByb3RhdGVSaWdodChwaXZvdCkge1xuICAgICAgICBjb25zdCByb290ID0gcGl2b3QuZ2V0UGFyZW50KCk7XG4gICAgICAgIGlmIChyb290Lmhhc1BhcmVudCgpKSB7XG4gICAgICAgICAgICBpZiAocm9vdCA9PT0gcm9vdC5nZXRQYXJlbnQoKS5nZXRMZWZ0KCkpIHtcbiAgICAgICAgICAgICAgICByb290LmdldFBhcmVudCgpLnNldExlZnQocGl2b3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcm9vdC5nZXRQYXJlbnQoKS5zZXRSaWdodChwaXZvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBwaXZvdDtcbiAgICAgICAgfVxuICAgICAgICBwaXZvdC5zZXRQYXJlbnQocm9vdC5nZXRQYXJlbnQoKSk7XG4gICAgICAgIHJvb3Quc2V0TGVmdChwaXZvdC5nZXRSaWdodCgpKTtcbiAgICAgICAgaWYgKHJvb3QuaGFzTGVmdCgpKSB7XG4gICAgICAgICAgICByb290LmdldExlZnQoKS5zZXRQYXJlbnQocm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgcGl2b3Quc2V0UmlnaHQocm9vdCk7XG4gICAgICAgIHBpdm90LmdldFJpZ2h0KCkuc2V0UGFyZW50KHBpdm90KTtcbiAgICAgICAgdGhpcy51cGRhdGVXZWlnaHQocm9vdCk7XG4gICAgICAgIHRoaXMudXBkYXRlV2VpZ2h0KHBpdm90KTtcbiAgICB9XG4gICAgaXNMZWZ0Q2hpbGQobm9kZSkge1xuICAgICAgICBpZiAobm9kZSAmJiBub2RlLmhhc1BhcmVudCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRQYXJlbnQoKS5nZXRMZWZ0KCkgPT09IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpc1JpZ2h0Q2hpbGQobm9kZSkge1xuICAgICAgICBpZiAobm9kZSAmJiBub2RlLmhhc1BhcmVudCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRQYXJlbnQoKS5nZXRSaWdodCgpID09PSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kb2N1bWVudC9jcmR0L3ByaW1pdGl2ZS50c1xuLypcbiAqIENvcHlyaWdodCAyMDIwIFRoZSBZb3JraWUgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuXG5cblxudmFyIFByaW1pdGl2ZVR5cGU7XG4oZnVuY3Rpb24gKFByaW1pdGl2ZVR5cGUpIHtcbiAgICBQcmltaXRpdmVUeXBlW1ByaW1pdGl2ZVR5cGVbXCJOdWxsXCJdID0gMF0gPSBcIk51bGxcIjtcbiAgICBQcmltaXRpdmVUeXBlW1ByaW1pdGl2ZVR5cGVbXCJCb29sZWFuXCJdID0gMV0gPSBcIkJvb2xlYW5cIjtcbiAgICBQcmltaXRpdmVUeXBlW1ByaW1pdGl2ZVR5cGVbXCJJbnRlZ2VyXCJdID0gMl0gPSBcIkludGVnZXJcIjtcbiAgICBQcmltaXRpdmVUeXBlW1ByaW1pdGl2ZVR5cGVbXCJMb25nXCJdID0gM10gPSBcIkxvbmdcIjtcbiAgICBQcmltaXRpdmVUeXBlW1ByaW1pdGl2ZVR5cGVbXCJEb3VibGVcIl0gPSA0XSA9IFwiRG91YmxlXCI7XG4gICAgUHJpbWl0aXZlVHlwZVtQcmltaXRpdmVUeXBlW1wiU3RyaW5nXCJdID0gNV0gPSBcIlN0cmluZ1wiO1xuICAgIFByaW1pdGl2ZVR5cGVbUHJpbWl0aXZlVHlwZVtcIkJ5dGVzXCJdID0gNl0gPSBcIkJ5dGVzXCI7XG4gICAgUHJpbWl0aXZlVHlwZVtQcmltaXRpdmVUeXBlW1wiRGF0ZVwiXSA9IDddID0gXCJEYXRlXCI7XG59KShQcmltaXRpdmVUeXBlIHx8IChQcmltaXRpdmVUeXBlID0ge30pKTtcbi8qKlxuICogYFByaW1pdGl2ZWAgcmVwcmVzZW50cyBwcmltaXRpdmUgZGF0YSB0eXBlIGluY2x1ZGluZyBsb2dpY2FsIGNsb2NrLlxuICogSXQgaGFzIGEgdHlwZSBhbmQgYSB2YWx1ZS5cbiAqL1xuY2xhc3MgUHJpbWl0aXZlIGV4dGVuZHMgQ1JEVEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBjcmVhdGVkQXQpIHtcbiAgICAgICAgc3VwZXIoY3JlYXRlZEF0KTtcbiAgICAgICAgdGhpcy52YWx1ZVR5cGUgPSBQcmltaXRpdmUuZ2V0UHJpbWl0aXZlVHlwZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgb2ZgIGNyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUHJpbWl0aXZlLlxuICAgICAqL1xuICAgIHN0YXRpYyBvZih2YWx1ZSwgY3JlYXRlZEF0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJpbWl0aXZlKHZhbHVlLCBjcmVhdGVkQXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdmFsdWVGcm9tQnl0ZXNgIHBhcnNlcyB0aGUgZ2l2ZW4gYnl0ZXMgaW50byB2YWx1ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdmFsdWVGcm9tQnl0ZXMocHJpbWl0aXZlVHlwZSwgYnl0ZXMpIHtcbiAgICAgICAgc3dpdGNoIChwcmltaXRpdmVUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFByaW1pdGl2ZVR5cGUuTnVsbDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNhc2UgUHJpbWl0aXZlVHlwZS5Cb29sZWFuOlxuICAgICAgICAgICAgICAgIHJldHVybiBieXRlc1swXSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgUHJpbWl0aXZlVHlwZS5JbnRlZ2VyOlxuICAgICAgICAgICAgICAgIHJldHVybiBieXRlc1swXSB8IChieXRlc1sxXSA8PCA4KSB8IChieXRlc1syXSA8PCAxNikgfCAoYnl0ZXNbM10gPDwgMjQpO1xuICAgICAgICAgICAgY2FzZSBQcmltaXRpdmVUeXBlLkRvdWJsZToge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnl0ZXMuYnVmZmVyKTtcbiAgICAgICAgICAgICAgICBieXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChiLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuc2V0VWludDgoaSwgYik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZXcuZ2V0RmxvYXQ2NCgwLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgUHJpbWl0aXZlVHlwZS5TdHJpbmc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigndXRmLTgnKS5kZWNvZGUoYnl0ZXMpO1xuICAgICAgICAgICAgY2FzZSBQcmltaXRpdmVUeXBlLkxvbmc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVfbW9kdWxlc19sb25nLmZyb21CeXRlc0xFKEFycmF5LmZyb20oYnl0ZXMpKTtcbiAgICAgICAgICAgIGNhc2UgUHJpbWl0aXZlVHlwZS5CeXRlczpcbiAgICAgICAgICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgICAgICAgICBjYXNlIFByaW1pdGl2ZVR5cGUuRGF0ZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUobm9kZV9tb2R1bGVzX2xvbmcuZnJvbUJ5dGVzTEUoQXJyYXkuZnJvbShieXRlcyksIHRydWUpLnRvTnVtYmVyKCkpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgWW9ya2llRXJyb3IoZXJyb3JfQ29kZS5VbmltcGxlbWVudGVkLCBgdW5pbXBsZW1lbnRlZCB0eXBlOiAke3ByaW1pdGl2ZVR5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRvSlNPTmAgcmV0dXJucyB0aGUgSlNPTiBlbmNvZGluZyBvZiB0aGUgdmFsdWUuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZVR5cGUgPT09IFByaW1pdGl2ZVR5cGUuU3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gYFwiJHtlc2NhcGVTdHJpbmcodGhpcy52YWx1ZSl9XCJgO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8oaGFja2Vyd2lucyk6IFdlIG5lZWQgdG8gY29uc2lkZXIgdGhlIGNhc2Ugd2hlcmUgdGhlIHZhbHVlIGlzXG4gICAgICAgIC8vIGEgYnl0ZSBhcnJheSBhbmQgYSBkYXRlLlxuICAgICAgICByZXR1cm4gYCR7dGhpcy52YWx1ZX1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdG9Tb3J0ZWRKU09OYCByZXR1cm5zIHRoZSBzb3J0ZWQgSlNPTiBlbmNvZGluZyBvZiB0aGUgdmFsdWUuXG4gICAgICovXG4gICAgdG9Tb3J0ZWRKU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0pTT04oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRvSlNGb3JUZXN0YCByZXR1cm5zIHZhbHVlIHdpdGggbWV0YSBkYXRhIGZvciB0ZXN0aW5nLlxuICAgICAqL1xuICAgIHRvSlNGb3JUZXN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHRoaXMuZ2V0Q3JlYXRlZEF0KCkudG9UZXN0U3RyaW5nKCksXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgICAgICAgIHR5cGU6ICdZT1JLSUVfUFJJTUlUSVZFJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGRlZXBjb3B5YCBjb3BpZXMgaXRzZWxmIGRlZXBseS5cbiAgICAgKi9cbiAgICBkZWVwY29weSgpIHtcbiAgICAgICAgY29uc3QgcHJpbWl0aXZlID0gUHJpbWl0aXZlLm9mKHRoaXMudmFsdWUsIHRoaXMuZ2V0Q3JlYXRlZEF0KCkpO1xuICAgICAgICBwcmltaXRpdmUuc2V0TW92ZWRBdCh0aGlzLmdldE1vdmVkQXQoKSk7XG4gICAgICAgIHByaW1pdGl2ZS5zZXRSZW1vdmVkQXQodGhpcy5nZXRSZW1vdmVkQXQoKSk7XG4gICAgICAgIHJldHVybiBwcmltaXRpdmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRUeXBlYCByZXR1cm5zIHRoZSB0eXBlIG9mIHRoZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZVR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRQcmltaXRpdmVUeXBlYCByZXR1cm5zIHRoZSBwcmltaXRpdmUgdHlwZSBvZiB0aGUgdmFsdWUuXG4gICAgICovXG4gICAgc3RhdGljIGdldFByaW1pdGl2ZVR5cGUodmFsdWUpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByaW1pdGl2ZVR5cGUuTnVsbDtcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgIHJldHVybiBQcmltaXRpdmVUeXBlLkJvb2xlYW47XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByaW1pdGl2ZVR5cGUuSW50ZWdlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcmltaXRpdmVUeXBlLkRvdWJsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIHJldHVybiBQcmltaXRpdmVUeXBlLlN0cmluZztcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcmltaXRpdmVUeXBlLk51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2Ygbm9kZV9tb2R1bGVzX2xvbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByaW1pdGl2ZVR5cGUuTG9uZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcmltaXRpdmVUeXBlLkJ5dGVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByaW1pdGl2ZVR5cGUuRGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgaXNTdXBwb3J0YCBjaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgc3VwcG9ydGVkIHR5cGUuXG4gICAgICovXG4gICAgc3RhdGljIGlzU3VwcG9ydCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBwcmltaXRpdmVUeXBlID0gUHJpbWl0aXZlLmdldFByaW1pdGl2ZVR5cGUodmFsdWUpO1xuICAgICAgICBpZiAocHJpbWl0aXZlVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBpc0ludGVnZXJgIGNoZWNrcyBpZiB0aGUgZ2l2ZW4gbnVtYmVyIGlzIGludGVnZXIuXG4gICAgICovXG4gICAgc3RhdGljIGlzSW50ZWdlcihudW0pIHtcbiAgICAgICAgcmV0dXJuIG51bSAlIDEgPT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBpc051bWVyaWNUeXBlYCBjaGVja3MgbnVtZXJpYyB0eXBlIGJ5IEpTT05QcmltaXRpdmVcbiAgICAgKi9cbiAgICBpc051bWVyaWNUeXBlKCkge1xuICAgICAgICBjb25zdCB0ID0gdGhpcy52YWx1ZVR5cGU7XG4gICAgICAgIHJldHVybiAodCA9PT0gUHJpbWl0aXZlVHlwZS5JbnRlZ2VyIHx8XG4gICAgICAgICAgICB0ID09PSBQcmltaXRpdmVUeXBlLkxvbmcgfHxcbiAgICAgICAgICAgIHQgPT09IFByaW1pdGl2ZVR5cGUuRG91YmxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldFZhbHVlYCByZXR1cm5zIHRoZSB2YWx1ZSBvZiBQcmltaXRpdmUuXG4gICAgICovXG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdG9CeXRlc2AgY3JlYXRlcyBhbiBhcnJheSByZXByZXNlbnRpbmcgdGhlIHZhbHVlLlxuICAgICAqL1xuICAgIHRvQnl0ZXMoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy52YWx1ZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgUHJpbWl0aXZlVHlwZS5OdWxsOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFByaW1pdGl2ZVR5cGUuQm9vbGVhbjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvb2xWYWwgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBib29sVmFsID8gbmV3IFVpbnQ4QXJyYXkoWzFdKSA6IG5ldyBVaW50OEFycmF5KFswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFByaW1pdGl2ZVR5cGUuSW50ZWdlcjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludFZhbCA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgICAgICAgICAgaW50VmFsICYgMHhmZixcbiAgICAgICAgICAgICAgICAgICAgKGludFZhbCA+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgICAgICAgICAgIChpbnRWYWwgPj4gMTYpICYgMHhmZixcbiAgICAgICAgICAgICAgICAgICAgKGludFZhbCA+PiAyNCkgJiAweGZmLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBQcmltaXRpdmVUeXBlLkRvdWJsZToge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvdWJsZVZhbCA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3QgdWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcodWludDhBcnJheS5idWZmZXIpO1xuICAgICAgICAgICAgICAgIHZpZXcuc2V0RmxvYXQ2NCgwLCBkb3VibGVWYWwsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB1aW50OEFycmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBQcmltaXRpdmVUeXBlLlN0cmluZzoge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFByaW1pdGl2ZVR5cGUuTG9uZzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvbmdWYWwgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvbmdUb0J5dGVzID0gbG9uZ1ZhbC50b0J5dGVzTEUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGxvbmdUb0J5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgUHJpbWl0aXZlVHlwZS5CeXRlczoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzVmFsID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnl0ZXNWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFByaW1pdGl2ZVR5cGUuRGF0ZToge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGVWYWwgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGVUb0J5dGVzID0gbm9kZV9tb2R1bGVzX2xvbmcuZnJvbU51bWJlcihkYXRlVmFsLmdldFRpbWUoKSwgdHJ1ZSkudG9CeXRlc0xFKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShkYXRlVG9CeXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBZb3JraWVFcnJvcihlcnJvcl9Db2RlLlVuaW1wbGVtZW50ZWQsIGB1bmltcGxlbWVudGVkIHR5cGU6ICR7dGhpcy52YWx1ZVR5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kb2N1bWVudC9jcmR0L3JnYV90cmVlX2xpc3QudHNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuXG5cbi8qKlxuICogYFJHQVRyZWVMaXN0Tm9kZWAgaXMgYSBub2RlIG9mIFJHQVRyZWVMaXN0LlxuICovXG5jbGFzcyBSR0FUcmVlTGlzdE5vZGUgZXh0ZW5kcyBTcGxheU5vZGUge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKHZhbHVlKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgY3JlYXRlQWZ0ZXJgIGNyZWF0ZXMgYSBuZXcgbm9kZSBhZnRlciB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlQWZ0ZXIocHJldiwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmV3Tm9kZSA9IG5ldyBSR0FUcmVlTGlzdE5vZGUodmFsdWUpO1xuICAgICAgICBjb25zdCBwcmV2TmV4dCA9IHByZXYubmV4dDtcbiAgICAgICAgcHJldi5uZXh0ID0gbmV3Tm9kZTtcbiAgICAgICAgbmV3Tm9kZS5wcmV2ID0gcHJldjtcbiAgICAgICAgbmV3Tm9kZS5uZXh0ID0gcHJldk5leHQ7XG4gICAgICAgIGlmIChwcmV2TmV4dCkge1xuICAgICAgICAgICAgcHJldk5leHQucHJldiA9IG5ld05vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGByZW1vdmVgIHJlbW92ZXMgdmFsdWUgYmFzZWQgb24gcmVtb3ZpbmcgdGltZS5cbiAgICAgKi9cbiAgICByZW1vdmUocmVtb3ZlZEF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlLnJlbW92ZShyZW1vdmVkQXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0Q3JlYXRlZEF0YCByZXR1cm5zIGNyZWF0aW9uIHRpbWUgb2YgdGhpcyB2YWx1ZVxuICAgICAqL1xuICAgIGdldENyZWF0ZWRBdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuZ2V0Q3JlYXRlZEF0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRQb3NpdGlvbmVkQXRgIHJldHVybnMgdGhlIHRpbWUgb2YgdGhpcyBlbGVtZW50IHdoZW4gaXQgd2FzIHBvc2l0aW9uZWRcbiAgICAgKiBpbiB0aGUgYXJyYXkuXG4gICAgICovXG4gICAgZ2V0UG9zaXRpb25lZEF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5nZXRQb3NpdGlvbmVkQXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHJlbGVhc2VgIHJlbGVhc2VzIHByZXYgYW5kIG5leHQgbm9kZS5cbiAgICAgKi9cbiAgICByZWxlYXNlKCkge1xuICAgICAgICBpZiAodGhpcy5wcmV2KSB7XG4gICAgICAgICAgICB0aGlzLnByZXYubmV4dCA9IHRoaXMubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQucHJldiA9IHRoaXMucHJldjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXYgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldExlbmd0aGAgcmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoaXMgbm9kZS5cbiAgICAgKi9cbiAgICBnZXRMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlLmlzUmVtb3ZlZCgpID8gMCA6IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRQcmV2YCByZXR1cm5zIGEgcHJldmlvdXMgbm9kZS5cbiAgICAgKi9cbiAgICBnZXRQcmV2KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0TmV4dGAgcmV0dXJucyBhIG5leHQgbm9kZS5cbiAgICAgKi9cbiAgICBnZXROZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0VmFsdWVgIHJldHVybnMgYSBlbGVtZW50IHZhbHVlLlxuICAgICAqL1xuICAgIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGlzUmVtb3ZlZGAgY2hlY2tzIGlmIHRoZSB2YWx1ZSB3YXMgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBpc1JlbW92ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlLmlzUmVtb3ZlZCgpO1xuICAgIH1cbn1cbi8qKlxuICogYFJHQVRyZWVMaXN0YCBpcyBhIHJlcGxpY2F0ZWQgZ3Jvd2FibGUgYXJyYXkuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIFJHQVRyZWVMaXN0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgY29uc3QgZHVtbXlWYWx1ZSA9IFByaW1pdGl2ZS5vZigwLCBJbml0aWFsVGltZVRpY2tldCk7XG4gICAgICAgIGR1bW15VmFsdWUuc2V0UmVtb3ZlZEF0KEluaXRpYWxUaW1lVGlja2V0KTtcbiAgICAgICAgdGhpcy5kdW1teUhlYWQgPSBuZXcgUkdBVHJlZUxpc3ROb2RlKGR1bW15VmFsdWUpO1xuICAgICAgICB0aGlzLmxhc3QgPSB0aGlzLmR1bW15SGVhZDtcbiAgICAgICAgdGhpcy5ub2RlTWFwQnlJbmRleCA9IG5ldyBTcGxheVRyZWUoKTtcbiAgICAgICAgdGhpcy5ub2RlTWFwQnlDcmVhdGVkQXQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubm9kZU1hcEJ5SW5kZXguaW5zZXJ0KHRoaXMuZHVtbXlIZWFkKTtcbiAgICAgICAgdGhpcy5ub2RlTWFwQnlDcmVhdGVkQXQuc2V0KHRoaXMuZHVtbXlIZWFkLmdldENyZWF0ZWRBdCgpLnRvSURTdHJpbmcoKSwgdGhpcy5kdW1teUhlYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgY3JlYXRlYCBjcmVhdGVzIGluc3RhbmNlIG9mIFJHQVRyZWVMaXN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUkdBVHJlZUxpc3QoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGxlbmd0aGAgcmV0dXJucyBzaXplIG9mIFJHQVRyZWVMaXN0LlxuICAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVNYXBCeUluZGV4Lmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGZpbmROZXh0QmVmb3JlRXhlY3V0ZWRBdGAgcmV0dXJucyB0aGUgbm9kZSBieSB0aGUgZ2l2ZW4gY3JlYXRlZEF0IGFuZFxuICAgICAqIGV4ZWN1dGVkQXQuIEl0IHBhc3NlcyB0aHJvdWdoIG5vZGVzIGNyZWF0ZWQgYWZ0ZXIgZXhlY3V0ZWRBdCBmcm9tIHRoZVxuICAgICAqIGdpdmVuIG5vZGUgYW5kIHJldHVybnMgdGhlIG5leHQgbm9kZS5cbiAgICAgKiBAcGFyYW0gY3JlYXRlZEF0IC0gY3JlYXRlZCB0aW1lXG4gICAgICogQHBhcmFtIGV4ZWN1dGVkQXQgLSBleGVjdXRlZCB0aW1lXG4gICAgICogQHJldHVybnMgbmV4dCBub2RlXG4gICAgICovXG4gICAgZmluZE5leHRCZWZvcmVFeGVjdXRlZEF0KGNyZWF0ZWRBdCwgZXhlY3V0ZWRBdCkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMubm9kZU1hcEJ5Q3JlYXRlZEF0LmdldChjcmVhdGVkQXQudG9JRFN0cmluZygpKTtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICBsb2dnZXIuZmF0YWwoYGNhbnQgZmluZCB0aGUgZ2l2ZW4gbm9kZTogJHtjcmVhdGVkQXQudG9JRFN0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChub2RlLmdldE5leHQoKSAmJlxuICAgICAgICAgICAgbm9kZS5nZXROZXh0KCkuZ2V0UG9zaXRpb25lZEF0KCkuYWZ0ZXIoZXhlY3V0ZWRBdCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmdldE5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgcmVsZWFzZShub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLmxhc3QgPT09IG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdCA9IG5vZGUuZ2V0UHJldigpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUucmVsZWFzZSgpO1xuICAgICAgICB0aGlzLm5vZGVNYXBCeUluZGV4LmRlbGV0ZShub2RlKTtcbiAgICAgICAgdGhpcy5ub2RlTWFwQnlDcmVhdGVkQXQuZGVsZXRlKG5vZGUuZ2V0VmFsdWUoKS5nZXRDcmVhdGVkQXQoKS50b0lEU3RyaW5nKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgaW5zZXJ0QWZ0ZXJgIGFkZHMgYSBuZXcgbm9kZSB3aXRoIHRoZSB2YWx1ZSBhZnRlciB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAgKi9cbiAgICBpbnNlcnRBZnRlcihwcmV2Q3JlYXRlZEF0LCB2YWx1ZSwgZXhlY3V0ZWRBdCA9IHZhbHVlLmdldENyZWF0ZWRBdCgpKSB7XG4gICAgICAgIGNvbnN0IHByZXZOb2RlID0gdGhpcy5maW5kTmV4dEJlZm9yZUV4ZWN1dGVkQXQocHJldkNyZWF0ZWRBdCwgZXhlY3V0ZWRBdCk7XG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSBSR0FUcmVlTGlzdE5vZGUuY3JlYXRlQWZ0ZXIocHJldk5vZGUsIHZhbHVlKTtcbiAgICAgICAgaWYgKHByZXZOb2RlID09PSB0aGlzLmxhc3QpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdCA9IG5ld05vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlTWFwQnlJbmRleC5pbnNlcnRBZnRlcihwcmV2Tm9kZSwgbmV3Tm9kZSk7XG4gICAgICAgIHRoaXMubm9kZU1hcEJ5Q3JlYXRlZEF0LnNldChuZXdOb2RlLmdldENyZWF0ZWRBdCgpLnRvSURTdHJpbmcoKSwgbmV3Tm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBtb3ZlQWZ0ZXJgIG1vdmVzIHRoZSBnaXZlbiBgY3JlYXRlZEF0YCBlbGVtZW50XG4gICAgICogYWZ0ZXIgdGhlIGBwcmV2Q3JlYXRlZEF0YCBlbGVtZW50LlxuICAgICAqL1xuICAgIG1vdmVBZnRlcihwcmV2Q3JlYXRlZEF0LCBjcmVhdGVkQXQsIGV4ZWN1dGVkQXQpIHtcbiAgICAgICAgY29uc3QgcHJldk5vZGUgPSB0aGlzLm5vZGVNYXBCeUNyZWF0ZWRBdC5nZXQocHJldkNyZWF0ZWRBdC50b0lEU3RyaW5nKCkpO1xuICAgICAgICBpZiAoIXByZXZOb2RlKSB7XG4gICAgICAgICAgICBsb2dnZXIuZmF0YWwoYGNhbnQgZmluZCB0aGUgZ2l2ZW4gbm9kZTogJHtwcmV2Q3JlYXRlZEF0LnRvSURTdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5ub2RlTWFwQnlDcmVhdGVkQXQuZ2V0KGNyZWF0ZWRBdC50b0lEU3RyaW5nKCkpO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci5mYXRhbChgY2FudCBmaW5kIHRoZSBnaXZlbiBub2RlOiAke2NyZWF0ZWRBdC50b0lEU3RyaW5nKCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZOb2RlICE9PSBub2RlICYmXG4gICAgICAgICAgICAoIW5vZGUuZ2V0VmFsdWUoKS5nZXRNb3ZlZEF0KCkgfHxcbiAgICAgICAgICAgICAgICBleGVjdXRlZEF0LmFmdGVyKG5vZGUuZ2V0VmFsdWUoKS5nZXRNb3ZlZEF0KCkpKSkge1xuICAgICAgICAgICAgdGhpcy5yZWxlYXNlKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRBZnRlcihwcmV2Tm9kZS5nZXRDcmVhdGVkQXQoKSwgbm9kZS5nZXRWYWx1ZSgpLCBleGVjdXRlZEF0KTtcbiAgICAgICAgICAgIG5vZGUuZ2V0VmFsdWUoKS5zZXRNb3ZlZEF0KGV4ZWN1dGVkQXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBpbnNlcnRgIGFkZHMgdGhlIGdpdmVuIGVsZW1lbnQgYWZ0ZXIgdGhlIGxhc3Qgbm9kZS5cbiAgICAgKi9cbiAgICBpbnNlcnQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5pbnNlcnRBZnRlcih0aGlzLmxhc3QuZ2V0Q3JlYXRlZEF0KCksIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldEJ5SURgIHJldHVybnMgdGhlIGVsZW1lbnQgb2YgdGhlIGdpdmVuIGNyZWF0aW9uIHRpbWUuXG4gICAgICovXG4gICAgZ2V0QnlJRChjcmVhdGVkQXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZU1hcEJ5Q3JlYXRlZEF0LmdldChjcmVhdGVkQXQudG9JRFN0cmluZygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHN1YlBhdGhPZmAgcmV0dXJucyB0aGUgc3ViIHBhdGggb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICovXG4gICAgc3ViUGF0aE9mKGNyZWF0ZWRBdCkge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5ub2RlTWFwQnlDcmVhdGVkQXQuZ2V0KGNyZWF0ZWRBdC50b0lEU3RyaW5nKCkpO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMubm9kZU1hcEJ5SW5kZXguaW5kZXhPZihub2RlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBwdXJnZWAgcGh5c2ljYWxseSBwdXJnZXMgZWxlbWVudC5cbiAgICAgKi9cbiAgICBwdXJnZShlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGVNYXBCeUNyZWF0ZWRBdC5nZXQoZWxlbWVudC5nZXRDcmVhdGVkQXQoKS50b0lEU3RyaW5nKCkpO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci5mYXRhbChgZmFpbCB0byBmaW5kIHRoZSBnaXZlbiBjcmVhdGVkQXQ6ICR7ZWxlbWVudFxuICAgICAgICAgICAgICAgIC5nZXRDcmVhdGVkQXQoKVxuICAgICAgICAgICAgICAgIC50b0lEU3RyaW5nKCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWxlYXNlKG5vZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0QnlJbmRleGAgcmV0dXJucyBub2RlIG9mIHRoZSBnaXZlbiBpbmRleC5cbiAgICAgKi9cbiAgICBnZXRCeUluZGV4KGlkeCkge1xuICAgICAgICBpZiAoaWR4ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW25vZGUsIG9mZnNldF0gPSB0aGlzLm5vZGVNYXBCeUluZGV4LmZpbmQoaWR4KTtcbiAgICAgICAgbGV0IHJnYU5vZGUgPSBub2RlO1xuICAgICAgICBpZiAoKGlkeCA9PT0gMCAmJiBub2RlID09PSB0aGlzLmR1bW15SGVhZCkgfHwgb2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChyZ2FOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJnYU5vZGUgPSByZ2FOb2RlLmdldE5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChyZ2FOb2RlICYmIHJnYU5vZGUuaXNSZW1vdmVkKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZ2FOb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0UHJldkNyZWF0ZWRBdGAgcmV0dXJucyBhIGNyZWF0aW9uIHRpbWUgb2YgdGhlIHByZXZpb3VzIG5vZGUuXG4gICAgICovXG4gICAgZ2V0UHJldkNyZWF0ZWRBdChjcmVhdGVkQXQpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLm5vZGVNYXBCeUNyZWF0ZWRBdC5nZXQoY3JlYXRlZEF0LnRvSURTdHJpbmcoKSk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmdldFByZXYoKTtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5kdW1teUhlYWQgIT09IG5vZGUgJiYgbm9kZS5pc1JlbW92ZWQoKSk7XG4gICAgICAgIHJldHVybiBub2RlLmdldFZhbHVlKCkuZ2V0Q3JlYXRlZEF0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBkZWxldGVgIGRlbGV0ZXMgdGhlIG5vZGUgb2YgdGhlIGdpdmVuIGNyZWF0aW9uIHRpbWUuXG4gICAgICovXG4gICAgZGVsZXRlKGNyZWF0ZWRBdCwgZWRpdGVkQXQpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZU1hcEJ5Q3JlYXRlZEF0LmdldChjcmVhdGVkQXQudG9JRFN0cmluZygpKTtcbiAgICAgICAgY29uc3QgYWxyZWFkeVJlbW92ZWQgPSBub2RlLmlzUmVtb3ZlZCgpO1xuICAgICAgICBpZiAobm9kZS5yZW1vdmUoZWRpdGVkQXQpICYmICFhbHJlYWR5UmVtb3ZlZCkge1xuICAgICAgICAgICAgdGhpcy5ub2RlTWFwQnlJbmRleC5zcGxheU5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUuZ2V0VmFsdWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGRlbGV0ZUJ5SW5kZXhgIGRlbGV0ZXMgdGhlIG5vZGUgb2YgdGhlIGdpdmVuIGluZGV4LlxuICAgICAqL1xuICAgIGRlbGV0ZUJ5SW5kZXgoaW5kZXgsIGVkaXRlZEF0KSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldEJ5SW5kZXgoaW5kZXgpO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5yZW1vdmUoZWRpdGVkQXQpKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVNYXBCeUluZGV4LnNwbGF5Tm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS5nZXRWYWx1ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0SGVhZGAgcmV0dXJucyB0aGUgdmFsdWUgb2YgaGVhZCBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBnZXRIZWFkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kdW1teUhlYWQuZ2V0VmFsdWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldExhc3RgIHJldHVybnMgdGhlIHZhbHVlIG9mIGxhc3QgZWxlbWVudHMuXG4gICAgICovXG4gICAgZ2V0TGFzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdC5nZXRWYWx1ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0TGFzdENyZWF0ZWRBdGAgcmV0dXJucyB0aGUgY3JlYXRpb24gdGltZSBvZiBsYXN0IGVsZW1lbnQuXG4gICAgICovXG4gICAgZ2V0TGFzdENyZWF0ZWRBdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdC5nZXRDcmVhdGVkQXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRvVGVzdFN0cmluZ2AgcmV0dXJucyBhIFN0cmluZyBjb250YWluaW5nIHRoZSBtZXRhIGRhdGEgb2YgdGhlIG5vZGUgaWRcbiAgICAgKiBmb3IgZGVidWdnaW5nIHB1cnBvc2UuXG4gICAgICovXG4gICAgdG9UZXN0U3RyaW5nKCkge1xuICAgICAgICBjb25zdCBqc29uID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtID0gYCR7bm9kZS5nZXRDcmVhdGVkQXQoKS50b0lEU3RyaW5nKCl9OiR7bm9kZVxuICAgICAgICAgICAgICAgIC5nZXRWYWx1ZSgpXG4gICAgICAgICAgICAgICAgLnRvSlNPTigpfWA7XG4gICAgICAgICAgICBpZiAobm9kZS5pc1JlbW92ZWQoKSkge1xuICAgICAgICAgICAgICAgIGpzb24ucHVzaChgeyR7ZWxlbX19YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBqc29uLnB1c2goYFske2VsZW19XWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc29uLmpvaW4oJycpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmR1bW15SGVhZC5nZXROZXh0KCk7XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICB5aWVsZCBub2RlO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuZ2V0TmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZG9jdW1lbnQvY3JkdC9hcnJheS50c1xuLypcbiAqIENvcHlyaWdodCAyMDIwIFRoZSBZb3JraWUgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuXG4vKipcbiAqIGBDUkRUQXJyYXlgIHJlcHJlc2VudHMgYW4gYXJyYXkgZGF0YSB0eXBlIGNvbnRhaW5pbmcgYENSRFRFbGVtZW50YHMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIENSRFRBcnJheSBleHRlbmRzIENSRFRDb250YWluZXIge1xuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXG4gICAgY29uc3RydWN0b3IoY3JlYXRlZEF0LCBlbGVtZW50cykge1xuICAgICAgICBzdXBlcihjcmVhdGVkQXQpO1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBjcmVhdGVgIGNyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgQXJyYXkuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShjcmVhdGVkQXQsIHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ1JEVEFycmF5KGNyZWF0ZWRBdCwgUkdBVHJlZUxpc3QuY3JlYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gUkdBVHJlZUxpc3QuY3JlYXRlKCk7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgZWxlbWVudHMuaW5zZXJ0QWZ0ZXIoZWxlbWVudHMuZ2V0TGFzdENyZWF0ZWRBdCgpLCB2LmRlZXBjb3B5KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ1JEVEFycmF5KGNyZWF0ZWRBdCwgZWxlbWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgc3ViUGF0aE9mYCByZXR1cm5zIHRoZSBzdWIgcGF0aCBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKi9cbiAgICBzdWJQYXRoT2YoY3JlYXRlZEF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzLnN1YlBhdGhPZihjcmVhdGVkQXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgcHVyZ2VgIHBoeXNpY2FsbHkgcHVyZ2UgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICovXG4gICAgcHVyZ2UoZWxlbWVudCkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzLnB1cmdlKGVsZW1lbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgaW5zZXJ0QWZ0ZXJgIGFkZHMgYSBuZXcgbm9kZSBhZnRlciB0aGUgdGhlIGdpdmVuIG5vZGUuXG4gICAgICovXG4gICAgaW5zZXJ0QWZ0ZXIocHJldkNyZWF0ZWRBdCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5pbnNlcnRBZnRlcihwcmV2Q3JlYXRlZEF0LCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBtb3ZlQWZ0ZXJgIG1vdmVzIHRoZSBnaXZlbiBgY3JlYXRlZEF0YCBlbGVtZW50IGFmdGVyIHRoZSBgcHJldkNyZWF0ZWRBdGAuXG4gICAgICovXG4gICAgbW92ZUFmdGVyKHByZXZDcmVhdGVkQXQsIGNyZWF0ZWRBdCwgZXhlY3V0ZWRBdCkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzLm1vdmVBZnRlcihwcmV2Q3JlYXRlZEF0LCBjcmVhdGVkQXQsIGV4ZWN1dGVkQXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0YCByZXR1cm5zIHRoZSBlbGVtZW50IG9mIHRoZSBnaXZlbiBpbmRleC5cbiAgICAgKi9cbiAgICBnZXQoaW5kZXgpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZWxlbWVudHMuZ2V0QnlJbmRleChpbmRleCk7XG4gICAgICAgIHJldHVybiBub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUuZ2V0VmFsdWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldEJ5SURgIHJldHVybnMgdGhlIGVsZW1lbnQgb2YgdGhlIGdpdmVuIGNyZWF0ZUF0LlxuICAgICAqL1xuICAgIGdldEJ5SUQoY3JlYXRlZEF0KSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmVsZW1lbnRzLmdldEJ5SUQoY3JlYXRlZEF0KTtcbiAgICAgICAgcmV0dXJuIG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5nZXRWYWx1ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0SGVhZGAgcmV0dXJucyBkdW1teSBoZWFkIGVsZW1lbnQuXG4gICAgICovXG4gICAgZ2V0SGVhZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMuZ2V0SGVhZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0TGFzdGAgcmV0dXJucyBsYXN0IGVsZW1lbnQuXG4gICAgICovXG4gICAgZ2V0TGFzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMuZ2V0TGFzdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0UHJldkNyZWF0ZWRBdGAgcmV0dXJucyB0aGUgY3JlYXRpb24gdGltZSBvZiB0aGUgcHJldmlvdXMgbm9kZS5cbiAgICAgKi9cbiAgICBnZXRQcmV2Q3JlYXRlZEF0KGNyZWF0ZWRBdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50cy5nZXRQcmV2Q3JlYXRlZEF0KGNyZWF0ZWRBdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBkZWxldGVgIGRlbGV0ZXMgdGhlIGVsZW1lbnQgb2YgdGhlIGdpdmVuIGNyZWF0aW9uIHRpbWUuXG4gICAgICovXG4gICAgZGVsZXRlKGNyZWF0ZWRBdCwgZWRpdGVkQXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMuZGVsZXRlKGNyZWF0ZWRBdCwgZWRpdGVkQXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZGVsZXRlQnlJbmRleGAgZGVsZXRlcyB0aGUgZWxlbWVudCBvZiBnaXZlbiBpbmRleCBhbmQgZWRpdGVkQXQuXG4gICAgICovXG4gICAgZGVsZXRlQnlJbmRleChpbmRleCwgZWRpdGVkQXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMuZGVsZXRlQnlJbmRleChpbmRleCwgZWRpdGVkQXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0TGFzdENyZWF0ZWRBdGAgZ2V0IGxhc3QgY3JlYXRlZCBlbGVtZW50LlxuICAgICAqL1xuICAgIGdldExhc3RDcmVhdGVkQXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzLmdldExhc3RDcmVhdGVkQXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGxlbmd0aGAgcmV0dXJucyBsZW5ndGggb2YgdGhpcyBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5lbGVtZW50cykge1xuICAgICAgICAgICAgaWYgKCFub2RlLmlzUmVtb3ZlZCgpKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgbm9kZS5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0b1Rlc3RTdHJpbmdgIHJldHVybnMgYSBTdHJpbmcgY29udGFpbmluZyB0aGUgbWV0YSBkYXRhIG9mIHRoaXMgdmFsdWVcbiAgICAgKiBmb3IgZGVidWdnaW5nIHB1cnBvc2UuXG4gICAgICovXG4gICAgdG9UZXN0U3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50cy50b1Rlc3RTdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldERlc2NlbmRhbnRzYCB0cmF2ZXJzZSB0aGUgZGVzY2VuZGFudHMgb2YgdGhpcyBhcnJheS5cbiAgICAgKi9cbiAgICBnZXREZXNjZW5kYW50cyhjYWxsYmFjaykge1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5lbGVtZW50cykge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IG5vZGUuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayhlbGVtZW50LCB0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgQ1JEVENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuZ2V0RGVzY2VuZGFudHMoY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0b0pTT05gIHJldHVybnMgdGhlIEpTT04gZW5jb2Rpbmcgb2YgdGhpcyBhcnJheS5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IGpzb24gPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzKSB7XG4gICAgICAgICAgICBqc29uLnB1c2godmFsdWUudG9KU09OKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgWyR7anNvbi5qb2luKCcsJyl9XWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0b0pTYCByZXR1cm4gdGhlIGphdmFzY3JpcHQgb2JqZWN0IG9mIHRoaXMgYXJyYXkuXG4gICAgICovXG4gICAgdG9KUygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy50b0pTT04oKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0b0pTRm9yVGVzdGAgcmV0dXJucyB2YWx1ZSB3aXRoIG1ldGEgZGF0YSBmb3IgdGVzdGluZy5cbiAgICAgKi9cbiAgICB0b0pTRm9yVGVzdCgpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgeyBpZCwgdmFsdWUsIHR5cGUgfSA9IHRoaXMuZ2V0KGkpLnRvSlNGb3JUZXN0KCk7XG4gICAgICAgICAgICB2YWx1ZXNbaV0gPSB7XG4gICAgICAgICAgICAgICAga2V5OiBTdHJpbmcoaSksXG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmdldENyZWF0ZWRBdCgpLnRvVGVzdFN0cmluZygpLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlcyxcbiAgICAgICAgICAgIHR5cGU6ICdZT1JLSUVfQVJSQVknLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdG9Tb3J0ZWRKU09OYCByZXR1cm5zIHRoZSBzb3J0ZWQgSlNPTiBlbmNvZGluZyBvZiB0aGlzIGFycmF5LlxuICAgICAqL1xuICAgIHRvU29ydGVkSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9KU09OKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRFbGVtZW50c2AgcmV0dXJucyBhbiBhcnJheSBvZiBlbGVtZW50cyBjb250YWluZWQgaW4gdGhpcyBSR0FUcmVlTGlzdC5cbiAgICAgKi9cbiAgICBnZXRFbGVtZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBkZWVwY29weWAgY29waWVzIGl0c2VsZiBkZWVwbHkuXG4gICAgICovXG4gICAgZGVlcGNvcHkoKSB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gQ1JEVEFycmF5LmNyZWF0ZSh0aGlzLmdldENyZWF0ZWRBdCgpKTtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMuZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGNsb25lLmVsZW1lbnRzLmluc2VydEFmdGVyKGNsb25lLmdldExhc3RDcmVhdGVkQXQoKSwgbm9kZS5nZXRWYWx1ZSgpLmRlZXBjb3B5KCkpO1xuICAgICAgICB9XG4gICAgICAgIGNsb25lLnJlbW92ZSh0aGlzLmdldFJlbW92ZWRBdCgpKTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2RvY3VtZW50L29wZXJhdGlvbi9yZW1vdmVfb3BlcmF0aW9uLnRzXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgVGhlIFlvcmtpZSBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5cblxuXG5cblxuLyoqXG4gKiBgUmVtb3ZlT3BlcmF0aW9uYCBpcyBhbiBvcGVyYXRpb24gdGhhdCByZW1vdmVzIGFuIGVsZW1lbnQgZnJvbSBgQ1JEVENvbnRhaW5lcmAuXG4gKi9cbmNsYXNzIFJlbW92ZU9wZXJhdGlvbiBleHRlbmRzIE9wZXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IocGFyZW50Q3JlYXRlZEF0LCBjcmVhdGVkQXQsIGV4ZWN1dGVkQXQpIHtcbiAgICAgICAgc3VwZXIocGFyZW50Q3JlYXRlZEF0LCBleGVjdXRlZEF0KTtcbiAgICAgICAgdGhpcy5jcmVhdGVkQXQgPSBjcmVhdGVkQXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBjcmVhdGVgIGNyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUmVtb3ZlT3BlcmF0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUocGFyZW50Q3JlYXRlZEF0LCBjcmVhdGVkQXQsIGV4ZWN1dGVkQXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVPcGVyYXRpb24ocGFyZW50Q3JlYXRlZEF0LCBjcmVhdGVkQXQsIGV4ZWN1dGVkQXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZXhlY3V0ZWAgZXhlY3V0ZXMgdGhpcyBvcGVyYXRpb24gb24gdGhlIGdpdmVuIGBDUkRUUm9vdGAuXG4gICAgICovXG4gICAgZXhlY3V0ZShyb290LCBzb3VyY2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSByb290LmZpbmRCeUNyZWF0ZWRBdCh0aGlzLmdldFBhcmVudENyZWF0ZWRBdCgpKTtcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgIGxvZ2dlci5mYXRhbChgZmFpbCB0byBmaW5kICR7dGhpcy5nZXRQYXJlbnRDcmVhdGVkQXQoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShjb250YWluZXIgaW5zdGFuY2VvZiBDUkRUQ29udGFpbmVyKSkge1xuICAgICAgICAgICAgbG9nZ2VyLmZhdGFsKGBvbmx5IG9iamVjdCBhbmQgYXJyYXkgY2FuIGV4ZWN1dGUgcmVtb3ZlOiAke2NvbnRhaW5lcn1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOT1RFKGNoYWNoYTkxMik6IEhhbmRsZSBjYXNlcyB3aGVyZSBvcGVyYXRpb24gY2Fubm90IGJlIGV4ZWN1dGVkIGR1cmluZyB1bmRvIGFuZCByZWRvLlxuICAgICAgICBpZiAoc291cmNlID09PSBPcFNvdXJjZS5VbmRvUmVkbykge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IGNvbnRhaW5lci5nZXRCeUlEKHRoaXMuY3JlYXRlZEF0KTtcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50LmdldFJlbW92ZWRBdCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gKF9hID0gcm9vdC5maW5kRWxlbWVudFBhaXJCeUNyZWF0ZWRBdChwYXJlbnQuZ2V0Q3JlYXRlZEF0KCkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleSA9IGNvbnRhaW5lci5zdWJQYXRoT2YodGhpcy5jcmVhdGVkQXQpO1xuICAgICAgICBjb25zdCByZXZlcnNlT3AgPSB0aGlzLnRvUmV2ZXJzZU9wZXJhdGlvbihjb250YWluZXIpO1xuICAgICAgICBjb25zdCBlbGVtID0gY29udGFpbmVyLmRlbGV0ZSh0aGlzLmNyZWF0ZWRBdCwgdGhpcy5nZXRFeGVjdXRlZEF0KCkpO1xuICAgICAgICByb290LnJlZ2lzdGVyUmVtb3ZlZEVsZW1lbnQoZWxlbSk7XG4gICAgICAgIGNvbnN0IG9wSW5mb3MgPSBjb250YWluZXIgaW5zdGFuY2VvZiBDUkRUQXJyYXlcbiAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3JlbW92ZScsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IHJvb3QuY3JlYXRlUGF0aCh0aGlzLmdldFBhcmVudENyZWF0ZWRBdCgpKSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IE51bWJlcihrZXkpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgICAgICA6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdyZW1vdmUnLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiByb290LmNyZWF0ZVBhdGgodGhpcy5nZXRQYXJlbnRDcmVhdGVkQXQoKSksXG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIHsgb3BJbmZvcywgcmV2ZXJzZU9wIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0b1JldmVyc2VPcGVyYXRpb25gIHJldHVybnMgdGhlIHJldmVyc2Ugb3BlcmF0aW9uIG9mIHRoaXMgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIHRvUmV2ZXJzZU9wZXJhdGlvbihwYXJlbnRPYmplY3QpIHtcbiAgICAgICAgLy8gVE9ETyhIeWVtbWllKTogY29uc2lkZXIgQ1JEVEFycmF5XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgaW5zdGFuY2VvZiBDUkRUT2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBwYXJlbnRPYmplY3Quc3ViUGF0aE9mKHRoaXMuY3JlYXRlZEF0KTtcbiAgICAgICAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFyZW50T2JqZWN0LmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTZXRPcGVyYXRpb24uY3JlYXRlKGtleSwgdmFsdWUuZGVlcGNvcHkoKSwgdGhpcy5nZXRQYXJlbnRDcmVhdGVkQXQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRFZmZlY3RlZENyZWF0ZWRBdGAgcmV0dXJucyB0aGUgY3JlYXRpb24gdGltZSBvZiB0aGUgZWZmZWN0ZWQgZWxlbWVudC5cbiAgICAgKi9cbiAgICBnZXRFZmZlY3RlZENyZWF0ZWRBdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFyZW50Q3JlYXRlZEF0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0b1Rlc3RTdHJpbmdgIHJldHVybnMgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgbWV0YSBkYXRhLlxuICAgICAqL1xuICAgIHRvVGVzdFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0UGFyZW50Q3JlYXRlZEF0KCkudG9UZXN0U3RyaW5nKCl9LlJFTU9WRS4ke3RoaXMuY3JlYXRlZEF0LnRvVGVzdFN0cmluZygpfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRDcmVhdGVkQXRgIHJldHVybnMgdGhlIGNyZWF0aW9uIHRpbWUgb2YgdGhlIHRhcmdldCBlbGVtZW50LlxuICAgICAqL1xuICAgIGdldENyZWF0ZWRBdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlZEF0O1xuICAgIH1cbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2RvY3VtZW50L29wZXJhdGlvbi9zZXRfb3BlcmF0aW9uLnRzXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgVGhlIFlvcmtpZSBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5cblxuXG4vKipcbiAqIGBTZXRPcGVyYXRpb25gIHJlcHJlc2VudHMgYW4gb3BlcmF0aW9uIHRoYXQgc3RvcmVzIHRoZSB2YWx1ZSBjb3JyZXNwb25kaW5nIHRvIHRoZVxuICogZ2l2ZW4ga2V5IGluIHRoZSBPYmplY3QuXG4gKi9cbmNsYXNzIFNldE9wZXJhdGlvbiBleHRlbmRzIE9wZXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCB2YWx1ZSwgcGFyZW50Q3JlYXRlZEF0LCBleGVjdXRlZEF0KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudENyZWF0ZWRBdCwgZXhlY3V0ZWRBdCk7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBjcmVhdGVgIGNyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgU2V0T3BlcmF0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoa2V5LCB2YWx1ZSwgcGFyZW50Q3JlYXRlZEF0LCBleGVjdXRlZEF0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2V0T3BlcmF0aW9uKGtleSwgdmFsdWUsIHBhcmVudENyZWF0ZWRBdCwgZXhlY3V0ZWRBdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBleGVjdXRlYCBleGVjdXRlcyB0aGlzIG9wZXJhdGlvbiBvbiB0aGUgZ2l2ZW4gYENSRFRSb290YC5cbiAgICAgKi9cbiAgICBleGVjdXRlKHJvb3QsIHNvdXJjZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG9iaiA9IHJvb3QuZmluZEJ5Q3JlYXRlZEF0KHRoaXMuZ2V0UGFyZW50Q3JlYXRlZEF0KCkpO1xuICAgICAgICBpZiAoIW9iaikge1xuICAgICAgICAgICAgbG9nZ2VyLmZhdGFsKGBmYWlsIHRvIGZpbmQgJHt0aGlzLmdldFBhcmVudENyZWF0ZWRBdCgpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKG9iaiBpbnN0YW5jZW9mIENSRFRPYmplY3QpKSB7XG4gICAgICAgICAgICBsb2dnZXIuZmF0YWwoYGZhaWwgdG8gZXhlY3V0ZSwgb25seSBvYmplY3QgY2FuIGV4ZWN1dGUgc2V0YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9URShjaGFjaGE5MTIpOiBIYW5kbGUgY2FzZXMgd2hlcmUgb3BlcmF0aW9uIGNhbm5vdCBiZSBleGVjdXRlZCBkdXJpbmcgdW5kbyBhbmQgcmVkby5cbiAgICAgICAgaWYgKHNvdXJjZSA9PT0gT3BTb3VyY2UuVW5kb1JlZG8pIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBvYmo7XG4gICAgICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5nZXRSZW1vdmVkQXQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudCA9IChfYSA9IHJvb3QuZmluZEVsZW1lbnRQYWlyQnlDcmVhdGVkQXQocGFyZW50LmdldENyZWF0ZWRBdCgpKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gb2JqLmdldCh0aGlzLmtleSk7XG4gICAgICAgIGNvbnN0IHJldmVyc2VPcCA9IHRoaXMudG9SZXZlcnNlT3BlcmF0aW9uKHByZXZpb3VzVmFsdWUpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmFsdWUuZGVlcGNvcHkoKTtcbiAgICAgICAgY29uc3QgcmVtb3ZlZCA9IG9iai5zZXQodGhpcy5rZXksIHZhbHVlLCB0aGlzLmdldEV4ZWN1dGVkQXQoKSk7XG4gICAgICAgIC8vIE5PVEUoY2hhY2hhOTEyKTogV2hlbiByZXNldHRpbmcgZWxlbWVudHMgd2l0aCB0aGUgcHJlLWV4aXN0aW5nIGNyZWF0ZWRBdFxuICAgICAgICAvLyBkdXJpbmcgdW5kby9yZWRvLCBpdCdzIGVzc2VudGlhbCB0byBoYW5kbGUgcHJldmlvdXNseSB0b21ic3RvbmVkIGVsZW1lbnRzLlxuICAgICAgICAvLyBJbiBub24tR0MgbGFuZ3VhZ2VzLCB0aGVyZSBtYXkgYmUgYSBuZWVkIHRvIGV4ZWN1dGUgYm90aCBkZXJlZ2lzdGVyIGFuZCBwdXJnZS5cbiAgICAgICAgaWYgKHNvdXJjZSA9PT0gT3BTb3VyY2UuVW5kb1JlZG8gJiZcbiAgICAgICAgICAgIHJvb3QuZmluZEJ5Q3JlYXRlZEF0KHZhbHVlLmdldENyZWF0ZWRBdCgpKSkge1xuICAgICAgICAgICAgcm9vdC5kZXJlZ2lzdGVyRWxlbWVudCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcm9vdC5yZWdpc3RlckVsZW1lbnQodmFsdWUsIG9iaik7XG4gICAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgICAgICByb290LnJlZ2lzdGVyUmVtb3ZlZEVsZW1lbnQocmVtb3ZlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wSW5mb3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzZXQnLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiByb290LmNyZWF0ZVBhdGgodGhpcy5nZXRQYXJlbnRDcmVhdGVkQXQoKSksXG4gICAgICAgICAgICAgICAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICByZXZlcnNlT3AsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0b1JldmVyc2VPcGVyYXRpb25gIHJldHVybnMgdGhlIHJldmVyc2Ugb3BlcmF0aW9uIG9mIHRoaXMgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIHRvUmV2ZXJzZU9wZXJhdGlvbih2YWx1ZSkge1xuICAgICAgICBsZXQgcmV2ZXJzZU9wID0gUmVtb3ZlT3BlcmF0aW9uLmNyZWF0ZSh0aGlzLmdldFBhcmVudENyZWF0ZWRBdCgpLCB0aGlzLnZhbHVlLmdldENyZWF0ZWRBdCgpKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIXZhbHVlLmlzUmVtb3ZlZCgpKSB7XG4gICAgICAgICAgICByZXZlcnNlT3AgPSBTZXRPcGVyYXRpb24uY3JlYXRlKHRoaXMua2V5LCB2YWx1ZS5kZWVwY29weSgpLCB0aGlzLmdldFBhcmVudENyZWF0ZWRBdCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV2ZXJzZU9wO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0RWZmZWN0ZWRDcmVhdGVkQXRgIHJldHVybnMgdGhlIGNyZWF0aW9uIHRpbWUgb2YgdGhlIGVmZmVjdGVkIGVsZW1lbnQuXG4gICAgICovXG4gICAgZ2V0RWZmZWN0ZWRDcmVhdGVkQXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlLmdldENyZWF0ZWRBdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdG9UZXN0U3RyaW5nYCByZXR1cm5zIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1ldGEgZGF0YS5cbiAgICAgKi9cbiAgICB0b1Rlc3RTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmdldFBhcmVudENyZWF0ZWRBdCgpLnRvVGVzdFN0cmluZygpfS5TRVQuJHt0aGlzLmtleX09JHt0aGlzLnZhbHVlLnRvU29ydGVkSlNPTigpfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRLZXlgIHJldHVybnMgdGhlIGtleSBvZiB0aGlzIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBnZXRLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldFZhbHVlYCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGlzIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZG9jdW1lbnQvb3BlcmF0aW9uL2FkZF9vcGVyYXRpb24udHNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuXG4vKipcbiAqIGBBZGRPcGVyYXRpb25gIGlzIGFuIG9wZXJhdGlvbiByZXByZXNlbnRpbmcgYWRkaW5nIGFuIGVsZW1lbnQgdG8gYW4gQXJyYXkuXG4gKi9cbmNsYXNzIEFkZE9wZXJhdGlvbiBleHRlbmRzIE9wZXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IocGFyZW50Q3JlYXRlZEF0LCBwcmV2Q3JlYXRlZEF0LCB2YWx1ZSwgZXhlY3V0ZWRBdCkge1xuICAgICAgICBzdXBlcihwYXJlbnRDcmVhdGVkQXQsIGV4ZWN1dGVkQXQpO1xuICAgICAgICB0aGlzLnByZXZDcmVhdGVkQXQgPSBwcmV2Q3JlYXRlZEF0O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBjcmVhdGVgIGNyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgQWRkT3BlcmF0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUocGFyZW50Q3JlYXRlZEF0LCBwcmV2Q3JlYXRlZEF0LCB2YWx1ZSwgZXhlY3V0ZWRBdCkge1xuICAgICAgICByZXR1cm4gbmV3IEFkZE9wZXJhdGlvbihwYXJlbnRDcmVhdGVkQXQsIHByZXZDcmVhdGVkQXQsIHZhbHVlLCBleGVjdXRlZEF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGV4ZWN1dGVgIGV4ZWN1dGVzIHRoaXMgb3BlcmF0aW9uIG9uIHRoZSBnaXZlbiBgQ1JEVFJvb3RgLlxuICAgICAqL1xuICAgIGV4ZWN1dGUocm9vdCkge1xuICAgICAgICBjb25zdCBwYXJlbnRPYmplY3QgPSByb290LmZpbmRCeUNyZWF0ZWRBdCh0aGlzLmdldFBhcmVudENyZWF0ZWRBdCgpKTtcbiAgICAgICAgaWYgKCFwYXJlbnRPYmplY3QpIHtcbiAgICAgICAgICAgIGxvZ2dlci5mYXRhbChgZmFpbCB0byBmaW5kICR7dGhpcy5nZXRQYXJlbnRDcmVhdGVkQXQoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShwYXJlbnRPYmplY3QgaW5zdGFuY2VvZiBDUkRUQXJyYXkpKSB7XG4gICAgICAgICAgICBsb2dnZXIuZmF0YWwoYGZhaWwgdG8gZXhlY3V0ZSwgb25seSBhcnJheSBjYW4gZXhlY3V0ZSBhZGRgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcnJheSA9IHBhcmVudE9iamVjdDtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbHVlLmRlZXBjb3B5KCk7XG4gICAgICAgIGFycmF5Lmluc2VydEFmdGVyKHRoaXMucHJldkNyZWF0ZWRBdCwgdmFsdWUpO1xuICAgICAgICByb290LnJlZ2lzdGVyRWxlbWVudCh2YWx1ZSwgYXJyYXkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3BJbmZvczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2FkZCcsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IHJvb3QuY3JlYXRlUGF0aCh0aGlzLmdldFBhcmVudENyZWF0ZWRBdCgpKSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IE51bWJlcihhcnJheS5zdWJQYXRoT2YodGhpcy5nZXRFZmZlY3RlZENyZWF0ZWRBdCgpKSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRFZmZlY3RlZENyZWF0ZWRBdGAgcmV0dXJucyB0aGUgY3JlYXRpb24gdGltZSBvZiB0aGUgZWZmZWN0ZWQgZWxlbWVudC5cbiAgICAgKi9cbiAgICBnZXRFZmZlY3RlZENyZWF0ZWRBdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuZ2V0Q3JlYXRlZEF0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0b1Rlc3RTdHJpbmdgIHJldHVybnMgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgbWV0YSBkYXRhLlxuICAgICAqL1xuICAgIHRvVGVzdFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0UGFyZW50Q3JlYXRlZEF0KCkudG9UZXN0U3RyaW5nKCl9LkFERC4ke3RoaXMudmFsdWUudG9KU09OKCl9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldFByZXZDcmVhdGVkQXRgIHJldHVybnMgdGhlIGNyZWF0aW9uIHRpbWUgb2YgcHJldmlvdXMgZWxlbWVudC5cbiAgICAgKi9cbiAgICBnZXRQcmV2Q3JlYXRlZEF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2Q3JlYXRlZEF0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0VmFsdWVgIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoaXMgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kb2N1bWVudC9vcGVyYXRpb24vbW92ZV9vcGVyYXRpb24udHNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuXG4vKipcbiAqIGBNb3ZlT3BlcmF0aW9uYCBpcyBhbiBvcGVyYXRpb24gcmVwcmVzZW50aW5nIG1vdmluZyBhbiBlbGVtZW50IHRvIGFuIEFycmF5LlxuICovXG5jbGFzcyBNb3ZlT3BlcmF0aW9uIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRDcmVhdGVkQXQsIHByZXZDcmVhdGVkQXQsIGNyZWF0ZWRBdCwgZXhlY3V0ZWRBdCkge1xuICAgICAgICBzdXBlcihwYXJlbnRDcmVhdGVkQXQsIGV4ZWN1dGVkQXQpO1xuICAgICAgICB0aGlzLnByZXZDcmVhdGVkQXQgPSBwcmV2Q3JlYXRlZEF0O1xuICAgICAgICB0aGlzLmNyZWF0ZWRBdCA9IGNyZWF0ZWRBdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGNyZWF0ZWAgY3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBNb3ZlT3BlcmF0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUocGFyZW50Q3JlYXRlZEF0LCBwcmV2Q3JlYXRlZEF0LCBjcmVhdGVkQXQsIGV4ZWN1dGVkQXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNb3ZlT3BlcmF0aW9uKHBhcmVudENyZWF0ZWRBdCwgcHJldkNyZWF0ZWRBdCwgY3JlYXRlZEF0LCBleGVjdXRlZEF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGV4ZWN1dGVgIGV4ZWN1dGVzIHRoaXMgb3BlcmF0aW9uIG9uIHRoZSBnaXZlbiBgQ1JEVFJvb3RgLlxuICAgICAqL1xuICAgIGV4ZWN1dGUocm9vdCkge1xuICAgICAgICBjb25zdCBwYXJlbnRPYmplY3QgPSByb290LmZpbmRCeUNyZWF0ZWRBdCh0aGlzLmdldFBhcmVudENyZWF0ZWRBdCgpKTtcbiAgICAgICAgaWYgKCFwYXJlbnRPYmplY3QpIHtcbiAgICAgICAgICAgIGxvZ2dlci5mYXRhbChgZmFpbCB0byBmaW5kICR7dGhpcy5nZXRQYXJlbnRDcmVhdGVkQXQoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShwYXJlbnRPYmplY3QgaW5zdGFuY2VvZiBDUkRUQXJyYXkpKSB7XG4gICAgICAgICAgICBsb2dnZXIuZmF0YWwoYGZhaWwgdG8gZXhlY3V0ZSwgb25seSBhcnJheSBjYW4gZXhlY3V0ZSBtb3ZlYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJyYXkgPSBwYXJlbnRPYmplY3Q7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzSW5kZXggPSBOdW1iZXIoYXJyYXkuc3ViUGF0aE9mKHRoaXMuY3JlYXRlZEF0KSk7XG4gICAgICAgIGFycmF5Lm1vdmVBZnRlcih0aGlzLnByZXZDcmVhdGVkQXQsIHRoaXMuY3JlYXRlZEF0LCB0aGlzLmdldEV4ZWN1dGVkQXQoKSk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gTnVtYmVyKGFycmF5LnN1YlBhdGhPZih0aGlzLmNyZWF0ZWRBdCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3BJbmZvczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ21vdmUnLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiByb290LmNyZWF0ZVBhdGgodGhpcy5nZXRQYXJlbnRDcmVhdGVkQXQoKSksXG4gICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0luZGV4LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0RWZmZWN0ZWRDcmVhdGVkQXRgIHJldHVybnMgdGhlIGNyZWF0aW9uIHRpbWUgb2YgdGhlIGVmZmVjdGVkIGVsZW1lbnQuXG4gICAgICovXG4gICAgZ2V0RWZmZWN0ZWRDcmVhdGVkQXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZWRBdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRvVGVzdFN0cmluZ2AgcmV0dXJucyBhIHN0cmluZyBjb250YWluaW5nIHRoZSBtZXRhIGRhdGEuXG4gICAgICovXG4gICAgdG9UZXN0U3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRQYXJlbnRDcmVhdGVkQXQoKS50b1Rlc3RTdHJpbmcoKX0uTU9WRWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRQcmV2Q3JlYXRlZEF0YCByZXR1cm5zIHRoZSBjcmVhdGlvbiB0aW1lIG9mIHByZXZpb3VzIGVsZW1lbnQuXG4gICAgICovXG4gICAgZ2V0UHJldkNyZWF0ZWRBdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldkNyZWF0ZWRBdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldENyZWF0ZWRBdGAgcmV0dXJucyB0aGUgY3JlYXRpb24gdGltZSBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAgICovXG4gICAgZ2V0Q3JlYXRlZEF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVkQXQ7XG4gICAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZG9jdW1lbnQvY3JkdC9yaHQudHNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogYFJIVE5vZGVgIGlzIGEgbm9kZSBvZiBSSFQoUmVwbGljYXRlZCBIYXNodGFibGUpLlxuICovXG5jbGFzcyBSSFROb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIHZhbHVlLCB1cGRhdGVkQXQpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVkQXQgPSB1cGRhdGVkQXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBvZmAgY3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSSFROb2RlLlxuICAgICAqL1xuICAgIHN0YXRpYyBvZihrZXksIHZhbHVlLCBjcmVhdGVkQXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSSFROb2RlKGtleSwgdmFsdWUsIGNyZWF0ZWRBdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRLZXlgIHJldHVybnMgYSBrZXkgb2Ygbm9kZS5cbiAgICAgKi9cbiAgICBnZXRLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldFZhbHVlYCByZXR1cm5zIGEgdmFsdWUgb2Ygbm9kZS5cbiAgICAgKi9cbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRVcGRhdGVkQXQgYHJldHVybnMgdXBkYXRlZCB0aW1lIG9mIG5vZGUuXG4gICAgICovXG4gICAgZ2V0VXBkYXRlZEF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVkQXQ7XG4gICAgfVxufVxuLyoqXG4gKiBSSFQgaXMgcmVwbGljYXRlZCBoYXNoIHRhYmxlIGJ5IGNyZWF0aW9uIHRpbWUuXG4gKiBGb3IgbW9yZSBkZXRhaWxzIGFib3V0IFJIVDogQHNlZSBodHRwOi8vY3NsLnNra3UuZWR1L3BhcGVycy9qcGRjMTEucGRmXG4gKi9cbmNsYXNzIFJIVCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubm9kZU1hcEJ5S2V5ID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgY3JlYXRlYCBjcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJIVC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJIVCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgc2V0YCBzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4ga2V5LlxuICAgICAqL1xuICAgIHNldChrZXksIHZhbHVlLCBleGVjdXRlZEF0KSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLm5vZGVNYXBCeUtleS5nZXQoa2V5KTtcbiAgICAgICAgaWYgKHByZXYgPT09IHVuZGVmaW5lZCB8fCBleGVjdXRlZEF0LmFmdGVyKHByZXYuZ2V0VXBkYXRlZEF0KCkpKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gUkhUTm9kZS5vZihrZXksIHZhbHVlLCBleGVjdXRlZEF0KTtcbiAgICAgICAgICAgIHRoaXMubm9kZU1hcEJ5S2V5LnNldChrZXksIG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBoYXNgIHJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBleGlzdHMgb2YgdGhlIGdpdmVuIGtleSBvciBub3QuXG4gICAgICovXG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlTWFwQnlLZXkuaGFzKGtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRgIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBrZXkuXG4gICAgICovXG4gICAgZ2V0KGtleSkge1xuICAgICAgICBpZiAoIXRoaXMubm9kZU1hcEJ5S2V5LmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZU1hcEJ5S2V5LmdldChrZXkpLmdldFZhbHVlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBkZWVwY29weWAgY29waWVzIGl0c2VsZiBkZWVwbHkuXG4gICAgICovXG4gICAgZGVlcGNvcHkoKSB7XG4gICAgICAgIGNvbnN0IHJodCA9IG5ldyBSSFQoKTtcbiAgICAgICAgZm9yIChjb25zdCBbLCBub2RlXSBvZiB0aGlzLm5vZGVNYXBCeUtleSkge1xuICAgICAgICAgICAgcmh0LnNldChub2RlLmdldEtleSgpLCBub2RlLmdldFZhbHVlKCksIG5vZGUuZ2V0VXBkYXRlZEF0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0b0pTT05gIHJldHVybnMgdGhlIEpTT04gZW5jb2Rpbmcgb2YgdGhpcyBoYXNodGFibGUuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIG5vZGVdIG9mIHRoaXMubm9kZU1hcEJ5S2V5KSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGBcIiR7ZXNjYXBlU3RyaW5nKGtleSl9XCI6XCIke2VzY2FwZVN0cmluZyhub2RlLmdldFZhbHVlKCkpfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGB7JHtpdGVtcy5qb2luKCcsJyl9fWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0b1hNTGAgY29udmVydHMgdGhlIGdpdmVuIFJIVCB0byBYTUwgc3RyaW5nLlxuICAgICAqL1xuICAgIHRvWE1MKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2l6ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAgJHtbLi4udGhpcy5ub2RlTWFwQnlLZXldXG4gICAgICAgICAgICAubWFwKChbaywgdl0pID0+IGAke2t9PVwiJHtKU09OLnBhcnNlKHYuZ2V0VmFsdWUoKSl9XCJgKVxuICAgICAgICAgICAgLmpvaW4oJyAnKX1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgc2l6ZWAgcmV0dXJucyB0aGUgc2l6ZSBvZiBSSFRcbiAgICAgKi9cbiAgICBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlTWFwQnlLZXkuc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRvT2JqZWN0YCByZXR1cm5zIHRoZSBvYmplY3Qgb2YgdGhpcyBoYXNodGFibGUuXG4gICAgICovXG4gICAgdG9PYmplY3QoKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIG5vZGVdIG9mIHRoaXMubm9kZU1hcEJ5S2V5KSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IG5vZGUuZ2V0VmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBbLCBub2RlXSBvZiB0aGlzLm5vZGVNYXBCeUtleSkge1xuICAgICAgICAgICAgeWllbGQgbm9kZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2RvY3VtZW50L2NyZHQvdGV4dC50c1xuLypcbiAqIENvcHlyaWdodCAyMDIwIFRoZSBZb3JraWUgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuXG5cblxuXG4vKipcbiAqIGBUZXh0Q2hhbmdlVHlwZWAgaXMgdGhlIHR5cGUgb2YgVGV4dENoYW5nZS5cbiAqXG4gKi9cbnZhciBUZXh0Q2hhbmdlVHlwZTtcbihmdW5jdGlvbiAoVGV4dENoYW5nZVR5cGUpIHtcbiAgICBUZXh0Q2hhbmdlVHlwZVtcIkNvbnRlbnRcIl0gPSBcImNvbnRlbnRcIjtcbiAgICBUZXh0Q2hhbmdlVHlwZVtcIlN0eWxlXCJdID0gXCJzdHlsZVwiO1xufSkoVGV4dENoYW5nZVR5cGUgfHwgKFRleHRDaGFuZ2VUeXBlID0ge30pKTtcbi8qKlxuICogYENSRFRUZXh0VmFsdWVgIGlzIGEgdmFsdWUgb2YgVGV4dFxuICogd2hpY2ggaGFzIGEgYXR0cmlidXRlcyB0aGF0IGV4cHJlc3NlcyB0aGUgdGV4dCBzdHlsZS5cbiAqIEF0dHJpYnV0ZXMgYXJlIHJlcHJlc2VudGVkIGJ5IFJIVC5cbiAqXG4gKi9cbmNsYXNzIENSRFRUZXh0VmFsdWUge1xuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXG4gICAgY29uc3RydWN0b3IoY29udGVudCkge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBSSFQuY3JlYXRlKCk7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBjcmVhdGVgIGNyZWF0ZXMgYSBpbnN0YW5jZSBvZiBDUkRUVGV4dFZhbHVlLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoY29udGVudCkge1xuICAgICAgICByZXR1cm4gbmV3IENSRFRUZXh0VmFsdWUoY29udGVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBsZW5ndGhgIHJldHVybnMgdGhlIGxlbmd0aCBvZiB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHN1YnN0cmluZ2AgcmV0dXJucyBhIHN1Yi1zdHJpbmcgdmFsdWUgb2YgdGhlIGdpdmVuIHJhbmdlLlxuICAgICAqL1xuICAgIHN1YnN0cmluZyhpbmRleFN0YXJ0LCBpbmRleEVuZCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG5ldyBDUkRUVGV4dFZhbHVlKHRoaXMuY29udGVudC5zdWJzdHJpbmcoaW5kZXhTdGFydCwgaW5kZXhFbmQpKTtcbiAgICAgICAgdmFsdWUuYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcy5kZWVwY29weSgpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBzZXRBdHRyYCBzZXRzIGF0dHJpYnV0ZSBvZiB0aGUgZ2l2ZW4ga2V5LCB1cGRhdGVkIHRpbWUgYW5kIHZhbHVlLlxuICAgICAqL1xuICAgIHNldEF0dHIoa2V5LCBjb250ZW50LCB1cGRhdGVkQXQpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLnNldChrZXksIGNvbnRlbnQsIHVwZGF0ZWRBdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRBdHRyYCByZXR1cm5zIHRoZSBhdHRyaWJ1dGVzIG9mIHRoaXMgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0QXR0cnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0b1N0cmluZ2AgcmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmFsdWUuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0b0pTT05gIHJldHVybnMgdGhlIEpTT04gZW5jb2Rpbmcgb2YgdGhpcyB2YWx1ZS5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBlc2NhcGVTdHJpbmcodGhpcy5jb250ZW50KTtcbiAgICAgICAgY29uc3QgYXR0cnNPYmogPSB0aGlzLmF0dHJpYnV0ZXMudG9PYmplY3QoKTtcbiAgICAgICAgY29uc3QgYXR0cnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2XSBvZiBPYmplY3QuZW50cmllcyhhdHRyc09iaikpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gSlNPTi5wYXJzZSh2KTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyBgXCIke2VzY2FwZVN0cmluZyhrZXkpfVwiOlwiJHtlc2NhcGVTdHJpbmcodmFsdWUpfVwiYFxuICAgICAgICAgICAgICAgIDogYFwiJHtlc2NhcGVTdHJpbmcoa2V5KX1cIjoke1N0cmluZyh2YWx1ZSl9YDtcbiAgICAgICAgICAgIGF0dHJzLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0cnMuc29ydCgpO1xuICAgICAgICBpZiAoYXR0cnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYHtcInZhbFwiOlwiJHtjb250ZW50fVwifWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGB7XCJhdHRyc1wiOnske2F0dHJzLmpvaW4oJywnKX19LFwidmFsXCI6XCIke2NvbnRlbnR9XCJ9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldEF0dHJpYnV0ZXNgIHJldHVybnMgdGhlIGF0dHJpYnV0ZXMgb2YgdGhpcyB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXRBdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnRvT2JqZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRDb250ZW50YCByZXR1cm5zIHRoZSBpbnRlcm5hbCBjb250ZW50LlxuICAgICAqL1xuICAgIGdldENvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQ7XG4gICAgfVxufVxuLyoqXG4gKiAgYENSRFRUZXh0YCBpcyBhIGN1c3RvbSBDUkRUIGRhdGEgdHlwZSB0byByZXByZXNlbnQgdGhlIGNvbnRlbnRzIG9mIHRleHQgZWRpdG9ycy5cbiAqXG4gKi9cbmNsYXNzIENSRFRUZXh0IGV4dGVuZHMgQ1JEVEdDRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IocmdhVHJlZVNwbGl0LCBjcmVhdGVkQXQpIHtcbiAgICAgICAgc3VwZXIoY3JlYXRlZEF0KTtcbiAgICAgICAgdGhpcy5yZ2FUcmVlU3BsaXQgPSByZ2FUcmVlU3BsaXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBjcmVhdGVgIGEgaW5zdGFuY2Ugb2YgVGV4dC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKHJnYVRyZWVTcGxpdCwgY3JlYXRlZEF0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQ1JEVFRleHQocmdhVHJlZVNwbGl0LCBjcmVhdGVkQXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZWRpdGAgZWRpdHMgdGhlIGdpdmVuIHJhbmdlIHdpdGggdGhlIGdpdmVuIHZhbHVlIGFuZCBhdHRyaWJ1dGVzLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZWRpdChyYW5nZSwgY29udGVudCwgZWRpdGVkQXQsIGF0dHJpYnV0ZXMsIGxhdGVzdENyZWF0ZWRBdE1hcEJ5QWN0b3IpIHtcbiAgICAgICAgY29uc3QgY3JkdFRleHRWYWx1ZSA9IGNvbnRlbnQgPyBDUkRUVGV4dFZhbHVlLmNyZWF0ZShjb250ZW50KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGNyZHRUZXh0VmFsdWUgJiYgYXR0cmlidXRlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgICAgICBjcmR0VGV4dFZhbHVlLnNldEF0dHIoaywgdiwgZWRpdGVkQXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtjYXJldFBvcywgbGF0ZXN0Q3JlYXRlZEF0TWFwLCB2YWx1ZUNoYW5nZXNdID0gdGhpcy5yZ2FUcmVlU3BsaXQuZWRpdChyYW5nZSwgZWRpdGVkQXQsIGNyZHRUZXh0VmFsdWUsIGxhdGVzdENyZWF0ZWRBdE1hcEJ5QWN0b3IpO1xuICAgICAgICBjb25zdCBjaGFuZ2VzID0gdmFsdWVDaGFuZ2VzLm1hcCgoY2hhbmdlKSA9PiAoe1xuICAgICAgICAgICAgLi4uY2hhbmdlLFxuICAgICAgICAgICAgdmFsdWU6IGNoYW5nZS52YWx1ZVxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBwYXJzZU9iamVjdFZhbHVlcyhjaGFuZ2UudmFsdWUuZ2V0QXR0cmlidXRlcygpKSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogY2hhbmdlLnZhbHVlLmdldENvbnRlbnQoKSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogJycsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHR5cGU6IFRleHRDaGFuZ2VUeXBlLkNvbnRlbnQsXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIFtsYXRlc3RDcmVhdGVkQXRNYXAsIGNoYW5nZXMsIFtjYXJldFBvcywgY2FyZXRQb3NdXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHNldFN0eWxlYCBhcHBsaWVzIHRoZSBzdHlsZSBvZiB0aGUgZ2l2ZW4gcmFuZ2UuXG4gICAgICogMDEuIHNwbGl0IG5vZGVzIHdpdGggZnJvbSBhbmQgdG9cbiAgICAgKiAwMi4gc3R5bGUgbm9kZXMgYmV0d2VlbiBmcm9tIGFuZCB0b1xuICAgICAqXG4gICAgICogQHBhcmFtIHJhbmdlIC0gcmFuZ2Ugb2YgUkdBVHJlZVNwbGl0Tm9kZVxuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzIC0gc3R5bGUgYXR0cmlidXRlc1xuICAgICAqIEBwYXJhbSBlZGl0ZWRBdCAtIGVkaXRlZCB0aW1lXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc2V0U3R5bGUocmFuZ2UsIGF0dHJpYnV0ZXMsIGVkaXRlZEF0LCBsYXRlc3RDcmVhdGVkQXRNYXBCeUFjdG9yKSB7XG4gICAgICAgIC8vIDAxLiBzcGxpdCBub2RlcyB3aXRoIGZyb20gYW5kIHRvXG4gICAgICAgIGNvbnN0IFssIHRvUmlnaHRdID0gdGhpcy5yZ2FUcmVlU3BsaXQuZmluZE5vZGVXaXRoU3BsaXQocmFuZ2VbMV0sIGVkaXRlZEF0KTtcbiAgICAgICAgY29uc3QgWywgZnJvbVJpZ2h0XSA9IHRoaXMucmdhVHJlZVNwbGl0LmZpbmROb2RlV2l0aFNwbGl0KHJhbmdlWzBdLCBlZGl0ZWRBdCk7XG4gICAgICAgIC8vIDAyLiBzdHlsZSBub2RlcyBiZXR3ZWVuIGZyb20gYW5kIHRvXG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSB0aGlzLnJnYVRyZWVTcGxpdC5maW5kQmV0d2Vlbihmcm9tUmlnaHQsIHRvUmlnaHQpO1xuICAgICAgICBjb25zdCBjcmVhdGVkQXRNYXBCeUFjdG9yID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCB0b0JlU3R5bGVkcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdG9ySUQgPSBub2RlLmdldENyZWF0ZWRBdCgpLmdldEFjdG9ySUQoKTtcbiAgICAgICAgICAgIGNvbnN0IGxhdGVzdENyZWF0ZWRBdCA9IChsYXRlc3RDcmVhdGVkQXRNYXBCeUFjdG9yID09PSBudWxsIHx8IGxhdGVzdENyZWF0ZWRBdE1hcEJ5QWN0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhdGVzdENyZWF0ZWRBdE1hcEJ5QWN0b3Iuc2l6ZSlcbiAgICAgICAgICAgICAgICA/IGxhdGVzdENyZWF0ZWRBdE1hcEJ5QWN0b3IuaGFzKGFjdG9ySUQpXG4gICAgICAgICAgICAgICAgICAgID8gbGF0ZXN0Q3JlYXRlZEF0TWFwQnlBY3Rvci5nZXQoYWN0b3JJRClcbiAgICAgICAgICAgICAgICAgICAgOiBJbml0aWFsVGltZVRpY2tldFxuICAgICAgICAgICAgICAgIDogTWF4VGltZVRpY2tldDtcbiAgICAgICAgICAgIGlmIChub2RlLmNhblN0eWxlKGVkaXRlZEF0LCBsYXRlc3RDcmVhdGVkQXQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGF0ZXN0Q3JlYXRlZEF0ID0gY3JlYXRlZEF0TWFwQnlBY3Rvci5nZXQoYWN0b3JJRCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3JlYXRlZEF0ID0gbm9kZS5nZXRDcmVhdGVkQXQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWxhdGVzdENyZWF0ZWRBdCB8fCBjcmVhdGVkQXQuYWZ0ZXIobGF0ZXN0Q3JlYXRlZEF0KSkge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVkQXRNYXBCeUFjdG9yLnNldChhY3RvcklELCBjcmVhdGVkQXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b0JlU3R5bGVkcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0b0JlU3R5bGVkcykge1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNSZW1vdmVkKCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFtmcm9tSWR4LCB0b0lkeF0gPSB0aGlzLnJnYVRyZWVTcGxpdC5maW5kSW5kZXhlc0Zyb21SYW5nZShub2RlLmNyZWF0ZVBvc1JhbmdlKCkpO1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUZXh0Q2hhbmdlVHlwZS5TdHlsZSxcbiAgICAgICAgICAgICAgICBhY3RvcjogZWRpdGVkQXQuZ2V0QWN0b3JJRCgpLFxuICAgICAgICAgICAgICAgIGZyb206IGZyb21JZHgsXG4gICAgICAgICAgICAgICAgdG86IHRvSWR4LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHBhcnNlT2JqZWN0VmFsdWVzKGF0dHJpYnV0ZXMpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5nZXRWYWx1ZSgpLnNldEF0dHIoa2V5LCB2YWx1ZSwgZWRpdGVkQXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbY3JlYXRlZEF0TWFwQnlBY3RvciwgY2hhbmdlc107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBpbmRleFJhbmdlVG9Qb3NSYW5nZWAgcmV0dXJucyB0aGUgcG9zaXRpb24gcmFuZ2Ugb2YgdGhlIGdpdmVuIGluZGV4IHJhbmdlLlxuICAgICAqL1xuICAgIGluZGV4UmFuZ2VUb1Bvc1JhbmdlKGZyb21JZHgsIHRvSWR4KSB7XG4gICAgICAgIGNvbnN0IGZyb21Qb3MgPSB0aGlzLnJnYVRyZWVTcGxpdC5pbmRleFRvUG9zKGZyb21JZHgpO1xuICAgICAgICBpZiAoZnJvbUlkeCA9PT0gdG9JZHgpIHtcbiAgICAgICAgICAgIHJldHVybiBbZnJvbVBvcywgZnJvbVBvc107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtmcm9tUG9zLCB0aGlzLnJnYVRyZWVTcGxpdC5pbmRleFRvUG9zKHRvSWR4KV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBsZW5ndGhgIHJldHVybnMgc2l6ZSBvZiBSR0FUcmVlTGlzdC5cbiAgICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZ2FUcmVlU3BsaXQubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgY2hlY2tXZWlnaHRgIHJldHVybnMgZmFsc2Ugd2hlbiB0aGVyZSBpcyBhbiBpbmNvcnJlY3Qgd2VpZ2h0IG5vZGUuXG4gICAgICogZm9yIGRlYnVnZ2luZyBwdXJwb3NlLlxuICAgICAqL1xuICAgIGNoZWNrV2VpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZ2FUcmVlU3BsaXQuY2hlY2tXZWlnaHQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRvSlNPTmAgcmV0dXJucyB0aGUgSlNPTiBlbmNvZGluZyBvZiB0aGlzIHRleHQuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBqc29uID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLnJnYVRyZWVTcGxpdCkge1xuICAgICAgICAgICAgaWYgKCFub2RlLmlzUmVtb3ZlZCgpKSB7XG4gICAgICAgICAgICAgICAganNvbi5wdXNoKG5vZGUuZ2V0VmFsdWUoKS50b0pTT04oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBbJHtqc29uLmpvaW4oJywnKX1dYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRvU29ydGVkSlNPTmAgcmV0dXJucyB0aGUgc29ydGVkIEpTT04gZW5jb2Rpbmcgb2YgdGhpcyB0ZXh0LlxuICAgICAqL1xuICAgIHRvU29ydGVkSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9KU09OKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0b0pTRm9yVGVzdGAgcmV0dXJucyB2YWx1ZSB3aXRoIG1ldGEgZGF0YSBmb3IgdGVzdGluZy5cbiAgICAgKi9cbiAgICB0b0pTRm9yVGVzdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmdldENyZWF0ZWRBdCgpLnRvVGVzdFN0cmluZygpLFxuICAgICAgICAgICAgdmFsdWU6IEpTT04ucGFyc2UodGhpcy50b0pTT04oKSksXG4gICAgICAgICAgICB0eXBlOiAnWU9SS0lFX1RFWFQnLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdG9TdHJpbmdgIHJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHRleHQuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJnYVRyZWVTcGxpdC50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdmFsdWVzYCByZXR1cm5zIHRoZSBjb250ZW50LWF0dHJpYnV0ZXMgcGFpciBhcnJheSBvZiB0aGlzIHRleHQuXG4gICAgICovXG4gICAgdmFsdWVzKCkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMucmdhVHJlZVNwbGl0KSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUuaXNSZW1vdmVkKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5vZGUuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHBhcnNlT2JqZWN0VmFsdWVzKHZhbHVlLmdldEF0dHJpYnV0ZXMoKSksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHZhbHVlLmdldENvbnRlbnQoKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0UkdBVHJlZVNwbGl0YCByZXR1cm5zIHJnYVRyZWVTcGxpdC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGdldFJHQVRyZWVTcGxpdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmdhVHJlZVNwbGl0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdG9UZXN0U3RyaW5nYCByZXR1cm5zIGEgU3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1ldGEgZGF0YSBvZiB0aGlzIHZhbHVlXG4gICAgICogZm9yIGRlYnVnZ2luZyBwdXJwb3NlLlxuICAgICAqL1xuICAgIHRvVGVzdFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmdhVHJlZVNwbGl0LnRvVGVzdFN0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0UmVtb3ZlZE5vZGVzTGVuYCByZXR1cm5zIGxlbmd0aCBvZiByZW1vdmVkIG5vZGVzXG4gICAgICovXG4gICAgZ2V0UmVtb3ZlZE5vZGVzTGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZ2FUcmVlU3BsaXQuZ2V0UmVtb3ZlZE5vZGVzTGVuKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBwdXJnZVJlbW92ZWROb2Rlc0JlZm9yZWAgcHVyZ2VzIHJlbW92ZWQgbm9kZXMgYmVmb3JlIHRoZSBnaXZlbiB0aW1lLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVyZ2VSZW1vdmVkTm9kZXNCZWZvcmUodGlja2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJnYVRyZWVTcGxpdC5wdXJnZVJlbW92ZWROb2Rlc0JlZm9yZSh0aWNrZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZGVlcGNvcHlgIGNvcGllcyBpdHNlbGYgZGVlcGx5LlxuICAgICAqL1xuICAgIGRlZXBjb3B5KCkge1xuICAgICAgICBjb25zdCB0ZXh0ID0gbmV3IENSRFRUZXh0KHRoaXMucmdhVHJlZVNwbGl0LmRlZXBjb3B5KCksIHRoaXMuZ2V0Q3JlYXRlZEF0KCkpO1xuICAgICAgICB0ZXh0LnJlbW92ZSh0aGlzLmdldFJlbW92ZWRBdCgpKTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBmaW5kSW5kZXhlc0Zyb21SYW5nZWAgcmV0dXJucyBwYWlyIG9mIGludGVnZXIgb2Zmc2V0cyBvZiB0aGUgZ2l2ZW4gcmFuZ2UuXG4gICAgICovXG4gICAgZmluZEluZGV4ZXNGcm9tUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmdhVHJlZVNwbGl0LmZpbmRJbmRleGVzRnJvbVJhbmdlKHJhbmdlKTtcbiAgICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kb2N1bWVudC9vcGVyYXRpb24vZWRpdF9vcGVyYXRpb24udHNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuXG4vKipcbiAqIGBFZGl0T3BlcmF0aW9uYCBpcyBhbiBvcGVyYXRpb24gcmVwcmVzZW50aW5nIGVkaXRpbmcgVGV4dC4gTW9zdCBvZiB0aGUgc2FtZSBhc1xuICogRWRpdCwgYnV0IHdpdGggYWRkaXRpb25hbCBzdHlsZSBwcm9wZXJ0aWVzLCBhdHRyaWJ1dGVzLlxuICovXG5jbGFzcyBFZGl0T3BlcmF0aW9uIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRDcmVhdGVkQXQsIGZyb21Qb3MsIHRvUG9zLCBtYXhDcmVhdGVkQXRNYXBCeUFjdG9yLCBjb250ZW50LCBhdHRyaWJ1dGVzLCBleGVjdXRlZEF0KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudENyZWF0ZWRBdCwgZXhlY3V0ZWRBdCk7XG4gICAgICAgIHRoaXMuZnJvbVBvcyA9IGZyb21Qb3M7XG4gICAgICAgIHRoaXMudG9Qb3MgPSB0b1BvcztcbiAgICAgICAgdGhpcy5tYXhDcmVhdGVkQXRNYXBCeUFjdG9yID0gbWF4Q3JlYXRlZEF0TWFwQnlBY3RvcjtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGNyZWF0ZWAgY3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBFZGl0T3BlcmF0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUocGFyZW50Q3JlYXRlZEF0LCBmcm9tUG9zLCB0b1BvcywgbWF4Q3JlYXRlZEF0TWFwQnlBY3RvciwgY29udGVudCwgYXR0cmlidXRlcywgZXhlY3V0ZWRBdCkge1xuICAgICAgICByZXR1cm4gbmV3IEVkaXRPcGVyYXRpb24ocGFyZW50Q3JlYXRlZEF0LCBmcm9tUG9zLCB0b1BvcywgbWF4Q3JlYXRlZEF0TWFwQnlBY3RvciwgY29udGVudCwgYXR0cmlidXRlcywgZXhlY3V0ZWRBdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBleGVjdXRlYCBleGVjdXRlcyB0aGlzIG9wZXJhdGlvbiBvbiB0aGUgZ2l2ZW4gYENSRFRSb290YC5cbiAgICAgKi9cbiAgICBleGVjdXRlKHJvb3QpIHtcbiAgICAgICAgY29uc3QgcGFyZW50T2JqZWN0ID0gcm9vdC5maW5kQnlDcmVhdGVkQXQodGhpcy5nZXRQYXJlbnRDcmVhdGVkQXQoKSk7XG4gICAgICAgIGlmICghcGFyZW50T2JqZWN0KSB7XG4gICAgICAgICAgICBsb2dnZXIuZmF0YWwoYGZhaWwgdG8gZmluZCAke3RoaXMuZ2V0UGFyZW50Q3JlYXRlZEF0KCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEocGFyZW50T2JqZWN0IGluc3RhbmNlb2YgQ1JEVFRleHQpKSB7XG4gICAgICAgICAgICBsb2dnZXIuZmF0YWwoYGZhaWwgdG8gZXhlY3V0ZSwgb25seSBUZXh0IGNhbiBleGVjdXRlIGVkaXRgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0ID0gcGFyZW50T2JqZWN0O1xuICAgICAgICBjb25zdCBbLCBjaGFuZ2VzXSA9IHRleHQuZWRpdChbdGhpcy5mcm9tUG9zLCB0aGlzLnRvUG9zXSwgdGhpcy5jb250ZW50LCB0aGlzLmdldEV4ZWN1dGVkQXQoKSwgT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuYXR0cmlidXRlcyksIHRoaXMubWF4Q3JlYXRlZEF0TWFwQnlBY3Rvcik7XG4gICAgICAgIGlmICghdGhpcy5mcm9tUG9zLmVxdWFscyh0aGlzLnRvUG9zKSkge1xuICAgICAgICAgICAgcm9vdC5yZWdpc3RlckVsZW1lbnRIYXNSZW1vdmVkTm9kZXModGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wSW5mb3M6IGNoYW5nZXMubWFwKCh7IGZyb20sIHRvLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2VkaXQnLFxuICAgICAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IHJvb3QuY3JlYXRlUGF0aCh0aGlzLmdldFBhcmVudENyZWF0ZWRBdCgpKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRFZmZlY3RlZENyZWF0ZWRBdGAgcmV0dXJucyB0aGUgY3JlYXRpb24gdGltZSBvZiB0aGUgZWZmZWN0ZWQgZWxlbWVudC5cbiAgICAgKi9cbiAgICBnZXRFZmZlY3RlZENyZWF0ZWRBdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFyZW50Q3JlYXRlZEF0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0b1Rlc3RTdHJpbmdgIHJldHVybnMgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgbWV0YSBkYXRhLlxuICAgICAqL1xuICAgIHRvVGVzdFN0cmluZygpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnRDcmVhdGVkQXQoKS50b1Rlc3RTdHJpbmcoKTtcbiAgICAgICAgY29uc3QgZnJvbVBvcyA9IHRoaXMuZnJvbVBvcy50b1Rlc3RTdHJpbmcoKTtcbiAgICAgICAgY29uc3QgdG9Qb3MgPSB0aGlzLnRvUG9zLnRvVGVzdFN0cmluZygpO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5jb250ZW50O1xuICAgICAgICByZXR1cm4gYCR7cGFyZW50fS5FRElUKCR7ZnJvbVBvc30sJHt0b1Bvc30sJHtjb250ZW50fSlgO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0RnJvbVBvc2AgcmV0dXJucyB0aGUgc3RhcnQgcG9pbnQgb2YgdGhlIGVkaXRpbmcgcmFuZ2UuXG4gICAgICovXG4gICAgZ2V0RnJvbVBvcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVBvcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldFRvUG9zYCByZXR1cm5zIHRoZSBlbmQgcG9pbnQgb2YgdGhlIGVkaXRpbmcgcmFuZ2UuXG4gICAgICovXG4gICAgZ2V0VG9Qb3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvUG9zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0Q29udGVudGAgcmV0dXJucyB0aGUgY29udGVudCBvZiBFZGl0LlxuICAgICAqL1xuICAgIGdldENvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRBdHRyaWJ1dGVzYCByZXR1cm5zIHRoZSBhdHRyaWJ1dGVzIG9mIHRoaXMgRWRpdC5cbiAgICAgKi9cbiAgICBnZXRBdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzIHx8IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldE1heENyZWF0ZWRBdE1hcEJ5QWN0b3JgIHJldHVybnMgdGhlIG1hcCB0aGF0IHN0b3JlcyB0aGUgbGF0ZXN0IGNyZWF0aW9uIHRpbWVcbiAgICAgKiBieSBhY3RvciBmb3IgdGhlIG5vZGVzIGluY2x1ZGVkIGluIHRoZSBlZGl0aW5nIHJhbmdlLlxuICAgICAqL1xuICAgIGdldE1heENyZWF0ZWRBdE1hcEJ5QWN0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1heENyZWF0ZWRBdE1hcEJ5QWN0b3I7XG4gICAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZG9jdW1lbnQvb3BlcmF0aW9uL3N0eWxlX29wZXJhdGlvbi50c1xuLypcbiAqIENvcHlyaWdodCAyMDIwIFRoZSBZb3JraWUgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuXG5cbi8qKlxuICogIGBTdHlsZU9wZXJhdGlvbmAgaXMgYW4gb3BlcmF0aW9uIGFwcGxpZXMgdGhlIHN0eWxlIG9mIHRoZSBnaXZlbiByYW5nZSB0byBUZXh0LlxuICovXG5jbGFzcyBTdHlsZU9wZXJhdGlvbiBleHRlbmRzIE9wZXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IocGFyZW50Q3JlYXRlZEF0LCBmcm9tUG9zLCB0b1BvcywgbWF4Q3JlYXRlZEF0TWFwQnlBY3RvciwgYXR0cmlidXRlcywgZXhlY3V0ZWRBdCkge1xuICAgICAgICBzdXBlcihwYXJlbnRDcmVhdGVkQXQsIGV4ZWN1dGVkQXQpO1xuICAgICAgICB0aGlzLmZyb21Qb3MgPSBmcm9tUG9zO1xuICAgICAgICB0aGlzLnRvUG9zID0gdG9Qb3M7XG4gICAgICAgIHRoaXMubWF4Q3JlYXRlZEF0TWFwQnlBY3RvciA9IG1heENyZWF0ZWRBdE1hcEJ5QWN0b3I7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBjcmVhdGVgIGNyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgU3R5bGVPcGVyYXRpb24uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShwYXJlbnRDcmVhdGVkQXQsIGZyb21Qb3MsIHRvUG9zLCBtYXhDcmVhdGVkQXRNYXBCeUFjdG9yLCBhdHRyaWJ1dGVzLCBleGVjdXRlZEF0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3R5bGVPcGVyYXRpb24ocGFyZW50Q3JlYXRlZEF0LCBmcm9tUG9zLCB0b1BvcywgbWF4Q3JlYXRlZEF0TWFwQnlBY3RvciwgYXR0cmlidXRlcywgZXhlY3V0ZWRBdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBleGVjdXRlYCBleGVjdXRlcyB0aGlzIG9wZXJhdGlvbiBvbiB0aGUgZ2l2ZW4gYENSRFRSb290YC5cbiAgICAgKi9cbiAgICBleGVjdXRlKHJvb3QpIHtcbiAgICAgICAgY29uc3QgcGFyZW50T2JqZWN0ID0gcm9vdC5maW5kQnlDcmVhdGVkQXQodGhpcy5nZXRQYXJlbnRDcmVhdGVkQXQoKSk7XG4gICAgICAgIGlmICghcGFyZW50T2JqZWN0KSB7XG4gICAgICAgICAgICBsb2dnZXIuZmF0YWwoYGZhaWwgdG8gZmluZCAke3RoaXMuZ2V0UGFyZW50Q3JlYXRlZEF0KCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEocGFyZW50T2JqZWN0IGluc3RhbmNlb2YgQ1JEVFRleHQpKSB7XG4gICAgICAgICAgICBsb2dnZXIuZmF0YWwoYGZhaWwgdG8gZXhlY3V0ZSwgb25seSBUZXh0IGNhbiBleGVjdXRlIGVkaXRgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0ID0gcGFyZW50T2JqZWN0O1xuICAgICAgICBjb25zdCBbLCBjaGFuZ2VzXSA9IHRleHQuc2V0U3R5bGUoW3RoaXMuZnJvbVBvcywgdGhpcy50b1Bvc10sIHRoaXMuYXR0cmlidXRlcyA/IE9iamVjdC5mcm9tRW50cmllcyh0aGlzLmF0dHJpYnV0ZXMpIDoge30sIHRoaXMuZ2V0RXhlY3V0ZWRBdCgpLCB0aGlzLm1heENyZWF0ZWRBdE1hcEJ5QWN0b3IpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3BJbmZvczogY2hhbmdlcy5tYXAoKHsgZnJvbSwgdG8sIHZhbHVlIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3R5bGUnLFxuICAgICAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IHJvb3QuY3JlYXRlUGF0aCh0aGlzLmdldFBhcmVudENyZWF0ZWRBdCgpKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRFZmZlY3RlZENyZWF0ZWRBdGAgcmV0dXJucyB0aGUgY3JlYXRpb24gdGltZSBvZiB0aGUgZWZmZWN0ZWQgZWxlbWVudC5cbiAgICAgKi9cbiAgICBnZXRFZmZlY3RlZENyZWF0ZWRBdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFyZW50Q3JlYXRlZEF0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0b1Rlc3RTdHJpbmdgIHJldHVybnMgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgbWV0YSBkYXRhLlxuICAgICAqL1xuICAgIHRvVGVzdFN0cmluZygpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnRDcmVhdGVkQXQoKS50b1Rlc3RTdHJpbmcoKTtcbiAgICAgICAgY29uc3QgZnJvbVBvcyA9IHRoaXMuZnJvbVBvcy50b1Rlc3RTdHJpbmcoKTtcbiAgICAgICAgY29uc3QgdG9Qb3MgPSB0aGlzLnRvUG9zLnRvVGVzdFN0cmluZygpO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgICAgICByZXR1cm4gYCR7cGFyZW50fS5TVFlMKCR7ZnJvbVBvc30sJHt0b1Bvc30sJHtKU09OLnN0cmluZ2lmeShhdHRyaWJ1dGVzKX0pYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldEZyb21Qb3NgIHJldHVybnMgdGhlIHN0YXJ0IHBvaW50IG9mIHRoZSBlZGl0aW5nIHJhbmdlLlxuICAgICAqL1xuICAgIGdldEZyb21Qb3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21Qb3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRUb1Bvc2AgcmV0dXJucyB0aGUgZW5kIHBvaW50IG9mIHRoZSBlZGl0aW5nIHJhbmdlLlxuICAgICAqL1xuICAgIGdldFRvUG9zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1BvcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldEF0dHJpYnV0ZXNgIHJldHVybnMgdGhlIGF0dHJpYnV0ZXMgb2YgdGhpcyBvcGVyYXRpb24uXG4gICAgICovXG4gICAgZ2V0QXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldE1heENyZWF0ZWRBdE1hcEJ5QWN0b3JgIHJldHVybnMgdGhlIG1hcCB0aGF0IHN0b3JlcyB0aGUgbGF0ZXN0IGNyZWF0aW9uIHRpbWVcbiAgICAgKiBieSBhY3RvciBmb3IgdGhlIG5vZGVzIGluY2x1ZGVkIGluIHRoZSBlZGl0aW5nIHJhbmdlLlxuICAgICAqL1xuICAgIGdldE1heENyZWF0ZWRBdE1hcEJ5QWN0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1heENyZWF0ZWRBdE1hcEJ5QWN0b3I7XG4gICAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9pbmRleF90cmVlLnRzXG4vKlxuICogQ29weXJpZ2h0IDIwMjMgVGhlIFlvcmtpZSBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBYm91dCBgaW5kZXhgLCBgcGF0aGAsIGBzaXplYCBhbmQgYFRyZWVQb3NgIGluIGNyZHQuSW5kZXhUcmVlLlxuICpcbiAqIGBpbmRleGAgb2YgY3JkdC5JbmRleFRyZWUgcmVwcmVzZW50cyBhIGFic29sdXRlIHBvc2l0aW9uIG9mIGEgbm9kZSBpbiB0aGUgdHJlZS5cbiAqIGBzaXplYCBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgcmVsYXRpdmUgaW5kZXggb2Ygbm9kZXMgaW4gdGhlIHRyZWUuXG4gKiBgaW5kZXhgIGluIHlvcmtpZS5JbmRleFRyZWUgaW5zcGlyZWQgYnkgUHJvc2VNaXJyb3IncyBpbmRleC5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgZW1wdHkgcGFyYWdyYXBoJ3Mgc2l6ZSBpcyAwIGFuZCBpbmRleCAwIGlzIHRoZSBwb3NpdGlvbiBvZiB0aGU6XG4gKiAgICAwXG4gKiA8cD4gPC9wPiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuc2l6ZSA9IDBcbiAqXG4gKiBJZiBhIHBhcmFncmFwaCBoYXMgPGk+LCBpdHMgc2l6ZSBiZWNvbWVzIDIgYW5kIHRoZXJlIGFyZSAzIGluZGV4ZXM6XG4gKiAgICAgMCAgIDEgICAgMlxuICogIDxwPiA8aT4gPC9pPiA8L3A+ICAgICAgICAgICAgICAgICAgICAgICBwLnNpemUgPSAyLCBpLnNpemUgPSAwXG4gKlxuICogSWYgdGhlIHBhcmFncmFwaCBoYXMgPGk+IGFuZCA8Yj4sIGl0cyBzaXplIGJlY29tZXMgNDpcbiAqICAgICAwICAgMSAgICAyICAgMyAgIDRcbiAqICA8cD4gPGk+IDwvaT4gPGI+IDwvYj4gPC9wPiAgICAgICAgICAgICAgcC5zaXplID0gNCwgaS5zaXplID0gMCwgYi5zaXplID0gMFxuICogICAgIDAgICAxICAgIDIgICAzICAgIDQgICAgNSAgIDZcbiAqICA8cD4gPGk+IDwvaT4gPGI+IDwvYj4gPHM+IDwvcz4gPC9wPiAgICAgcC5zaXplID0gNiwgaS5zaXplID0gMCwgYi5zaXplID0gMCwgcy5zaXplID0gMFxuICpcbiAqIElmIGEgcGFyYWdyYXBoIGhhcyB0ZXh0LCBpdHMgc2l6ZSBiZWNvbWVzIGxlbmd0aCBvZiB0aGUgY2hhcmFjdGVyczpcbiAqICAgICAwIDEgMiAzXG4gKiAgPHA+IEEgQiBDIDwvcD4gICAgICAgICAgICAgICAgICAgICAgICAgIHAuc2l6ZSA9IDMsICAgdGV4dC5zaXplID0gM1xuICpcbiAqIFNvIHRoZSBzaXplIG9mIGEgbm9kZSBpcyB0aGUgc3VtIG9mIHRoZSBzaXplIGFuZCB0eXBlIG9mIGl0cyBjaGlsZHJlbjpcbiAqICBgc2l6ZSA9IGNoaWxkcmVuKGVsZW1lbnQgdHlwZSkubGVuZ3RoICogMiArIGNoaWxkcmVuLnJlZHVjZSgoY2hpbGQsIGFjYykgPT4gY2hpbGQuc2l6ZSArIGFjYywgMClgXG4gKlxuICogYFRyZWVQb3NgIGlzIGFsc28gdXNlZCB0byByZXByZXNlbnQgdGhlIHBvc2l0aW9uIGluIHRoZSB0cmVlLiBJdCBjb250YWlucyBub2RlIGFuZCBvZmZzZXQuXG4gKiBgVHJlZVBvc2AgY2FuIGJlIGNvbnZlcnRlZCB0byBgaW5kZXhgIGFuZCB2aWNlIHZlcnNhLlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiBhIHBhcmFncmFwaCBoYXMgPGk+LCB0aGVyZSBhcmUgMyBpbmRleGVzOlxuICogICAgIDAgICAxICAgIDJcbiAqICA8cD4gPGk+IDwvaT4gPC9wPiAgICAgICAgICAgICAgICAgICAgICAgcC5zaXplID0gMiwgaS5zaXplID0gMFxuICpcbiAqIEluIHRoaXMgY2FzZSwgaW5kZXggb2YgVHJlZVBvcyhwLCAwKSBpcyAwLCBpbmRleCBvZiBUcmVlUG9zKHAsIDEpIGlzIDIuXG4gKiBJbmRleCAxIGNhbiBiZSBjb252ZXJ0ZWQgdG8gVHJlZVBvcyhpLCAwKS5cbiAqXG4gKiBgcGF0aGAgb2YgY3JkdC5JbmRleFRyZWUgcmVwcmVzZW50cyBhIHBvc2l0aW9uIGxpa2UgYGluZGV4YCBpbiBjcmR0LkluZGV4VHJlZS5cbiAqIEl0IGNvbnRhaW5zIG9mZnNldHMgb2YgZWFjaCBub2RlIGZyb20gdGhlIHJvb3Qgbm9kZSBhcyBlbGVtZW50cyBleGNlcHQgdGhlIGxhc3QuXG4gKiBUaGUgbGFzdCBlbGVtZW50IG9mIHRoZSBwYXRoIHJlcHJlc2VudHMgdGhlIHBvc2l0aW9uIGluIHRoZSBwYXJlbnQgbm9kZS5cbiAqXG4gKiBMZXQncyBzYXkgd2UgaGF2ZSBhIHRyZWUgbGlrZSB0aGlzOlxuICogICAgICAgICAgICAgICAgICAgICAwIDEgMlxuICogPHA+IDxpPiBhIGIgPC9pPiA8Yj4gYyBkIDwvYj4gPC9wPlxuICpcbiAqIFRoZSBwYXRoIG9mIHRoZSBwb3NpdGlvbiBiZXR3ZWVuICdjJyBhbmQgJ2QnIGlzIFsxLCAxXS4gVGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlXG4gKiBwYXRoIGlzIHRoZSBvZmZzZXQgb2YgdGhlIDxiPiBpbiA8cD4gYW5kIHRoZSBzZWNvbmQgZWxlbWVudCByZXByZXNlbnRzIHRoZSBwb3NpdGlvblxuICogYmV0d2VlbiAnYycgYW5kICdkJyBpbiA8Yj4uXG4gKi9cbi8qKlxuICogYEVsZW1lbnRQYWRkaW5nU2l6ZWAgaXMgdGhlIHNpemUgb2YgYW4gZWxlbWVudCBub2RlIGFzIGEgY2hpbGQgb2YgYW5vdGhlciBlbGVtZW50IG5vZGUuXG4gKiBCZWNhdXNlIGFuIGVsZW1lbnQgbm9kZSBjb3VsZCBiZSBjb25zaWRlcmVkIGFzIGEgcGFpciBvZiBvcGVuIGFuZCBjbG9zZSB0YWdzLlxuICovXG5jb25zdCBFbGVtZW50UGFkZGluZ1NpemUgPSAyO1xuLyoqXG4gKiBgRGVmYXVsdFJvb3RUeXBlYCBpcyB0aGUgZGVmYXVsdCB0eXBlIG9mIHRoZSByb290IG5vZGUuXG4gKiBJdCBpcyB1c2VkIHdoZW4gdGhlIHR5cGUgb2YgdGhlIHJvb3Qgbm9kZSBpcyBub3Qgc3BlY2lmaWVkLlxuICovXG5jb25zdCBEZWZhdWx0Um9vdFR5cGUgPSAncm9vdCc7XG4vKipcbiAqIGBEZWZhdWx0VGV4dFR5cGVgIGlzIHRoZSBkZWZhdWx0IHR5cGUgb2YgdGhlIHRleHQgbm9kZS5cbiAqIEl0IGlzIHVzZWQgd2hlbiB0aGUgdHlwZSBvZiB0aGUgdGV4dCBub2RlIGlzIG5vdCBzcGVjaWZpZWQuXG4gKi9cbmNvbnN0IERlZmF1bHRUZXh0VHlwZSA9ICd0ZXh0Jztcbi8qKlxuICogYGFkZFNpemVPZkxlZnRTaWJsaW5nc2AgcmV0dXJucyB0aGUgc2l6ZSBvZiBsZWZ0IHNpYmxpbmdzIG9mIHRoZSBnaXZlbiBvZmZzZXQuXG4gKi9cbmZ1bmN0aW9uIGFkZFNpemVPZkxlZnRTaWJsaW5ncyhwYXJlbnQsIG9mZnNldCkge1xuICAgIGxldCBhY2MgPSAwO1xuICAgIGNvbnN0IHNpYmxpbmdzID0gcGFyZW50LmNoaWxkcmVuO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2Zmc2V0OyBpKyspIHtcbiAgICAgICAgY29uc3QgbGVmdFNpYmxpbmcgPSBzaWJsaW5nc1tpXTtcbiAgICAgICAgaWYgKCFsZWZ0U2libGluZyB8fCBsZWZ0U2libGluZy5pc1JlbW92ZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGFjYyArPSBsZWZ0U2libGluZy5wYWRkZWRTaXplO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xufVxuLyoqXG4gKiBgSW5kZXhUcmVlTm9kZWAgaXMgdGhlIG5vZGUgb2YgSW5kZXhUcmVlLiBJdCBpcyB1c2VkIHRvIHJlcHJlc2VudCB0aGVcbiAqIGRvY3VtZW50IG9mIHRleHQtYmFzZWQgZWRpdG9ycy5cbiAqL1xuY2xhc3MgSW5kZXhUcmVlTm9kZSB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgY2hpbGRyZW4gPSBbXSkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICBpZiAodGhpcy5pc1RleHQgJiYgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZXh0IG5vZGUgY2Fubm90IGhhdmUgY2hpbGRyZW46ICR7dGhpcy50eXBlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB1cGRhdGVBbmNlc3RvcnNTaXplYCB1cGRhdGVzIHRoZSBzaXplIG9mIHRoZSBhbmNlc3RvcnMuXG4gICAgICovXG4gICAgdXBkYXRlQW5jZXN0b3JzU2l6ZSgpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICBjb25zdCBzaWduID0gdGhpcy5pc1JlbW92ZWQgPyAtMSA6IDE7XG4gICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudC5zaXplICs9IHRoaXMucGFkZGVkU2l6ZSAqIHNpZ247XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBpc1RleHRgIHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBpcyBhIHRleHQgbm9kZS5cbiAgICAgKi9cbiAgICBnZXQgaXNUZXh0KCkge1xuICAgICAgICAvLyBUT0RPKGhhY2tlcndpbnMpOiBXZSBuZWVkIHRvIGdldCB0aGUgdHlwZSBvZiB0ZXh0IG5vZGUgZnJvbSB1c2VyLlxuICAgICAgICAvLyBDb25zaWRlciB0aGUgdXNlIHNjaGVtYSB0byBnZXQgdGhlIHR5cGUgb2YgdGV4dCBub2RlLlxuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBEZWZhdWx0VGV4dFR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBwYWRkZWRTaXplYCByZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBub2RlIGluY2x1ZGluZyBwYWRkaW5nIHNpemUuXG4gICAgICovXG4gICAgZ2V0IHBhZGRlZFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgKyAodGhpcy5pc1RleHQgPyAwIDogRWxlbWVudFBhZGRpbmdTaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGlzQW5jZW5zdG9yT2ZgIHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBpcyBhbiBhbmNlc3RvciBvZiB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAgKi9cbiAgICBpc0FuY2VzdG9yT2Yobm9kZSkge1xuICAgICAgICByZXR1cm4gYW5jZXN0b3JPZih0aGlzLCBub2RlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYG5leHRTaWJsaW5nYCByZXR1cm5zIHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhlIG5vZGUuXG4gICAgICovXG4gICAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLnBhcmVudC5maW5kT2Zmc2V0KHRoaXMpO1xuICAgICAgICBjb25zdCBzaWJsaW5nID0gdGhpcy5wYXJlbnQuY2hpbGRyZW5bb2Zmc2V0ICsgMV07XG4gICAgICAgIGlmIChzaWJsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gc2libGluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgc3BsaXRUZXh0YCBzcGxpdHMgdGhlIGdpdmVuIG5vZGUgYXQgdGhlIGdpdmVuIG9mZnNldC5cbiAgICAgKi9cbiAgICBzcGxpdFRleHQob2Zmc2V0LCBhYnNPZmZzZXQpIHtcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gMCB8fCBvZmZzZXQgPT09IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlZnRWYWx1ZSA9IHRoaXMudmFsdWUuc2xpY2UoMCwgb2Zmc2V0KTtcbiAgICAgICAgY29uc3QgcmlnaHRWYWx1ZSA9IHRoaXMudmFsdWUuc2xpY2Uob2Zmc2V0KTtcbiAgICAgICAgaWYgKCFyaWdodFZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSBsZWZ0VmFsdWU7XG4gICAgICAgIGNvbnN0IHJpZ2h0Tm9kZSA9IHRoaXMuY2xvbmVUZXh0KG9mZnNldCArIGFic09mZnNldCk7XG4gICAgICAgIHJpZ2h0Tm9kZS52YWx1ZSA9IHJpZ2h0VmFsdWU7XG4gICAgICAgIHRoaXMucGFyZW50Lmluc2VydEFmdGVySW50ZXJuYWwocmlnaHROb2RlLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHJpZ2h0Tm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGNoaWxkcmVuYCByZXR1cm5zIHRoZSBjaGlsZHJlbiBvZiB0aGUgbm9kZS5cbiAgICAgKi9cbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgIC8vIFRvbWJzdG9uZSBub2RlcyByZW1haW4gYXdoaWxlIGluIHRoZSB0cmVlIGR1cmluZyBlZGl0aW5nLlxuICAgICAgICAvLyBUaGV5IHdpbGwgYmUgcmVtb3ZlZCBhZnRlciB0aGUgZWRpdGluZyBpcyBkb25lLlxuICAgICAgICAvLyBTbywgd2UgbmVlZCB0byBmaWx0ZXIgb3V0IHRoZSB0b21ic3RvbmUgbm9kZXMgdG8gZ2V0IHRoZSByZWFsIGNoaWxkcmVuLlxuICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4uZmlsdGVyKChjaGlsZCkgPT4gIWNoaWxkLmlzUmVtb3ZlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBhbGxDaGlsZHJlbmAgcmV0dXJucyBhbGwgdGhlIGNoaWxkcmVuIG9mIHRoZSBub2RlIGluY2x1ZGluZyB0b21ic3RvbmUgbm9kZXMuXG4gICAgICogSXQgcmV0dXJucyB0aGUgc2hhbGxvdyBjb3B5IG9mIHRoZSBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBnZXQgYWxsQ2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiBbLi4udGhpcy5fY2hpbGRyZW5dO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgaGFzVGV4dENoaWxkYCByZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgaGFzIGFuIHRleHQgY2hpbGQuXG4gICAgICovXG4gICAgaGFzVGV4dENoaWxkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5zb21lKChjaGlsZCkgPT4gY2hpbGQuaXNUZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGFwcGVuZGAgYXBwZW5kcyB0aGUgZ2l2ZW4gbm9kZXMgdG8gdGhlIGNoaWxkcmVuLlxuICAgICAqL1xuICAgIGFwcGVuZCguLi5uZXdOb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVGV4dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0IG5vZGUgY2Fubm90IGhhdmUgY2hpbGRyZW4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKC4uLm5ld05vZGUpO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgbmV3Tm9kZSkge1xuICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgbm9kZS51cGRhdGVBbmNlc3RvcnNTaXplKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogYHByZXBlbmRgIHByZXBlbmRzIHRoZSBnaXZlbiBub2RlcyB0byB0aGUgY2hpbGRyZW4uXG4gICAgICovXG4gICAgcHJlcGVuZCguLi5uZXdOb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVGV4dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0IG5vZGUgY2Fubm90IGhhdmUgY2hpbGRyZW4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGlsZHJlbi51bnNoaWZ0KC4uLm5ld05vZGUpO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgbmV3Tm9kZSkge1xuICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCFub2RlLmlzUmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgIG5vZGUudXBkYXRlQW5jZXN0b3JzU2l6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBpbnNlcnRCZWZvcmVgIGluc2VydHMgdGhlIGdpdmVuIG5vZGUgYmVmb3JlIHRoZSBnaXZlbiBjaGlsZC5cbiAgICAgKi9cbiAgICBpbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICAgICAgICBpZiAodGhpcy5pc1RleHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGV4dCBub2RlIGNhbm5vdCBoYXZlIGNoaWxkcmVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fY2hpbGRyZW4uaW5kZXhPZihyZWZlcmVuY2VOb2RlKTtcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hpbGQgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnNlcnRBdEludGVybmFsKG5ld05vZGUsIG9mZnNldCk7XG4gICAgICAgIG5ld05vZGUudXBkYXRlQW5jZXN0b3JzU2l6ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgaW5zZXJ0QWZ0ZXJgIGluc2VydHMgdGhlIGdpdmVuIG5vZGUgYWZ0ZXIgdGhlIGdpdmVuIGNoaWxkLlxuICAgICAqL1xuICAgIGluc2VydEFmdGVyKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNUZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHQgbm9kZSBjYW5ub3QgaGF2ZSBjaGlsZHJlbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX2NoaWxkcmVuLmluZGV4T2YocmVmZXJlbmNlTm9kZSk7XG4gICAgICAgIGlmIChvZmZzZXQgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoaWxkIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5zZXJ0QXRJbnRlcm5hbChuZXdOb2RlLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgbmV3Tm9kZS51cGRhdGVBbmNlc3RvcnNTaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBpbnNlcnRBdGAgaW5zZXJ0cyB0aGUgZ2l2ZW4gbm9kZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0LlxuICAgICAqL1xuICAgIGluc2VydEF0KG5ld05vZGUsIG9mZnNldCkge1xuICAgICAgICBpZiAodGhpcy5pc1RleHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGV4dCBub2RlIGNhbm5vdCBoYXZlIGNoaWxkcmVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnNlcnRBdEludGVybmFsKG5ld05vZGUsIG9mZnNldCk7XG4gICAgICAgIG5ld05vZGUudXBkYXRlQW5jZXN0b3JzU2l6ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgcmVtb3ZlQ2hpbGRgIHJlbW92ZXMgdGhlIGdpdmVuIGNoaWxkLlxuICAgICAqL1xuICAgIHJlbW92ZUNoaWxkKGNoaWxkKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVGV4dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0IG5vZGUgY2Fubm90IGhhdmUgY2hpbGRyZW4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hpbGQgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hpbGRyZW4uc3BsaWNlKG9mZnNldCwgMSk7XG4gICAgICAgIGNoaWxkLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHNwbGl0RWxlbWVudGAgc3BsaXRzIHRoZSBnaXZlbiBlbGVtZW50IGF0IHRoZSBnaXZlbiBvZmZzZXQuXG4gICAgICovXG4gICAgc3BsaXRFbGVtZW50KG9mZnNldCwgaXNzdWVUaW1lVGlja2V0KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUT0RPKGhhY2tlcndpbnMpOiBEZWZpbmUgSUQgb2Ygc3BsaXQgbm9kZSBmb3IgY29uY3VycmVudCBlZGl0aW5nLlxuICAgICAgICAgKiBUZXh0IGhhcyBmaXhlZCBjb250ZW50IGFuZCBpdHMgc3BsaXQgbm9kZXMgY291bGQgaGF2ZSBsaW1pdGVkIG9mZnNldFxuICAgICAgICAgKiByYW5nZS4gQnV0IGVsZW1lbnQgbm9kZSBjb3VsZCBoYXZlIGFyYml0cmFyeSBjaGlsZHJlbiBhbmQgaXRzIHNwbGl0XG4gICAgICAgICAqIG5vZGVzIGNvdWxkIGhhdmUgYXJiaXRyYXJ5IG9mZnNldCByYW5nZS4gU28sIGlkIGNvdWxkIGJlIGR1cGxpY2F0ZWRcbiAgICAgICAgICogYW5kIGl0cyBvcmRlciBjb3VsZCBiZSBicm9rZW4gd2hlbiBjb25jdXJyZW50IGVkaXRpbmcgaGFwcGVucy5cbiAgICAgICAgICogQ3VycmVudGx5LCB3ZSB1c2UgdGhlIHNpbWlsYXIgSUQgb2Ygc3BsaXQgZWxlbWVudCB3aXRoIHRoZSBzcGxpdCB0ZXh0LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgY2xvbmUgPSB0aGlzLmNsb25lRWxlbWVudChpc3N1ZVRpbWVUaWNrZXQpO1xuICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRBZnRlckludGVybmFsKGNsb25lLCB0aGlzKTtcbiAgICAgICAgY2xvbmUudXBkYXRlQW5jZXN0b3JzU2l6ZSgpO1xuICAgICAgICBjb25zdCBsZWZ0Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnNsaWNlKDAsIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnNsaWNlKG9mZnNldCk7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gbGVmdENoaWxkcmVuO1xuICAgICAgICBjbG9uZS5fY2hpbGRyZW4gPSByaWdodENoaWxkcmVuO1xuICAgICAgICB0aGlzLnNpemUgPSB0aGlzLl9jaGlsZHJlbi5yZWR1Y2UoKGFjYywgY2hpbGQpID0+IGFjYyArIGNoaWxkLnBhZGRlZFNpemUsIDApO1xuICAgICAgICBjbG9uZS5zaXplID0gY2xvbmUuX2NoaWxkcmVuLnJlZHVjZSgoYWNjLCBjaGlsZCkgPT4gYWNjICsgY2hpbGQucGFkZGVkU2l6ZSwgMCk7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2xvbmUuX2NoaWxkcmVuKSB7XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBjbG9uZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBpbnNlcnRBZnRlckludGVybmFsYCBpbnNlcnRzIHRoZSBnaXZlbiBub2RlIGFmdGVyIHRoZSBnaXZlbiBjaGlsZC5cbiAgICAgKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCB1cGRhdGUgdGhlIHNpemUgb2YgdGhlIGFuY2VzdG9ycy5cbiAgICAgKi9cbiAgICBpbnNlcnRBZnRlckludGVybmFsKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNUZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHQgbm9kZSBjYW5ub3QgaGF2ZSBjaGlsZHJlbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX2NoaWxkcmVuLmluZGV4T2YocmVmZXJlbmNlTm9kZSk7XG4gICAgICAgIGlmIChvZmZzZXQgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoaWxkIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5zZXJ0QXRJbnRlcm5hbChuZXdOb2RlLCBvZmZzZXQgKyAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGluc2VydEF0SW50ZXJuYWxgIGluc2VydHMgdGhlIGdpdmVuIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICAqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHVwZGF0ZSB0aGUgc2l6ZSBvZiB0aGUgYW5jZXN0b3JzLlxuICAgICAqL1xuICAgIGluc2VydEF0SW50ZXJuYWwobmV3Tm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVGV4dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0IG5vZGUgY2Fubm90IGhhdmUgY2hpbGRyZW4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGlsZHJlbi5zcGxpY2Uob2Zmc2V0LCAwLCBuZXdOb2RlKTtcbiAgICAgICAgbmV3Tm9kZS5wYXJlbnQgPSB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBmaW5kT2Zmc2V0IHJldHVybnMgdGhlIG9mZnNldCBvZiB0aGUgZ2l2ZW4gbm9kZSBpbiB0aGUgY2hpbGRyZW4uXG4gICAgICogSXQgZXhjbHVkZXMgdGhlIHJlbW92ZWQgbm9kZXMuXG4gICAgICovXG4gICAgZmluZE9mZnNldChub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVGV4dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0IG5vZGUgY2Fubm90IGhhdmUgY2hpbGRyZW4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5pc1JlbW92ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fY2hpbGRyZW4uaW5kZXhPZihub2RlKTtcbiAgICAgICAgICAgIC8vIElmIG5vZGVzIGFyZSByZW1vdmVkLCB0aGUgb2Zmc2V0IG9mIHRoZSByZW1vdmVkIG5vZGUgaXMgdGhlIG51bWJlciBvZlxuICAgICAgICAgICAgLy8gbm9kZXMgYmVmb3JlIHRoZSBub2RlIGV4Y2x1ZGluZyB0aGUgcmVtb3ZlZCBub2Rlcy5cbiAgICAgICAgICAgIGNvbnN0IHJlZmluZWQgPSB0aGlzLmFsbENoaWxkcmVuXG4gICAgICAgICAgICAgICAgLnNwbGljZSgwLCBpbmRleClcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChub2RlKSA9PiAhbm9kZS5pc1JlbW92ZWQpLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiByZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmluZGV4T2Yobm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBmaW5kQnJhbmNoT2Zmc2V0YCByZXR1cm5zIG9mZnNldCBvZiB0aGUgZ2l2ZW4gZGVzY2VuZGFudCBub2RlIGluIHRoaXMgbm9kZS5cbiAgICAgKiBJZiB0aGUgZ2l2ZW4gbm9kZSBpcyBub3QgYSBkZXNjZW5kYW50IG9mIHRoaXMgbm9kZSwgaXQgcmV0dXJucyAtMS5cbiAgICAgKi9cbiAgICBmaW5kQnJhbmNoT2Zmc2V0KG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNUZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHQgbm9kZSBjYW5ub3QgaGF2ZSBjaGlsZHJlbicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50ID0gbm9kZTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX2NoaWxkcmVuLmluZGV4T2YoY3VycmVudCk7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn1cbi8qKlxuICogYGFuY2VzdG9yT2ZgIHJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbm9kZSBpcyBhbiBhbmNlc3RvciBvZiB0aGUgb3RoZXIgbm9kZS5cbiAqL1xuZnVuY3Rpb24gYW5jZXN0b3JPZihhbmNlc3Rvciwgbm9kZSkge1xuICAgIGlmIChhbmNlc3RvciA9PT0gbm9kZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHdoaWxlIChub2RlLnBhcmVudCkge1xuICAgICAgICBpZiAobm9kZS5wYXJlbnQgPT09IGFuY2VzdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIFRhZ0NvbnRhaW5lZCByZXByZXNlbnRzIHdoZXRoZXIgdGhlIG9wZW5pbmcgb3IgY2xvc2luZyB0YWcgb2YgYSBlbGVtZW50IGlzIHNlbGVjdGVkLlxudmFyIFRhZ0NvbnRhaW5lZDtcbihmdW5jdGlvbiAoVGFnQ29udGFpbmVkKSB7XG4gICAgLy8gQWxsIHJlcHJlc2VudHMgdGhhdCBib3RoIG9wZW5pbmcgYW5kIGNsb3NpbmcgdGFnIG9mIGEgZWxlbWVudCBhcmUgc2VsZWN0ZWQuXG4gICAgVGFnQ29udGFpbmVkW1wiQWxsXCJdID0gXCJBbGxcIjtcbiAgICAvLyBPcGVuaW5nIHJlcHJlc2VudHMgdGhhdCBvbmx5IHRoZSBvcGVuaW5nIHRhZyBpcyBzZWxlY3RlZC5cbiAgICBUYWdDb250YWluZWRbXCJPcGVuaW5nXCJdID0gXCJPcGVuaW5nXCI7XG4gICAgLy8gQ2xvc2luZyByZXByZXNlbnRzIHRoYXQgb25seSB0aGUgY2xvc2luZyB0YWcgaXMgc2VsZWN0ZWQuXG4gICAgVGFnQ29udGFpbmVkW1wiQ2xvc2luZ1wiXSA9IFwiQ2xvc2luZ1wiO1xufSkoVGFnQ29udGFpbmVkIHx8IChUYWdDb250YWluZWQgPSB7fSkpO1xuLyoqXG4gKiBgbm9kZXNCZXR3ZWVuYCBpdGVyYXRlcyB0aGUgbm9kZXMgYmV0d2VlbiB0aGUgZ2l2ZW4gcmFuZ2UuXG4gKiBJZiB0aGUgZ2l2ZW4gcmFuZ2UgaXMgY29sbGFwc2VkLCB0aGUgY2FsbGJhY2sgaXMgbm90IGNhbGxlZC5cbiAqIEl0IHRyYXZlcnNlcyB0aGUgdHJlZSB3aXRoIHBvc3RvcmRlciB0cmF2ZXJzYWwuXG4gKiBOT1RFKHNlam9uZ2spOiBOb2RlcyBzaG91bGQgbm90IGJlIHJlbW92ZWQgaW4gY2FsbGJhY2ssIGJlY2F1c2UgaXQgbGVhZHMgd3JvbmcgYmVoYXZpb3JzLlxuICovXG5mdW5jdGlvbiBub2Rlc0JldHdlZW4ocm9vdCwgZnJvbSwgdG8sIGNhbGxiYWNrKSB7XG4gICAgaWYgKGZyb20gPiB0bykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZyb20gaXMgZ3JlYXRlciB0aGFuIHRvOiAke2Zyb219ID4gJHt0b31gKTtcbiAgICB9XG4gICAgaWYgKGZyb20gPiByb290LnNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmcm9tIGlzIG91dCBvZiByYW5nZTogJHtmcm9tfSA+ICR7cm9vdC5zaXplfWApO1xuICAgIH1cbiAgICBpZiAodG8gPiByb290LnNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0byBpcyBvdXQgb2YgcmFuZ2U6ICR7dG99ID4gJHtyb290LnNpemV9YCk7XG4gICAgfVxuICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBwb3MgPSAwO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygcm9vdC5jaGlsZHJlbikge1xuICAgICAgICAvLyBJZiB0aGUgY2hpbGQgaXMgYW4gZWxlbWVudCBub2RlLCB0aGUgc2l6ZSBvZiB0aGUgY2hpbGQuXG4gICAgICAgIGlmIChmcm9tIC0gY2hpbGQucGFkZGVkU2l6ZSA8IHBvcyAmJiBwb3MgPCB0bykge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNoaWxkIGlzIGFuIGVsZW1lbnQgbm9kZSwgdGhlIHJhbmdlIG9mIHRoZSBjaGlsZFxuICAgICAgICAgICAgLy8gaXMgZnJvbSAtIDEgdG8gdG8gLSAxLiBCZWNhdXNlIHRoZSByYW5nZSBvZiB0aGUgZWxlbWVudCBub2RlIGlzIGZyb21cbiAgICAgICAgICAgIC8vIHRoZSBvcGVuIHRhZyB0byB0aGUgY2xvc2UgdGFnLlxuICAgICAgICAgICAgY29uc3QgZnJvbUNoaWxkID0gY2hpbGQuaXNUZXh0ID8gZnJvbSAtIHBvcyA6IGZyb20gLSBwb3MgLSAxO1xuICAgICAgICAgICAgY29uc3QgdG9DaGlsZCA9IGNoaWxkLmlzVGV4dCA/IHRvIC0gcG9zIDogdG8gLSBwb3MgLSAxO1xuICAgICAgICAgICAgbm9kZXNCZXR3ZWVuKGNoaWxkLCBNYXRoLm1heCgwLCBmcm9tQ2hpbGQpLCBNYXRoLm1pbih0b0NoaWxkLCBjaGlsZC5zaXplKSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHJhbmdlIHNwYW5zIG91dHNpZGUgdGhlIGNoaWxkLFxuICAgICAgICAgICAgLy8gdGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIHRoZSBjaGlsZC5cbiAgICAgICAgICAgIGlmIChmcm9tQ2hpbGQgPCAwIHx8IHRvQ2hpbGQgPiBjaGlsZC5zaXplIHx8IGNoaWxkLmlzVGV4dCkge1xuICAgICAgICAgICAgICAgIGxldCBjb250YWluO1xuICAgICAgICAgICAgICAgIGlmICgoZnJvbUNoaWxkIDwgMCAmJiB0b0NoaWxkID4gY2hpbGQuc2l6ZSkgfHwgY2hpbGQuaXNUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW4gPSBUYWdDb250YWluZWQuQWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmcm9tQ2hpbGQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW4gPSBUYWdDb250YWluZWQuT3BlbmluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW4gPSBUYWdDb250YWluZWQuQ2xvc2luZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soY2hpbGQsIGNvbnRhaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBjaGlsZC5wYWRkZWRTaXplO1xuICAgIH1cbn1cbi8qKlxuICogYHRyYXZlcnNlYCB0cmF2ZXJzZXMgdGhlIHRyZWUgd2l0aCBwb3N0b3JkZXIgdHJhdmVyc2FsLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZShub2RlLCBjYWxsYmFjaywgZGVwdGggPSAwKSB7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHRyYXZlcnNlKGNoaWxkLCBjYWxsYmFjaywgZGVwdGggKyAxKTtcbiAgICB9XG4gICAgY2FsbGJhY2sobm9kZSwgZGVwdGgpO1xufVxuLyoqXG4gKiBgdHJhdmVyc2VBbGxgIHRyYXZlcnNlcyB0aGUgd2hvbGUgdHJlZSAoaW5jbHVkZSB0b21ic3RvbmVzKSB3aXRoIHBvc3RvcmRlciB0cmF2ZXJzYWwuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsKG5vZGUsIGNhbGxiYWNrLCBkZXB0aCA9IDApIHtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG5vZGUuX2NoaWxkcmVuKSB7XG4gICAgICAgIHRyYXZlcnNlQWxsKGNoaWxkLCBjYWxsYmFjaywgZGVwdGggKyAxKTtcbiAgICB9XG4gICAgY2FsbGJhY2sobm9kZSwgZGVwdGgpO1xufVxuLyoqXG4gKiBgZmluZFRyZWVQb3NgIGZpbmRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgZ2l2ZW4gaW5kZXggaW4gdGhlIGdpdmVuIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGZpbmRUcmVlUG9zKG5vZGUsIGluZGV4LCBwcmVmZXJUZXh0ID0gdHJ1ZSkge1xuICAgIGlmIChpbmRleCA+IG5vZGUuc2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGluZGV4IGlzIG91dCBvZiByYW5nZTogJHtpbmRleH0gPiAke25vZGUuc2l6ZX1gKTtcbiAgICB9XG4gICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgIHJldHVybiB7IG5vZGUsIG9mZnNldDogaW5kZXggfTtcbiAgICB9XG4gICAgLy8gb2Zmc2V0IGlzIHRoZSBpbmRleCBvZiB0aGUgY2hpbGQgbm9kZS5cbiAgICAvLyBwb3MgaXMgdGhlIHdpbmRvdyBvZiB0aGUgaW5kZXggaW4gdGhlIGdpdmVuIG5vZGUuXG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIC8vIFRoZSBwb3MgaXMgaW4gYm90aHNpZGVzIG9mIHRoZSB0ZXh0IG5vZGUsIHdlIHNob3VsZCB0cmF2ZXJzZVxuICAgICAgICAvLyBpbnNpZGUgb2YgdGhlIHRleHQgbm9kZSBpZiBwcmVmZXJUZXh0IGlzIHRydWUuXG4gICAgICAgIGlmIChwcmVmZXJUZXh0ICYmIGNoaWxkLmlzVGV4dCAmJiBjaGlsZC5zaXplID49IGluZGV4IC0gcG9zKSB7XG4gICAgICAgICAgICByZXR1cm4gZmluZFRyZWVQb3MoY2hpbGQsIGluZGV4IC0gcG9zLCBwcmVmZXJUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgcG9zaXRpb24gaXMgaW4gbGVmdHNpZGUgb2YgdGhlIGVsZW1lbnQgbm9kZS5cbiAgICAgICAgaWYgKGluZGV4ID09PSBwb3MpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGUsIG9mZnNldCB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBwb3NpdGlvbiBpcyBpbiByaWdodHNpZGUgb2YgdGhlIGVsZW1lbnQgbm9kZSBhbmQgcHJlZmVyVGV4dCBpcyBmYWxzZS5cbiAgICAgICAgaWYgKCFwcmVmZXJUZXh0ICYmIGNoaWxkLnBhZGRlZFNpemUgPT09IGluZGV4IC0gcG9zKSB7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlLCBvZmZzZXQ6IG9mZnNldCArIDEgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgcG9zaXRpb24gaXMgaW4gbWlkZGxlIHRoZSBlbGVtZW50IG5vZGUuXG4gICAgICAgIGlmIChjaGlsZC5wYWRkZWRTaXplID4gaW5kZXggLSBwb3MpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIHRyYXZlcnNlIGluc2lkZSBvZiB0aGUgZWxlbWVudCBub2RlLCB3ZSBzaG91bGQgc2tpcCB0aGUgb3Blbi5cbiAgICAgICAgICAgIGNvbnN0IHNraXBPcGVuU2l6ZSA9IDE7XG4gICAgICAgICAgICByZXR1cm4gZmluZFRyZWVQb3MoY2hpbGQsIGluZGV4IC0gcG9zIC0gc2tpcE9wZW5TaXplLCBwcmVmZXJUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gY2hpbGQucGFkZGVkU2l6ZTtcbiAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgfVxuICAgIC8vIFRoZSBwb3NpdGlvbiBpcyBpbiByaWdodG1vc3Qgb2YgdGhlIGdpdmVuIG5vZGUuXG4gICAgcmV0dXJuIHsgbm9kZSwgb2Zmc2V0IH07XG59XG4vKipcbiAqIGBnZXRBbmNlc3RvcnNgIHJldHVybnMgdGhlIGFuY2VzdG9ycyBvZiB0aGUgZ2l2ZW4gbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0QW5jZXN0b3JzKG5vZGUpIHtcbiAgICBjb25zdCBhbmNlc3RvcnMgPSBbXTtcbiAgICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICBhbmNlc3RvcnMudW5zaGlmdChwYXJlbnQpO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gYW5jZXN0b3JzO1xufVxuLyoqXG4gKiBgZmluZENvbW1vbkFuY2VzdG9yYCBmaW5kcyB0aGUgbG93ZXN0IGNvbW1vbiBhbmNlc3RvciBvZiB0aGUgZ2l2ZW4gbm9kZXMuXG4gKi9cbmZ1bmN0aW9uIGZpbmRDb21tb25BbmNlc3Rvcihub2RlQSwgbm9kZUIpIHtcbiAgICBpZiAobm9kZUEgPT09IG5vZGVCKSB7XG4gICAgICAgIHJldHVybiBub2RlQTtcbiAgICB9XG4gICAgY29uc3QgYW5jZXN0b3JzT2ZBID0gZ2V0QW5jZXN0b3JzKG5vZGVBKTtcbiAgICBjb25zdCBhbmNlc3RvcnNPZkIgPSBnZXRBbmNlc3RvcnMobm9kZUIpO1xuICAgIGxldCBjb21tb25BbmNlc3RvcjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFuY2VzdG9yc09mQS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhbmNlc3Rvck9mQSA9IGFuY2VzdG9yc09mQVtpXTtcbiAgICAgICAgY29uc3QgYW5jZXN0b3JPZkIgPSBhbmNlc3RvcnNPZkJbaV07XG4gICAgICAgIGlmIChhbmNlc3Rvck9mQSAhPT0gYW5jZXN0b3JPZkIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbW1vbkFuY2VzdG9yID0gYW5jZXN0b3JPZkE7XG4gICAgfVxuICAgIHJldHVybiBjb21tb25BbmNlc3Rvcjtcbn1cbi8qKlxuICogYGZpbmRMZWZ0bW9zdGAgZmluZHMgdGhlIGxlZnRtb3N0IG5vZGUgb2YgdGhlIGdpdmVuIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIGZpbmRMZWZ0bW9zdChub2RlKSB7XG4gICAgaWYgKG5vZGUuaXNUZXh0IHx8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gZmluZExlZnRtb3N0KG5vZGUuY2hpbGRyZW5bMF0pO1xufVxuLyoqXG4gKiBgZmluZFRleHRQb3NgIHJldHVybnMgdGhlIHRyZWUgcG9zaXRpb24gb2YgdGhlIGdpdmVuIHBhdGggZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gZmluZFRleHRQb3Mobm9kZSwgcGF0aEVsZW1lbnQpIHtcbiAgICBpZiAobm9kZS5zaXplIDwgcGF0aEVsZW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmFjY2VwdGFibGUgcGF0aCcpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoY2hpbGQuc2l6ZSA8IHBhdGhFbGVtZW50KSB7XG4gICAgICAgICAgICBwYXRoRWxlbWVudCAtPSBjaGlsZC5zaXplO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IGNoaWxkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbm9kZSwgb2Zmc2V0OiBwYXRoRWxlbWVudCB9O1xufVxuLyoqXG4gKiBgSW5kZXhUcmVlYCBpcyBhIHRyZWUgc3RydWN0dXJlIGZvciBsaW5lYXIgaW5kZXhpbmcuXG4gKi9cbmNsYXNzIEluZGV4VHJlZSB7XG4gICAgY29uc3RydWN0b3Iocm9vdCkge1xuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgbm9kZUJldHdlZW5gIHJldHVybnMgdGhlIG5vZGVzIGJldHdlZW4gdGhlIGdpdmVuIHJhbmdlLlxuICAgICAqL1xuICAgIG5vZGVzQmV0d2Vlbihmcm9tLCB0bywgY2FsbGJhY2spIHtcbiAgICAgICAgbm9kZXNCZXR3ZWVuKHRoaXMucm9vdCwgZnJvbSwgdG8sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRyYXZlcnNlYCB0cmF2ZXJzZXMgdGhlIHRyZWUgd2l0aCBwb3N0b3JkZXIgdHJhdmVyc2FsLlxuICAgICAqL1xuICAgIHRyYXZlcnNlKGNhbGxiYWNrKSB7XG4gICAgICAgIHRyYXZlcnNlKHRoaXMucm9vdCwgY2FsbGJhY2ssIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdHJhdmVyc2VBbGxgIHRyYXZlcnNlcyB0aGUgd2hvbGUgdHJlZSAoaW5jbHVkZSB0b21ic3RvbmVzKSB3aXRoIHBvc3RvcmRlciB0cmF2ZXJzYWwuXG4gICAgICovXG4gICAgdHJhdmVyc2VBbGwoY2FsbGJhY2spIHtcbiAgICAgICAgdHJhdmVyc2VBbGwodGhpcy5yb290LCBjYWxsYmFjaywgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGZpbmRUcmVlUG9zIGZpbmRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgZ2l2ZW4gaW5kZXggaW4gdGhlIHRyZWUuXG4gICAgICovXG4gICAgZmluZFRyZWVQb3MoaW5kZXgsIHByZWZlclRleHQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBmaW5kVHJlZVBvcyh0aGlzLnJvb3QsIGluZGV4LCBwcmVmZXJUZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRyZWVQb3NUb1BhdGhgIHJldHVybnMgcGF0aCBmcm9tIGdpdmVuIHRyZWVQb3NcbiAgICAgKi9cbiAgICB0cmVlUG9zVG9QYXRoKHRyZWVQb3MpIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IFtdO1xuICAgICAgICBsZXQgbm9kZSA9IHRyZWVQb3Mubm9kZTtcbiAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBub2RlLnBhcmVudC5maW5kT2Zmc2V0KG5vZGUpO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdHJlZVBvcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2l6ZU9mTGVmdFNpYmxpbmdzID0gYWRkU2l6ZU9mTGVmdFNpYmxpbmdzKG5vZGUucGFyZW50LCBvZmZzZXQpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgICAgICAgcGF0aC5wdXNoKHNpemVPZkxlZnRTaWJsaW5ncyArIHRyZWVQb3Mub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdGgucHVzaCh0cmVlUG9zLm9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKG5vZGUucGFyZW50KSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBub2RlLnBhcmVudC5maW5kT2Zmc2V0KG5vZGUpO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdHJlZVBvcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0aC5wdXNoKG9mZnNldCk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGgucmV2ZXJzZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgcGF0aFRvSW5kZXhgIHJldHVybnMgaW5kZXggZnJvbSBnaXZlbiBwYXRoXG4gICAgICovXG4gICAgcGF0aFRvSW5kZXgocGF0aCkge1xuICAgICAgICBjb25zdCB0cmVlUG9zID0gdGhpcy5wYXRoVG9UcmVlUG9zKHBhdGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleE9mKHRyZWVQb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgcGF0aFRvVHJlZVBvc2AgcmV0dXJucyB0cmVlUG9zIGZyb20gZ2l2ZW4gcGF0aFxuICAgICAqL1xuICAgIHBhdGhUb1RyZWVQb3MocGF0aCkge1xuICAgICAgICBpZiAoIXBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWNjZXB0YWJsZSBwYXRoJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnJvb3Q7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhFbGVtZW50ID0gcGF0aFtpXTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW3BhdGhFbGVtZW50XTtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5hY2NlcHRhYmxlIHBhdGgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5oYXNUZXh0Q2hpbGQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbmRUZXh0UG9zKG5vZGUsIHBhdGhbcGF0aC5sZW5ndGggLSAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoIDwgcGF0aFtwYXRoLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWNjZXB0YWJsZSBwYXRoJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBvZmZzZXQ6IHBhdGhbcGF0aC5sZW5ndGggLSAxXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldFJvb3RgIHJldHVybnMgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgdHJlZS5cbiAgICAgKi9cbiAgICBnZXRSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0U2l6ZWAgcmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgdHJlZS5cbiAgICAgKi9cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5zaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZmluZFBvc3RvcmRlclJpZ2h0YCBmaW5kcyByaWdodCBub2RlIG9mIHRoZSBnaXZlbiB0cmVlIHBvc2l0aW9uIHdpdGhcbiAgICAgKiAgcG9zdG9yZGVyIHRyYXZlcnNhbC5cbiAgICAgKi9cbiAgICBmaW5kUG9zdG9yZGVyUmlnaHQodHJlZVBvcykge1xuICAgICAgICBjb25zdCB7IG5vZGUsIG9mZnNldCB9ID0gdHJlZVBvcztcbiAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICBpZiAobm9kZS5zaXplID09PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0U2libGluZyA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSBvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaW5kTGVmdG1vc3Qobm9kZS5jaGlsZHJlbltvZmZzZXRdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGluZGV4T2ZgIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiB0cmVlIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIGluZGV4T2YocG9zKSB7XG4gICAgICAgIGxldCB7IG5vZGUgfSA9IHBvcztcbiAgICAgICAgY29uc3QgeyBvZmZzZXQgfSA9IHBvcztcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICBsZXQgZGVwdGggPSAxO1xuICAgICAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgICAgICAgIHNpemUgKz0gb2Zmc2V0O1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRPZk5vZGUgPSBwYXJlbnQuZmluZE9mZnNldChub2RlKTtcbiAgICAgICAgICAgIGlmIChvZmZzZXRPZk5vZGUgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2l6ZSArPSBhZGRTaXplT2ZMZWZ0U2libGluZ3MocGFyZW50LCBvZmZzZXRPZk5vZGUpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2l6ZSArPSBhZGRTaXplT2ZMZWZ0U2libGluZ3Mobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLnBhcmVudCkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRPZk5vZGUgPSBwYXJlbnQuZmluZE9mZnNldChub2RlKTtcbiAgICAgICAgICAgIGlmIChvZmZzZXRPZk5vZGUgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2l6ZSArPSBhZGRTaXplT2ZMZWZ0U2libGluZ3MocGFyZW50LCBvZmZzZXRPZk5vZGUpO1xuICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2l6ZSArIGRlcHRoIC0gMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGluZGV4VG9QYXRoYCByZXR1cm5zIHRoZSBwYXRoIG9mIHRoZSBnaXZlbiBpbmRleC5cbiAgICAgKi9cbiAgICBpbmRleFRvUGF0aChpbmRleCkge1xuICAgICAgICBjb25zdCB0cmVlUG9zID0gdGhpcy5maW5kVHJlZVBvcyhpbmRleCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWVQb3NUb1BhdGgodHJlZVBvcyk7XG4gICAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9jb21wYXJhdG9yLnRzXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgVGhlIFlvcmtpZSBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmNvbnN0IERlZmF1bHRDb21wYXJhdG9yID0gKGEsIGIpID0+IHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxufTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvbGxyYl90cmVlLnRzXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgVGhlIFlvcmtpZSBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIGBMTFJCTm9kZWAgaXMgbm9kZSBvZiBMTFJCVHJlZS5cbiAqL1xuY2xhc3MgTExSQk5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgdmFsdWUsIGlzUmVkKSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaXNSZWQgPSBpc1JlZDtcbiAgICB9XG59XG4vKipcbiAqIGBTb3J0ZWRNYXBJdGVyYXRvcmAgaXMgYSBpbnRlcmF0b3IgZm9yIHRyYXZlcnNpbmcgTExSQlRyZWUuXG4gKi9cbmNsYXNzIFNvcnRlZE1hcEl0ZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcihyb290KSB7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy50cmF2ZXJzZUlub3JkZXIocm9vdCk7XG4gICAgfVxuICAgIC8vIFRPRE86IFJlcGxhY2Ugd2l0aCBpdGVyYXRpdmUgYXBwcm9hY2gsIGlmIHdlIGVuY291bnRlciBwZXJmb3JtYW5jZSBwcm9ibGVtLlxuICAgIHRyYXZlcnNlSW5vcmRlcihub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhdmVyc2VJbm9yZGVyKG5vZGUubGVmdCk7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh7XG4gICAgICAgICAgICBrZXk6IG5vZGUua2V5LFxuICAgICAgICAgICAgdmFsdWU6IG5vZGUudmFsdWUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYXZlcnNlSW5vcmRlcihub2RlLnJpZ2h0KTtcbiAgICB9XG59XG4vKipcbiAqIExMUkJUcmVlIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIExlZnQtbGVhcm5pbmcgUmVkLUJsYWNrIFRyZWUuXG4gKlxuICogT3JpZ2luYWwgcGFwZXIgb24gTGVmdC1sZWFuaW5nIFJlZC1CbGFjayBUcmVlczpcbiAqIEBzZWUgaHR0cDovL3d3dy5jcy5wcmluY2V0b24uZWR1L35ycy90YWxrcy9MTFJCL0xMUkIucGRmXG4gKlxuICogSW52YXJpYW50IDE6IE5vIHJlZCBub2RlIGhhcyBhIHJlZCBjaGlsZFxuICogSW52YXJpYW50IDI6IEV2ZXJ5IGxlYWYgcGF0aCBoYXMgdGhlIHNhbWUgbnVtYmVyIG9mIGJsYWNrIG5vZGVzXG4gKiBJbnZhcmlhbnQgMzogT25seSB0aGUgbGVmdCBjaGlsZCBjYW4gYmUgcmVkIChsZWZ0IGxlYW5pbmcpXG4gKi9cbmNsYXNzIExMUkJUcmVlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wYXJhdG9yKSB7XG4gICAgICAgIHRoaXMuY29tcGFyYXRvciA9XG4gICAgICAgICAgICB0eXBlb2YgY29tcGFyYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyBjb21wYXJhdG9yIDogRGVmYXVsdENvbXBhcmF0b3I7XG4gICAgICAgIHRoaXMuY291bnRlciA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBwdXRgIHB1dHMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBrZXkuXG4gICAgICovXG4gICAgcHV0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5yb290ID0gdGhpcy5wdXRJbnRlcm5hbChrZXksIHZhbHVlLCB0aGlzLnJvb3QpO1xuICAgICAgICB0aGlzLnJvb3QuaXNSZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0YCBnZXRzIGEgdmFsdWUgb2YgdGhlIGdpdmVuIGtleS5cbiAgICAgKi9cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldEludGVybmFsKGtleSwgdGhpcy5yb290KTtcbiAgICAgICAgcmV0dXJuIG5vZGUgPyBub2RlLnZhbHVlIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgcmVtb3ZlYCByZW1vdmVzIGEgZWxlbWVudCBvZiBrZXkuXG4gICAgICovXG4gICAgcmVtb3ZlKGtleSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNSZWQodGhpcy5yb290LmxlZnQpICYmICF0aGlzLmlzUmVkKHRoaXMucm9vdC5yaWdodCkpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC5pc1JlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb290ID0gdGhpcy5yZW1vdmVJbnRlcm5hbCh0aGlzLnJvb3QsIGtleSk7XG4gICAgICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC5pc1JlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRJdGVyYXRvcmAgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiBTb3J0ZWRNYXBJdGVyYXRvci5cbiAgICAgKi9cbiAgICBnZXRJdGVyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdmFsdWVzYCByZXR1cm5zIHZhbHVlIGFycmF5IG9mIExMUkJUcmVlLlxuICAgICAqL1xuICAgIHZhbHVlcygpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5nZXRJdGVyYXRvcigpLnN0YWNrKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChlbnRyeS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGZsb29yRW50cnlgIHJldHVybnMgdGhlIGVudHJ5IGZvciB0aGUgZ3JlYXRlc3Qga2V5IGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGVcbiAgICAgKiAgZ2l2ZW4ga2V5LiBJZiB0aGVyZSBpcyBubyBzdWNoIGtleSwgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAgICAgKi9cbiAgICBmbG9vckVudHJ5KGtleSkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMucm9vdDtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBhcmUgPSB0aGlzLmNvbXBhcmF0b3Ioa2V5LCBub2RlLmtleSk7XG4gICAgICAgICAgICBpZiAoY29tcGFyZSA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5yaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnJpZ2h0LnBhcmVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29tcGFyZSA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubGVmdC5wYXJlbnQgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGROb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBhcmVudCAmJiBjaGlsZE5vZGUgPT09IHBhcmVudC5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgbGFzdEVudHJ5YCByZXR1cm5zIGxhc3QgZW50cnkgb2YgTExSQlRyZWUuXG4gICAgICovXG4gICAgbGFzdEVudHJ5KCkge1xuICAgICAgICBpZiAoIXRoaXMucm9vdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMucm9vdDtcbiAgICAgICAgd2hpbGUgKG5vZGUucmlnaHQpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgc2l6ZWAgaXMgYSBzaXplIG9mIExMUkJUcmVlLlxuICAgICAqL1xuICAgIHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvdW50ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBpc0VtcHR5YCBjaGVja3MgaWYgc2l6ZSBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb3VudGVyID09PSAwO1xuICAgIH1cbiAgICBnZXRJbnRlcm5hbChrZXksIG5vZGUpIHtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBhcmUgPSB0aGlzLmNvbXBhcmF0b3Ioa2V5LCBub2RlLmtleSk7XG4gICAgICAgICAgICBpZiAoY29tcGFyZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29tcGFyZSA8IDApIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29tcGFyZSA+IDApIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHB1dEludGVybmFsKGtleSwgdmFsdWUsIG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50ZXIgKz0gMTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTExSQk5vZGUoa2V5LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcGFyZSA9IHRoaXMuY29tcGFyYXRvcihrZXksIG5vZGUua2V5KTtcbiAgICAgICAgaWYgKGNvbXBhcmUgPCAwKSB7XG4gICAgICAgICAgICBub2RlLmxlZnQgPSB0aGlzLnB1dEludGVybmFsKGtleSwgdmFsdWUsIG5vZGUubGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcGFyZSA+IDApIHtcbiAgICAgICAgICAgIG5vZGUucmlnaHQgPSB0aGlzLnB1dEludGVybmFsKGtleSwgdmFsdWUsIG5vZGUucmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzUmVkKG5vZGUucmlnaHQpICYmICF0aGlzLmlzUmVkKG5vZGUubGVmdCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLnJvdGF0ZUxlZnQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNSZWQobm9kZS5sZWZ0KSAmJiB0aGlzLmlzUmVkKG5vZGUubGVmdC5sZWZ0KSkge1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMucm90YXRlUmlnaHQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNSZWQobm9kZS5sZWZ0KSAmJiB0aGlzLmlzUmVkKG5vZGUucmlnaHQpKSB7XG4gICAgICAgICAgICB0aGlzLmZsaXBDb2xvcnMobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHJlbW92ZUludGVybmFsKG5vZGUsIGtleSkge1xuICAgICAgICBpZiAodGhpcy5jb21wYXJhdG9yKGtleSwgbm9kZS5rZXkpIDwgMCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzUmVkKG5vZGUubGVmdCkgJiYgIXRoaXMuaXNSZWQobm9kZS5sZWZ0LmxlZnQpKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHRoaXMubW92ZVJlZExlZnQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLmxlZnQgPSB0aGlzLnJlbW92ZUludGVybmFsKG5vZGUubGVmdCwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUmVkKG5vZGUubGVmdCkpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gdGhpcy5yb3RhdGVSaWdodChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhcmF0b3Ioa2V5LCBub2RlLmtleSkgPT09IDAgJiYgIW5vZGUucmlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ZXIgLT0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNSZWQobm9kZS5yaWdodCkgJiYgIXRoaXMuaXNSZWQobm9kZS5yaWdodC5sZWZ0KSkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLm1vdmVSZWRSaWdodChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhcmF0b3Ioa2V5LCBub2RlLmtleSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ZXIgLT0gMTtcbiAgICAgICAgICAgICAgICBjb25zdCBzbWFsbGVzdCA9IHRoaXMubWluKG5vZGUucmlnaHQpO1xuICAgICAgICAgICAgICAgIG5vZGUudmFsdWUgPSBzbWFsbGVzdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBub2RlLmtleSA9IHNtYWxsZXN0LmtleTtcbiAgICAgICAgICAgICAgICBub2RlLnJpZ2h0ID0gdGhpcy5yZW1vdmVNaW4obm9kZS5yaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLnJpZ2h0ID0gdGhpcy5yZW1vdmVJbnRlcm5hbChub2RlLnJpZ2h0LCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZpeFVwKG5vZGUpO1xuICAgIH1cbiAgICBtaW4obm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUubGVmdCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5taW4obm9kZS5sZWZ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVNaW4obm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUubGVmdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc1JlZChub2RlLmxlZnQpICYmICF0aGlzLmlzUmVkKG5vZGUubGVmdC5sZWZ0KSkge1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMubW92ZVJlZExlZnQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5sZWZ0ID0gdGhpcy5yZW1vdmVNaW4obm9kZS5sZWZ0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZml4VXAobm9kZSk7XG4gICAgfVxuICAgIGZpeFVwKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSZWQobm9kZS5yaWdodCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLnJvdGF0ZUxlZnQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNSZWQobm9kZS5sZWZ0KSAmJiB0aGlzLmlzUmVkKG5vZGUubGVmdC5sZWZ0KSkge1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMucm90YXRlUmlnaHQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNSZWQobm9kZS5sZWZ0KSAmJiB0aGlzLmlzUmVkKG5vZGUucmlnaHQpKSB7XG4gICAgICAgICAgICB0aGlzLmZsaXBDb2xvcnMobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIG1vdmVSZWRMZWZ0KG5vZGUpIHtcbiAgICAgICAgdGhpcy5mbGlwQ29sb3JzKG5vZGUpO1xuICAgICAgICBpZiAodGhpcy5pc1JlZChub2RlLnJpZ2h0LmxlZnQpKSB7XG4gICAgICAgICAgICBub2RlLnJpZ2h0ID0gdGhpcy5yb3RhdGVSaWdodChub2RlLnJpZ2h0KTtcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLnJvdGF0ZUxlZnQobm9kZSk7XG4gICAgICAgICAgICB0aGlzLmZsaXBDb2xvcnMobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIG1vdmVSZWRSaWdodChub2RlKSB7XG4gICAgICAgIHRoaXMuZmxpcENvbG9ycyhub2RlKTtcbiAgICAgICAgaWYgKHRoaXMuaXNSZWQobm9kZS5sZWZ0LmxlZnQpKSB7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5yb3RhdGVSaWdodChub2RlKTtcbiAgICAgICAgICAgIHRoaXMuZmxpcENvbG9ycyhub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgaXNSZWQobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZSAmJiBub2RlLmlzUmVkO1xuICAgIH1cbiAgICByb3RhdGVMZWZ0KG5vZGUpIHtcbiAgICAgICAgY29uc3QgeCA9IG5vZGUucmlnaHQ7XG4gICAgICAgIG5vZGUucmlnaHQgPSB4LmxlZnQ7XG4gICAgICAgIHgubGVmdCA9IG5vZGU7XG4gICAgICAgIHguaXNSZWQgPSB4LmxlZnQuaXNSZWQ7XG4gICAgICAgIHgubGVmdC5pc1JlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICByb3RhdGVSaWdodChub2RlKSB7XG4gICAgICAgIGNvbnN0IHggPSBub2RlLmxlZnQ7XG4gICAgICAgIG5vZGUubGVmdCA9IHgucmlnaHQ7XG4gICAgICAgIHgucmlnaHQgPSBub2RlO1xuICAgICAgICB4LmlzUmVkID0geC5yaWdodC5pc1JlZDtcbiAgICAgICAgeC5yaWdodC5pc1JlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICBmbGlwQ29sb3JzKG5vZGUpIHtcbiAgICAgICAgbm9kZS5pc1JlZCA9ICFub2RlLmlzUmVkO1xuICAgICAgICBub2RlLmxlZnQuaXNSZWQgPSAhbm9kZS5sZWZ0LmlzUmVkO1xuICAgICAgICBub2RlLnJpZ2h0LmlzUmVkID0gIW5vZGUucmlnaHQuaXNSZWQ7XG4gICAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZG9jdW1lbnQvY3JkdC90cmVlLnRzXG4vKlxuICogQ29weXJpZ2h0IDIwMjMgVGhlIFlvcmtpZSBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5cblxuXG5cblxuLyoqXG4gKiBgVHJlZUNoYW5nZVR5cGVgIHJlcHJlc2VudHMgdGhlIHR5cGUgb2YgY2hhbmdlIGluIHRoZSB0cmVlLlxuICovXG52YXIgVHJlZUNoYW5nZVR5cGU7XG4oZnVuY3Rpb24gKFRyZWVDaGFuZ2VUeXBlKSB7XG4gICAgVHJlZUNoYW5nZVR5cGVbXCJDb250ZW50XCJdID0gXCJjb250ZW50XCI7XG4gICAgVHJlZUNoYW5nZVR5cGVbXCJTdHlsZVwiXSA9IFwic3R5bGVcIjtcbn0pKFRyZWVDaGFuZ2VUeXBlIHx8IChUcmVlQ2hhbmdlVHlwZSA9IHt9KSk7XG4vKipcbiAqIGBDUkRUVHJlZVBvc2AgcmVwcmVzZW50IGEgcG9zaXRpb24gaW4gdGhlIHRyZWUuIEl0IGlzIHVzZWQgdG8gaWRlbnRpZnkgYVxuICogcG9zaXRpb24gaW4gdGhlIHRyZWUuIEl0IGlzIGNvbXBvc2VkIG9mIHRoZSBwYXJlbnQgSUQgYW5kIHRoZSBsZWZ0IHNpYmxpbmdcbiAqIElELiBJZiB0aGVyZSdzIG5vIGxlZnQgc2libGluZyBpbiBwYXJlbnQncyBjaGlsZHJlbiwgdGhlbiBsZWZ0IHNpYmxpbmcgaXNcbiAqIHBhcmVudC5cbiAqL1xuY2xhc3MgQ1JEVFRyZWVQb3Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudElELCBsZWZ0U2libGluZ0lEKSB7XG4gICAgICAgIHRoaXMucGFyZW50SUQgPSBwYXJlbnRJRDtcbiAgICAgICAgdGhpcy5sZWZ0U2libGluZ0lEID0gbGVmdFNpYmxpbmdJRDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYG9mYCBjcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIENSRFRUcmVlUG9zLlxuICAgICAqL1xuICAgIHN0YXRpYyBvZihwYXJlbnRJRCwgbGVmdFNpYmxpbmdJRCkge1xuICAgICAgICByZXR1cm4gbmV3IENSRFRUcmVlUG9zKHBhcmVudElELCBsZWZ0U2libGluZ0lEKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGZyb21UcmVlUG9zYCBjcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIENSRFRUcmVlUG9zIGZyb20gdGhlIGdpdmVuIFRyZWVQb3MuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21UcmVlUG9zKHBvcykge1xuICAgICAgICBjb25zdCB7IG9mZnNldCB9ID0gcG9zO1xuICAgICAgICBsZXQgeyBub2RlIH0gPSBwb3M7XG4gICAgICAgIGxldCBsZWZ0Tm9kZTtcbiAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQuY2hpbGRyZW5bMF0gPT09IG5vZGUgJiYgb2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbGVmdE5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxlZnROb2RlID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBsZWZ0Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZWZ0Tm9kZSA9IG5vZGUuY2hpbGRyZW5bb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENSRFRUcmVlUG9zLm9mKG5vZGUuaWQsIENSRFRUcmVlTm9kZUlELm9mKGxlZnROb2RlLmdldENyZWF0ZWRBdCgpLCBsZWZ0Tm9kZS5nZXRPZmZzZXQoKSArIG9mZnNldCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0UGFyZW50SURgIHJldHVybnMgdGhlIHBhcmVudCBJRC5cbiAgICAgKi9cbiAgICBnZXRQYXJlbnRJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50SUQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBmcm9tU3RydWN0YCBjcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIENSRFRUcmVlTm9kZUlEIGZyb20gdGhlIGdpdmVuIHN0cnVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cnVjdChzdHJ1Y3QpIHtcbiAgICAgICAgcmV0dXJuIENSRFRUcmVlUG9zLm9mKENSRFRUcmVlTm9kZUlELm9mKFRpbWVUaWNrZXQuZnJvbVN0cnVjdChzdHJ1Y3QucGFyZW50SUQuY3JlYXRlZEF0KSwgc3RydWN0LnBhcmVudElELm9mZnNldCksIENSRFRUcmVlTm9kZUlELm9mKFRpbWVUaWNrZXQuZnJvbVN0cnVjdChzdHJ1Y3QubGVmdFNpYmxpbmdJRC5jcmVhdGVkQXQpLCBzdHJ1Y3QubGVmdFNpYmxpbmdJRC5vZmZzZXQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRvU3RydWN0YCByZXR1cm5zIHRoZSBzdHJ1Y3R1cmUgb2YgdGhpcyBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICB0b1N0cnVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhcmVudElEOiB7XG4gICAgICAgICAgICAgICAgY3JlYXRlZEF0OiB0aGlzLmdldFBhcmVudElEKCkuZ2V0Q3JlYXRlZEF0KCkudG9TdHJ1Y3QoKSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMuZ2V0UGFyZW50SUQoKS5nZXRPZmZzZXQoKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZWZ0U2libGluZ0lEOiB7XG4gICAgICAgICAgICAgICAgY3JlYXRlZEF0OiB0aGlzLmdldExlZnRTaWJsaW5nSUQoKS5nZXRDcmVhdGVkQXQoKS50b1N0cnVjdCgpLFxuICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5nZXRMZWZ0U2libGluZ0lEKCkuZ2V0T2Zmc2V0KCksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdG9UcmVlTm9kZXNgIGNvbnZlcnRzIHRoZSBwb3MgdG8gcGFyZW50IGFuZCBsZWZ0IHNpYmxpbmcgbm9kZXMuXG4gICAgICogSWYgdGhlIHBvc2l0aW9uIHBvaW50cyB0byB0aGUgbWlkZGxlIG9mIGEgbm9kZSwgdGhlbiB0aGUgbGVmdCBzaWJsaW5nIG5vZGVcbiAgICAgKiBpcyB0aGUgbm9kZSB0aGF0IGNvbnRhaW5zIHRoZSBwb3NpdGlvbi4gT3RoZXJ3aXNlLCB0aGUgbGVmdCBzaWJsaW5nIG5vZGUgaXNcbiAgICAgKiB0aGUgbm9kZSB0aGF0IGlzIGxvY2F0ZWQgYXQgdGhlIGxlZnQgb2YgdGhlIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIHRvVHJlZU5vZGVzKHRyZWUpIHtcbiAgICAgICAgY29uc3QgcGFyZW50SUQgPSB0aGlzLmdldFBhcmVudElEKCk7XG4gICAgICAgIGNvbnN0IGxlZnRTaWJsaW5nSUQgPSB0aGlzLmdldExlZnRTaWJsaW5nSUQoKTtcbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IHRyZWUuZmluZEZsb29yTm9kZShwYXJlbnRJRCk7XG4gICAgICAgIGxldCBsZWZ0Tm9kZSA9IHRyZWUuZmluZEZsb29yTm9kZShsZWZ0U2libGluZ0lEKTtcbiAgICAgICAgaWYgKCFwYXJlbnROb2RlIHx8ICFsZWZ0Tm9kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZmluZCBub2RlIGF0ICR7dGhpc31gKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTk9URShoYWNrZXJ3aW5zKTogSWYgdGhlIGxlZnQgbm9kZSBhbmQgdGhlIHBhcmVudCBub2RlIGFyZSB0aGUgc2FtZSxcbiAgICAgICAgICogaXQgbWVhbnMgdGhhdCB0aGUgcG9zaXRpb24gaXMgdGhlIGxlZnQtbW9zdCBvZiB0aGUgcGFyZW50IG5vZGUuXG4gICAgICAgICAqIFdlIG5lZWQgdG8gc2tpcCBmaW5kaW5nIHRoZSBsZWZ0IG9mIHRoZSBwb3NpdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGlmICghbGVmdFNpYmxpbmdJRC5lcXVhbHMocGFyZW50SUQpICYmXG4gICAgICAgICAgICBsZWZ0U2libGluZ0lELmdldE9mZnNldCgpID4gMCAmJlxuICAgICAgICAgICAgbGVmdFNpYmxpbmdJRC5nZXRPZmZzZXQoKSA9PT0gbGVmdE5vZGUuaWQuZ2V0T2Zmc2V0KCkgJiZcbiAgICAgICAgICAgIGxlZnROb2RlLmluc1ByZXZJRCkge1xuICAgICAgICAgICAgbGVmdE5vZGUgPSB0cmVlLmZpbmRGbG9vck5vZGUobGVmdE5vZGUuaW5zUHJldklEKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3BhcmVudE5vZGUsIGxlZnROb2RlXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldExlZnRTaWJsaW5nSURgIHJldHVybnMgdGhlIGxlZnQgc2libGluZyBJRC5cbiAgICAgKi9cbiAgICBnZXRMZWZ0U2libGluZ0lEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0U2libGluZ0lEO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZXF1YWxzYCByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIHBvcyBlcXVhbHMgdG8gdGhpcyBvciBub3QuXG4gICAgICovXG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5nZXRQYXJlbnRJRCgpXG4gICAgICAgICAgICAuZ2V0Q3JlYXRlZEF0KClcbiAgICAgICAgICAgIC5lcXVhbHMob3RoZXIuZ2V0UGFyZW50SUQoKS5nZXRDcmVhdGVkQXQoKSkgJiZcbiAgICAgICAgICAgIHRoaXMuZ2V0UGFyZW50SUQoKS5nZXRPZmZzZXQoKSA9PT0gb3RoZXIuZ2V0UGFyZW50SUQoKS5nZXRPZmZzZXQoKSAmJlxuICAgICAgICAgICAgdGhpcy5nZXRMZWZ0U2libGluZ0lEKClcbiAgICAgICAgICAgICAgICAuZ2V0Q3JlYXRlZEF0KClcbiAgICAgICAgICAgICAgICAuZXF1YWxzKG90aGVyLmdldExlZnRTaWJsaW5nSUQoKS5nZXRDcmVhdGVkQXQoKSkgJiZcbiAgICAgICAgICAgIHRoaXMuZ2V0TGVmdFNpYmxpbmdJRCgpLmdldE9mZnNldCgpID09PVxuICAgICAgICAgICAgICAgIG90aGVyLmdldExlZnRTaWJsaW5nSUQoKS5nZXRPZmZzZXQoKSk7XG4gICAgfVxufVxuLyoqXG4gKiBgQ1JEVFRyZWVOb2RlSURgIHJlcHJlc2VudCBhbiBJRCBvZiBhIG5vZGUgaW4gdGhlIHRyZWUuIEl0IGlzIHVzZWQgdG9cbiAqIGlkZW50aWZ5IGEgbm9kZSBpbiB0aGUgdHJlZS4gSXQgaXMgY29tcG9zZWQgb2YgdGhlIGNyZWF0aW9uIHRpbWUgb2YgdGhlIG5vZGVcbiAqIGFuZCB0aGUgb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgbm9kZSBpZiB0aGUgbm9kZSBpcyBzcGxpdC5cbiAqXG4gKiBTb21lIG9mIHJlcGxpY2FzIG1heSBoYXZlIG5vZGVzIHRoYXQgYXJlIG5vdCBzcGxpdCB5ZXQuIEluIHRoaXMgY2FzZSwgd2UgY2FuXG4gKiB1c2UgYG1hcC5mbG9vckVudHJ5KClgIHRvIGZpbmQgdGhlIGFkamFjZW50IG5vZGUuXG4gKi9cbmNsYXNzIENSRFRUcmVlTm9kZUlEIHtcbiAgICBjb25zdHJ1Y3RvcihjcmVhdGVkQXQsIG9mZnNldCkge1xuICAgICAgICB0aGlzLmNyZWF0ZWRBdCA9IGNyZWF0ZWRBdDtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBvZmAgY3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBDUkRUVHJlZU5vZGVJRC5cbiAgICAgKi9cbiAgICBzdGF0aWMgb2YoY3JlYXRlZEF0LCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDUkRUVHJlZU5vZGVJRChjcmVhdGVkQXQsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBmcm9tU3RydWN0YCBjcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIENSRFRUcmVlTm9kZUlEIGZyb20gdGhlIGdpdmVuIHN0cnVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cnVjdChzdHJ1Y3QpIHtcbiAgICAgICAgcmV0dXJuIENSRFRUcmVlTm9kZUlELm9mKFRpbWVUaWNrZXQuZnJvbVN0cnVjdChzdHJ1Y3QuY3JlYXRlZEF0KSwgc3RydWN0Lm9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBjcmVhdGVDb21wYXJhdG9yYCBjcmVhdGVzIGEgY29tcGFyYXRvciBmb3IgQ1JEVFRyZWVOb2RlSUQuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUNvbXBhcmF0b3IoKSB7XG4gICAgICAgIHJldHVybiAoaWRBLCBpZEIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBhcmUgPSBpZEEuZ2V0Q3JlYXRlZEF0KCkuY29tcGFyZShpZEIuZ2V0Q3JlYXRlZEF0KCkpO1xuICAgICAgICAgICAgaWYgKGNvbXBhcmUgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpZEEuZ2V0T2Zmc2V0KCkgPiBpZEIuZ2V0T2Zmc2V0KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlkQS5nZXRPZmZzZXQoKSA8IGlkQi5nZXRPZmZzZXQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0Q3JlYXRlZEF0YCByZXR1cm5zIHRoZSBjcmVhdGlvbiB0aW1lIG9mIHRoZSBub2RlLlxuICAgICAqL1xuICAgIGdldENyZWF0ZWRBdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlZEF0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZXF1YWxzYCByZXR1cm5zIHdoZXRoZXIgZ2l2ZW4gSUQgZXF1YWxzIHRvIHRoaXMgSUQgb3Igbm90LlxuICAgICAqL1xuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gKHRoaXMuY3JlYXRlZEF0LmNvbXBhcmUob3RoZXIuY3JlYXRlZEF0KSA9PT0gMCAmJlxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPT09IG90aGVyLm9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRPZmZzZXRgIHJldHVybnMgcmV0dXJucyB0aGUgb2Zmc2V0IG9mIHRoZSBub2RlLlxuICAgICAqL1xuICAgIGdldE9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgc2V0T2Zmc2V0YCBzZXRzIHRoZSBvZmZzZXQgb2YgdGhlIG5vZGUuXG4gICAgICovXG4gICAgc2V0T2Zmc2V0KG9mZnNldCkge1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRvU3RydWN0YCByZXR1cm5zIHRoZSBzdHJ1Y3R1cmUgb2YgdGhpcyBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICB0b1N0cnVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogdGhpcy5jcmVhdGVkQXQudG9TdHJ1Y3QoKSxcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0b0lEU3RyaW5nYCByZXR1cm5zIGEgc3RyaW5nIHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gSUQgZm9yIHRoaXMgcG9zaXRpb24uXG4gICAgICovXG4gICAgdG9JRFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY3JlYXRlZEF0LnRvSURTdHJpbmcoKX06JHt0aGlzLm9mZnNldH1gO1xuICAgIH1cbn1cbi8qKlxuICogYENSRFRUcmVlTm9kZWAgaXMgYSBub2RlIG9mIENSRFRUcmVlLiBJdCBpcyBpbmNsdWRlcyB0aGUgbG9naWNhbCBjbG9jayBhbmRcbiAqIGxpbmtzIHRvIG90aGVyIG5vZGVzIHRvIHJlc29sdmUgY29uZmxpY3RzLlxuICovXG5jbGFzcyBDUkRUVHJlZU5vZGUgZXh0ZW5kcyBJbmRleFRyZWVOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihpZCwgdHlwZSwgb3B0cywgYXR0cmlidXRlcywgcmVtb3ZlZEF0KSB7XG4gICAgICAgIHN1cGVyKHR5cGUpO1xuICAgICAgICB0aGlzLl92YWx1ZSA9ICcnO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMucmVtb3ZlZEF0ID0gcmVtb3ZlZEF0O1xuICAgICAgICBhdHRyaWJ1dGVzICYmICh0aGlzLmF0dHJzID0gYXR0cmlidXRlcyk7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBvcHRzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3B0cykpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuID0gb3B0cztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBgY3JlYXRlYCBjcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIENSRFRUcmVlTm9kZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGlkLCB0eXBlLCBvcHRzLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ1JEVFRyZWVOb2RlKGlkLCB0eXBlLCBvcHRzLCBhdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGRlZXBjb3B5YCBjb3BpZXMgaXRzZWxmIGRlZXBseS5cbiAgICAgKi9cbiAgICBkZWVwY29weSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjbG9uZSA9IG5ldyBDUkRUVHJlZU5vZGUodGhpcy5pZCwgdGhpcy50eXBlKTtcbiAgICAgICAgY2xvbmUucmVtb3ZlZEF0ID0gdGhpcy5yZW1vdmVkQXQ7XG4gICAgICAgIGNsb25lLl92YWx1ZSA9IHRoaXMuX3ZhbHVlO1xuICAgICAgICBjbG9uZS5zaXplID0gdGhpcy5zaXplO1xuICAgICAgICBjbG9uZS5hdHRycyA9IChfYSA9IHRoaXMuYXR0cnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWVwY29weSgpO1xuICAgICAgICBjbG9uZS5fY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZENsb25lID0gY2hpbGQuZGVlcGNvcHkoKTtcbiAgICAgICAgICAgIGNoaWxkQ2xvbmUucGFyZW50ID0gY2xvbmU7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRDbG9uZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHZhbHVlYCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbm9kZS5cbiAgICAgKi9cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1RleHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGdldCB2YWx1ZSBvZiBlbGVtZW50IG5vZGU6ICR7dGhpcy50eXBlfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHZhbHVlYCBzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgbm9kZS5cbiAgICAgKi9cbiAgICBzZXQgdmFsdWUodikge1xuICAgICAgICBpZiAoIXRoaXMuaXNUZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBzZXQgdmFsdWUgb2YgZWxlbWVudCBub2RlOiAke3RoaXMudHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92YWx1ZSA9IHY7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHYubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgaXNSZW1vdmVkYCByZXR1cm5zIHdoZXRoZXIgdGhlIG5vZGUgaXMgcmVtb3ZlZCBvciBub3QuXG4gICAgICovXG4gICAgZ2V0IGlzUmVtb3ZlZCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5yZW1vdmVkQXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGByZW1vdmVgIG1hcmtzIHRoZSBub2RlIGFzIHJlbW92ZWQuXG4gICAgICovXG4gICAgcmVtb3ZlKHJlbW92ZWRBdCkge1xuICAgICAgICBjb25zdCBhbGl2ZWQgPSAhdGhpcy5yZW1vdmVkQXQ7XG4gICAgICAgIGlmICghdGhpcy5yZW1vdmVkQXQgfHwgdGhpcy5yZW1vdmVkQXQuY29tcGFyZShyZW1vdmVkQXQpID4gMCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVkQXQgPSByZW1vdmVkQXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsaXZlZCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBbmNlc3RvcnNTaXplKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogYGNsb25lVGV4dGAgY2xvbmVzIHRoaXMgdGV4dCBub2RlIHdpdGggdGhlIGdpdmVuIG9mZnNldC5cbiAgICAgKi9cbiAgICBjbG9uZVRleHQob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQ1JEVFRyZWVOb2RlKENSRFRUcmVlTm9kZUlELm9mKHRoaXMuaWQuZ2V0Q3JlYXRlZEF0KCksIG9mZnNldCksIHRoaXMudHlwZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRoaXMucmVtb3ZlZEF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGNsb25lRWxlbWVudGAgY2xvbmVzIHRoaXMgZWxlbWVudCBub2RlIHdpdGggdGhlIGdpdmVuIGlzc3VlVGltZVRpY2tldCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBjbG9uZUVsZW1lbnQoaXNzdWVUaW1lVGlja2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQ1JEVFRyZWVOb2RlKENSRFRUcmVlTm9kZUlELm9mKGlzc3VlVGltZVRpY2tldCgpLCAwKSwgdGhpcy50eXBlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGhpcy5yZW1vdmVkQXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgc3BsaXRgIHNwbGl0cyB0aGUgZ2l2ZW4gb2Zmc2V0IG9mIHRoaXMgbm9kZS5cbiAgICAgKi9cbiAgICBzcGxpdCh0cmVlLCBvZmZzZXQsIGlzc3VlVGltZVRpY2tldCkge1xuICAgICAgICBjb25zdCBzcGxpdCA9IHRoaXMuaXNUZXh0XG4gICAgICAgICAgICA/IHRoaXMuc3BsaXRUZXh0KG9mZnNldCwgdGhpcy5pZC5nZXRPZmZzZXQoKSlcbiAgICAgICAgICAgIDogdGhpcy5zcGxpdEVsZW1lbnQob2Zmc2V0LCBpc3N1ZVRpbWVUaWNrZXQpO1xuICAgICAgICBpZiAoc3BsaXQpIHtcbiAgICAgICAgICAgIHNwbGl0Lmluc1ByZXZJRCA9IHRoaXMuaWQ7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnNOZXh0SUQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnNOZXh0ID0gdHJlZS5maW5kRmxvb3JOb2RlKHRoaXMuaW5zTmV4dElEKTtcbiAgICAgICAgICAgICAgICBpbnNOZXh0Lmluc1ByZXZJRCA9IHNwbGl0LmlkO1xuICAgICAgICAgICAgICAgIHNwbGl0Lmluc05leHRJRCA9IHRoaXMuaW5zTmV4dElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbnNOZXh0SUQgPSBzcGxpdC5pZDtcbiAgICAgICAgICAgIHRyZWUucmVnaXN0ZXJOb2RlKHNwbGl0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BsaXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRDcmVhdGVkQXRgIHJldHVybnMgdGhlIGNyZWF0aW9uIHRpbWUgb2YgdGhpcyBlbGVtZW50LlxuICAgICAqL1xuICAgIGdldENyZWF0ZWRBdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQuZ2V0Q3JlYXRlZEF0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRPZmZzZXRgIHJldHVybnMgdGhlIG9mZnNldCBvZiBhIHBvcy5cbiAgICAgKi9cbiAgICBnZXRPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkLmdldE9mZnNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgY2FuRGVsZXRlYCBjaGVja3MgaWYgbm9kZSBpcyBhYmxlIHRvIGRlbGV0ZS5cbiAgICAgKi9cbiAgICBjYW5EZWxldGUoZWRpdGVkQXQsIGxhdGVzdENyZWF0ZWRBdCkge1xuICAgICAgICByZXR1cm4gKCF0aGlzLmdldENyZWF0ZWRBdCgpLmFmdGVyKGxhdGVzdENyZWF0ZWRBdCkgJiZcbiAgICAgICAgICAgICghdGhpcy5yZW1vdmVkQXQgfHwgZWRpdGVkQXQuYWZ0ZXIodGhpcy5yZW1vdmVkQXQpKSk7XG4gICAgfVxufVxuLyoqXG4gKiB0b1RyZWVOb2RlIGNvbnZlcnRzIHRoZSBnaXZlbiBDUkRUVHJlZU5vZGUgdG8gVHJlZU5vZGUuXG4gKi9cbmZ1bmN0aW9uIHRvVHJlZU5vZGUobm9kZSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgICAgY29uc3QgY3VycmVudE5vZGUgPSBub2RlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogY3VycmVudE5vZGUudHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiBjdXJyZW50Tm9kZS52YWx1ZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICBjaGlsZHJlbjogbm9kZS5jaGlsZHJlbi5tYXAodG9UcmVlTm9kZSksXG4gICAgICAgIGF0dHJpYnV0ZXM6IG5vZGUuYXR0cnNcbiAgICAgICAgICAgID8gcGFyc2VPYmplY3RWYWx1ZXMoKF9hID0gbm9kZS5hdHRycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvT2JqZWN0KCkpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuLyoqXG4gKiB0b1hNTCBjb252ZXJ0cyB0aGUgZ2l2ZW4gQ1JEVE5vZGUgdG8gWE1MIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9YTUwobm9kZSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgICAgY29uc3QgY3VycmVudE5vZGUgPSBub2RlO1xuICAgICAgICByZXR1cm4gY3VycmVudE5vZGUudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBgPCR7bm9kZS50eXBlfSR7KChfYSA9IG5vZGUuYXR0cnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b1hNTCgpKSB8fCAnJ30+JHtub2RlLmNoaWxkcmVuXG4gICAgICAgIC5tYXAoKGNoaWxkKSA9PiB0b1hNTChjaGlsZCkpXG4gICAgICAgIC5qb2luKCcnKX08LyR7bm9kZS50eXBlfT5gO1xufVxuLyoqXG4gKiBgdG9UZXN0VHJlZU5vZGVgIGNvbnZlcnRzIHRoZSBnaXZlbiBDUkRUTm9kZSBKU09OIGZvciBkZWJ1Z2dpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvVGVzdFRyZWVOb2RlKG5vZGUpIHtcbiAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgICAgY29uc3QgY3VycmVudE5vZGUgPSBub2RlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogY3VycmVudE5vZGUudHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiBjdXJyZW50Tm9kZS52YWx1ZSxcbiAgICAgICAgICAgIHNpemU6IGN1cnJlbnROb2RlLnNpemUsXG4gICAgICAgICAgICBpc1JlbW92ZWQ6IGN1cnJlbnROb2RlLmlzUmVtb3ZlZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICBjaGlsZHJlbjogbm9kZS5jaGlsZHJlbi5tYXAodG9UZXN0VHJlZU5vZGUpLFxuICAgICAgICBzaXplOiBub2RlLnNpemUsXG4gICAgICAgIGlzUmVtb3ZlZDogbm9kZS5pc1JlbW92ZWQsXG4gICAgfTtcbn1cbi8qKlxuICogYENSRFRUcmVlYCBpcyBhIENSRFQgaW1wbGVtZW50YXRpb24gb2YgYSB0cmVlLlxuICovXG5jbGFzcyBDUkRUVHJlZSBleHRlbmRzIENSRFRHQ0VsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHJvb3QsIGNyZWF0ZWRBdCkge1xuICAgICAgICBzdXBlcihjcmVhdGVkQXQpO1xuICAgICAgICB0aGlzLmluZGV4VHJlZSA9IG5ldyBJbmRleFRyZWUocm9vdCk7XG4gICAgICAgIHRoaXMubm9kZU1hcEJ5SUQgPSBuZXcgTExSQlRyZWUoQ1JEVFRyZWVOb2RlSUQuY3JlYXRlQ29tcGFyYXRvcigpKTtcbiAgICAgICAgdGhpcy5yZW1vdmVkTm9kZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pbmRleFRyZWUudHJhdmVyc2UoKG5vZGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMubm9kZU1hcEJ5SUQucHV0KG5vZGUuaWQsIG5vZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGNyZWF0ZWAgY3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBgQ1JEVFRyZWVgLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUocm9vdCwgdGlja2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQ1JEVFRyZWUocm9vdCwgdGlja2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGZpbmRGbG9vck5vZGVgIGZpbmRzIG5vZGUgb2YgZ2l2ZW4gaWQuXG4gICAgICovXG4gICAgZmluZEZsb29yTm9kZShpZCkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMubm9kZU1hcEJ5SUQuZmxvb3JFbnRyeShpZCk7XG4gICAgICAgIGlmICghZW50cnkgfHwgIWVudHJ5LmtleS5nZXRDcmVhdGVkQXQoKS5lcXVhbHMoaWQuZ2V0Q3JlYXRlZEF0KCkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgcmVnaXN0ZXJOb2RlYCByZWdpc3RlcnMgdGhlIGdpdmVuIG5vZGUgdG8gdGhlIHRyZWUuXG4gICAgICovXG4gICAgcmVnaXN0ZXJOb2RlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5ub2RlTWFwQnlJRC5wdXQobm9kZS5pZCwgbm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBmaW5kTm9kZXNBbmRTcGxpdFRleHRgIGZpbmRzIGBUcmVlUG9zYCBvZiB0aGUgZ2l2ZW4gYENSRFRUcmVlTm9kZUlEYCBhbmRcbiAgICAgKiBzcGxpdHMgbm9kZXMgaWYgdGhlIHBvc2l0aW9uIGlzIGluIHRoZSBtaWRkbGUgb2YgYSB0ZXh0IG5vZGUuXG4gICAgICpcbiAgICAgKiBUaGUgaWRzIG9mIHRoZSBnaXZlbiBgcG9zYCBhcmUgdGhlIGlkcyBvZiB0aGUgbm9kZSBpbiB0aGUgQ1JEVCBwZXJzcGVjdGl2ZS5cbiAgICAgKiBUaGlzIGlzIGRpZmZlcmVudCBmcm9tIGBUcmVlUG9zYCB3aGljaCBpcyBhIHBvc2l0aW9uIG9mIHRoZSB0cmVlIGluIHRoZVxuICAgICAqIHBoeXNpY2FsIHBlcnNwZWN0aXZlLlxuICAgICAqL1xuICAgIGZpbmROb2Rlc0FuZFNwbGl0VGV4dChwb3MsIGVkaXRlZEF0KSB7XG4gICAgICAgIC8vIDAxLiBGaW5kIHRoZSBwYXJlbnQgYW5kIGxlZnQgc2libGluZyBub2RlIG9mIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAgICAgY29uc3QgW3BhcmVudCwgbGVmdFNpYmxpbmddID0gcG9zLnRvVHJlZU5vZGVzKHRoaXMpO1xuICAgICAgICBsZXQgbGVmdE5vZGUgPSBsZWZ0U2libGluZztcbiAgICAgICAgLy8gMDIuIERldGVybWluZSB3aGV0aGVyIHRoZSBwb3NpdGlvbiBpcyBsZWZ0LW1vc3QgYW5kIHRoZSBleGFjdCBwYXJlbnRcbiAgICAgICAgLy8gaW4gdGhlIGN1cnJlbnQgdHJlZS5cbiAgICAgICAgY29uc3QgaXNMZWZ0TW9zdCA9IHBhcmVudCA9PT0gbGVmdE5vZGU7XG4gICAgICAgIGNvbnN0IHJlYWxQYXJlbnQgPSBsZWZ0Tm9kZS5wYXJlbnQgJiYgIWlzTGVmdE1vc3QgPyBsZWZ0Tm9kZS5wYXJlbnQgOiBwYXJlbnQ7XG4gICAgICAgIC8vIDAzLiBTcGxpdCB0ZXh0IG5vZGUgaWYgdGhlIGxlZnQgbm9kZSBpcyBhIHRleHQgbm9kZS5cbiAgICAgICAgaWYgKGxlZnROb2RlLmlzVGV4dCkge1xuICAgICAgICAgICAgbGVmdE5vZGUuc3BsaXQodGhpcywgcG9zLmdldExlZnRTaWJsaW5nSUQoKS5nZXRPZmZzZXQoKSAtIGxlZnROb2RlLmlkLmdldE9mZnNldCgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAwNC4gRmluZCB0aGUgYXBwcm9wcmlhdGUgbGVmdCBub2RlLiBJZiBzb21lIG5vZGVzIGFyZSBpbnNlcnRlZCBhdCB0aGVcbiAgICAgICAgLy8gc2FtZSBwb3NpdGlvbiBjb25jdXJyZW50bHksIHRoZW4gd2UgbmVlZCB0byBmaW5kIHRoZSBhcHByb3ByaWF0ZSBsZWZ0XG4gICAgICAgIC8vIG5vZGUuIFRoaXMgaXMgc2ltaWxhciB0byBSR0EuXG4gICAgICAgIGNvbnN0IGFsbENoaWxkcmVuID0gcmVhbFBhcmVudC5hbGxDaGlsZHJlbjtcbiAgICAgICAgY29uc3QgaW5kZXggPSBpc0xlZnRNb3N0ID8gMCA6IGFsbENoaWxkcmVuLmluZGV4T2YobGVmdE5vZGUpICsgMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4OyBpIDwgcGFyZW50LmFsbENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gYWxsQ2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoIW5leHQuaWQuZ2V0Q3JlYXRlZEF0KCkuYWZ0ZXIoZWRpdGVkQXQpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZWZ0Tm9kZSA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtyZWFsUGFyZW50LCBsZWZ0Tm9kZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBzdHlsZWAgYXBwbGllcyB0aGUgZ2l2ZW4gYXR0cmlidXRlcyBvZiB0aGUgZ2l2ZW4gcmFuZ2UuXG4gICAgICovXG4gICAgc3R5bGUocmFuZ2UsIGF0dHJpYnV0ZXMsIGVkaXRlZEF0KSB7XG4gICAgICAgIGNvbnN0IFtmcm9tUGFyZW50LCBmcm9tTGVmdF0gPSB0aGlzLmZpbmROb2Rlc0FuZFNwbGl0VGV4dChyYW5nZVswXSwgZWRpdGVkQXQpO1xuICAgICAgICBjb25zdCBbdG9QYXJlbnQsIHRvTGVmdF0gPSB0aGlzLmZpbmROb2Rlc0FuZFNwbGl0VGV4dChyYW5nZVsxXSwgZWRpdGVkQXQpO1xuICAgICAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBUcmVlQ2hhbmdlVHlwZS5TdHlsZSxcbiAgICAgICAgICAgIGZyb206IHRoaXMudG9JbmRleChmcm9tUGFyZW50LCBmcm9tTGVmdCksXG4gICAgICAgICAgICB0bzogdGhpcy50b0luZGV4KHRvUGFyZW50LCB0b0xlZnQpLFxuICAgICAgICAgICAgZnJvbVBhdGg6IHRoaXMudG9QYXRoKGZyb21QYXJlbnQsIGZyb21MZWZ0KSxcbiAgICAgICAgICAgIHRvUGF0aDogdGhpcy50b1BhdGgodG9QYXJlbnQsIHRvTGVmdCksXG4gICAgICAgICAgICBhY3RvcjogZWRpdGVkQXQuZ2V0QWN0b3JJRCgpLFxuICAgICAgICAgICAgdmFsdWU6IGF0dHJpYnV0ZXMgPyBwYXJzZU9iamVjdFZhbHVlcyhhdHRyaWJ1dGVzKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJhdmVyc2VJblBvc1JhbmdlKGZyb21QYXJlbnQsIGZyb21MZWZ0LCB0b1BhcmVudCwgdG9MZWZ0LCAobm9kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFub2RlLmlzUmVtb3ZlZCAmJiAhbm9kZS5pc1RleHQgJiYgYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIGlmICghbm9kZS5hdHRycykge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmF0dHJzID0gbmV3IFJIVCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmF0dHJzLnNldChrZXksIHZhbHVlLCBlZGl0ZWRBdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNoYW5nZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBlZGl0YCBlZGl0cyB0aGUgdHJlZSB3aXRoIHRoZSBnaXZlbiByYW5nZSBhbmQgY29udGVudC5cbiAgICAgKiBJZiB0aGUgY29udGVudCBpcyB1bmRlZmluZWQsIHRoZSByYW5nZSB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICovXG4gICAgZWRpdChyYW5nZSwgY29udGVudHMsIHNwbGl0TGV2ZWwsIGVkaXRlZEF0LCBpc3N1ZVRpbWVUaWNrZXQsIGxhdGVzdENyZWF0ZWRBdE1hcEJ5QWN0b3IpIHtcbiAgICAgICAgLy8gMDEuIGZpbmQgbm9kZXMgZnJvbSB0aGUgZ2l2ZW4gcmFuZ2UgYW5kIHNwbGl0IG5vZGVzLlxuICAgICAgICBjb25zdCBbZnJvbVBhcmVudCwgZnJvbUxlZnRdID0gdGhpcy5maW5kTm9kZXNBbmRTcGxpdFRleHQocmFuZ2VbMF0sIGVkaXRlZEF0KTtcbiAgICAgICAgY29uc3QgW3RvUGFyZW50LCB0b0xlZnRdID0gdGhpcy5maW5kTm9kZXNBbmRTcGxpdFRleHQocmFuZ2VbMV0sIGVkaXRlZEF0KTtcbiAgICAgICAgY29uc3QgdG9CZVJlbW92ZWRzID0gW107XG4gICAgICAgIGNvbnN0IHRvQmVNb3ZlZFRvRnJvbVBhcmVudHMgPSBbXTtcbiAgICAgICAgY29uc3QgbGF0ZXN0Q3JlYXRlZEF0TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnRyYXZlcnNlSW5Qb3NSYW5nZShmcm9tUGFyZW50LCBmcm9tTGVmdCwgdG9QYXJlbnQsIHRvTGVmdCwgKG5vZGUsIGNvbnRhaW4pID0+IHtcbiAgICAgICAgICAgIC8vIE5PVEUoaGFja2Vyd2lucyk6IElmIHRoZSBub2RlIG92ZXJsYXBzIGFzIGEgY2xvc2luZyB0YWcgd2l0aCB0aGVcbiAgICAgICAgICAgIC8vIHJhbmdlIHRoZW4gd2UgbmVlZCB0byBrZWVwIHRoZSBub2RlLlxuICAgICAgICAgICAgaWYgKCFub2RlLmlzVGV4dCAmJiBjb250YWluID09IFRhZ0NvbnRhaW5lZC5DbG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTk9URShoYWNrZXJ3aW5zKTogSWYgdGhlIG5vZGUgb3ZlcmxhcHMgYXMgYW4gb3BlbmluZyB0YWcgd2l0aCB0aGVcbiAgICAgICAgICAgIC8vIHJhbmdlIHRoZW4gd2UgbmVlZCB0byBtb3ZlIHRoZSByZW1haW5pbmcgY2hpbGRyZW4gdG8gZnJvbVBhcmVudC5cbiAgICAgICAgICAgIGlmICghbm9kZS5pc1RleHQgJiYgY29udGFpbiA9PSBUYWdDb250YWluZWQuT3BlbmluZykge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8oaGFja2Vyd2lucyk6IERlZmluZSBtb3JlIGNsZWFybHkgbWVyZ2UtYWJsZSBydWxlc1xuICAgICAgICAgICAgICAgIC8vIGJldHdlZW4gdHdvIHBhcmVudHMuIEZvciBub3csIHdlIG9ubHkgbWVyZ2UgdHdvIHBhcmVudHMgYXJlXG4gICAgICAgICAgICAgICAgLy8gYm90aCBlbGVtZW50IG5vZGVzIGhhdmluZyB0ZXh0IGNoaWxkcmVuLlxuICAgICAgICAgICAgICAgIC8vIGUuZy4gPHA+YXxiPC9wPjxwPmN8ZDwvcD4gLT4gPHA+YXxkPC9wPlxuICAgICAgICAgICAgICAgIC8vIGlmICghZnJvbVBhcmVudC5oYXNUZXh0Q2hpbGQoKSB8fCAhdG9QYXJlbnQuaGFzVGV4dENoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICAvLyAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b0JlUmVtb3ZlZHMuaW5jbHVkZXMoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0b0JlTW92ZWRUb0Zyb21QYXJlbnRzLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFjdG9ySUQgPSBub2RlLmdldENyZWF0ZWRBdCgpLmdldEFjdG9ySUQoKTtcbiAgICAgICAgICAgIGNvbnN0IGxhdGVzdENyZWF0ZWRBdCA9IGxhdGVzdENyZWF0ZWRBdE1hcEJ5QWN0b3JcbiAgICAgICAgICAgICAgICA/IGxhdGVzdENyZWF0ZWRBdE1hcEJ5QWN0b3IuaGFzKGFjdG9ySUQpXG4gICAgICAgICAgICAgICAgICAgID8gbGF0ZXN0Q3JlYXRlZEF0TWFwQnlBY3Rvci5nZXQoYWN0b3JJRClcbiAgICAgICAgICAgICAgICAgICAgOiBJbml0aWFsVGltZVRpY2tldFxuICAgICAgICAgICAgICAgIDogTWF4VGltZVRpY2tldDtcbiAgICAgICAgICAgIGlmIChub2RlLmNhbkRlbGV0ZShlZGl0ZWRBdCwgbGF0ZXN0Q3JlYXRlZEF0KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhdGVzdENyZWF0ZWRBdCA9IGxhdGVzdENyZWF0ZWRBdE1hcC5nZXQoYWN0b3JJRCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3JlYXRlZEF0ID0gbm9kZS5nZXRDcmVhdGVkQXQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWxhdGVzdENyZWF0ZWRBdCB8fCBjcmVhdGVkQXQuYWZ0ZXIobGF0ZXN0Q3JlYXRlZEF0KSkge1xuICAgICAgICAgICAgICAgICAgICBsYXRlc3RDcmVhdGVkQXRNYXAuc2V0KGFjdG9ySUQsIGNyZWF0ZWRBdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvQmVSZW1vdmVkcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVE9ETyhoYWNrZXJ3aW5zKTogSWYgY29uY3VycmVudCBkZWxldGlvbiBoYXBwZW5zLCB3ZSBuZWVkIHRvIHNlcGVyYXRlIHRoZVxuICAgICAgICAvLyByYW5nZShmcm9tLCB0bykgaW50byBtdWx0aXBsZSByYW5nZXMuXG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFRyZWVDaGFuZ2VUeXBlLkNvbnRlbnQsXG4gICAgICAgICAgICBmcm9tOiB0aGlzLnRvSW5kZXgoZnJvbVBhcmVudCwgZnJvbUxlZnQpLFxuICAgICAgICAgICAgdG86IHRoaXMudG9JbmRleCh0b1BhcmVudCwgdG9MZWZ0KSxcbiAgICAgICAgICAgIGZyb21QYXRoOiB0aGlzLnRvUGF0aChmcm9tUGFyZW50LCBmcm9tTGVmdCksXG4gICAgICAgICAgICB0b1BhdGg6IHRoaXMudG9QYXRoKHRvUGFyZW50LCB0b0xlZnQpLFxuICAgICAgICAgICAgYWN0b3I6IGVkaXRlZEF0LmdldEFjdG9ySUQoKSxcbiAgICAgICAgICAgIHZhbHVlOiAoY29udGVudHMgPT09IG51bGwgfHwgY29udGVudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRlbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICA/IGNvbnRlbnRzLm1hcCgoY29udGVudCkgPT4gdG9UcmVlTm9kZShjb250ZW50KSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNwbGl0TGV2ZWwsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyAwMi4gRGVsZXRlOiBkZWxldGUgdGhlIG5vZGVzIHRoYXQgYXJlIG1hcmtlZCBhcyByZW1vdmVkLlxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdG9CZVJlbW92ZWRzKSB7XG4gICAgICAgICAgICBub2RlLnJlbW92ZShlZGl0ZWRBdCk7XG4gICAgICAgICAgICBpZiAobm9kZS5pc1JlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZWROb2RlTWFwLnNldChub2RlLmlkLnRvSURTdHJpbmcoKSwgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gMDMuIE1lcmdlOiBtb3ZlIHRoZSBub2RlcyB0aGF0IGFyZSBtYXJrZWQgYXMgbW92ZWQuXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0b0JlTW92ZWRUb0Zyb21QYXJlbnRzKSB7XG4gICAgICAgICAgICBmcm9tUGFyZW50LmFwcGVuZChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAwNC4gU3BsaXQ6IHNwbGl0IHRoZSBlbGVtZW50IG5vZGVzIGZvciB0aGUgZ2l2ZW4gc3BsaXQgbGV2ZWwuXG4gICAgICAgIGlmIChzcGxpdExldmVsID4gMCkge1xuICAgICAgICAgICAgbGV0IHNwbGl0Q291bnQgPSAwO1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IGZyb21QYXJlbnQ7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IGZyb21MZWZ0O1xuICAgICAgICAgICAgd2hpbGUgKHNwbGl0Q291bnQgPCBzcGxpdExldmVsKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LnNwbGl0KHRoaXMsIHBhcmVudC5maW5kT2Zmc2V0KGxlZnQpICsgMSwgaXNzdWVUaW1lVGlja2V0KTtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gcGFyZW50O1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgc3BsaXRDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIDA1LiBJbnNlcnQ6IGluc2VydCB0aGUgZ2l2ZW4gbm9kZXMgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICAgICBpZiAoY29udGVudHMgPT09IG51bGwgfHwgY29udGVudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRlbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGxlZnRJbkNoaWxkcmVuID0gZnJvbUxlZnQ7IC8vIHRyZWVcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29udGVudCBvZiBjb250ZW50cykge1xuICAgICAgICAgICAgICAgIC8vIDA1LTEuIEluc2VydCB0aGUgY29udGVudCBub2RlcyB0byB0aGUgdHJlZS5cbiAgICAgICAgICAgICAgICBpZiAobGVmdEluQ2hpbGRyZW4gPT09IGZyb21QYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gMDUtMS0xLiB3aGVuIHRoZXJlJ3Mgbm8gbGVmdFNpYmxpbmcsIHRoZW4gaW5zZXJ0IGNvbnRlbnQgaW50byB2ZXJ5IGZyb250IG9mIHBhcmVudCdzIGNoaWxkcmVuLlxuICAgICAgICAgICAgICAgICAgICBmcm9tUGFyZW50Lmluc2VydEF0KGNvbnRlbnQsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gMDUtMS0yLiBpbnNlcnQgYWZ0ZXIgbGVmdFNpYmxpbmdcbiAgICAgICAgICAgICAgICAgICAgZnJvbVBhcmVudC5pbnNlcnRBZnRlcihjb250ZW50LCBsZWZ0SW5DaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxlZnRJbkNoaWxkcmVuID0gY29udGVudDtcbiAgICAgICAgICAgICAgICB0cmF2ZXJzZUFsbChjb250ZW50LCAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpbnNlcnRpb24gaGFwcGVucyBkdXJpbmcgY29uY3VycmVudCBlZGl0aW5nIGFuZCBwYXJlbnQgbm9kZSBoYXMgYmVlbiByZW1vdmVkLFxuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIG5ldyBub2RlcyBhcyB0b21ic3RvbmUgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmcm9tUGFyZW50LmlzUmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmUoZWRpdGVkQXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVkTm9kZU1hcC5zZXQobm9kZS5pZC50b0lEU3RyaW5nKCksIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZU1hcEJ5SUQucHV0KG5vZGUuaWQsIG5vZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbY2hhbmdlcywgbGF0ZXN0Q3JlYXRlZEF0TWFwXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGVkaXRUYCBlZGl0cyB0aGUgZ2l2ZW4gcmFuZ2Ugd2l0aCB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgICogVGhpcyBtZXRob2QgdXNlcyBpbmRleGVzIGluc3RlYWQgb2YgYSBwYWlyIG9mIFRyZWVQb3MgZm9yIHRlc3RpbmcuXG4gICAgICovXG4gICAgZWRpdFQocmFuZ2UsIGNvbnRlbnRzLCBzcGxpdExldmVsLCBlZGl0ZWRBdCwgaXNzdWVUaW1lVGlja2V0KSB7XG4gICAgICAgIGNvbnN0IGZyb21Qb3MgPSB0aGlzLmZpbmRQb3MocmFuZ2VbMF0pO1xuICAgICAgICBjb25zdCB0b1BvcyA9IHRoaXMuZmluZFBvcyhyYW5nZVsxXSk7XG4gICAgICAgIHRoaXMuZWRpdChbZnJvbVBvcywgdG9Qb3NdLCBjb250ZW50cywgc3BsaXRMZXZlbCwgZWRpdGVkQXQsIGlzc3VlVGltZVRpY2tldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBtb3ZlYCBtb3ZlIHRoZSBnaXZlbiBzb3VyY2UgcmFuZ2UgdG8gdGhlIGdpdmVuIHRhcmdldCByYW5nZS5cbiAgICAgKi9cbiAgICBtb3ZlKHRhcmdldCwgc291cmNlLCB0aWNrZXQpIHtcbiAgICAgICAgLy8gVE9ETyhoYWNrZXJ3aW5zLCBlYXN5bG9naWMpOiBJbXBsZW1lbnQgdGhpcyB3aXRoIGtlZXBpbmcgcmVmZXJlbmNlcyBvZiB0aGUgbm9kZXMuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm90IGltcGxlbWVudGVkOiAke3RhcmdldH0sICR7c291cmNlfSwgJHt0aWNrZXR9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBwdXJnZVJlbW92ZWROb2Rlc0JlZm9yZWAgcGh5c2ljYWxseSBwdXJnZXMgbm9kZXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBwdXJnZVJlbW92ZWROb2Rlc0JlZm9yZSh0aWNrZXQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBub2Rlc1RvQmVSZW1vdmVkID0gbmV3IFNldCgpO1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IFssIG5vZGVdIG9mIHRoaXMucmVtb3ZlZE5vZGVNYXApIHtcbiAgICAgICAgICAgIGlmIChub2RlLnJlbW92ZWRBdCAmJiB0aWNrZXQuY29tcGFyZShub2RlLnJlbW92ZWRBdCkgPj0gMCkge1xuICAgICAgICAgICAgICAgIG5vZGVzVG9CZVJlbW92ZWQuYWRkKG5vZGUpO1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzVG9CZVJlbW92ZWQpIHtcbiAgICAgICAgICAgIChfYSA9IG5vZGUucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB0aGlzLm5vZGVNYXBCeUlELnJlbW92ZShub2RlLmlkKTtcbiAgICAgICAgICAgIHRoaXMucHVyZ2Uobm9kZSk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZWROb2RlTWFwLmRlbGV0ZShub2RlLmlkLnRvSURTdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgcHVyZ2VgIHBoeXNpY2FsbHkgcHVyZ2VzIHRoZSBnaXZlbiBub2RlIGZyb20gUkdBVHJlZVNwbGl0LlxuICAgICAqL1xuICAgIHB1cmdlKG5vZGUpIHtcbiAgICAgICAgY29uc3QgaW5zUHJldklEID0gbm9kZS5pbnNQcmV2SUQ7XG4gICAgICAgIGNvbnN0IGluc05leHRJRCA9IG5vZGUuaW5zTmV4dElEO1xuICAgICAgICBpZiAoaW5zUHJldklEKSB7XG4gICAgICAgICAgICBjb25zdCBpbnNQcmV2ID0gdGhpcy5maW5kRmxvb3JOb2RlKGluc1ByZXZJRCk7XG4gICAgICAgICAgICBpbnNQcmV2Lmluc05leHRJRCA9IGluc05leHRJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5zTmV4dElEKSB7XG4gICAgICAgICAgICBjb25zdCBpbnNOZXh0ID0gdGhpcy5maW5kRmxvb3JOb2RlKGluc05leHRJRCk7XG4gICAgICAgICAgICBpbnNOZXh0Lmluc1ByZXZJRCA9IGluc1ByZXZJRDtcbiAgICAgICAgfVxuICAgICAgICBub2RlLmluc1ByZXZJRCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbm9kZS5pbnNOZXh0SUQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBmaW5kUG9zYCBmaW5kcyB0aGUgcG9zaXRpb24gb2YgdGhlIGdpdmVuIGluZGV4IGluIHRoZSB0cmVlLlxuICAgICAqL1xuICAgIGZpbmRQb3MoaW5kZXgsIHByZWZlclRleHQgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHRyZWVQb3MgPSB0aGlzLmluZGV4VHJlZS5maW5kVHJlZVBvcyhpbmRleCwgcHJlZmVyVGV4dCk7XG4gICAgICAgIHJldHVybiBDUkRUVHJlZVBvcy5mcm9tVHJlZVBvcyh0cmVlUG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldFJlbW92ZWROb2Rlc0xlbmAgcmV0dXJucyBzaXplIG9mIHJlbW92ZWQgbm9kZXMuXG4gICAgICovXG4gICAgZ2V0UmVtb3ZlZE5vZGVzTGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVkTm9kZU1hcC5zaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgcGF0aFRvUG9zUmFuZ2VgIGNvbnZlcnRzIHRoZSBnaXZlbiBwYXRoIG9mIHRoZSBub2RlIHRvIHRoZSByYW5nZSBvZiB0aGUgcG9zaXRpb24uXG4gICAgICovXG4gICAgcGF0aFRvUG9zUmFuZ2UocGF0aCkge1xuICAgICAgICBjb25zdCBmcm9tSWR4ID0gdGhpcy5wYXRoVG9JbmRleChwYXRoKTtcbiAgICAgICAgcmV0dXJuIFt0aGlzLmZpbmRQb3MoZnJvbUlkeCksIHRoaXMuZmluZFBvcyhmcm9tSWR4ICsgMSldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgcGF0aFRvUG9zYCBmaW5kcyB0aGUgcG9zaXRpb24gb2YgdGhlIGdpdmVuIGluZGV4IGluIHRoZSB0cmVlIGJ5IHBhdGguXG4gICAgICovXG4gICAgcGF0aFRvUG9zKHBhdGgpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmluZGV4VHJlZS5wYXRoVG9JbmRleChwYXRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZFBvcyhpbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRSb290YCByZXR1cm5zIHRoZSByb290IG5vZGUgb2YgdGhlIHRyZWUuXG4gICAgICovXG4gICAgZ2V0Um9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhUcmVlLmdldFJvb3QoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldFNpemVgIHJldHVybnMgdGhlIHNpemUgb2YgdGhlIHRyZWUuXG4gICAgICovXG4gICAgZ2V0U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhUcmVlLnNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRJbmRleFRyZWVgIHJldHVybnMgdGhlIGluZGV4IHRyZWUuXG4gICAgICovXG4gICAgZ2V0SW5kZXhUcmVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleFRyZWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRvWE1MIHJldHVybnMgdGhlIFhNTCBlbmNvZGluZyBvZiB0aGlzIHRyZWUuXG4gICAgICovXG4gICAgdG9YTUwoKSB7XG4gICAgICAgIHJldHVybiB0b1hNTCh0aGlzLmluZGV4VHJlZS5nZXRSb290KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdG9KU09OYCByZXR1cm5zIHRoZSBKU09OIGVuY29kaW5nIG9mIHRoaXMgdHJlZS5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLmdldFJvb3RUcmVlTm9kZSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRvSlNGb3JUZXN0YCByZXR1cm5zIHZhbHVlIHdpdGggbWV0YSBkYXRhIGZvciB0ZXN0aW5nLlxuICAgICAqL1xuICAgIHRvSlNGb3JUZXN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHRoaXMuZ2V0Q3JlYXRlZEF0KCkudG9UZXN0U3RyaW5nKCksXG4gICAgICAgICAgICB2YWx1ZTogSlNPTi5wYXJzZSh0aGlzLnRvSlNPTigpKSxcbiAgICAgICAgICAgIHR5cGU6ICdZT1JLSUVfVFJFRScsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRSb290VHJlZU5vZGVgIHJldHVybnMgdGhlIGNvbnZlcnRlZCB2YWx1ZSBvZiB0aGlzIHRyZWUgdG8gVHJlZU5vZGUuXG4gICAgICovXG4gICAgZ2V0Um9vdFRyZWVOb2RlKCkge1xuICAgICAgICByZXR1cm4gdG9UcmVlTm9kZSh0aGlzLmluZGV4VHJlZS5nZXRSb290KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdG9UZXN0VHJlZU5vZGVgIHJldHVybnMgdGhlIEpTT04gb2YgdGhpcyB0cmVlIGZvciBkZWJ1Z2dpbmcuXG4gICAgICovXG4gICAgdG9UZXN0VHJlZU5vZGUoKSB7XG4gICAgICAgIHJldHVybiB0b1Rlc3RUcmVlTm9kZSh0aGlzLmluZGV4VHJlZS5nZXRSb290KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdG9Tb3J0ZWRKU09OYCByZXR1cm5zIHRoZSBzb3J0ZWQgSlNPTiBlbmNvZGluZyBvZiB0aGlzIHRyZWUuXG4gICAgICovXG4gICAgdG9Tb3J0ZWRKU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0pTT04oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGRlZXBjb3B5YCBjb3BpZXMgaXRzZWxmIGRlZXBseS5cbiAgICAgKi9cbiAgICBkZWVwY29weSgpIHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMuZ2V0Um9vdCgpO1xuICAgICAgICByZXR1cm4gbmV3IENSRFRUcmVlKHJvb3QuZGVlcGNvcHkoKSwgdGhpcy5nZXRDcmVhdGVkQXQoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0b1BhdGhgIGNvbnZlcnRzIHRoZSBnaXZlbiBDUkRUVHJlZU5vZGVJRCB0byB0aGUgcGF0aCBvZiB0aGUgdHJlZS5cbiAgICAgKi9cbiAgICB0b1BhdGgocGFyZW50Tm9kZSwgbGVmdE5vZGUpIHtcbiAgICAgICAgY29uc3QgdHJlZVBvcyA9IHRoaXMudG9UcmVlUG9zKHBhcmVudE5vZGUsIGxlZnROb2RlKTtcbiAgICAgICAgaWYgKCF0cmVlUG9zKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhUcmVlLnRyZWVQb3NUb1BhdGgodHJlZVBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0b0luZGV4YCBjb252ZXJ0cyB0aGUgZ2l2ZW4gQ1JEVFRyZWVOb2RlSUQgdG8gdGhlIGluZGV4IG9mIHRoZSB0cmVlLlxuICAgICAqL1xuICAgIHRvSW5kZXgocGFyZW50Tm9kZSwgbGVmdE5vZGUpIHtcbiAgICAgICAgY29uc3QgdHJlZVBvcyA9IHRoaXMudG9UcmVlUG9zKHBhcmVudE5vZGUsIGxlZnROb2RlKTtcbiAgICAgICAgaWYgKCF0cmVlUG9zKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhUcmVlLmluZGV4T2YodHJlZVBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBpbmRleFRvUGF0aGAgY29udmVydHMgdGhlIGdpdmVuIHRyZWUgaW5kZXggdG8gcGF0aC5cbiAgICAgKi9cbiAgICBpbmRleFRvUGF0aChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleFRyZWUuaW5kZXhUb1BhdGgoaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgcGF0aFRvSW5kZXhgIGNvbnZlcnRzIHRoZSBnaXZlbiBwYXRoIHRvIGluZGV4LlxuICAgICAqL1xuICAgIHBhdGhUb0luZGV4KHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhUcmVlLnBhdGhUb0luZGV4KHBhdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgaW5kZXhSYW5nZVRvUG9zUmFuZ2VgIHJldHVybnMgdGhlIHBvc2l0aW9uIHJhbmdlIGZyb20gdGhlIGdpdmVuIGluZGV4IHJhbmdlLlxuICAgICAqL1xuICAgIGluZGV4UmFuZ2VUb1Bvc1JhbmdlKHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IGZyb21Qb3MgPSB0aGlzLmZpbmRQb3MocmFuZ2VbMF0pO1xuICAgICAgICBpZiAocmFuZ2VbMF0gPT09IHJhbmdlWzFdKSB7XG4gICAgICAgICAgICByZXR1cm4gW2Zyb21Qb3MsIGZyb21Qb3NdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZnJvbVBvcywgdGhpcy5maW5kUG9zKHJhbmdlWzFdKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBpbmRleFJhbmdlVG9Qb3NTdHJ1Y3RSYW5nZWAgY29udmVydHMgdGhlIGludGVnZXIgaW5kZXggcmFuZ2UgaW50byB0aGUgVHJlZSBwb3NpdGlvbiByYW5nZSBzdHJ1Y3R1cmUuXG4gICAgICovXG4gICAgaW5kZXhSYW5nZVRvUG9zU3RydWN0UmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgY29uc3QgW2Zyb21JZHgsIHRvSWR4XSA9IHJhbmdlO1xuICAgICAgICBjb25zdCBmcm9tUG9zID0gdGhpcy5maW5kUG9zKGZyb21JZHgpO1xuICAgICAgICBpZiAoZnJvbUlkeCA9PT0gdG9JZHgpIHtcbiAgICAgICAgICAgIHJldHVybiBbZnJvbVBvcy50b1N0cnVjdCgpLCBmcm9tUG9zLnRvU3RydWN0KCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZnJvbVBvcy50b1N0cnVjdCgpLCB0aGlzLmZpbmRQb3ModG9JZHgpLnRvU3RydWN0KCldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgcG9zUmFuZ2VUb1BhdGhSYW5nZWAgY29udmVydHMgdGhlIGdpdmVuIHBvc2l0aW9uIHJhbmdlIHRvIHRoZSBwYXRoIHJhbmdlLlxuICAgICAqL1xuICAgIHBvc1JhbmdlVG9QYXRoUmFuZ2UocmFuZ2UsIHRpbWVUaWNrZXQpIHtcbiAgICAgICAgY29uc3QgW2Zyb21QYXJlbnQsIGZyb21MZWZ0XSA9IHRoaXMuZmluZE5vZGVzQW5kU3BsaXRUZXh0KHJhbmdlWzBdLCB0aW1lVGlja2V0KTtcbiAgICAgICAgY29uc3QgW3RvUGFyZW50LCB0b0xlZnRdID0gdGhpcy5maW5kTm9kZXNBbmRTcGxpdFRleHQocmFuZ2VbMV0sIHRpbWVUaWNrZXQpO1xuICAgICAgICByZXR1cm4gW3RoaXMudG9QYXRoKGZyb21QYXJlbnQsIGZyb21MZWZ0KSwgdGhpcy50b1BhdGgodG9QYXJlbnQsIHRvTGVmdCldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgcG9zUmFuZ2VUb0luZGV4UmFuZ2VgIGNvbnZlcnRzIHRoZSBnaXZlbiBwb3NpdGlvbiByYW5nZSB0byB0aGUgcGF0aCByYW5nZS5cbiAgICAgKi9cbiAgICBwb3NSYW5nZVRvSW5kZXhSYW5nZShyYW5nZSwgdGltZVRpY2tldCkge1xuICAgICAgICBjb25zdCBbZnJvbVBhcmVudCwgZnJvbUxlZnRdID0gdGhpcy5maW5kTm9kZXNBbmRTcGxpdFRleHQocmFuZ2VbMF0sIHRpbWVUaWNrZXQpO1xuICAgICAgICBjb25zdCBbdG9QYXJlbnQsIHRvTGVmdF0gPSB0aGlzLmZpbmROb2Rlc0FuZFNwbGl0VGV4dChyYW5nZVsxXSwgdGltZVRpY2tldCk7XG4gICAgICAgIHJldHVybiBbdGhpcy50b0luZGV4KGZyb21QYXJlbnQsIGZyb21MZWZ0KSwgdGhpcy50b0luZGV4KHRvUGFyZW50LCB0b0xlZnQpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRyYXZlcnNlSW5Qb3NSYW5nZWAgdHJhdmVyc2VzIHRoZSB0cmVlIGluIHRoZSBnaXZlbiBwb3NpdGlvbiByYW5nZS5cbiAgICAgKi9cbiAgICB0cmF2ZXJzZUluUG9zUmFuZ2UoZnJvbVBhcmVudCwgZnJvbUxlZnQsIHRvUGFyZW50LCB0b0xlZnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGZyb21JZHggPSB0aGlzLnRvSW5kZXgoZnJvbVBhcmVudCwgZnJvbUxlZnQpO1xuICAgICAgICBjb25zdCB0b0lkeCA9IHRoaXMudG9JbmRleCh0b1BhcmVudCwgdG9MZWZ0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhUcmVlLm5vZGVzQmV0d2Vlbihmcm9tSWR4LCB0b0lkeCwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdG9UcmVlUG9zYCBjb252ZXJ0cyB0aGUgZ2l2ZW4gbm9kZXMgdG8gdGhlIHBvc2l0aW9uIG9mIHRoZSBJbmRleFRyZWUuXG4gICAgICovXG4gICAgdG9UcmVlUG9zKHBhcmVudE5vZGUsIGxlZnROb2RlKSB7XG4gICAgICAgIGlmICghcGFyZW50Tm9kZSB8fCAhbGVmdE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50Tm9kZS5pc1JlbW92ZWQpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZE5vZGU7XG4gICAgICAgICAgICB3aGlsZSAocGFyZW50Tm9kZS5pc1JlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBwYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBjaGlsZE5vZGUucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcGFyZW50Tm9kZS5maW5kT2Zmc2V0KGNoaWxkTm9kZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5vZGU6IHBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50Tm9kZSA9PT0gbGVmdE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbm9kZTogcGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBvZmZzZXQgPSBwYXJlbnROb2RlLmZpbmRPZmZzZXQobGVmdE5vZGUpO1xuICAgICAgICBpZiAoIWxlZnROb2RlLmlzUmVtb3ZlZCkge1xuICAgICAgICAgICAgaWYgKGxlZnROb2RlLmlzVGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IGxlZnROb2RlLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGxlZnROb2RlLnBhZGRlZFNpemUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlOiBwYXJlbnROb2RlLFxuICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2RvY3VtZW50L29wZXJhdGlvbi90cmVlX2VkaXRfb3BlcmF0aW9uLnRzXG4vKlxuICogQ29weXJpZ2h0IDIwMjMgVGhlIFlvcmtpZSBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5cblxuXG4vKipcbiAqIGBUcmVlRWRpdE9wZXJhdGlvbmAgaXMgYW4gb3BlcmF0aW9uIHJlcHJlc2VudGluZyBUcmVlIGVkaXRpbmcuXG4gKi9cbmNsYXNzIFRyZWVFZGl0T3BlcmF0aW9uIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRDcmVhdGVkQXQsIGZyb21Qb3MsIHRvUG9zLCBjb250ZW50cywgc3BsaXRMZXZlbCwgbWF4Q3JlYXRlZEF0TWFwQnlBY3RvciwgZXhlY3V0ZWRBdCkge1xuICAgICAgICBzdXBlcihwYXJlbnRDcmVhdGVkQXQsIGV4ZWN1dGVkQXQpO1xuICAgICAgICB0aGlzLmZyb21Qb3MgPSBmcm9tUG9zO1xuICAgICAgICB0aGlzLnRvUG9zID0gdG9Qb3M7XG4gICAgICAgIHRoaXMuY29udGVudHMgPSBjb250ZW50cztcbiAgICAgICAgdGhpcy5zcGxpdExldmVsID0gc3BsaXRMZXZlbDtcbiAgICAgICAgdGhpcy5tYXhDcmVhdGVkQXRNYXBCeUFjdG9yID0gbWF4Q3JlYXRlZEF0TWFwQnlBY3RvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGNyZWF0ZWAgY3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBFZGl0T3BlcmF0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUocGFyZW50Q3JlYXRlZEF0LCBmcm9tUG9zLCB0b1BvcywgY29udGVudHMsIHNwbGl0TGV2ZWwsIG1heENyZWF0ZWRBdE1hcEJ5QWN0b3IsIGV4ZWN1dGVkQXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlRWRpdE9wZXJhdGlvbihwYXJlbnRDcmVhdGVkQXQsIGZyb21Qb3MsIHRvUG9zLCBjb250ZW50cywgc3BsaXRMZXZlbCwgbWF4Q3JlYXRlZEF0TWFwQnlBY3RvciwgZXhlY3V0ZWRBdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBleGVjdXRlYCBleGVjdXRlcyB0aGlzIG9wZXJhdGlvbiBvbiB0aGUgZ2l2ZW4gYENSRFRSb290YC5cbiAgICAgKi9cbiAgICBleGVjdXRlKHJvb3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBwYXJlbnRPYmplY3QgPSByb290LmZpbmRCeUNyZWF0ZWRBdCh0aGlzLmdldFBhcmVudENyZWF0ZWRBdCgpKTtcbiAgICAgICAgaWYgKCFwYXJlbnRPYmplY3QpIHtcbiAgICAgICAgICAgIGxvZ2dlci5mYXRhbChgZmFpbCB0byBmaW5kICR7dGhpcy5nZXRQYXJlbnRDcmVhdGVkQXQoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShwYXJlbnRPYmplY3QgaW5zdGFuY2VvZiBDUkRUVHJlZSkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5mYXRhbChgZmFpbCB0byBleGVjdXRlLCBvbmx5IFRyZWUgY2FuIGV4ZWN1dGUgZWRpdGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVkaXRlZEF0ID0gdGhpcy5nZXRFeGVjdXRlZEF0KCk7XG4gICAgICAgIGNvbnN0IHRyZWUgPSBwYXJlbnRPYmplY3Q7XG4gICAgICAgIGNvbnN0IFtjaGFuZ2VzXSA9IHRyZWUuZWRpdChbdGhpcy5mcm9tUG9zLCB0aGlzLnRvUG9zXSwgKF9hID0gdGhpcy5jb250ZW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoY29udGVudCkgPT4gY29udGVudC5kZWVwY29weSgpKSwgdGhpcy5zcGxpdExldmVsLCBlZGl0ZWRBdCwgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUT0RPKHNlam9uZ2spOiBXaGVuIHNwbGl0dGluZyBlbGVtZW50IG5vZGVzLCBhIG5ldyBub2RlSUQgaXMgYXNzaWduZWQgd2l0aCBhIGRpZmZlcmVudCB0aW1lVGlja2V0LlxuICAgICAgICAgKiBJbiB0aGUgc2FtZSBjaGFuZ2UgY29udGV4dCwgdGhlIHRpbWVUaWNrZXRzIHNoYXJlIHRoZSBzYW1lIGxhbXBvcnQgYW5kIGFjdG9ySUQgYnV0IGhhdmUgZGlmZmVyZW50IGRlbGltaXRlcnMsXG4gICAgICAgICAqIGluY3JlbWVudGVkIGJ5IG9uZSBmb3IgZWFjaC5cbiAgICAgICAgICogVGhlcmVmb3JlLCBpdCBpcyBwb3NzaWJsZSB0byBzaW11bGF0ZSBsYXRlciB0aW1lVGlja2V0cyB1c2luZyBgZWRpdGVkQXRgIGFuZCB0aGUgbGVuZ3RoIG9mIGBjb250ZW50c2AuXG4gICAgICAgICAqIFRoaXMgbG9naWMgbWlnaHQgYmUgdW5jbGVhcjsgY29uc2lkZXIgcmVmYWN0b3JpbmcgZm9yIG11bHRpLWxldmVsIGNvbmN1cnJlbnQgZWRpdGluZyBpbiB0aGUgVHJlZSBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgICgoKSA9PiB7XG4gICAgICAgICAgICBsZXQgZGVsaW1pdGVyID0gZWRpdGVkQXQuZ2V0RGVsaW1pdGVyKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGVsaW1pdGVyICs9IHRoaXMuY29udGVudHMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNzdWVUaW1lVGlja2V0ID0gKCkgPT4gVGltZVRpY2tldC5vZihlZGl0ZWRBdC5nZXRMYW1wb3J0KCksICsrZGVsaW1pdGVyLCBlZGl0ZWRBdC5nZXRBY3RvcklEKCkpO1xuICAgICAgICAgICAgcmV0dXJuIGlzc3VlVGltZVRpY2tldDtcbiAgICAgICAgfSkoKSwgdGhpcy5tYXhDcmVhdGVkQXRNYXBCeUFjdG9yKTtcbiAgICAgICAgaWYgKCF0aGlzLmZyb21Qb3MuZXF1YWxzKHRoaXMudG9Qb3MpKSB7XG4gICAgICAgICAgICByb290LnJlZ2lzdGVyRWxlbWVudEhhc1JlbW92ZWROb2Rlcyh0cmVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3BJbmZvczogY2hhbmdlcy5tYXAoKHsgZnJvbSwgdG8sIHZhbHVlLCBzcGxpdExldmVsLCBmcm9tUGF0aCwgdG9QYXRoIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAndHJlZS1lZGl0JyxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogcm9vdC5jcmVhdGVQYXRoKHRoaXMuZ2V0UGFyZW50Q3JlYXRlZEF0KCkpLFxuICAgICAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0TGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgIGZyb21QYXRoLFxuICAgICAgICAgICAgICAgICAgICB0b1BhdGgsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0RWZmZWN0ZWRDcmVhdGVkQXRgIHJldHVybnMgdGhlIGNyZWF0aW9uIHRpbWUgb2YgdGhlIGVmZmVjdGVkIGVsZW1lbnQuXG4gICAgICovXG4gICAgZ2V0RWZmZWN0ZWRDcmVhdGVkQXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhcmVudENyZWF0ZWRBdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdG9UZXN0U3RyaW5nYCByZXR1cm5zIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1ldGEgZGF0YS5cbiAgICAgKi9cbiAgICB0b1Rlc3RTdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50Q3JlYXRlZEF0KCkudG9UZXN0U3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGZyb21Qb3MgPSBgJHt0aGlzLmZyb21Qb3NcbiAgICAgICAgICAgIC5nZXRMZWZ0U2libGluZ0lEKClcbiAgICAgICAgICAgIC5nZXRDcmVhdGVkQXQoKVxuICAgICAgICAgICAgLnRvVGVzdFN0cmluZygpfToke3RoaXMuZnJvbVBvcy5nZXRMZWZ0U2libGluZ0lEKCkuZ2V0T2Zmc2V0KCl9YDtcbiAgICAgICAgY29uc3QgdG9Qb3MgPSBgJHt0aGlzLnRvUG9zXG4gICAgICAgICAgICAuZ2V0TGVmdFNpYmxpbmdJRCgpXG4gICAgICAgICAgICAuZ2V0Q3JlYXRlZEF0KClcbiAgICAgICAgICAgIC50b1Rlc3RTdHJpbmcoKX06JHt0aGlzLnRvUG9zLmdldExlZnRTaWJsaW5nSUQoKS5nZXRPZmZzZXQoKX1gO1xuICAgICAgICBjb25zdCBjb250ZW50cyA9IHRoaXMuY29udGVudHM7XG4gICAgICAgIHJldHVybiBgJHtwYXJlbnR9LkVESVQoJHtmcm9tUG9zfSwke3RvUG9zfSwke2NvbnRlbnRzID09PSBudWxsIHx8IGNvbnRlbnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZW50cy5qb2luKCcnKX0pYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldEZyb21Qb3NgIHJldHVybnMgdGhlIHN0YXJ0IHBvaW50IG9mIHRoZSBlZGl0aW5nIHJhbmdlLlxuICAgICAqL1xuICAgIGdldEZyb21Qb3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21Qb3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRUb1Bvc2AgcmV0dXJucyB0aGUgZW5kIHBvaW50IG9mIHRoZSBlZGl0aW5nIHJhbmdlLlxuICAgICAqL1xuICAgIGdldFRvUG9zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1BvcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldENvbnRlbnRgIHJldHVybnMgdGhlIGNvbnRlbnQgb2YgRWRpdC5cbiAgICAgKi9cbiAgICBnZXRDb250ZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRTcGxpdExldmVsYCByZXR1cm5zIHRoZSBzcGxpdCBsZXZlbCBvZiBFZGl0LlxuICAgICAqL1xuICAgIGdldFNwbGl0TGV2ZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwbGl0TGV2ZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRNYXhDcmVhdGVkQXRNYXBCeUFjdG9yYCByZXR1cm5zIHRoZSBtYXAgdGhhdCBzdG9yZXMgdGhlIGxhdGVzdCBjcmVhdGlvbiB0aW1lXG4gICAgICogYnkgYWN0b3IgZm9yIHRoZSBub2RlcyBpbmNsdWRlZCBpbiB0aGUgZWRpdGluZyByYW5nZS5cbiAgICAgKi9cbiAgICBnZXRNYXhDcmVhdGVkQXRNYXBCeUFjdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXhDcmVhdGVkQXRNYXBCeUFjdG9yO1xuICAgIH1cbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2RvY3VtZW50L2NoYW5nZS9jaGFuZ2VfaWQudHNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuXG4vKipcbiAqIGBDaGFuZ2VJRGAgaXMgZm9yIGlkZW50aWZ5aW5nIHRoZSBDaGFuZ2UuIFRoaXMgaXMgaW1tdXRhYmxlLlxuICovXG5jbGFzcyBDaGFuZ2VJRCB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50U2VxLCBsYW1wb3J0LCBhY3Rvcikge1xuICAgICAgICB0aGlzLmNsaWVudFNlcSA9IGNsaWVudFNlcTtcbiAgICAgICAgdGhpcy5sYW1wb3J0ID0gbGFtcG9ydDtcbiAgICAgICAgdGhpcy5hY3RvciA9IGFjdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgb2ZgIGNyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgQ2hhbmdlSUQuXG4gICAgICovXG4gICAgc3RhdGljIG9mKGNsaWVudFNlcSwgbGFtcG9ydCwgYWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VJRChjbGllbnRTZXEsIGxhbXBvcnQsIGFjdG9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYG5leHRgIGNyZWF0ZXMgYSBuZXh0IElEIG9mIHRoaXMgSUQuXG4gICAgICovXG4gICAgbmV4dCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VJRCh0aGlzLmNsaWVudFNlcSArIDEsIHRoaXMubGFtcG9ydC5hZGQoMSksIHRoaXMuYWN0b3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgc3luY0xhbXBvcnRgIHN5bmNzIGxhbXBvcnQgdGltZXN0YW1wIHdpdGggdGhlIGdpdmVuIElELlxuICAgICAqXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhbXBvcnRfdGltZXN0YW1wcyNBbGdvcml0aG19XG4gICAgICovXG4gICAgc3luY0xhbXBvcnQob3RoZXJMYW1wb3J0KSB7XG4gICAgICAgIGlmIChvdGhlckxhbXBvcnQuZ3JlYXRlclRoYW4odGhpcy5sYW1wb3J0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VJRCh0aGlzLmNsaWVudFNlcSwgb3RoZXJMYW1wb3J0LCB0aGlzLmFjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENoYW5nZUlEKHRoaXMuY2xpZW50U2VxLCB0aGlzLmxhbXBvcnQuYWRkKDEpLCB0aGlzLmFjdG9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGNyZWF0ZVRpbWVUaWNrZXRgIGNyZWF0ZXMgYSB0aWNrZXQgb2YgdGhlIGdpdmVuIGRlbGltaXRlci5cbiAgICAgKi9cbiAgICBjcmVhdGVUaW1lVGlja2V0KGRlbGltaXRlcikge1xuICAgICAgICByZXR1cm4gVGltZVRpY2tldC5vZih0aGlzLmxhbXBvcnQsIGRlbGltaXRlciwgdGhpcy5hY3Rvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBzZXRBY3RvcmAgc2V0cyB0aGUgZ2l2ZW4gYWN0b3IuXG4gICAgICovXG4gICAgc2V0QWN0b3IoYWN0b3JJRCkge1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZUlEKHRoaXMuY2xpZW50U2VxLCB0aGlzLmxhbXBvcnQsIGFjdG9ySUQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0Q2xpZW50U2VxYCByZXR1cm5zIHRoZSBjbGllbnQgc2VxdWVuY2Ugb2YgdGhpcyBJRC5cbiAgICAgKi9cbiAgICBnZXRDbGllbnRTZXEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudFNlcTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldExhbXBvcnRgIHJldHVybnMgdGhlIGxhbXBvcnQgY2xvY2sgb2YgdGhpcyBJRC5cbiAgICAgKi9cbiAgICBnZXRMYW1wb3J0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYW1wb3J0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0TGFtcG9ydEFzU3RyaW5nYCByZXR1cm5zIHRoZSBsYW1wb3J0IGNsb2NrIG9mIHRoaXMgSUQgYXMgYSBzdHJpbmcuXG4gICAgICovXG4gICAgZ2V0TGFtcG9ydEFzU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYW1wb3J0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRBY3RvcklEYCByZXR1cm5zIHRoZSBhY3RvciBvZiB0aGlzIElELlxuICAgICAqL1xuICAgIGdldEFjdG9ySUQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdG9UZXN0U3RyaW5nYCByZXR1cm5zIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1ldGEgZGF0YSBvZiB0aGlzIElELlxuICAgICAqL1xuICAgIHRvVGVzdFN0cmluZygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5sYW1wb3J0LnRvU3RyaW5nKCl9Om5pbDoke3RoaXMuY2xpZW50U2VxfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3RoaXMubGFtcG9ydC50b1N0cmluZygpfToke3RoaXMuYWN0b3Iuc3Vic3RyaW5nKDIyLCAyNCl9OiR7dGhpcy5jbGllbnRTZXF9YDtcbiAgICB9XG59XG4vKipcbiAqIGBJbml0aWFsQ2hhbmdlSURgIHJlcHJlc2VudHMgdGhlIGluaXRpYWwgc3RhdGUgSUQuIFVzdWFsbHkgdGhpcyBpcyB1c2VkIHRvXG4gKiByZXByZXNlbnQgYSBzdGF0ZSB3aGVyZSBub3RoaW5nIGhhcyBiZWVuIGVkaXRlZC5cbiAqL1xuY29uc3QgSW5pdGlhbENoYW5nZUlEID0gbmV3IENoYW5nZUlEKDAsIG5vZGVfbW9kdWxlc19sb25nLmZyb21JbnQoMCwgdHJ1ZSksIEluaXRpYWxBY3RvcklEKTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2RvY3VtZW50L2NoYW5nZS9jaGFuZ2UudHNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuLyoqXG4gKiBgQ2hhbmdlYCByZXByZXNlbnRzIGEgdW5pdCBvZiBtb2RpZmljYXRpb24gaW4gdGhlIGRvY3VtZW50LlxuICovXG5jbGFzcyBDaGFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHsgaWQsIG9wZXJhdGlvbnMsIHByZXNlbmNlQ2hhbmdlLCBtZXNzYWdlLCB9KSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5vcGVyYXRpb25zID0gb3BlcmF0aW9ucyB8fCBbXTtcbiAgICAgICAgdGhpcy5wcmVzZW5jZUNoYW5nZSA9IHByZXNlbmNlQ2hhbmdlO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgY3JlYXRlYCBjcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIENoYW5nZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKHsgaWQsIG9wZXJhdGlvbnMsIHByZXNlbmNlQ2hhbmdlLCBtZXNzYWdlLCB9KSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlKHsgaWQsIG9wZXJhdGlvbnMsIHByZXNlbmNlQ2hhbmdlLCBtZXNzYWdlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0SURgIHJldHVybnMgdGhlIElEIG9mIHRoaXMgY2hhbmdlLlxuICAgICAqL1xuICAgIGdldElEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldE1lc3NhZ2VgIHJldHVybnMgdGhlIG1lc3NhZ2Ugb2YgdGhpcyBjaGFuZ2UuXG4gICAgICovXG4gICAgZ2V0TWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGhhc09wZXJhdGlvbnNgIHJldHVybnMgd2hldGhlciB0aGlzIGNoYW5nZSBoYXMgb3BlcmF0aW9ucyBvciBub3QuXG4gICAgICovXG4gICAgaGFzT3BlcmF0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0aW9ucy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0T3BlcmF0aW9uc2AgcmV0dXJucyB0aGUgb3BlcmF0aW9ucyBvZiB0aGlzIGNoYW5nZS5cbiAgICAgKi9cbiAgICBnZXRPcGVyYXRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgc2V0QWN0b3JgIHNldHMgdGhlIGdpdmVuIGFjdG9yLlxuICAgICAqL1xuICAgIHNldEFjdG9yKGFjdG9ySUQpIHtcbiAgICAgICAgZm9yIChjb25zdCBvcGVyYXRpb24gb2YgdGhpcy5vcGVyYXRpb25zKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24uc2V0QWN0b3IoYWN0b3JJRCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZCA9IHRoaXMuaWQuc2V0QWN0b3IoYWN0b3JJRCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBoYXNQcmVzZW5jZUNoYW5nZWAgcmV0dXJucyB3aGV0aGVyIHRoaXMgY2hhbmdlIGhhcyBwcmVzZW5jZSBjaGFuZ2Ugb3Igbm90LlxuICAgICAqL1xuICAgIGhhc1ByZXNlbmNlQ2hhbmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmVzZW5jZUNoYW5nZSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0UHJlc2VuY2VDaGFuZ2VgIHJldHVybnMgdGhlIHByZXNlbmNlIGNoYW5nZSBvZiB0aGlzIGNoYW5nZS5cbiAgICAgKi9cbiAgICBnZXRQcmVzZW5jZUNoYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlc2VuY2VDaGFuZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBleGVjdXRlYCBleGVjdXRlcyB0aGUgb3BlcmF0aW9ucyBvZiB0aGlzIGNoYW5nZSB0byB0aGUgZ2l2ZW4gcm9vdC5cbiAgICAgKi9cbiAgICBleGVjdXRlKHJvb3QsIHByZXNlbmNlcywgc291cmNlKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZU9wSW5mb3MgPSBbXTtcbiAgICAgICAgY29uc3QgcmV2ZXJzZU9wcyA9IFtdO1xuICAgICAgICBpZiAoZmFsc2UpIHt9XG4gICAgICAgIGZvciAoY29uc3Qgb3BlcmF0aW9uIG9mIHRoaXMub3BlcmF0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgZXhlY3V0aW9uUmVzdWx0ID0gb3BlcmF0aW9uLmV4ZWN1dGUocm9vdCwgc291cmNlKTtcbiAgICAgICAgICAgIC8vIE5PVEUoaGFja2Vyd2lucyk6IElmIHRoZSBlbGVtZW50IHdhcyByZW1vdmVkIHdoaWxlIGV4ZWN1dGluZyB1bmRvL3JlZG8sXG4gICAgICAgICAgICAvLyB0aGUgb3BlcmF0aW9uIGlzIG5vdCBleGVjdXRlZCBhbmQgZXhlY3V0aW9uUmVzdWx0IGlzIHVuZGVmaW5lZC5cbiAgICAgICAgICAgIGlmICghZXhlY3V0aW9uUmVzdWx0KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgeyBvcEluZm9zLCByZXZlcnNlT3AgfSA9IGV4ZWN1dGlvblJlc3VsdDtcbiAgICAgICAgICAgIGNoYW5nZU9wSW5mb3MucHVzaCguLi5vcEluZm9zKTtcbiAgICAgICAgICAgIC8vIFRPRE8oaGFja2Vyd2lucyk6IFRoaXMgY29uZGl0aW9uIHNob3VsZCBiZSByZW1vdmVkIGFmdGVyIGltcGxlbWVudGluZ1xuICAgICAgICAgICAgLy8gYWxsIHJldmVyc2Ugb3BlcmF0aW9ucy5cbiAgICAgICAgICAgIGlmIChyZXZlcnNlT3ApIHtcbiAgICAgICAgICAgICAgICByZXZlcnNlT3BzLnVuc2hpZnQocmV2ZXJzZU9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcmVzZW5jZUNoYW5nZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJlc2VuY2VDaGFuZ2UudHlwZSA9PT0gUHJlc2VuY2VDaGFuZ2VUeXBlLlB1dCkge1xuICAgICAgICAgICAgICAgIHByZXNlbmNlcy5zZXQodGhpcy5pZC5nZXRBY3RvcklEKCksIGRlZXBjb3B5KHRoaXMucHJlc2VuY2VDaGFuZ2UucHJlc2VuY2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXNlbmNlcy5kZWxldGUodGhpcy5pZC5nZXRBY3RvcklEKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG9wSW5mb3M6IGNoYW5nZU9wSW5mb3MsIHJldmVyc2VPcHMgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRvVGVzdFN0cmluZ2AgcmV0dXJucyBhIHN0cmluZyBjb250YWluaW5nIHRoZSBtZXRhIGRhdGEgb2YgdGhpcyBjaGFuZ2UuXG4gICAgICovXG4gICAgdG9UZXN0U3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5vcGVyYXRpb25zXG4gICAgICAgICAgICAubWFwKChvcGVyYXRpb24pID0+IG9wZXJhdGlvbi50b1Rlc3RTdHJpbmcoKSlcbiAgICAgICAgICAgIC5qb2luKCcsJyl9YDtcbiAgICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kb2N1bWVudC9jaGFuZ2UvY2hhbmdlX3BhY2sudHNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIGBDaGFuZ2VQYWNrYCBpcyBhIHVuaXQgZm9yIGRlbGl2ZXJpbmcgY2hhbmdlcyBpbiBhIGRvY3VtZW50IHRvIHRoZSByZW1vdGUuXG4gKlxuICovXG5jbGFzcyBDaGFuZ2VQYWNrIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIGNoZWNrcG9pbnQsIGlzUmVtb3ZlZCwgY2hhbmdlcywgc25hcHNob3QsIG1pblN5bmNlZFRpY2tldCkge1xuICAgICAgICB0aGlzLmRvY3VtZW50S2V5ID0ga2V5O1xuICAgICAgICB0aGlzLmNoZWNrcG9pbnQgPSBjaGVja3BvaW50O1xuICAgICAgICB0aGlzLmlzUmVtb3ZlZCA9IGlzUmVtb3ZlZDtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gY2hhbmdlcztcbiAgICAgICAgdGhpcy5zbmFwc2hvdCA9IHNuYXBzaG90O1xuICAgICAgICB0aGlzLm1pblN5bmNlZFRpY2tldCA9IG1pblN5bmNlZFRpY2tldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGNyZWF0ZWAgY3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBDaGFuZ2VQYWNrLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoa2V5LCBjaGVja3BvaW50LCBpc1JlbW92ZWQsIGNoYW5nZXMsIHNuYXBzaG90LCBtaW5TeW5jZWRUaWNrZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VQYWNrKGtleSwgY2hlY2twb2ludCwgaXNSZW1vdmVkLCBjaGFuZ2VzLCBzbmFwc2hvdCwgbWluU3luY2VkVGlja2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldEtleWAgcmV0dXJucyB0aGUgZG9jdW1lbnQga2V5IG9mIHRoaXMgcGFjay5cbiAgICAgKi9cbiAgICBnZXREb2N1bWVudEtleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRLZXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRDaGVja3BvaW50YCByZXR1cm5zIHRoZSBjaGVja3BvaW50IG9mIHRoaXMgcGFjay5cbiAgICAgKi9cbiAgICBnZXRDaGVja3BvaW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGVja3BvaW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0SXNSZW1vdmVkYCByZXR1cm5zIHRoZSB3aGV0aGVyIHRoaXMgZG9jdW1lbnQgaXMgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBnZXRJc1JlbW92ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzUmVtb3ZlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldENoYW5nZXNgIHJldHVybnMgdGhlIGNoYW5nZXMgb2YgdGhpcyBwYWNrLlxuICAgICAqL1xuICAgIGdldENoYW5nZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBoYXNDaGFuZ2VzYCByZXR1cm5zIHRoZSB3aGV0aGVyIHRoaXMgcGFjayBoYXMgY2hhbmdlcyBvciBub3QuXG4gICAgICovXG4gICAgaGFzQ2hhbmdlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlcy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0Q2hhbmdlU2l6ZWAgcmV0dXJucyB0aGUgc2l6ZSBvZiBjaGFuZ2VzIHRoaXMgcGFjayBoYXMuXG4gICAgICovXG4gICAgZ2V0Q2hhbmdlU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlcy5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBoYXNTbmFwc2hvdGAgcmV0dXJucyB0aGUgd2hldGhlciB0aGlzIHBhY2sgaGFzIGEgc25hcHNob3Qgb3Igbm90LlxuICAgICAqL1xuICAgIGhhc1NuYXBzaG90KCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnNuYXBzaG90ICYmICEhdGhpcy5zbmFwc2hvdC5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRTbmFwc2hvdGAgcmV0dXJucyB0aGUgc25hcHNob3Qgb2YgdGhpcyBwYWNrLlxuICAgICAqL1xuICAgIGdldFNuYXBzaG90KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbmFwc2hvdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldE1pblN5bmNlZFRpY2tldGAgcmV0dXJucyB0aGUgbWluaW11bSBzeW5jZWQgdGlja2V0IG9mIHRoaXMgcGFjay5cbiAgICAgKi9cbiAgICBnZXRNaW5TeW5jZWRUaWNrZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pblN5bmNlZFRpY2tldDtcbiAgICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kb2N1bWVudC9jaGFuZ2UvY2hlY2twb2ludC50c1xuLypcbiAqIENvcHlyaWdodCAyMDIwIFRoZSBZb3JraWUgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBgQ2hlY2twb2ludGAgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGNoYW5nZXMgc2VudCBhbmQgcmVjZWl2ZWQgYnkgdGhlXG4gKiBjbGllbnQuIFRoaXMgaXMgaW1tdXRhYmxlLlxuICpcbiAqKi9cbmNsYXNzIENoZWNrcG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZlclNlcSwgY2xpZW50U2VxKSB7XG4gICAgICAgIHRoaXMuc2VydmVyU2VxID0gc2VydmVyU2VxO1xuICAgICAgICB0aGlzLmNsaWVudFNlcSA9IGNsaWVudFNlcTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYG9mYCBjcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIENoZWNrcG9pbnQuXG4gICAgICovXG4gICAgc3RhdGljIG9mKHNlcnZlclNlcSwgY2xpZW50U2VxKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hlY2twb2ludChzZXJ2ZXJTZXEsIGNsaWVudFNlcSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBpbmNyZWFzZUNsaWVudFNlcWAgY3JlYXRlcyBhIG5ldyBpbnN0YW5jZSB3aXRoIGluY3JlYXNlZCBjbGllbnQgc2VxdWVuY2UuXG4gICAgICovXG4gICAgaW5jcmVhc2VDbGllbnRTZXEoaW5jKSB7XG4gICAgICAgIGlmIChpbmMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2hlY2twb2ludCh0aGlzLnNlcnZlclNlcSwgdGhpcy5jbGllbnRTZXEgKyBpbmMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZm9yd2FyZGAgY3JlYXRlcyBhIG5ldyBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBjaGVja3BvaW50IGlmIGl0IGlzXG4gICAgICogZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZXMgb2YgaW50ZXJuYWwgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBmb3J3YXJkKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmVxdWFscyhvdGhlcikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcnZlclNlcSA9IHRoaXMuc2VydmVyU2VxLmdyZWF0ZXJUaGFuKG90aGVyLnNlcnZlclNlcSlcbiAgICAgICAgICAgID8gdGhpcy5zZXJ2ZXJTZXFcbiAgICAgICAgICAgIDogb3RoZXIuc2VydmVyU2VxO1xuICAgICAgICBjb25zdCBjbGllbnRTZXEgPSBNYXRoLm1heCh0aGlzLmNsaWVudFNlcSwgb3RoZXIuY2xpZW50U2VxKTtcbiAgICAgICAgcmV0dXJuIENoZWNrcG9pbnQub2Yoc2VydmVyU2VxLCBjbGllbnRTZXEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0U2VydmVyU2VxQXNTdHJpbmdgIHJldHVybnMgdGhlIHNlcnZlciBzZXEgb2YgdGhpcyBjaGVja3BvaW50IGFzIGFcbiAgICAgKiBzdHJpbmcuXG4gICAgICovXG4gICAgZ2V0U2VydmVyU2VxQXNTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZlclNlcS50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0Q2xpZW50U2VxYCByZXR1cm5zIHRoZSBjbGllbnQgc2VxIG9mIHRoaXMgY2hlY2twb2ludC5cbiAgICAgKi9cbiAgICBnZXRDbGllbnRTZXEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudFNlcTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldFNlcnZlclNlcWAgcmV0dXJucyB0aGUgc2VydmVyIHNlcSBvZiB0aGlzIGNoZWNrcG9pbnQuXG4gICAgICovXG4gICAgZ2V0U2VydmVyU2VxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXJTZXE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBlcXVhbHNgIHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gY2hlY2twb2ludCBpcyBlcXVhbCB0byB0aGlzIGNoZWNrcG9pbnRcbiAgICAgKiBvciBub3QuXG4gICAgICovXG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5jbGllbnRTZXEgPT09IG90aGVyLmNsaWVudFNlcSAmJlxuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJTZXEuZXF1YWxzKG90aGVyLnNlcnZlclNlcSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdG9UZXN0U3RyaW5nYCByZXR1cm5zIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1ldGEgZGF0YSBvZiB0aGlzXG4gICAgICogY2hlY2twb2ludC5cbiAgICAgKi9cbiAgICB0b1Rlc3RTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgc2VydmVyU2VxPSR7dGhpcy5zZXJ2ZXJTZXF9LCBjbGllbnRTZXE9JHt0aGlzLmNsaWVudFNlcX1gO1xuICAgIH1cbn1cbi8qKlxuICogYEluaXRpYWxDaGVja3BvaW50YCBpcyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgY2hlY2twb2ludC5cbiAqL1xuY29uc3QgSW5pdGlhbENoZWNrcG9pbnQgPSBuZXcgQ2hlY2twb2ludChub2RlX21vZHVsZXNfbG9uZy5mcm9tSW50KDAsIHRydWUpLCAwKTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2RvY3VtZW50L2NyZHQvcmdhX3RyZWVfc3BsaXQudHNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuXG5cbi8qKlxuICogYFJHQVRyZWVTcGxpdE5vZGVJRGAgaXMgYW4gSUQgb2YgUkdBVHJlZVNwbGl0Tm9kZS5cbiAqL1xuY2xhc3MgUkdBVHJlZVNwbGl0Tm9kZUlEIHtcbiAgICBjb25zdHJ1Y3RvcihjcmVhdGVkQXQsIG9mZnNldCkge1xuICAgICAgICB0aGlzLmNyZWF0ZWRBdCA9IGNyZWF0ZWRBdDtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBvZmAgY3JlYXRlcyBhIGluc3RhbmNlIG9mIFJHQVRyZWVTcGxpdE5vZGVJRC5cbiAgICAgKi9cbiAgICBzdGF0aWMgb2YoY3JlYXRlZEF0LCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSR0FUcmVlU3BsaXROb2RlSUQoY3JlYXRlZEF0LCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZnJvbVN0cnVjdGAgY3JlYXRlcyBhIGluc3RhbmNlIG9mIFJHQVRyZWVTcGxpdE5vZGVJRCBmcm9tIHRoZSBzdHJ1Y3QuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21TdHJ1Y3Qoc3RydWN0KSB7XG4gICAgICAgIHJldHVybiBSR0FUcmVlU3BsaXROb2RlSUQub2YoVGltZVRpY2tldC5mcm9tU3RydWN0KHN0cnVjdC5jcmVhdGVkQXQpLCBzdHJ1Y3Qub2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldENyZWF0ZWRBdGAgcmV0dXJucyB0aGUgY3JlYXRpb24gdGltZSBvZiB0aGlzIElELlxuICAgICAqL1xuICAgIGdldENyZWF0ZWRBdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlZEF0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0T2Zmc2V0YCByZXR1cm5zIHJldHVybnMgdGhlIG9mZnNldCBvZiB0aGlzIElELlxuICAgICAqL1xuICAgIGdldE9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZXF1YWxzYCByZXR1cm5zIHdoZXRoZXIgZ2l2ZW4gSUQgZXF1YWxzIHRvIHRoaXMgSUQgb3Igbm90LlxuICAgICAqL1xuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gKHRoaXMuY3JlYXRlZEF0LmNvbXBhcmUob3RoZXIuY3JlYXRlZEF0KSA9PT0gMCAmJlxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPT09IG90aGVyLm9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBoYXNTYW1lQ3JlYXRlZEF0YCByZXR1cm5zIHdoZXRoZXIgZ2l2ZW4gSUQgaGFzIHNhbWUgY3JlYXRpb24gdGltZSB3aXRoIHRoaXMgSUQuXG4gICAgICovXG4gICAgaGFzU2FtZUNyZWF0ZWRBdChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVkQXQuY29tcGFyZShvdGhlci5jcmVhdGVkQXQpID09PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgc3BsaXRgIGNyZWF0ZXMgYSBuZXcgSUQgd2l0aCBhbiBvZmZzZXQgZnJvbSB0aGlzIElELlxuICAgICAqL1xuICAgIHNwbGl0KG9mZnNldCkge1xuICAgICAgICByZXR1cm4gbmV3IFJHQVRyZWVTcGxpdE5vZGVJRCh0aGlzLmNyZWF0ZWRBdCwgdGhpcy5vZmZzZXQgKyBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdG9TdHJ1Y3RgIHJldHVybnMgdGhlIHN0cnVjdHVyZSBvZiB0aGlzIG5vZGUgaWQuXG4gICAgICovXG4gICAgdG9TdHJ1Y3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGVkQXQ6IHRoaXMuY3JlYXRlZEF0LnRvU3RydWN0KCksXG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdG9UZXN0U3RyaW5nYCByZXR1cm5zIGEgU3RyaW5nIGNvbnRhaW5pbmdcbiAgICAgKiB0aGUgbWV0YSBkYXRhIG9mIHRoZSBub2RlIGlkIGZvciBkZWJ1Z2dpbmcgcHVycG9zZS5cbiAgICAgKi9cbiAgICB0b1Rlc3RTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNyZWF0ZWRBdC50b1Rlc3RTdHJpbmcoKX06JHt0aGlzLm9mZnNldH1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdG9JRFN0cmluZ2AgcmV0dXJucyBhIHN0cmluZyB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIElEIGZvciB0aGlzIG5vZGUgaWQuXG4gICAgICovXG4gICAgdG9JRFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY3JlYXRlZEF0LnRvSURTdHJpbmcoKX06JHt0aGlzLm9mZnNldH1gO1xuICAgIH1cbn1cbmNvbnN0IEluaXRpYWxSR0FUcmVlU3BsaXROb2RlSUQgPSBSR0FUcmVlU3BsaXROb2RlSUQub2YoSW5pdGlhbFRpbWVUaWNrZXQsIDApO1xuLyoqXG4gKiBgUkdBVHJlZVNwbGl0UG9zYCBpcyB0aGUgcG9zaXRpb24gb2YgdGhlIHRleHQgaW5zaWRlIHRoZSBub2RlLlxuICovXG5jbGFzcyBSR0FUcmVlU3BsaXRQb3Mge1xuICAgIGNvbnN0cnVjdG9yKGlkLCByZWxhdGl2ZU9mZnNldCkge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgPSByZWxhdGl2ZU9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYG9mYCBjcmVhdGVzIGEgaW5zdGFuY2Ugb2YgUkdBVHJlZVNwbGl0UG9zLlxuICAgICAqL1xuICAgIHN0YXRpYyBvZihpZCwgcmVsYXRpdmVPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSR0FUcmVlU3BsaXRQb3MoaWQsIHJlbGF0aXZlT2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGZyb21TdHJ1Y3RgIGNyZWF0ZXMgYSBpbnN0YW5jZSBvZiBSR0FUcmVlU3BsaXRQb3MgZnJvbSB0aGUgc3RydWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tU3RydWN0KHN0cnVjdCkge1xuICAgICAgICBjb25zdCBpZCA9IFJHQVRyZWVTcGxpdE5vZGVJRC5mcm9tU3RydWN0KHN0cnVjdC5pZCk7XG4gICAgICAgIHJldHVybiBSR0FUcmVlU3BsaXRQb3Mub2YoaWQsIHN0cnVjdC5yZWxhdGl2ZU9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRJRGAgcmV0dXJucyB0aGUgSUQgb2YgdGhpcyBSR0FUcmVlU3BsaXRQb3MuXG4gICAgICovXG4gICAgZ2V0SUQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0UmVsYXRpdmVPZmZzZXRgIHJldHVybnMgdGhlIHJlbGF0aXZlIG9mZnNldCBvZiB0aGlzIFJHQVRyZWVTcGxpdFBvcy5cbiAgICAgKi9cbiAgICBnZXRSZWxhdGl2ZU9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRBYnNvbHV0ZUlEYCByZXR1cm5zIHRoZSBhYnNvbHV0ZSBpZCBvZiB0aGlzIFJHQVRyZWVTcGxpdFBvcy5cbiAgICAgKi9cbiAgICBnZXRBYnNvbHV0ZUlEKCkge1xuICAgICAgICByZXR1cm4gUkdBVHJlZVNwbGl0Tm9kZUlELm9mKHRoaXMuaWQuZ2V0Q3JlYXRlZEF0KCksIHRoaXMuaWQuZ2V0T2Zmc2V0KCkgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpgdG9UZXN0U3RyaW5nYCByZXR1cm5zIGEgU3RyaW5nIGNvbnRhaW5pbmdcbiAgICAgKiB0aGUgbWV0YSBkYXRhIG9mIHRoZSBwb3NpdGlvbiBmb3IgZGVidWdnaW5nIHB1cnBvc2UuXG4gICAgICovXG4gICAgdG9UZXN0U3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5pZC50b1Rlc3RTdHJpbmcoKX06JHt0aGlzLnJlbGF0aXZlT2Zmc2V0fWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0b1N0cnVjdGAgcmV0dXJucyB0aGUgc3RydWN0dXJlIG9mIHRoaXMgbm9kZSBwb3MuXG4gICAgICovXG4gICAgdG9TdHJ1Y3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogdGhpcy5pZC50b1N0cnVjdCgpLFxuICAgICAgICAgICAgcmVsYXRpdmVPZmZzZXQ6IHRoaXMucmVsYXRpdmVPZmZzZXQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBlcXVhbHNgIHJldHVybnMgd2hldGhlciBnaXZlbiBwb3MgZXF1YWwgdG8gdGhpcyBwb3Mgb3Igbm90LlxuICAgICAqL1xuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICBpZiAoIXRoaXMuaWQuZXF1YWxzKG90aGVyLmlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlbGF0aXZlT2Zmc2V0ID09PSBvdGhlci5yZWxhdGl2ZU9mZnNldDtcbiAgICB9XG59XG4vKipcbiAqIGBSR0FUcmVlU3BsaXROb2RlYCBpcyBhIG5vZGUgb2YgUkdBVHJlZVNwbGl0LlxuICovXG5jbGFzcyBSR0FUcmVlU3BsaXROb2RlIGV4dGVuZHMgU3BsYXlOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihpZCwgdmFsdWUsIHJlbW92ZWRBdCkge1xuICAgICAgICBzdXBlcih2YWx1ZSk7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5yZW1vdmVkQXQgPSByZW1vdmVkQXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBjcmVhdGVgIGNyZWF0ZXMgYSBpbnN0YW5jZSBvZiBSR0FUcmVlU3BsaXROb2RlLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoaWQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUkdBVHJlZVNwbGl0Tm9kZShpZCwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgY3JlYXRlQ29tcGFyYXRvcmAgY3JlYXRlcyBhIGZ1bmN0aW9uIHRvIGNvbXBhcmUgdHdvIFJHQVRyZWVTcGxpdE5vZGVJRC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlQ29tcGFyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIChwMSwgcDIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBhcmUgPSBwMS5nZXRDcmVhdGVkQXQoKS5jb21wYXJlKHAyLmdldENyZWF0ZWRBdCgpKTtcbiAgICAgICAgICAgIGlmIChjb21wYXJlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocDEuZ2V0T2Zmc2V0KCkgPiBwMi5nZXRPZmZzZXQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocDEuZ2V0T2Zmc2V0KCkgPCBwMi5nZXRPZmZzZXQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0SURgIHJldHVybnMgdGhlIElEIG9mIHRoaXMgUkdBVHJlZVNwbGl0Tm9kZS5cbiAgICAgKi9cbiAgICBnZXRJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRDcmVhdGVkQXRgIHJldHVybnMgY3JlYXRpb24gdGltZSBvZiB0aGUgSWQgb2YgUkdBVHJlZVNwbGl0Tm9kZS5cbiAgICAgKi9cbiAgICBnZXRDcmVhdGVkQXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkLmdldENyZWF0ZWRBdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0TGVuZ3RoYCByZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhpcyBub2RlLlxuICAgICAqL1xuICAgIGdldExlbmd0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVtb3ZlZEF0KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb250ZW50TGVuZ3RoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRDb250ZW50TGVuZ3RoYCByZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhpcyB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXRDb250ZW50TGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudmFsdWUgJiYgdGhpcy52YWx1ZS5sZW5ndGgpIHx8IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRQcmV2YCByZXR1cm5zIGEgcHJldmlvdXMgbm9kZSBvZiB0aGlzIG5vZGUuXG4gICAgICovXG4gICAgZ2V0UHJldigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldE5leHRgIHJldHVybnMgYSBuZXh0IG5vZGUgb2YgdGhpcyBub2RlLlxuICAgICAqL1xuICAgIGdldE5leHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRJbnNQcmV2YCByZXR1cm5zIGEgcHJldmlvdXMgbm9kZSBvZiB0aGlzIG5vZGUgaW5zZXJ0aW9uLlxuICAgICAqL1xuICAgIGdldEluc1ByZXYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc1ByZXY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRJbnNOZXh0YCByZXR1cm5zIGEgbmV4dCBub2RlIG9mIHRoaXMgbm9kZSBpbnNlcnRpb24uXG4gICAgICovXG4gICAgZ2V0SW5zTmV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zTmV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldEluc1ByZXZJRGAgcmV0dXJucyBhIElEIG9mIHByZXZpb3VzIG5vZGUgaW5zZXJ0aW9uLlxuICAgICAqL1xuICAgIGdldEluc1ByZXZJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zUHJldi5nZXRJRCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgc2V0UHJldmAgc2V0cyBwcmV2aW91cyBub2RlIG9mIHRoaXMgbm9kZS5cbiAgICAgKi9cbiAgICBzZXRQcmV2KG5vZGUpIHtcbiAgICAgICAgdGhpcy5wcmV2ID0gbm9kZTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUubmV4dCA9IHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogYHNldE5leHRgIHNldHMgbmV4dCBub2RlIG9mIHRoaXMgbm9kZS5cbiAgICAgKi9cbiAgICBzZXROZXh0KG5vZGUpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gbm9kZTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUucHJldiA9IHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogYHNldEluc1ByZXZgIHNldHMgcHJldmlvdXMgbm9kZSBvZiB0aGlzIG5vZGUgaW5zZXJ0aW9uLlxuICAgICAqL1xuICAgIHNldEluc1ByZXYobm9kZSkge1xuICAgICAgICB0aGlzLmluc1ByZXYgPSBub2RlO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZS5pbnNOZXh0ID0gdGhpcztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBgc2V0SW5zTmV4dGAgc2V0cyBuZXh0IG5vZGUgb2YgdGhpcyBub2RlIGluc2VydGlvbi5cbiAgICAgKi9cbiAgICBzZXRJbnNOZXh0KG5vZGUpIHtcbiAgICAgICAgdGhpcy5pbnNOZXh0ID0gbm9kZTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUuaW5zUHJldiA9IHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogYGhhc05leHRgIGNoZWNrcyBpZiBuZXh0IG5vZGUgZXhpc3RzLlxuICAgICAqL1xuICAgIGhhc05leHQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMubmV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGhhc0luc1ByZXZgIGNoZWNrcyBpZiBwcmV2aW91cyBpbnNlcnRpb24gbm9kZSBleGlzdHMuXG4gICAgICovXG4gICAgaGFzSW5zUHJldigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5pbnNQcmV2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgaXNSZW1vdmVkYCBjaGVja3MgaWYgcmVtb3ZlZCB0aW1lIGV4aXN0cy5cbiAgICAgKi9cbiAgICBpc1JlbW92ZWQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMucmVtb3ZlZEF0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0UmVtb3ZlZEF0YCByZXR1cm5zIHRoZSByZW1vdmUgdGltZSBvZiB0aGlzIG5vZGUuXG4gICAgICovXG4gICAgZ2V0UmVtb3ZlZEF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVkQXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBzcGxpdGAgY3JlYXRlcyBhIG5ldyBzcGxpdCBub2RlIG9mIHRoZSBnaXZlbiBvZmZzZXQuXG4gICAgICovXG4gICAgc3BsaXQob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUkdBVHJlZVNwbGl0Tm9kZSh0aGlzLmlkLnNwbGl0KG9mZnNldCksIHRoaXMuc3BsaXRWYWx1ZShvZmZzZXQpLCB0aGlzLnJlbW92ZWRBdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBjYW5EZWxldGVgIGNoZWNrcyBpZiBub2RlIGlzIGFibGUgdG8gZGVsZXRlLlxuICAgICAqL1xuICAgIGNhbkRlbGV0ZShlZGl0ZWRBdCwgbGF0ZXN0Q3JlYXRlZEF0KSB7XG4gICAgICAgIHJldHVybiAoIXRoaXMuZ2V0Q3JlYXRlZEF0KCkuYWZ0ZXIobGF0ZXN0Q3JlYXRlZEF0KSAmJlxuICAgICAgICAgICAgKCF0aGlzLnJlbW92ZWRBdCB8fCBlZGl0ZWRBdC5hZnRlcih0aGlzLnJlbW92ZWRBdCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGNhblN0eWxlYCBjaGVja3MgaWYgbm9kZSBpcyBhYmxlIHRvIHNldCBzdHlsZS5cbiAgICAgKi9cbiAgICBjYW5TdHlsZShlZGl0ZWRBdCwgbGF0ZXN0Q3JlYXRlZEF0KSB7XG4gICAgICAgIHJldHVybiAoIXRoaXMuZ2V0Q3JlYXRlZEF0KCkuYWZ0ZXIobGF0ZXN0Q3JlYXRlZEF0KSAmJlxuICAgICAgICAgICAgKCF0aGlzLnJlbW92ZWRBdCB8fCBlZGl0ZWRBdC5hZnRlcih0aGlzLnJlbW92ZWRBdCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHJlbW92ZWAgcmVtb3ZlcyBub2RlIG9mIGdpdmVuIGVkaXRlZCB0aW1lLlxuICAgICAqL1xuICAgIHJlbW92ZShlZGl0ZWRBdCkge1xuICAgICAgICB0aGlzLnJlbW92ZWRBdCA9IGVkaXRlZEF0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgY3JlYXRlUmFuZ2VgIGNyZWF0ZXMgcmFuZ2VzIG9mIFJHQVRyZWVTcGxpdFBvcy5cbiAgICAgKi9cbiAgICBjcmVhdGVQb3NSYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFJHQVRyZWVTcGxpdFBvcy5vZih0aGlzLmlkLCAwKSxcbiAgICAgICAgICAgIFJHQVRyZWVTcGxpdFBvcy5vZih0aGlzLmlkLCB0aGlzLmdldExlbmd0aCgpKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGRlZXBjb3B5YCByZXR1cm5zIGEgbmV3IGluc3RhbmNlIG9mIHRoaXMgUkdBVHJlZVNwbGl0Tm9kZSB3aXRob3V0IHN0cnVjdHVyYWwgaW5mby5cbiAgICAgKi9cbiAgICBkZWVwY29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSR0FUcmVlU3BsaXROb2RlKHRoaXMuaWQsIHRoaXMudmFsdWUsIHRoaXMucmVtb3ZlZEF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRvVGVzdFN0cmluZ2AgcmV0dXJucyBhIFN0cmluZyBjb250YWluaW5nXG4gICAgICogdGhlIG1ldGEgZGF0YSBvZiB0aGUgbm9kZSBmb3IgZGVidWdnaW5nIHB1cnBvc2UuXG4gICAgICovXG4gICAgdG9UZXN0U3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5pZC50b1Rlc3RTdHJpbmcoKX0gJHt0aGlzLnZhbHVlID8gdGhpcy52YWx1ZSA6ICcnfWA7XG4gICAgfVxuICAgIHNwbGl0VmFsdWUob2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKG9mZnNldCwgdmFsdWUubGVuZ3RoKTtcbiAgICB9XG59XG4vKipcbiAqIGBSR0FUcmVlU3BsaXRgIGlzIGEgYmxvY2stYmFzZWQgbGlzdCB3aXRoIGltcHJvdmVkIGluZGV4LWJhc2VkIGxvb2t1cCBpbiBSR0EuXG4gKiBUaGUgZGlmZmVyZW5jZSBmcm9tIFJHQVRyZWVMaXN0IGlzIHRoYXQgaXQgaGFzIGRhdGEgb24gYSBibG9jayBiYXNpcyB0b1xuICogcmVkdWNlIHRoZSBzaXplIG9mIENSRFQgbWV0YWRhdGEuIFdoZW4gYW4gZWRpdCBvY2N1cnMgb24gYSBibG9jayxcbiAqIHRoZSBibG9jayBpcyBzcGxpdC5cbiAqXG4gKi9cbmNsYXNzIFJHQVRyZWVTcGxpdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IFJHQVRyZWVTcGxpdE5vZGUuY3JlYXRlKEluaXRpYWxSR0FUcmVlU3BsaXROb2RlSUQpO1xuICAgICAgICB0aGlzLnRyZWVCeUluZGV4ID0gbmV3IFNwbGF5VHJlZSgpO1xuICAgICAgICB0aGlzLnRyZWVCeUlEID0gbmV3IExMUkJUcmVlKFJHQVRyZWVTcGxpdE5vZGUuY3JlYXRlQ29tcGFyYXRvcigpKTtcbiAgICAgICAgdGhpcy5yZW1vdmVkTm9kZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy50cmVlQnlJbmRleC5pbnNlcnQodGhpcy5oZWFkKTtcbiAgICAgICAgdGhpcy50cmVlQnlJRC5wdXQodGhpcy5oZWFkLmdldElEKCksIHRoaXMuaGVhZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBjcmVhdGVgIGNyZWF0ZXMgYSBpbnN0YW5jZSBSR0FUcmVlU3BsaXQuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSR0FUcmVlU3BsaXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGVkaXRgIGRvZXMgZm9sbG93aW5nIHN0ZXBzXG4gICAgICogMS4gc3BsaXQgbm9kZXMgd2l0aCBmcm9tIGFuZCB0b1xuICAgICAqIDIuIGRlbGV0ZSBiZXR3ZWVuIGZyb20gYW5kIHRvXG4gICAgICogMy4gaW5zZXJ0IGEgbmV3IG5vZGVcbiAgICAgKiA0LiBhZGQgcmVtb3ZlZCBub2RlXG4gICAgICogQHBhcmFtIHJhbmdlIC0gcmFuZ2Ugb2YgUkdBVHJlZVNwbGl0Tm9kZVxuICAgICAqIEBwYXJhbSBlZGl0ZWRBdCAtIGVkaXRlZCB0aW1lXG4gICAgICogQHBhcmFtIHZhbHVlIC0gdmFsdWVcbiAgICAgKiBAcGFyYW0gbGF0ZXN0Q3JlYXRlZEF0TWFwQnlBY3RvciAtIGxhdGVzdENyZWF0ZWRBdE1hcEJ5QWN0b3JcbiAgICAgKiBAcmV0dXJucyBgW1JHQVRyZWVTcGxpdFBvcywgTWFwPHN0cmluZywgVGltZVRpY2tldD4sIEFycmF5PENoYW5nZT5dYFxuICAgICAqL1xuICAgIGVkaXQocmFuZ2UsIGVkaXRlZEF0LCB2YWx1ZSwgbGF0ZXN0Q3JlYXRlZEF0TWFwQnlBY3Rvcikge1xuICAgICAgICAvLyAwMS4gc3BsaXQgbm9kZXMgd2l0aCBmcm9tIGFuZCB0b1xuICAgICAgICBjb25zdCBbdG9MZWZ0LCB0b1JpZ2h0XSA9IHRoaXMuZmluZE5vZGVXaXRoU3BsaXQocmFuZ2VbMV0sIGVkaXRlZEF0KTtcbiAgICAgICAgY29uc3QgW2Zyb21MZWZ0LCBmcm9tUmlnaHRdID0gdGhpcy5maW5kTm9kZVdpdGhTcGxpdChyYW5nZVswXSwgZWRpdGVkQXQpO1xuICAgICAgICAvLyAwMi4gZGVsZXRlIGJldHdlZW4gZnJvbSBhbmQgdG9cbiAgICAgICAgY29uc3Qgbm9kZXNUb0RlbGV0ZSA9IHRoaXMuZmluZEJldHdlZW4oZnJvbVJpZ2h0LCB0b1JpZ2h0KTtcbiAgICAgICAgY29uc3QgW2NoYW5nZXMsIGxhdGVzdENyZWF0ZWRBdE1hcCwgcmVtb3ZlZE5vZGVNYXBCeU5vZGVLZXldID0gdGhpcy5kZWxldGVOb2Rlcyhub2Rlc1RvRGVsZXRlLCBlZGl0ZWRBdCwgbGF0ZXN0Q3JlYXRlZEF0TWFwQnlBY3Rvcik7XG4gICAgICAgIGNvbnN0IGNhcmV0SUQgPSB0b1JpZ2h0ID8gdG9SaWdodC5nZXRJRCgpIDogdG9MZWZ0LmdldElEKCk7XG4gICAgICAgIGxldCBjYXJldFBvcyA9IFJHQVRyZWVTcGxpdFBvcy5vZihjYXJldElELCAwKTtcbiAgICAgICAgLy8gMDMuIGluc2VydCBhIG5ldyBub2RlXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5wb3NUb0luZGV4KGZyb21MZWZ0LmNyZWF0ZVBvc1JhbmdlKClbMV0sIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgaW5zZXJ0ZWQgPSB0aGlzLmluc2VydEFmdGVyKGZyb21MZWZ0LCBSR0FUcmVlU3BsaXROb2RlLmNyZWF0ZShSR0FUcmVlU3BsaXROb2RlSUQub2YoZWRpdGVkQXQsIDApLCB2YWx1ZSkpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZXMubGVuZ3RoICYmIGNoYW5nZXNbY2hhbmdlcy5sZW5ndGggLSAxXS5mcm9tID09PSBpZHgpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzW2NoYW5nZXMubGVuZ3RoIC0gMV0udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGFjdG9yOiBlZGl0ZWRBdC5nZXRBY3RvcklEKCksXG4gICAgICAgICAgICAgICAgICAgIGZyb206IGlkeCxcbiAgICAgICAgICAgICAgICAgICAgdG86IGlkeCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXJldFBvcyA9IFJHQVRyZWVTcGxpdFBvcy5vZihpbnNlcnRlZC5nZXRJRCgpLCBpbnNlcnRlZC5nZXRDb250ZW50TGVuZ3RoKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDA0LiBhZGQgcmVtb3ZlZCBub2RlXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgcmVtb3ZlZE5vZGVdIG9mIHJlbW92ZWROb2RlTWFwQnlOb2RlS2V5KSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZWROb2RlTWFwLnNldChrZXksIHJlbW92ZWROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2NhcmV0UG9zLCBsYXRlc3RDcmVhdGVkQXRNYXAsIGNoYW5nZXNdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgaW5kZXhUb1Bvc2AgZmluZHMgUkdBVHJlZVNwbGl0UG9zIG9mIGdpdmVuIG9mZnNldC5cbiAgICAgKi9cbiAgICBpbmRleFRvUG9zKGlkeCkge1xuICAgICAgICBjb25zdCBbbm9kZSwgb2Zmc2V0XSA9IHRoaXMudHJlZUJ5SW5kZXguZmluZChpZHgpO1xuICAgICAgICBjb25zdCBzcGxpdE5vZGUgPSBub2RlO1xuICAgICAgICByZXR1cm4gUkdBVHJlZVNwbGl0UG9zLm9mKHNwbGl0Tm9kZS5nZXRJRCgpLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZmluZEluZGV4ZXNGcm9tUmFuZ2VgIGZpbmRzIGluZGV4ZXMgYmFzZWQgb24gcmFuZ2UuXG4gICAgICovXG4gICAgZmluZEluZGV4ZXNGcm9tUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgY29uc3QgW2Zyb21Qb3MsIHRvUG9zXSA9IHJhbmdlO1xuICAgICAgICByZXR1cm4gW3RoaXMucG9zVG9JbmRleChmcm9tUG9zLCBmYWxzZSksIHRoaXMucG9zVG9JbmRleCh0b1BvcywgdHJ1ZSldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgcG9zVG9JbmRleGAgY29udmVydHMgdGhlIGdpdmVuIHBvc2l0aW9uIHRvIGluZGV4LlxuICAgICAqL1xuICAgIHBvc1RvSW5kZXgocG9zLCBwcmVmZXJUb0xlZnQpIHtcbiAgICAgICAgY29uc3QgYWJzb2x1dGVJRCA9IHBvcy5nZXRBYnNvbHV0ZUlEKCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBwcmVmZXJUb0xlZnRcbiAgICAgICAgICAgID8gdGhpcy5maW5kRmxvb3JOb2RlUHJlZmVyVG9MZWZ0KGFic29sdXRlSUQpXG4gICAgICAgICAgICA6IHRoaXMuZmluZEZsb29yTm9kZShhYnNvbHV0ZUlEKTtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICBsb2dnZXIuZmF0YWwoYHRoZSBub2RlIG9mIHRoZSBnaXZlbiBpZCBzaG91bGQgYmUgZm91bmQ6ICR7YWJzb2x1dGVJRC50b1Rlc3RTdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMudHJlZUJ5SW5kZXguaW5kZXhPZihub2RlKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gbm9kZS5pc1JlbW92ZWQoKVxuICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICA6IGFic29sdXRlSUQuZ2V0T2Zmc2V0KCkgLSBub2RlLmdldElEKCkuZ2V0T2Zmc2V0KCk7XG4gICAgICAgIHJldHVybiBpbmRleCArIG9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGZpbmROb2RlYCBmaW5kcyBub2RlIG9mIGdpdmVuIGlkLlxuICAgICAqL1xuICAgIGZpbmROb2RlKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRGbG9vck5vZGUoaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgbGVuZ3RoYCByZXR1cm5zIHNpemUgb2YgUkdBVHJlZVNwbGl0LlxuICAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWVCeUluZGV4Lmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGNoZWNrV2VpZ2h0YCByZXR1cm5zIGZhbHNlIHdoZW4gdGhlcmUgaXMgYW4gaW5jb3JyZWN0IHdlaWdodCBub2RlLlxuICAgICAqIGZvciBkZWJ1Z2dpbmcgcHVycG9zZS5cbiAgICAgKi9cbiAgICBjaGVja1dlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZUJ5SW5kZXguY2hlY2tXZWlnaHQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRvU3RyaW5nYCByZXR1cm5zIHRoZSBzdHJpbmcgZW5jb2Rpbmcgb2YgdGhpcyBSR0FUcmVlU3BsaXQuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHN0ciA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcykge1xuICAgICAgICAgICAgaWYgKCFub2RlLmlzUmVtb3ZlZCgpKSB7XG4gICAgICAgICAgICAgICAgc3RyLnB1c2gobm9kZS5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyLmpvaW4oJycpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmhlYWQuZ2V0TmV4dCgpO1xuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgeWllbGQgbm9kZTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmdldE5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0SGVhZGAgcmV0dXJucyBoZWFkIG9mIFJHQVRyZWVTcGxpdE5vZGUuXG4gICAgICovXG4gICAgZ2V0SGVhZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGRlZXBjb3B5YCBjb3BpZXMgaXRzZWxmIGRlZXBseS5cbiAgICAgKi9cbiAgICBkZWVwY29weSgpIHtcbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgUkdBVHJlZVNwbGl0KCk7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5oZWFkLmdldE5leHQoKTtcbiAgICAgICAgbGV0IHByZXYgPSBjbG9uZS5oZWFkO1xuICAgICAgICBsZXQgY3VycmVudDtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjbG9uZS5pbnNlcnRBZnRlcihwcmV2LCBub2RlLmRlZXBjb3B5KCkpO1xuICAgICAgICAgICAgaWYgKG5vZGUuaGFzSW5zUHJldigpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5zUHJldk5vZGUgPSBjbG9uZS5maW5kTm9kZShub2RlLmdldEluc1ByZXZJRCgpKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50LnNldEluc1ByZXYoaW5zUHJldk5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5nZXROZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdG9UZXN0U3RyaW5nYCByZXR1cm5zIGEgU3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1ldGEgZGF0YSBvZiB0aGUgbm9kZVxuICAgICAqIGZvciBkZWJ1Z2dpbmcgcHVycG9zZS5cbiAgICAgKi9cbiAgICB0b1Rlc3RTdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuaGVhZDtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmlzUmVtb3ZlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYHske25vZGUudG9UZXN0U3RyaW5nKCl9fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYFske25vZGUudG9UZXN0U3RyaW5nKCl9XWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUuZ2V0TmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBpbnNlcnRBZnRlcmAgaW5zZXJ0cyB0aGUgZ2l2ZW4gbm9kZSBhZnRlciB0aGUgZ2l2ZW4gcHJldmlvdXMgbm9kZS5cbiAgICAgKi9cbiAgICBpbnNlcnRBZnRlcihwcmV2Tm9kZSwgbmV3Tm9kZSkge1xuICAgICAgICBjb25zdCBuZXh0ID0gcHJldk5vZGUuZ2V0TmV4dCgpO1xuICAgICAgICBuZXdOb2RlLnNldFByZXYocHJldk5vZGUpO1xuICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgbmV4dC5zZXRQcmV2KG5ld05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJlZUJ5SUQucHV0KG5ld05vZGUuZ2V0SUQoKSwgbmV3Tm9kZSk7XG4gICAgICAgIHRoaXMudHJlZUJ5SW5kZXguaW5zZXJ0QWZ0ZXIocHJldk5vZGUsIG5ld05vZGUpO1xuICAgICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGZpbmROb2RlV2l0aFNwbGl0YCBzcGxpdHMgYW5kIHJldHVybiBub2RlcyBvZiB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICovXG4gICAgZmluZE5vZGVXaXRoU3BsaXQocG9zLCBlZGl0ZWRBdCkge1xuICAgICAgICBjb25zdCBhYnNvbHV0ZUlEID0gcG9zLmdldEFic29sdXRlSUQoKTtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmZpbmRGbG9vck5vZGVQcmVmZXJUb0xlZnQoYWJzb2x1dGVJRCk7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlT2Zmc2V0ID0gYWJzb2x1dGVJRC5nZXRPZmZzZXQoKSAtIG5vZGUuZ2V0SUQoKS5nZXRPZmZzZXQoKTtcbiAgICAgICAgdGhpcy5zcGxpdE5vZGUobm9kZSwgcmVsYXRpdmVPZmZzZXQpO1xuICAgICAgICB3aGlsZSAobm9kZS5oYXNOZXh0KCkgJiYgbm9kZS5nZXROZXh0KCkuZ2V0Q3JlYXRlZEF0KCkuYWZ0ZXIoZWRpdGVkQXQpKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5nZXROZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtub2RlLCBub2RlLmdldE5leHQoKV07XG4gICAgfVxuICAgIGZpbmRGbG9vck5vZGVQcmVmZXJUb0xlZnQoaWQpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmZpbmRGbG9vck5vZGUoaWQpO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci5mYXRhbChgdGhlIG5vZGUgb2YgdGhlIGdpdmVuIGlkIHNob3VsZCBiZSBmb3VuZDogJHtpZC50b1Rlc3RTdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWQuZ2V0T2Zmc2V0KCkgPiAwICYmIG5vZGUuZ2V0SUQoKS5nZXRPZmZzZXQoKSA9PSBpZC5nZXRPZmZzZXQoKSkge1xuICAgICAgICAgICAgLy8gTk9URTogSW5zUHJldiBtYXkgbm90IGJlIHByZXNlbnQgZHVlIHRvIEdDLlxuICAgICAgICAgICAgaWYgKCFub2RlLmhhc0luc1ByZXYoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUuZ2V0SW5zUHJldigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBmaW5kRmxvb3JOb2RlKGlkKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy50cmVlQnlJRC5mbG9vckVudHJ5KGlkKTtcbiAgICAgICAgaWYgKCFlbnRyeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZW50cnkua2V5LmVxdWFscyhpZCkgJiYgIWVudHJ5LmtleS5oYXNTYW1lQ3JlYXRlZEF0KGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGZpbmRCZXR3ZWVuYCByZXR1cm5zIG5vZGVzIGJldHdlZW4gZnJvbU5vZGUgYW5kIHRvTm9kZS5cbiAgICAgKi9cbiAgICBmaW5kQmV0d2Vlbihmcm9tTm9kZSwgdG9Ob2RlKSB7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgICAgIGxldCBjdXJyZW50ID0gZnJvbU5vZGU7XG4gICAgICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQgIT09IHRvTm9kZSkge1xuICAgICAgICAgICAgbm9kZXMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmdldE5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIHNwbGl0Tm9kZShub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKG9mZnNldCA+IG5vZGUuZ2V0Q29udGVudExlbmd0aCgpKSB7XG4gICAgICAgICAgICBsb2dnZXIuZmF0YWwoJ29mZnNldCBzaG91bGQgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGxlbmd0aCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9mZnNldCA9PT0gbm9kZS5nZXRDb250ZW50TGVuZ3RoKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmdldE5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcGxpdE5vZGUgPSBub2RlLnNwbGl0KG9mZnNldCk7XG4gICAgICAgIHRoaXMudHJlZUJ5SW5kZXgudXBkYXRlV2VpZ2h0KHNwbGl0Tm9kZSk7XG4gICAgICAgIHRoaXMuaW5zZXJ0QWZ0ZXIobm9kZSwgc3BsaXROb2RlKTtcbiAgICAgICAgY29uc3QgaW5zTmV4dCA9IG5vZGUuZ2V0SW5zTmV4dCgpO1xuICAgICAgICBpZiAoaW5zTmV4dCkge1xuICAgICAgICAgICAgaW5zTmV4dC5zZXRJbnNQcmV2KHNwbGl0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3BsaXROb2RlLnNldEluc1ByZXYobm9kZSk7XG4gICAgICAgIHJldHVybiBzcGxpdE5vZGU7XG4gICAgfVxuICAgIGRlbGV0ZU5vZGVzKGNhbmRpZGF0ZXMsIGVkaXRlZEF0LCBsYXRlc3RDcmVhdGVkQXRNYXBCeUFjdG9yKSB7XG4gICAgICAgIGlmICghY2FuZGlkYXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbW10sIG5ldyBNYXAoKSwgbmV3IE1hcCgpXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGVyZSBhcmUgMiB0eXBlcyBvZiBub2RlcyBpbiBgY2FuZGlkYXRlc2A6IHNob3VsZCBkZWxldGUsIHNob3VsZCBub3QgZGVsZXRlLlxuICAgICAgICAvLyBgbm9kZXNUb0tlZXBgIGNvbnRhaW5zIG5vZGVzIHNob3VsZCBub3QgZGVsZXRlLFxuICAgICAgICAvLyB0aGVuIGlzIHVzZWQgdG8gZmluZCB0aGUgYm91bmRhcnkgb2YgdGhlIHJhbmdlIHRvIGJlIGRlbGV0ZWQuXG4gICAgICAgIGNvbnN0IFtub2Rlc1RvRGVsZXRlLCBub2Rlc1RvS2VlcF0gPSB0aGlzLmZpbHRlck5vZGVzKGNhbmRpZGF0ZXMsIGVkaXRlZEF0LCBsYXRlc3RDcmVhdGVkQXRNYXBCeUFjdG9yKTtcbiAgICAgICAgY29uc3QgY3JlYXRlZEF0TWFwQnlBY3RvciA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgcmVtb3ZlZE5vZGVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIEZpcnN0IHdlIG5lZWQgdG8gY29sbGVjdCBpbmRleGVzIGZvciBjaGFuZ2UuXG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLm1ha2VDaGFuZ2VzKG5vZGVzVG9LZWVwLCBlZGl0ZWRBdCk7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlc1RvRGVsZXRlKSB7XG4gICAgICAgICAgICAvLyBUaGVuIG1ha2Ugbm9kZXMgYmUgdG9tYnN0b25lcyBhbmQgbWFwIHRoYXQuXG4gICAgICAgICAgICBjb25zdCBhY3RvcklEID0gbm9kZS5nZXRDcmVhdGVkQXQoKS5nZXRBY3RvcklEKCk7XG4gICAgICAgICAgICBpZiAoIWNyZWF0ZWRBdE1hcEJ5QWN0b3IuaGFzKGFjdG9ySUQpIHx8XG4gICAgICAgICAgICAgICAgbm9kZS5nZXRJRCgpLmdldENyZWF0ZWRBdCgpLmFmdGVyKGNyZWF0ZWRBdE1hcEJ5QWN0b3IuZ2V0KGFjdG9ySUQpKSkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZWRBdE1hcEJ5QWN0b3Iuc2V0KGFjdG9ySUQsIG5vZGUuZ2V0SUQoKS5nZXRDcmVhdGVkQXQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1vdmVkTm9kZU1hcC5zZXQobm9kZS5nZXRJRCgpLnRvSURTdHJpbmcoKSwgbm9kZSk7XG4gICAgICAgICAgICBub2RlLnJlbW92ZShlZGl0ZWRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluYWxseSByZW1vdmUgaW5kZXggbm9kZXMgb2YgdG9tYnN0b25lcy5cbiAgICAgICAgdGhpcy5kZWxldGVJbmRleE5vZGVzKG5vZGVzVG9LZWVwKTtcbiAgICAgICAgcmV0dXJuIFtjaGFuZ2VzLCBjcmVhdGVkQXRNYXBCeUFjdG9yLCByZW1vdmVkTm9kZU1hcF07XG4gICAgfVxuICAgIGZpbHRlck5vZGVzKGNhbmRpZGF0ZXMsIGVkaXRlZEF0LCBsYXRlc3RDcmVhdGVkQXRNYXBCeUFjdG9yKSB7XG4gICAgICAgIGNvbnN0IGlzUmVtb3RlID0gISFsYXRlc3RDcmVhdGVkQXRNYXBCeUFjdG9yO1xuICAgICAgICBjb25zdCBub2Rlc1RvRGVsZXRlID0gW107XG4gICAgICAgIGNvbnN0IG5vZGVzVG9LZWVwID0gW107XG4gICAgICAgIGNvbnN0IFtsZWZ0RWRnZSwgcmlnaHRFZGdlXSA9IHRoaXMuZmluZEVkZ2VzT2ZDYW5kaWRhdGVzKGNhbmRpZGF0ZXMpO1xuICAgICAgICBub2Rlc1RvS2VlcC5wdXNoKGxlZnRFZGdlKTtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGNhbmRpZGF0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdG9ySUQgPSBub2RlLmdldENyZWF0ZWRBdCgpLmdldEFjdG9ySUQoKTtcbiAgICAgICAgICAgIGNvbnN0IGxhdGVzdENyZWF0ZWRBdCA9IGlzUmVtb3RlXG4gICAgICAgICAgICAgICAgPyBsYXRlc3RDcmVhdGVkQXRNYXBCeUFjdG9yLmhhcyhhY3RvcklEKVxuICAgICAgICAgICAgICAgICAgICA/IGxhdGVzdENyZWF0ZWRBdE1hcEJ5QWN0b3IuZ2V0KGFjdG9ySUQpXG4gICAgICAgICAgICAgICAgICAgIDogSW5pdGlhbFRpbWVUaWNrZXRcbiAgICAgICAgICAgICAgICA6IE1heFRpbWVUaWNrZXQ7XG4gICAgICAgICAgICBpZiAobm9kZS5jYW5EZWxldGUoZWRpdGVkQXQsIGxhdGVzdENyZWF0ZWRBdCkpIHtcbiAgICAgICAgICAgICAgICBub2Rlc1RvRGVsZXRlLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2Rlc1RvS2VlcC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGVzVG9LZWVwLnB1c2gocmlnaHRFZGdlKTtcbiAgICAgICAgcmV0dXJuIFtub2Rlc1RvRGVsZXRlLCBub2Rlc1RvS2VlcF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBmaW5kRWRnZXNPZkNhbmRpZGF0ZXNgIGZpbmRzIHRoZSBlZGdlcyBvdXRzaWRlIGBjYW5kaWRhdGVzYCxcbiAgICAgKiAod2hpY2ggaGFzIG5vdCBhbHJlYWR5IGJlZW4gZGVsZXRlZCwgb3IgYmUgdW5kZWZpbmVkIGJ1dCBub3QgeWV0IGltcGxlbWVudGVkKVxuICAgICAqIHJpZ2h0IGVkZ2UgaXMgdW5kZWZpbmVkIG1lYW5zIGBjYW5kaWRhdGVzYCBjb250YWlucyB0aGUgZW5kIG9mIHRleHQuXG4gICAgICovXG4gICAgZmluZEVkZ2VzT2ZDYW5kaWRhdGVzKGNhbmRpZGF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGNhbmRpZGF0ZXNbMF0uZ2V0UHJldigpLFxuICAgICAgICAgICAgY2FuZGlkYXRlc1tjYW5kaWRhdGVzLmxlbmd0aCAtIDFdLmdldE5leHQoKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgbWFrZUNoYW5nZXMoYm91bmRhcmllcywgZWRpdGVkQXQpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgICAgICBsZXQgZnJvbUlkeCwgdG9JZHg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm91bmRhcmllcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRCb3VuZGFyeSA9IGJvdW5kYXJpZXNbaV07XG4gICAgICAgICAgICBjb25zdCByaWdodEJvdW5kYXJ5ID0gYm91bmRhcmllc1tpICsgMV07XG4gICAgICAgICAgICBpZiAobGVmdEJvdW5kYXJ5LmdldE5leHQoKSA9PSByaWdodEJvdW5kYXJ5KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBbZnJvbUlkeF0gPSB0aGlzLmZpbmRJbmRleGVzRnJvbVJhbmdlKGxlZnRCb3VuZGFyeS5nZXROZXh0KCkuY3JlYXRlUG9zUmFuZ2UoKSk7XG4gICAgICAgICAgICBpZiAocmlnaHRCb3VuZGFyeSkge1xuICAgICAgICAgICAgICAgIFssIHRvSWR4XSA9IHRoaXMuZmluZEluZGV4ZXNGcm9tUmFuZ2UocmlnaHRCb3VuZGFyeS5nZXRQcmV2KCkuY3JlYXRlUG9zUmFuZ2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b0lkeCA9IHRoaXMudHJlZUJ5SW5kZXgubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZyb21JZHggPCB0b0lkeCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGFjdG9yOiBlZGl0ZWRBdC5nZXRBY3RvcklEKCksXG4gICAgICAgICAgICAgICAgICAgIGZyb206IGZyb21JZHgsXG4gICAgICAgICAgICAgICAgICAgIHRvOiB0b0lkeCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlcy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBkZWxldGVJbmRleE5vZGVzYCBjbGVhcnMgdGhlIGluZGV4IG5vZGVzIG9mIHRoZSBnaXZlbiBkZWxldGlvbiBib3VuZGFyaWVzLlxuICAgICAqIFRoZSBib3VuZGFyaWVzIG1lYW4gdGhlIG5vZGVzIHRoYXQgd2lsbCBub3QgYmUgZGVsZXRlZCBpbiB0aGUgcmFuZ2UuXG4gICAgICovXG4gICAgZGVsZXRlSW5kZXhOb2Rlcyhib3VuZGFyaWVzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm91bmRhcmllcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRCb3VuZGFyeSA9IGJvdW5kYXJpZXNbaV07XG4gICAgICAgICAgICBjb25zdCByaWdodEJvdW5kYXJ5ID0gYm91bmRhcmllc1tpICsgMV07XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBub2RlIHRvIGRlbGV0ZSBiZXR3ZWVuIGJvdW5kYXJpZXMsIGRvIG5vdHRpbmcuXG4gICAgICAgICAgICBpZiAobGVmdEJvdW5kYXJ5LmdldE5leHQoKSAhPSByaWdodEJvdW5kYXJ5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlQnlJbmRleC5kZWxldGVSYW5nZShsZWZ0Qm91bmRhcnksIHJpZ2h0Qm91bmRhcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRSZW1vdmVkTm9kZXNMZW5gIHJldHVybnMgc2l6ZSBvZiByZW1vdmVkIG5vZGVzLlxuICAgICAqL1xuICAgIGdldFJlbW92ZWROb2Rlc0xlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlZE5vZGVNYXAuc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHB1cmdlUmVtb3ZlZE5vZGVzQmVmb3JlYCBwaHlzaWNhbGx5IHB1cmdlcyBub2RlcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkLlxuICAgICAqL1xuICAgIHB1cmdlUmVtb3ZlZE5vZGVzQmVmb3JlKHRpY2tldCkge1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IFssIG5vZGVdIG9mIHRoaXMucmVtb3ZlZE5vZGVNYXApIHtcbiAgICAgICAgICAgIGlmIChub2RlLmdldFJlbW92ZWRBdCgpICYmIHRpY2tldC5jb21wYXJlKG5vZGUuZ2V0UmVtb3ZlZEF0KCkpID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWVCeUluZGV4LmRlbGV0ZShub2RlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1cmdlKG5vZGUpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJlZUJ5SUQucmVtb3ZlKG5vZGUuZ2V0SUQoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVkTm9kZU1hcC5kZWxldGUobm9kZS5nZXRJRCgpLnRvSURTdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBwdXJnZWAgcGh5c2ljYWxseSBwdXJnZXMgdGhlIGdpdmVuIG5vZGUgZnJvbSBSR0FUcmVlU3BsaXQuXG4gICAgICovXG4gICAgcHVyZ2Uobm9kZSkge1xuICAgICAgICBjb25zdCBwcmV2ID0gbm9kZS5nZXRQcmV2KCk7XG4gICAgICAgIGNvbnN0IG5leHQgPSBub2RlLmdldE5leHQoKTtcbiAgICAgICAgY29uc3QgaW5zUHJldiA9IG5vZGUuZ2V0SW5zUHJldigpO1xuICAgICAgICBjb25zdCBpbnNOZXh0ID0gbm9kZS5nZXRJbnNOZXh0KCk7XG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICBwcmV2LnNldE5leHQobmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgIG5leHQuc2V0UHJldihwcmV2KTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnNldFByZXYodW5kZWZpbmVkKTtcbiAgICAgICAgbm9kZS5zZXROZXh0KHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChpbnNQcmV2KSB7XG4gICAgICAgICAgICBpbnNQcmV2LnNldEluc05leHQoaW5zTmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc05leHQpIHtcbiAgICAgICAgICAgIGluc05leHQuc2V0SW5zUHJldihpbnNQcmV2KTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnNldEluc1ByZXYodW5kZWZpbmVkKTtcbiAgICAgICAgbm9kZS5zZXRJbnNOZXh0KHVuZGVmaW5lZCk7XG4gICAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9udW1iZXIudHNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMyBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiBgcmVtb3ZlRGVjaW1hbGAgcmV0dXJucyBhIG51bWJlciB3aXRoIHRoZSBkZWNpbWFsIHBhcnQgcmVtb3ZlZC5cbiAqL1xuY29uc3QgcmVtb3ZlRGVjaW1hbCA9IChudW1iZXIpID0+IG51bWJlciA8IDAgPyBNYXRoLmNlaWwobnVtYmVyKSA6IE1hdGguZmxvb3IobnVtYmVyKTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2RvY3VtZW50L2NyZHQvY291bnRlci50c1xuLypcbiAqIENvcHlyaWdodCAyMDIwIFRoZSBZb3JraWUgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuXG5cblxuXG52YXIgQ291bnRlclR5cGU7XG4oZnVuY3Rpb24gKENvdW50ZXJUeXBlKSB7XG4gICAgQ291bnRlclR5cGVbQ291bnRlclR5cGVbXCJJbnRlZ2VyQ250XCJdID0gMF0gPSBcIkludGVnZXJDbnRcIjtcbiAgICBDb3VudGVyVHlwZVtDb3VudGVyVHlwZVtcIkxvbmdDbnRcIl0gPSAxXSA9IFwiTG9uZ0NudFwiO1xufSkoQ291bnRlclR5cGUgfHwgKENvdW50ZXJUeXBlID0ge30pKTtcbi8qKlxuICogYENSRFRDb3VudGVyYCBpcyBhIENSRFQgaW1wbGVtZW50YXRpb24gb2YgYSBjb3VudGVyLiBJdCBpcyB1c2VkIHRvIHJlcHJlc2VudFxuICogYSBudW1iZXIgdGhhdCBjYW4gYmUgaW5jcmVtZW50ZWQgb3IgZGVjcmVtZW50ZWQuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIENSRFRDb3VudGVyIGV4dGVuZHMgQ1JEVEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlVHlwZSwgdmFsdWUsIGNyZWF0ZWRBdCkge1xuICAgICAgICBzdXBlcihjcmVhdGVkQXQpO1xuICAgICAgICB0aGlzLnZhbHVlVHlwZSA9IHZhbHVlVHlwZTtcbiAgICAgICAgc3dpdGNoICh2YWx1ZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgQ291bnRlclR5cGUuSW50ZWdlckNudDpcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiBNYXRoLnBvdygyLCAzMSkgLSAxIHx8IHZhbHVlIDwgLU1hdGgucG93KDIsIDMxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG5vZGVfbW9kdWxlc19sb25nLmZyb21OdW1iZXIodmFsdWUpLnRvSW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gcmVtb3ZlRGVjaW1hbCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZS50b0ludCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ291bnRlclR5cGUuTG9uZ0NudDpcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbm9kZV9tb2R1bGVzX2xvbmcuZnJvbU51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgWW9ya2llRXJyb3IoZXJyb3JfQ29kZS5VbmltcGxlbWVudGVkLCBgdW5pbXBsZW1lbnRlZCB0eXBlOiAke3ZhbHVlVHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBgb2ZgIGNyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgQ291bnRlci5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKHZhbHVlVHlwZSwgdmFsdWUsIGNyZWF0ZWRBdCkge1xuICAgICAgICByZXR1cm4gbmV3IENSRFRDb3VudGVyKHZhbHVlVHlwZSwgdmFsdWUsIGNyZWF0ZWRBdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB2YWx1ZUZyb21CeXRlc2AgcGFyc2VzIHRoZSBnaXZlbiBieXRlcyBpbnRvIHZhbHVlLlxuICAgICAqL1xuICAgIHN0YXRpYyB2YWx1ZUZyb21CeXRlcyhjb3VudGVyVHlwZSwgYnl0ZXMpIHtcbiAgICAgICAgc3dpdGNoIChjb3VudGVyVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBDb3VudGVyVHlwZS5JbnRlZ2VyQ250OlxuICAgICAgICAgICAgICAgIHJldHVybiBieXRlc1swXSB8IChieXRlc1sxXSA8PCA4KSB8IChieXRlc1syXSA8PCAxNikgfCAoYnl0ZXNbM10gPDwgMjQpO1xuICAgICAgICAgICAgY2FzZSBDb3VudGVyVHlwZS5Mb25nQ250OlxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlX21vZHVsZXNfbG9uZy5mcm9tQnl0ZXNMRShBcnJheS5mcm9tKGJ5dGVzKSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBZb3JraWVFcnJvcihlcnJvcl9Db2RlLlVuaW1wbGVtZW50ZWQsIGB1bmltcGxlbWVudGVkIHR5cGU6ICR7Y291bnRlclR5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRvSlNPTmAgcmV0dXJucyB0aGUgSlNPTiBlbmNvZGluZyBvZiB0aGUgdmFsdWUuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy52YWx1ZX1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdG9Tb3J0ZWRKU09OYCByZXR1cm5zIHRoZSBzb3J0ZWQgSlNPTiBlbmNvZGluZyBvZiB0aGUgdmFsdWUuXG4gICAgICovXG4gICAgdG9Tb3J0ZWRKU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0pTT04oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRvSlNGb3JUZXN0YCByZXR1cm5zIHZhbHVlIHdpdGggbWV0YSBkYXRhIGZvciB0ZXN0aW5nLlxuICAgICAqL1xuICAgIHRvSlNGb3JUZXN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHRoaXMuZ2V0Q3JlYXRlZEF0KCkudG9UZXN0U3RyaW5nKCksXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgICAgICAgIHR5cGU6ICdZT1JLSUVfQ09VTlRFUicsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBkZWVwY29weWAgY29waWVzIGl0c2VsZiBkZWVwbHkuXG4gICAgICovXG4gICAgZGVlcGNvcHkoKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBDUkRUQ291bnRlci5jcmVhdGUodGhpcy52YWx1ZVR5cGUsIHRoaXMudmFsdWUsIHRoaXMuZ2V0Q3JlYXRlZEF0KCkpO1xuICAgICAgICBjb3VudGVyLnNldE1vdmVkQXQodGhpcy5nZXRNb3ZlZEF0KCkpO1xuICAgICAgICByZXR1cm4gY291bnRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldFR5cGVgIHJldHVybnMgdGhlIHR5cGUgb2YgdGhlIHZhbHVlLlxuICAgICAqL1xuICAgIGdldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldENvdW50ZXJUeXBlYCByZXR1cm5zIGNvdW50ZXIgdHlwZSBvZiBnaXZlbiB2YWx1ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q291bnRlclR5cGUodmFsdWUpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2Ygbm9kZV9tb2R1bGVzX2xvbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvdW50ZXJUeXBlLkxvbmdDbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiBNYXRoLnBvdygyLCAzMSkgLSAxIHx8IHZhbHVlIDwgLU1hdGgucG93KDIsIDMxKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ291bnRlclR5cGUuTG9uZ0NudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDb3VudGVyVHlwZS5JbnRlZ2VyQ250O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBpc1N1cHBvcnRgIGNoZWNrIGlmIHRoZXJlIGlzIGEgY291bnRlciB0eXBlIG9mIGdpdmVuIHZhbHVlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc1N1cHBvcnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhQ1JEVENvdW50ZXIuZ2V0Q291bnRlclR5cGUodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgaXNJbnRlZ2VyYCBjaGVja3MgaWYgdGhlIG51bSBpcyBpbnRlZ2VyLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ludGVnZXIobnVtKSB7XG4gICAgICAgIHJldHVybiBudW0gJSAxID09PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgaXNOdW1lcmljVHlwZWAgY2hlY2sgbnVtZXJpYyB0eXBlIGJ5IEpTT05Db3VudGVyLlxuICAgICAqL1xuICAgIGlzTnVtZXJpY1R5cGUoKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLnZhbHVlVHlwZTtcbiAgICAgICAgcmV0dXJuIHQgPT09IENvdW50ZXJUeXBlLkludGVnZXJDbnQgfHwgdCA9PT0gQ291bnRlclR5cGUuTG9uZ0NudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldFZhbHVlVHlwZWAgZ2V0IGNvdW50ZXIgdmFsdWUgdHlwZS5cbiAgICAgKi9cbiAgICBnZXRWYWx1ZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldFZhbHVlYCBnZXQgY291bnRlciB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0b0J5dGVzYCBjcmVhdGVzIGFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgdmFsdWUuXG4gICAgICovXG4gICAgdG9CeXRlcygpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnZhbHVlVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBDb3VudGVyVHlwZS5JbnRlZ2VyQ250OiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW50VmFsID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgICAgICAgICBpbnRWYWwgJiAweGZmLFxuICAgICAgICAgICAgICAgICAgICAoaW50VmFsID4+IDgpICYgMHhmZixcbiAgICAgICAgICAgICAgICAgICAgKGludFZhbCA+PiAxNikgJiAweGZmLFxuICAgICAgICAgICAgICAgICAgICAoaW50VmFsID4+IDI0KSAmIDB4ZmYsXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIENvdW50ZXJUeXBlLkxvbmdDbnQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb25nVmFsID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb25nVG9CeXRlcyA9IGxvbmdWYWwudG9CeXRlc0xFKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShsb25nVG9CeXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBZb3JraWVFcnJvcihlcnJvcl9Db2RlLlVuaW1wbGVtZW50ZWQsIGB1bmltcGxlbWVudGVkIHR5cGU6ICR7dGhpcy52YWx1ZVR5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogYGluY3JlYXNlYCBpbmNyZWFzZXMgbnVtZXJpYyBkYXRhLlxuICAgICAqL1xuICAgIGluY3JlYXNlKHYpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGBjaGVja051bWVyaWNUeXBlYCBjaGVja3MgaWYgdGhlIGdpdmVuIHRhcmdldCBpcyBhIG51bWVyaWMgdHlwZS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrTnVtZXJpY1R5cGUodGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAoIXRhcmdldC5pc051bWVyaWNUeXBlKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0eXBlIG9mIHZhbHVlOiAke3R5cGVvZiB0YXJnZXQuZ2V0VmFsdWUoKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGVja051bWVyaWNUeXBlKHRoaXMpO1xuICAgICAgICBjaGVja051bWVyaWNUeXBlKHYpO1xuICAgICAgICBpZiAodGhpcy52YWx1ZVR5cGUgPT09IENvdW50ZXJUeXBlLkxvbmdDbnQpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlLmFkZCh2LmdldFZhbHVlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHYuZ2V0VHlwZSgpID09PSBQcmltaXRpdmVUeXBlLkxvbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZSArIHYuZ2V0VmFsdWUoKS50b0ludCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG5vZGVfbW9kdWxlc19sb25nLmZyb21OdW1iZXIodGhpcy52YWx1ZSArIHJlbW92ZURlY2ltYWwodi5nZXRWYWx1ZSgpKSkudG9JbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kb2N1bWVudC9vcGVyYXRpb24vaW5jcmVhc2Vfb3BlcmF0aW9uLnRzXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgVGhlIFlvcmtpZSBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5cblxuXG4vKipcbiAqIGBJbmNyZWFzZU9wZXJhdGlvbmAgcmVwcmVzZW50cyBhbiBvcGVyYXRpb24gdGhhdCBpbmNyZW1lbnRzIGEgbnVtZXJpYyB2YWx1ZSB0byBDb3VudGVyLlxuICogQW1vbmcgUHJpbWl0aXZlcywgbnVtZXJpYyB0eXBlcyBJbnRlZ2VyLCBMb25nIGFyZSB1c2VkIGFzIHZhbHVlcy5cbiAqL1xuY2xhc3MgSW5jcmVhc2VPcGVyYXRpb24gZXh0ZW5kcyBPcGVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudENyZWF0ZWRBdCwgdmFsdWUsIGV4ZWN1dGVkQXQpIHtcbiAgICAgICAgc3VwZXIocGFyZW50Q3JlYXRlZEF0LCBleGVjdXRlZEF0KTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgY3JlYXRlYCBjcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIEluY3JlYXNlT3BlcmF0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUocGFyZW50Q3JlYXRlZEF0LCB2YWx1ZSwgZXhlY3V0ZWRBdCkge1xuICAgICAgICByZXR1cm4gbmV3IEluY3JlYXNlT3BlcmF0aW9uKHBhcmVudENyZWF0ZWRBdCwgdmFsdWUsIGV4ZWN1dGVkQXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZXhlY3V0ZWAgZXhlY3V0ZXMgdGhpcyBvcGVyYXRpb24gb24gdGhlIGdpdmVuIGBDUkRUUm9vdGAuXG4gICAgICovXG4gICAgZXhlY3V0ZShyb290KSB7XG4gICAgICAgIGNvbnN0IHBhcmVudE9iamVjdCA9IHJvb3QuZmluZEJ5Q3JlYXRlZEF0KHRoaXMuZ2V0UGFyZW50Q3JlYXRlZEF0KCkpO1xuICAgICAgICBpZiAoIXBhcmVudE9iamVjdCkge1xuICAgICAgICAgICAgbG9nZ2VyLmZhdGFsKGBmYWlsIHRvIGZpbmQgJHt0aGlzLmdldFBhcmVudENyZWF0ZWRBdCgpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHBhcmVudE9iamVjdCBpbnN0YW5jZW9mIENSRFRDb3VudGVyKSkge1xuICAgICAgICAgICAgbG9nZ2VyLmZhdGFsKGBmYWlsIHRvIGV4ZWN1dGUsIG9ubHkgQ291bnRlciBjYW4gZXhlY3V0ZSBpbmNyZWFzZWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBwYXJlbnRPYmplY3Q7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZS5kZWVwY29weSgpO1xuICAgICAgICBjb3VudGVyLmluY3JlYXNlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wSW5mb3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbmNyZWFzZScsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IHJvb3QuY3JlYXRlUGF0aCh0aGlzLmdldFBhcmVudENyZWF0ZWRBdCgpKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLmdldFZhbHVlKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICByZXZlcnNlT3A6IHRoaXMudG9SZXZlcnNlT3BlcmF0aW9uKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0b1JldmVyc2VPcGVyYXRpb25gIHJldHVybnMgdGhlIHJldmVyc2Ugb3BlcmF0aW9uIG9mIHRoaXMgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIHRvUmV2ZXJzZU9wZXJhdGlvbigpIHtcbiAgICAgICAgY29uc3QgcHJpbWl0aXZlVmFsdWUgPSB0aGlzLnZhbHVlLmRlZXBjb3B5KCk7XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHByaW1pdGl2ZVZhbHVlLmdldFR5cGUoKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZVR5cGUgPT09IFByaW1pdGl2ZVR5cGUuTG9uZ1xuICAgICAgICAgICAgPyBwcmltaXRpdmVWYWx1ZS5nZXRWYWx1ZSgpLm11bHRpcGx5KC0xKVxuICAgICAgICAgICAgOiBwcmltaXRpdmVWYWx1ZS5nZXRWYWx1ZSgpICogLTE7XG4gICAgICAgIGNvbnN0IHJldmVyc2VPcCA9IEluY3JlYXNlT3BlcmF0aW9uLmNyZWF0ZSh0aGlzLmdldFBhcmVudENyZWF0ZWRBdCgpLCBQcmltaXRpdmUub2YodmFsdWUsIHByaW1pdGl2ZVZhbHVlLmdldENyZWF0ZWRBdCgpKSk7XG4gICAgICAgIHJldHVybiByZXZlcnNlT3A7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRFZmZlY3RlZENyZWF0ZWRBdGAgcmV0dXJucyB0aGUgY3JlYXRpb24gdGltZSBvZiB0aGUgZWZmZWN0ZWQgZWxlbWVudC5cbiAgICAgKi9cbiAgICBnZXRFZmZlY3RlZENyZWF0ZWRBdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFyZW50Q3JlYXRlZEF0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0b1Rlc3RTdHJpbmdgIHJldHVybnMgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgbWV0YSBkYXRhLlxuICAgICAqL1xuICAgIHRvVGVzdFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0UGFyZW50Q3JlYXRlZEF0KCkudG9UZXN0U3RyaW5nKCl9LklOQ1JFQVNFLiR7dGhpcy52YWx1ZS50b0pTT04oKX1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0VmFsdWVgIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoaXMgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kb2N1bWVudC9vcGVyYXRpb24vdHJlZV9zdHlsZV9vcGVyYXRpb24udHNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMyBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuXG4vKipcbiAqIGBUcmVlU3R5bGVPcGVyYXRpb25gIHJlcHJlc2VudHMgYW4gb3BlcmF0aW9uIHRoYXQgbW9kaWZpZXMgdGhlIHN0eWxlIG9mIHRoZVxuICogbm9kZSBpbiB0aGUgVHJlZS5cbiAqL1xuY2xhc3MgVHJlZVN0eWxlT3BlcmF0aW9uIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRDcmVhdGVkQXQsIGZyb21Qb3MsIHRvUG9zLCBhdHRyaWJ1dGVzLCBleGVjdXRlZEF0KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudENyZWF0ZWRBdCwgZXhlY3V0ZWRBdCk7XG4gICAgICAgIHRoaXMuZnJvbVBvcyA9IGZyb21Qb3M7XG4gICAgICAgIHRoaXMudG9Qb3MgPSB0b1BvcztcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGNyZWF0ZWAgY3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBUcmVlU3R5bGVPcGVyYXRpb24uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShwYXJlbnRDcmVhdGVkQXQsIGZyb21Qb3MsIHRvUG9zLCBhdHRyaWJ1dGVzLCBleGVjdXRlZEF0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZVN0eWxlT3BlcmF0aW9uKHBhcmVudENyZWF0ZWRBdCwgZnJvbVBvcywgdG9Qb3MsIGF0dHJpYnV0ZXMsIGV4ZWN1dGVkQXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZXhlY3V0ZWAgZXhlY3V0ZXMgdGhpcyBvcGVyYXRpb24gb24gdGhlIGdpdmVuIGBDUkRUUm9vdGAuXG4gICAgICovXG4gICAgZXhlY3V0ZShyb290KSB7XG4gICAgICAgIGNvbnN0IHBhcmVudE9iamVjdCA9IHJvb3QuZmluZEJ5Q3JlYXRlZEF0KHRoaXMuZ2V0UGFyZW50Q3JlYXRlZEF0KCkpO1xuICAgICAgICBpZiAoIXBhcmVudE9iamVjdCkge1xuICAgICAgICAgICAgbG9nZ2VyLmZhdGFsKGBmYWlsIHRvIGZpbmQgJHt0aGlzLmdldFBhcmVudENyZWF0ZWRBdCgpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHBhcmVudE9iamVjdCBpbnN0YW5jZW9mIENSRFRUcmVlKSkge1xuICAgICAgICAgICAgbG9nZ2VyLmZhdGFsKGBmYWlsIHRvIGV4ZWN1dGUsIG9ubHkgVHJlZSBjYW4gZXhlY3V0ZSBlZGl0YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICBbLi4udGhpcy5hdHRyaWJ1dGVzXS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IChhdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZSkpO1xuICAgICAgICBjb25zdCB0cmVlID0gcGFyZW50T2JqZWN0O1xuICAgICAgICBjb25zdCBjaGFuZ2VzID0gdHJlZS5zdHlsZShbdGhpcy5mcm9tUG9zLCB0aGlzLnRvUG9zXSwgYXR0cmlidXRlcywgdGhpcy5nZXRFeGVjdXRlZEF0KCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3BJbmZvczogY2hhbmdlcy5tYXAoKHsgZnJvbSwgdG8sIHZhbHVlLCBmcm9tUGF0aCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RyZWUtc3R5bGUnLFxuICAgICAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGZyb21QYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiByb290LmNyZWF0ZVBhdGgodGhpcy5nZXRQYXJlbnRDcmVhdGVkQXQoKSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0RWZmZWN0ZWRDcmVhdGVkQXRgIHJldHVybnMgdGhlIGNyZWF0aW9uIHRpbWUgb2YgdGhlIGVmZmVjdGVkIGVsZW1lbnQuXG4gICAgICovXG4gICAgZ2V0RWZmZWN0ZWRDcmVhdGVkQXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhcmVudENyZWF0ZWRBdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdG9UZXN0U3RyaW5nYCByZXR1cm5zIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1ldGEgZGF0YS5cbiAgICAgKi9cbiAgICB0b1Rlc3RTdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50Q3JlYXRlZEF0KCkudG9UZXN0U3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGZyb21Qb3MgPSBgJHt0aGlzLmZyb21Qb3NcbiAgICAgICAgICAgIC5nZXRMZWZ0U2libGluZ0lEKClcbiAgICAgICAgICAgIC5nZXRDcmVhdGVkQXQoKVxuICAgICAgICAgICAgLnRvVGVzdFN0cmluZygpfToke3RoaXMuZnJvbVBvcy5nZXRMZWZ0U2libGluZ0lEKCkuZ2V0T2Zmc2V0KCl9YDtcbiAgICAgICAgY29uc3QgdG9Qb3MgPSBgJHt0aGlzLnRvUG9zXG4gICAgICAgICAgICAuZ2V0TGVmdFNpYmxpbmdJRCgpXG4gICAgICAgICAgICAuZ2V0Q3JlYXRlZEF0KClcbiAgICAgICAgICAgIC50b1Rlc3RTdHJpbmcoKX06JHt0aGlzLnRvUG9zLmdldExlZnRTaWJsaW5nSUQoKS5nZXRPZmZzZXQoKX1gO1xuICAgICAgICByZXR1cm4gYCR7cGFyZW50fS5TVFlMRSgke2Zyb21Qb3N9LCR7dG9Qb3N9LCR7T2JqZWN0LmVudHJpZXModGhpcy5hdHRyaWJ1dGVzIHx8IHt9KVxuICAgICAgICAgICAgLm1hcCgoW2ssIHZdKSA9PiBgJHtrfTpcIiR7dn1cImApXG4gICAgICAgICAgICAuam9pbignICcpfSlgO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0RnJvbVBvc2AgcmV0dXJucyB0aGUgc3RhcnQgcG9pbnQgb2YgdGhlIGVkaXRpbmcgcmFuZ2UuXG4gICAgICovXG4gICAgZ2V0RnJvbVBvcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVBvcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldFRvUG9zYCByZXR1cm5zIHRoZSBlbmQgcG9pbnQgb2YgdGhlIGVkaXRpbmcgcmFuZ2UuXG4gICAgICovXG4gICAgZ2V0VG9Qb3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvUG9zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0QXR0cmlidXRlc2AgcmV0dXJucyB0aGUgYXR0cmlidXRlcyBvZiBTdHlsZS5cbiAgICAgKi9cbiAgICBnZXRBdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzO1xuICAgIH1cbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2FwaS9jb252ZXJ0ZXIudHNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMyBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vKipcbiAqIGB0b1ByZXNlbmNlYCBjb252ZXJ0cyB0aGUgZ2l2ZW4gbW9kZWwgdG8gUHJvdG9idWYgZm9ybWF0LlxuICovXG5mdW5jdGlvbiB0b1ByZXNlbmNlKHByZXNlbmNlKSB7XG4gICAgY29uc3QgcGJQcmVzZW5jZSA9IG5ldyByZXNvdXJjZXNfcGIuUHJlc2VuY2UoKTtcbiAgICBjb25zdCBwYkRhdGFNYXAgPSBwYlByZXNlbmNlLmRhdGE7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJlc2VuY2UpKSB7XG4gICAgICAgIHBiRGF0YU1hcFtrZXldID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcGJQcmVzZW5jZTtcbn1cbi8qKlxuICogYHRvUHJlc2VuY2VDaGFuZ2VgIGNvbnZlcnRzIHRoZSBnaXZlbiBtb2RlbCB0byBQcm90b2J1ZiBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIHRvUHJlc2VuY2VDaGFuZ2UocHJlc2VuY2VDaGFuZ2UpIHtcbiAgICBpZiAocHJlc2VuY2VDaGFuZ2UudHlwZSA9PT0gUHJlc2VuY2VDaGFuZ2VUeXBlLlB1dCkge1xuICAgICAgICByZXR1cm4gbmV3IHJlc291cmNlc19wYi5QcmVzZW5jZUNoYW5nZSh7XG4gICAgICAgICAgICB0eXBlOiByZXNvdXJjZXNfcGIuUHJlc2VuY2VDaGFuZ2VfQ2hhbmdlVHlwZS5QVVQsXG4gICAgICAgICAgICBwcmVzZW5jZTogdG9QcmVzZW5jZShwcmVzZW5jZUNoYW5nZS5wcmVzZW5jZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocHJlc2VuY2VDaGFuZ2UudHlwZSA9PT0gUHJlc2VuY2VDaGFuZ2VUeXBlLkNsZWFyKSB7XG4gICAgICAgIHJldHVybiBuZXcgcmVzb3VyY2VzX3BiLlByZXNlbmNlQ2hhbmdlKHtcbiAgICAgICAgICAgIHR5cGU6IHJlc291cmNlc19wYi5QcmVzZW5jZUNoYW5nZV9DaGFuZ2VUeXBlLkNMRUFSLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFlvcmtpZUVycm9yKGVycm9yX0NvZGUuVW5pbXBsZW1lbnRlZCwgYHVuaW1wbGVtZW50ZWQgdHlwZWApO1xufVxuLyoqXG4gKiBgdG9DaGVja3BvaW50YCBjb252ZXJ0cyB0aGUgZ2l2ZW4gbW9kZWwgdG8gUHJvdG9idWYgZm9ybWF0LlxuICovXG5mdW5jdGlvbiB0b0NoZWNrcG9pbnQoY2hlY2twb2ludCkge1xuICAgIHJldHVybiBuZXcgcmVzb3VyY2VzX3BiLkNoZWNrcG9pbnQoe1xuICAgICAgICBzZXJ2ZXJTZXE6IGNoZWNrcG9pbnQuZ2V0U2VydmVyU2VxQXNTdHJpbmcoKSxcbiAgICAgICAgY2xpZW50U2VxOiBjaGVja3BvaW50LmdldENsaWVudFNlcSgpLFxuICAgIH0pO1xufVxuLyoqXG4gKiBgdG9DaGFuZ2VJRGAgY29udmVydHMgdGhlIGdpdmVuIG1vZGVsIHRvIFByb3RvYnVmIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gdG9DaGFuZ2VJRChjaGFuZ2VJRCkge1xuICAgIHJldHVybiBuZXcgcmVzb3VyY2VzX3BiLkNoYW5nZUlEKHtcbiAgICAgICAgY2xpZW50U2VxOiBjaGFuZ2VJRC5nZXRDbGllbnRTZXEoKSxcbiAgICAgICAgbGFtcG9ydDogY2hhbmdlSUQuZ2V0TGFtcG9ydEFzU3RyaW5nKCksXG4gICAgICAgIGFjdG9ySWQ6IHRvVWludDhBcnJheShjaGFuZ2VJRC5nZXRBY3RvcklEKCkpLFxuICAgIH0pO1xufVxuLyoqXG4gKiBgdG9UaW1lVGlja2V0YCBjb252ZXJ0cyB0aGUgZ2l2ZW4gbW9kZWwgdG8gUHJvdG9idWYgZm9ybWF0LlxuICovXG5mdW5jdGlvbiB0b1RpbWVUaWNrZXQodGlja2V0KSB7XG4gICAgaWYgKCF0aWNrZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHJlc291cmNlc19wYi5UaW1lVGlja2V0KHtcbiAgICAgICAgbGFtcG9ydDogdGlja2V0LmdldExhbXBvcnRBc1N0cmluZygpLFxuICAgICAgICBkZWxpbWl0ZXI6IHRpY2tldC5nZXREZWxpbWl0ZXIoKSxcbiAgICAgICAgYWN0b3JJZDogdG9VaW50OEFycmF5KHRpY2tldC5nZXRBY3RvcklEKCkpLFxuICAgIH0pO1xufVxuLyoqXG4gKiBgdG9WYWx1ZVR5cGVgIGNvbnZlcnRzIHRoZSBnaXZlbiBtb2RlbCB0byBQcm90b2J1ZiBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIHRvVmFsdWVUeXBlKHZhbHVlVHlwZSkge1xuICAgIHN3aXRjaCAodmFsdWVUeXBlKSB7XG4gICAgICAgIGNhc2UgUHJpbWl0aXZlVHlwZS5OdWxsOlxuICAgICAgICAgICAgcmV0dXJuIHJlc291cmNlc19wYi5WYWx1ZVR5cGUuTlVMTDtcbiAgICAgICAgY2FzZSBQcmltaXRpdmVUeXBlLkJvb2xlYW46XG4gICAgICAgICAgICByZXR1cm4gcmVzb3VyY2VzX3BiLlZhbHVlVHlwZS5CT09MRUFOO1xuICAgICAgICBjYXNlIFByaW1pdGl2ZVR5cGUuSW50ZWdlcjpcbiAgICAgICAgICAgIHJldHVybiByZXNvdXJjZXNfcGIuVmFsdWVUeXBlLklOVEVHRVI7XG4gICAgICAgIGNhc2UgUHJpbWl0aXZlVHlwZS5Mb25nOlxuICAgICAgICAgICAgcmV0dXJuIHJlc291cmNlc19wYi5WYWx1ZVR5cGUuTE9ORztcbiAgICAgICAgY2FzZSBQcmltaXRpdmVUeXBlLkRvdWJsZTpcbiAgICAgICAgICAgIHJldHVybiByZXNvdXJjZXNfcGIuVmFsdWVUeXBlLkRPVUJMRTtcbiAgICAgICAgY2FzZSBQcmltaXRpdmVUeXBlLlN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiByZXNvdXJjZXNfcGIuVmFsdWVUeXBlLlNUUklORztcbiAgICAgICAgY2FzZSBQcmltaXRpdmVUeXBlLkJ5dGVzOlxuICAgICAgICAgICAgcmV0dXJuIHJlc291cmNlc19wYi5WYWx1ZVR5cGUuQllURVM7XG4gICAgICAgIGNhc2UgUHJpbWl0aXZlVHlwZS5EYXRlOlxuICAgICAgICAgICAgcmV0dXJuIHJlc291cmNlc19wYi5WYWx1ZVR5cGUuREFURTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBZb3JraWVFcnJvcihlcnJvcl9Db2RlLlVuc3VwcG9ydGVkLCBgdW5zdXBwb3J0ZWQgdHlwZTogJHt2YWx1ZVR5cGV9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBgdG9Db3VudGVyVHlwZWAgY29udmVydHMgdGhlIGdpdmVuIG1vZGVsIHRvIFByb3RvYnVmIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gdG9Db3VudGVyVHlwZSh2YWx1ZVR5cGUpIHtcbiAgICBzd2l0Y2ggKHZhbHVlVHlwZSkge1xuICAgICAgICBjYXNlIENvdW50ZXJUeXBlLkludGVnZXJDbnQ6XG4gICAgICAgICAgICByZXR1cm4gcmVzb3VyY2VzX3BiLlZhbHVlVHlwZS5JTlRFR0VSX0NOVDtcbiAgICAgICAgY2FzZSBDb3VudGVyVHlwZS5Mb25nQ250OlxuICAgICAgICAgICAgcmV0dXJuIHJlc291cmNlc19wYi5WYWx1ZVR5cGUuTE9OR19DTlQ7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgWW9ya2llRXJyb3IoZXJyb3JfQ29kZS5VbnN1cHBvcnRlZCwgYHVuc3VwcG9ydGVkIHR5cGU6ICR7dmFsdWVUeXBlfWApO1xuICAgIH1cbn1cbi8qKlxuICogYHRvRWxlbWVudFNpbXBsZWAgY29udmVydHMgdGhlIGdpdmVuIG1vZGVsIHRvIFByb3RvYnVmIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gdG9FbGVtZW50U2ltcGxlKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIENSRFRPYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByZXNvdXJjZXNfcGIuSlNPTkVsZW1lbnRTaW1wbGUoe1xuICAgICAgICAgICAgdHlwZTogcmVzb3VyY2VzX3BiLlZhbHVlVHlwZS5KU09OX09CSkVDVCxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogdG9UaW1lVGlja2V0KGVsZW1lbnQuZ2V0Q3JlYXRlZEF0KCkpLFxuICAgICAgICAgICAgdmFsdWU6IG9iamVjdFRvQnl0ZXMoZWxlbWVudCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIENSRFRBcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IHJlc291cmNlc19wYi5KU09ORWxlbWVudFNpbXBsZSh7XG4gICAgICAgICAgICB0eXBlOiByZXNvdXJjZXNfcGIuVmFsdWVUeXBlLkpTT05fQVJSQVksXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IHRvVGltZVRpY2tldChlbGVtZW50LmdldENyZWF0ZWRBdCgpKSxcbiAgICAgICAgICAgIHZhbHVlOiBhcnJheVRvQnl0ZXMoZWxlbWVudCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIENSRFRUZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgcmVzb3VyY2VzX3BiLkpTT05FbGVtZW50U2ltcGxlKHtcbiAgICAgICAgICAgIHR5cGU6IHJlc291cmNlc19wYi5WYWx1ZVR5cGUuVEVYVCxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogdG9UaW1lVGlja2V0KGVsZW1lbnQuZ2V0Q3JlYXRlZEF0KCkpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBQcmltaXRpdmUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByZXNvdXJjZXNfcGIuSlNPTkVsZW1lbnRTaW1wbGUoe1xuICAgICAgICAgICAgdHlwZTogdG9WYWx1ZVR5cGUoZWxlbWVudC5nZXRUeXBlKCkpLFxuICAgICAgICAgICAgY3JlYXRlZEF0OiB0b1RpbWVUaWNrZXQoZWxlbWVudC5nZXRDcmVhdGVkQXQoKSksXG4gICAgICAgICAgICB2YWx1ZTogZWxlbWVudC50b0J5dGVzKCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIENSRFRDb3VudGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgcmVzb3VyY2VzX3BiLkpTT05FbGVtZW50U2ltcGxlKHtcbiAgICAgICAgICAgIHR5cGU6IHRvQ291bnRlclR5cGUoZWxlbWVudC5nZXRUeXBlKCkpLFxuICAgICAgICAgICAgY3JlYXRlZEF0OiB0b1RpbWVUaWNrZXQoZWxlbWVudC5nZXRDcmVhdGVkQXQoKSksXG4gICAgICAgICAgICB2YWx1ZTogZWxlbWVudC50b0J5dGVzKCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIENSRFRUcmVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgcmVzb3VyY2VzX3BiLkpTT05FbGVtZW50U2ltcGxlKHtcbiAgICAgICAgICAgIHR5cGU6IHJlc291cmNlc19wYi5WYWx1ZVR5cGUuVFJFRSxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogdG9UaW1lVGlja2V0KGVsZW1lbnQuZ2V0Q3JlYXRlZEF0KCkpLFxuICAgICAgICAgICAgdmFsdWU6IHRyZWVUb0J5dGVzKGVsZW1lbnQpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFlvcmtpZUVycm9yKGVycm9yX0NvZGUuVW5pbXBsZW1lbnRlZCwgYHVuaW1wbGVtZW50ZWQgZWxlbWVudGApO1xufVxuLyoqXG4gKiBgdG9UZXh0Tm9kZUlEYCBjb252ZXJ0cyB0aGUgZ2l2ZW4gbW9kZWwgdG8gUHJvdG9idWYgZm9ybWF0LlxuICovXG5mdW5jdGlvbiB0b1RleHROb2RlSUQoaWQpIHtcbiAgICByZXR1cm4gbmV3IHJlc291cmNlc19wYi5UZXh0Tm9kZUlEKHtcbiAgICAgICAgY3JlYXRlZEF0OiB0b1RpbWVUaWNrZXQoaWQuZ2V0Q3JlYXRlZEF0KCkpLFxuICAgICAgICBvZmZzZXQ6IGlkLmdldE9mZnNldCgpLFxuICAgIH0pO1xufVxuLyoqXG4gKiBgdG9UZXh0Tm9kZVBvc2AgY29udmVydHMgdGhlIGdpdmVuIG1vZGVsIHRvIFByb3RvYnVmIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gdG9UZXh0Tm9kZVBvcyhwb3MpIHtcbiAgICByZXR1cm4gbmV3IHJlc291cmNlc19wYi5UZXh0Tm9kZVBvcyh7XG4gICAgICAgIGNyZWF0ZWRBdDogdG9UaW1lVGlja2V0KHBvcy5nZXRJRCgpLmdldENyZWF0ZWRBdCgpKSxcbiAgICAgICAgb2Zmc2V0OiBwb3MuZ2V0SUQoKS5nZXRPZmZzZXQoKSxcbiAgICAgICAgcmVsYXRpdmVPZmZzZXQ6IHBvcy5nZXRSZWxhdGl2ZU9mZnNldCgpLFxuICAgIH0pO1xufVxuLyoqXG4gKiBgdG9UcmVlUG9zYCBjb252ZXJ0cyB0aGUgZ2l2ZW4gbW9kZWwgdG8gUHJvdG9idWYgZm9ybWF0LlxuICovXG5mdW5jdGlvbiB0b1RyZWVQb3MocG9zKSB7XG4gICAgcmV0dXJuIG5ldyByZXNvdXJjZXNfcGIuVHJlZVBvcyh7XG4gICAgICAgIHBhcmVudElkOiB0b1RyZWVOb2RlSUQocG9zLmdldFBhcmVudElEKCkpLFxuICAgICAgICBsZWZ0U2libGluZ0lkOiB0b1RyZWVOb2RlSUQocG9zLmdldExlZnRTaWJsaW5nSUQoKSksXG4gICAgfSk7XG59XG4vKipcbiAqIGB0b1RyZWVOb2RlSURgIGNvbnZlcnRzIHRoZSBnaXZlbiBtb2RlbCB0byBQcm90b2J1ZiBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIHRvVHJlZU5vZGVJRCh0cmVlTm9kZUlEKSB7XG4gICAgcmV0dXJuIG5ldyByZXNvdXJjZXNfcGIuVHJlZU5vZGVJRCh7XG4gICAgICAgIGNyZWF0ZWRBdDogdG9UaW1lVGlja2V0KHRyZWVOb2RlSUQuZ2V0Q3JlYXRlZEF0KCkpLFxuICAgICAgICBvZmZzZXQ6IHRyZWVOb2RlSUQuZ2V0T2Zmc2V0KCksXG4gICAgfSk7XG59XG4vKipcbiAqIGB0b09wZXJhdGlvbmAgY29udmVydHMgdGhlIGdpdmVuIG1vZGVsIHRvIFByb3RvYnVmIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gdG9PcGVyYXRpb24ob3BlcmF0aW9uKSB7XG4gICAgY29uc3QgcGJPcGVyYXRpb24gPSBuZXcgcmVzb3VyY2VzX3BiLk9wZXJhdGlvbigpO1xuICAgIGlmIChvcGVyYXRpb24gaW5zdGFuY2VvZiBTZXRPcGVyYXRpb24pIHtcbiAgICAgICAgY29uc3Qgc2V0T3BlcmF0aW9uID0gb3BlcmF0aW9uO1xuICAgICAgICBjb25zdCBwYlNldE9wZXJhdGlvbiA9IG5ldyByZXNvdXJjZXNfcGIuT3BlcmF0aW9uX1NldCgpO1xuICAgICAgICBwYlNldE9wZXJhdGlvbi5wYXJlbnRDcmVhdGVkQXQgPSB0b1RpbWVUaWNrZXQoc2V0T3BlcmF0aW9uLmdldFBhcmVudENyZWF0ZWRBdCgpKTtcbiAgICAgICAgcGJTZXRPcGVyYXRpb24ua2V5ID0gc2V0T3BlcmF0aW9uLmdldEtleSgpO1xuICAgICAgICBwYlNldE9wZXJhdGlvbi52YWx1ZSA9IHRvRWxlbWVudFNpbXBsZShzZXRPcGVyYXRpb24uZ2V0VmFsdWUoKSk7XG4gICAgICAgIHBiU2V0T3BlcmF0aW9uLmV4ZWN1dGVkQXQgPSB0b1RpbWVUaWNrZXQoc2V0T3BlcmF0aW9uLmdldEV4ZWN1dGVkQXQoKSk7XG4gICAgICAgIHBiT3BlcmF0aW9uLmJvZHkuY2FzZSA9ICdzZXQnO1xuICAgICAgICBwYk9wZXJhdGlvbi5ib2R5LnZhbHVlID0gcGJTZXRPcGVyYXRpb247XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wZXJhdGlvbiBpbnN0YW5jZW9mIEFkZE9wZXJhdGlvbikge1xuICAgICAgICBjb25zdCBhZGRPcGVyYXRpb24gPSBvcGVyYXRpb247XG4gICAgICAgIGNvbnN0IHBiQWRkT3BlcmF0aW9uID0gbmV3IHJlc291cmNlc19wYi5PcGVyYXRpb25fQWRkKCk7XG4gICAgICAgIHBiQWRkT3BlcmF0aW9uLnBhcmVudENyZWF0ZWRBdCA9IHRvVGltZVRpY2tldChhZGRPcGVyYXRpb24uZ2V0UGFyZW50Q3JlYXRlZEF0KCkpO1xuICAgICAgICBwYkFkZE9wZXJhdGlvbi5wcmV2Q3JlYXRlZEF0ID0gdG9UaW1lVGlja2V0KGFkZE9wZXJhdGlvbi5nZXRQcmV2Q3JlYXRlZEF0KCkpO1xuICAgICAgICBwYkFkZE9wZXJhdGlvbi52YWx1ZSA9IHRvRWxlbWVudFNpbXBsZShhZGRPcGVyYXRpb24uZ2V0VmFsdWUoKSk7XG4gICAgICAgIHBiQWRkT3BlcmF0aW9uLmV4ZWN1dGVkQXQgPSB0b1RpbWVUaWNrZXQoYWRkT3BlcmF0aW9uLmdldEV4ZWN1dGVkQXQoKSk7XG4gICAgICAgIHBiT3BlcmF0aW9uLmJvZHkuY2FzZSA9ICdhZGQnO1xuICAgICAgICBwYk9wZXJhdGlvbi5ib2R5LnZhbHVlID0gcGJBZGRPcGVyYXRpb247XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wZXJhdGlvbiBpbnN0YW5jZW9mIE1vdmVPcGVyYXRpb24pIHtcbiAgICAgICAgY29uc3QgbW92ZU9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcbiAgICAgICAgY29uc3QgcGJNb3ZlT3BlcmF0aW9uID0gbmV3IHJlc291cmNlc19wYi5PcGVyYXRpb25fTW92ZSgpO1xuICAgICAgICBwYk1vdmVPcGVyYXRpb24ucGFyZW50Q3JlYXRlZEF0ID0gdG9UaW1lVGlja2V0KG1vdmVPcGVyYXRpb24uZ2V0UGFyZW50Q3JlYXRlZEF0KCkpO1xuICAgICAgICBwYk1vdmVPcGVyYXRpb24ucHJldkNyZWF0ZWRBdCA9IHRvVGltZVRpY2tldChtb3ZlT3BlcmF0aW9uLmdldFByZXZDcmVhdGVkQXQoKSk7XG4gICAgICAgIHBiTW92ZU9wZXJhdGlvbi5jcmVhdGVkQXQgPSB0b1RpbWVUaWNrZXQobW92ZU9wZXJhdGlvbi5nZXRDcmVhdGVkQXQoKSk7XG4gICAgICAgIHBiTW92ZU9wZXJhdGlvbi5leGVjdXRlZEF0ID0gdG9UaW1lVGlja2V0KG1vdmVPcGVyYXRpb24uZ2V0RXhlY3V0ZWRBdCgpKTtcbiAgICAgICAgcGJPcGVyYXRpb24uYm9keS5jYXNlID0gJ21vdmUnO1xuICAgICAgICBwYk9wZXJhdGlvbi5ib2R5LnZhbHVlID0gcGJNb3ZlT3BlcmF0aW9uO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcGVyYXRpb24gaW5zdGFuY2VvZiBSZW1vdmVPcGVyYXRpb24pIHtcbiAgICAgICAgY29uc3QgcmVtb3ZlT3BlcmF0aW9uID0gb3BlcmF0aW9uO1xuICAgICAgICBjb25zdCBwYlJlbW92ZU9wZXJhdGlvbiA9IG5ldyByZXNvdXJjZXNfcGIuT3BlcmF0aW9uX1JlbW92ZSgpO1xuICAgICAgICBwYlJlbW92ZU9wZXJhdGlvbi5wYXJlbnRDcmVhdGVkQXQgPSB0b1RpbWVUaWNrZXQocmVtb3ZlT3BlcmF0aW9uLmdldFBhcmVudENyZWF0ZWRBdCgpKTtcbiAgICAgICAgcGJSZW1vdmVPcGVyYXRpb24uY3JlYXRlZEF0ID0gdG9UaW1lVGlja2V0KHJlbW92ZU9wZXJhdGlvbi5nZXRDcmVhdGVkQXQoKSk7XG4gICAgICAgIHBiUmVtb3ZlT3BlcmF0aW9uLmV4ZWN1dGVkQXQgPSB0b1RpbWVUaWNrZXQocmVtb3ZlT3BlcmF0aW9uLmdldEV4ZWN1dGVkQXQoKSk7XG4gICAgICAgIHBiT3BlcmF0aW9uLmJvZHkuY2FzZSA9ICdyZW1vdmUnO1xuICAgICAgICBwYk9wZXJhdGlvbi5ib2R5LnZhbHVlID0gcGJSZW1vdmVPcGVyYXRpb247XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wZXJhdGlvbiBpbnN0YW5jZW9mIEVkaXRPcGVyYXRpb24pIHtcbiAgICAgICAgY29uc3QgZWRpdE9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcbiAgICAgICAgY29uc3QgcGJFZGl0T3BlcmF0aW9uID0gbmV3IHJlc291cmNlc19wYi5PcGVyYXRpb25fRWRpdCgpO1xuICAgICAgICBwYkVkaXRPcGVyYXRpb24ucGFyZW50Q3JlYXRlZEF0ID0gdG9UaW1lVGlja2V0KGVkaXRPcGVyYXRpb24uZ2V0UGFyZW50Q3JlYXRlZEF0KCkpO1xuICAgICAgICBwYkVkaXRPcGVyYXRpb24uZnJvbSA9IHRvVGV4dE5vZGVQb3MoZWRpdE9wZXJhdGlvbi5nZXRGcm9tUG9zKCkpO1xuICAgICAgICBwYkVkaXRPcGVyYXRpb24udG8gPSB0b1RleHROb2RlUG9zKGVkaXRPcGVyYXRpb24uZ2V0VG9Qb3MoKSk7XG4gICAgICAgIGNvbnN0IHBiQ3JlYXRlZEF0TWFwQnlBY3RvciA9IHBiRWRpdE9wZXJhdGlvbi5jcmVhdGVkQXRNYXBCeUFjdG9yO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlZGl0T3BlcmF0aW9uLmdldE1heENyZWF0ZWRBdE1hcEJ5QWN0b3IoKSkge1xuICAgICAgICAgICAgcGJDcmVhdGVkQXRNYXBCeUFjdG9yW2tleV0gPSB0b1RpbWVUaWNrZXQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHBiRWRpdE9wZXJhdGlvbi5jb250ZW50ID0gZWRpdE9wZXJhdGlvbi5nZXRDb250ZW50KCk7XG4gICAgICAgIGNvbnN0IHBiQXR0cmlidXRlcyA9IHBiRWRpdE9wZXJhdGlvbi5hdHRyaWJ1dGVzO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlZGl0T3BlcmF0aW9uLmdldEF0dHJpYnV0ZXMoKSkge1xuICAgICAgICAgICAgcGJBdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBwYkVkaXRPcGVyYXRpb24uZXhlY3V0ZWRBdCA9IHRvVGltZVRpY2tldChlZGl0T3BlcmF0aW9uLmdldEV4ZWN1dGVkQXQoKSk7XG4gICAgICAgIHBiT3BlcmF0aW9uLmJvZHkuY2FzZSA9ICdlZGl0JztcbiAgICAgICAgcGJPcGVyYXRpb24uYm9keS52YWx1ZSA9IHBiRWRpdE9wZXJhdGlvbjtcbiAgICB9XG4gICAgZWxzZSBpZiAob3BlcmF0aW9uIGluc3RhbmNlb2YgU3R5bGVPcGVyYXRpb24pIHtcbiAgICAgICAgY29uc3Qgc3R5bGVPcGVyYXRpb24gPSBvcGVyYXRpb247XG4gICAgICAgIGNvbnN0IHBiU3R5bGVPcGVyYXRpb24gPSBuZXcgcmVzb3VyY2VzX3BiLk9wZXJhdGlvbl9TdHlsZSgpO1xuICAgICAgICBwYlN0eWxlT3BlcmF0aW9uLnBhcmVudENyZWF0ZWRBdCA9IHRvVGltZVRpY2tldChzdHlsZU9wZXJhdGlvbi5nZXRQYXJlbnRDcmVhdGVkQXQoKSk7XG4gICAgICAgIHBiU3R5bGVPcGVyYXRpb24uZnJvbSA9IHRvVGV4dE5vZGVQb3Moc3R5bGVPcGVyYXRpb24uZ2V0RnJvbVBvcygpKTtcbiAgICAgICAgcGJTdHlsZU9wZXJhdGlvbi50byA9IHRvVGV4dE5vZGVQb3Moc3R5bGVPcGVyYXRpb24uZ2V0VG9Qb3MoKSk7XG4gICAgICAgIGNvbnN0IHBiQ3JlYXRlZEF0TWFwQnlBY3RvciA9IHBiU3R5bGVPcGVyYXRpb24uY3JlYXRlZEF0TWFwQnlBY3RvcjtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3R5bGVPcGVyYXRpb24uZ2V0TWF4Q3JlYXRlZEF0TWFwQnlBY3RvcigpKSB7XG4gICAgICAgICAgICBwYkNyZWF0ZWRBdE1hcEJ5QWN0b3Jba2V5XSA9IHRvVGltZVRpY2tldCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGJBdHRyaWJ1dGVzID0gcGJTdHlsZU9wZXJhdGlvbi5hdHRyaWJ1dGVzO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzdHlsZU9wZXJhdGlvbi5nZXRBdHRyaWJ1dGVzKCkpIHtcbiAgICAgICAgICAgIHBiQXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcGJTdHlsZU9wZXJhdGlvbi5leGVjdXRlZEF0ID0gdG9UaW1lVGlja2V0KHN0eWxlT3BlcmF0aW9uLmdldEV4ZWN1dGVkQXQoKSk7XG4gICAgICAgIHBiT3BlcmF0aW9uLmJvZHkuY2FzZSA9ICdzdHlsZSc7XG4gICAgICAgIHBiT3BlcmF0aW9uLmJvZHkudmFsdWUgPSBwYlN0eWxlT3BlcmF0aW9uO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcGVyYXRpb24gaW5zdGFuY2VvZiBJbmNyZWFzZU9wZXJhdGlvbikge1xuICAgICAgICBjb25zdCBpbmNyZWFzZU9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcbiAgICAgICAgY29uc3QgcGJJbmNyZWFzZU9wZXJhdGlvbiA9IG5ldyByZXNvdXJjZXNfcGIuT3BlcmF0aW9uX0luY3JlYXNlKCk7XG4gICAgICAgIHBiSW5jcmVhc2VPcGVyYXRpb24ucGFyZW50Q3JlYXRlZEF0ID0gdG9UaW1lVGlja2V0KGluY3JlYXNlT3BlcmF0aW9uLmdldFBhcmVudENyZWF0ZWRBdCgpKTtcbiAgICAgICAgcGJJbmNyZWFzZU9wZXJhdGlvbi52YWx1ZSA9IHRvRWxlbWVudFNpbXBsZShpbmNyZWFzZU9wZXJhdGlvbi5nZXRWYWx1ZSgpKTtcbiAgICAgICAgcGJJbmNyZWFzZU9wZXJhdGlvbi5leGVjdXRlZEF0ID0gdG9UaW1lVGlja2V0KGluY3JlYXNlT3BlcmF0aW9uLmdldEV4ZWN1dGVkQXQoKSk7XG4gICAgICAgIHBiT3BlcmF0aW9uLmJvZHkuY2FzZSA9ICdpbmNyZWFzZSc7XG4gICAgICAgIHBiT3BlcmF0aW9uLmJvZHkudmFsdWUgPSBwYkluY3JlYXNlT3BlcmF0aW9uO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcGVyYXRpb24gaW5zdGFuY2VvZiBUcmVlRWRpdE9wZXJhdGlvbikge1xuICAgICAgICBjb25zdCB0cmVlRWRpdE9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcbiAgICAgICAgY29uc3QgcGJUcmVlRWRpdE9wZXJhdGlvbiA9IG5ldyByZXNvdXJjZXNfcGIuT3BlcmF0aW9uX1RyZWVFZGl0KCk7XG4gICAgICAgIGNvbnN0IHBiQ3JlYXRlZEF0TWFwQnlBY3RvciA9IHBiVHJlZUVkaXRPcGVyYXRpb24uY3JlYXRlZEF0TWFwQnlBY3RvcjtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdHJlZUVkaXRPcGVyYXRpb24uZ2V0TWF4Q3JlYXRlZEF0TWFwQnlBY3RvcigpKSB7XG4gICAgICAgICAgICBwYkNyZWF0ZWRBdE1hcEJ5QWN0b3Jba2V5XSA9IHRvVGltZVRpY2tldCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGJUcmVlRWRpdE9wZXJhdGlvbi5wYXJlbnRDcmVhdGVkQXQgPSB0b1RpbWVUaWNrZXQodHJlZUVkaXRPcGVyYXRpb24uZ2V0UGFyZW50Q3JlYXRlZEF0KCkpO1xuICAgICAgICBwYlRyZWVFZGl0T3BlcmF0aW9uLmZyb20gPSB0b1RyZWVQb3ModHJlZUVkaXRPcGVyYXRpb24uZ2V0RnJvbVBvcygpKTtcbiAgICAgICAgcGJUcmVlRWRpdE9wZXJhdGlvbi50byA9IHRvVHJlZVBvcyh0cmVlRWRpdE9wZXJhdGlvbi5nZXRUb1BvcygpKTtcbiAgICAgICAgcGJUcmVlRWRpdE9wZXJhdGlvbi5jb250ZW50cyA9IHRvVHJlZU5vZGVzV2hlbkVkaXQodHJlZUVkaXRPcGVyYXRpb24uZ2V0Q29udGVudHMoKSk7XG4gICAgICAgIHBiVHJlZUVkaXRPcGVyYXRpb24uc3BsaXRMZXZlbCA9IHRyZWVFZGl0T3BlcmF0aW9uLmdldFNwbGl0TGV2ZWwoKTtcbiAgICAgICAgcGJUcmVlRWRpdE9wZXJhdGlvbi5leGVjdXRlZEF0ID0gdG9UaW1lVGlja2V0KHRyZWVFZGl0T3BlcmF0aW9uLmdldEV4ZWN1dGVkQXQoKSk7XG4gICAgICAgIHBiT3BlcmF0aW9uLmJvZHkuY2FzZSA9ICd0cmVlRWRpdCc7XG4gICAgICAgIHBiT3BlcmF0aW9uLmJvZHkudmFsdWUgPSBwYlRyZWVFZGl0T3BlcmF0aW9uO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcGVyYXRpb24gaW5zdGFuY2VvZiBUcmVlU3R5bGVPcGVyYXRpb24pIHtcbiAgICAgICAgY29uc3QgdHJlZVN0eWxlT3BlcmF0aW9uID0gb3BlcmF0aW9uO1xuICAgICAgICBjb25zdCBwYlRyZWVTdHlsZU9wZXJhdGlvbiA9IG5ldyByZXNvdXJjZXNfcGIuT3BlcmF0aW9uX1RyZWVTdHlsZSgpO1xuICAgICAgICBwYlRyZWVTdHlsZU9wZXJhdGlvbi5wYXJlbnRDcmVhdGVkQXQgPSB0b1RpbWVUaWNrZXQodHJlZVN0eWxlT3BlcmF0aW9uLmdldFBhcmVudENyZWF0ZWRBdCgpKTtcbiAgICAgICAgcGJUcmVlU3R5bGVPcGVyYXRpb24uZnJvbSA9IHRvVHJlZVBvcyh0cmVlU3R5bGVPcGVyYXRpb24uZ2V0RnJvbVBvcygpKTtcbiAgICAgICAgcGJUcmVlU3R5bGVPcGVyYXRpb24udG8gPSB0b1RyZWVQb3ModHJlZVN0eWxlT3BlcmF0aW9uLmdldFRvUG9zKCkpO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzTWFwID0gcGJUcmVlU3R5bGVPcGVyYXRpb24uYXR0cmlidXRlcztcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdHJlZVN0eWxlT3BlcmF0aW9uLmdldEF0dHJpYnV0ZXMoKSkge1xuICAgICAgICAgICAgYXR0cmlidXRlc01hcFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcGJUcmVlU3R5bGVPcGVyYXRpb24uZXhlY3V0ZWRBdCA9IHRvVGltZVRpY2tldCh0cmVlU3R5bGVPcGVyYXRpb24uZ2V0RXhlY3V0ZWRBdCgpKTtcbiAgICAgICAgcGJPcGVyYXRpb24uYm9keS5jYXNlID0gJ3RyZWVTdHlsZSc7XG4gICAgICAgIHBiT3BlcmF0aW9uLmJvZHkudmFsdWUgPSBwYlRyZWVTdHlsZU9wZXJhdGlvbjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBZb3JraWVFcnJvcihlcnJvcl9Db2RlLlVuaW1wbGVtZW50ZWQsICd1bmltcGxlbWVudGVkIG9wZXJhdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gcGJPcGVyYXRpb247XG59XG4vKipcbiAqIGB0b09wZXJhdGlvbnNgIGNvbnZlcnRzIHRoZSBnaXZlbiBtb2RlbCB0byBQcm90b2J1ZiBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIHRvT3BlcmF0aW9ucyhvcGVyYXRpb25zKSB7XG4gICAgY29uc3QgcGJPcGVyYXRpb25zID0gW107XG4gICAgZm9yIChjb25zdCBvcGVyYXRpb24gb2Ygb3BlcmF0aW9ucykge1xuICAgICAgICBwYk9wZXJhdGlvbnMucHVzaCh0b09wZXJhdGlvbihvcGVyYXRpb24pKTtcbiAgICB9XG4gICAgcmV0dXJuIHBiT3BlcmF0aW9ucztcbn1cbi8qKlxuICogYHRvQ2hhbmdlYCBjb252ZXJ0cyB0aGUgZ2l2ZW4gbW9kZWwgdG8gUHJvdG9idWYgZm9ybWF0LlxuICovXG5mdW5jdGlvbiB0b0NoYW5nZShjaGFuZ2UpIHtcbiAgICBjb25zdCBwYkNoYW5nZSA9IG5ldyByZXNvdXJjZXNfcGIuQ2hhbmdlKHtcbiAgICAgICAgaWQ6IHRvQ2hhbmdlSUQoY2hhbmdlLmdldElEKCkpLFxuICAgICAgICBtZXNzYWdlOiBjaGFuZ2UuZ2V0TWVzc2FnZSgpLFxuICAgIH0pO1xuICAgIGlmIChjaGFuZ2UuaGFzT3BlcmF0aW9ucygpKSB7XG4gICAgICAgIHBiQ2hhbmdlLm9wZXJhdGlvbnMgPSB0b09wZXJhdGlvbnMoY2hhbmdlLmdldE9wZXJhdGlvbnMoKSk7XG4gICAgfVxuICAgIGlmIChjaGFuZ2UuaGFzUHJlc2VuY2VDaGFuZ2UoKSkge1xuICAgICAgICBwYkNoYW5nZS5wcmVzZW5jZUNoYW5nZSA9IHRvUHJlc2VuY2VDaGFuZ2UoY2hhbmdlLmdldFByZXNlbmNlQ2hhbmdlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gcGJDaGFuZ2U7XG59XG4vKipcbiAqIGB0b0NoYW5nZXNgIGNvbnZlcnRzIHRoZSBnaXZlbiBtb2RlbCB0byBQcm90b2J1ZiBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIHRvQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgY29uc3QgcGJDaGFuZ2VzID0gW107XG4gICAgZm9yIChjb25zdCBjaGFuZ2Ugb2YgY2hhbmdlcykge1xuICAgICAgICBwYkNoYW5nZXMucHVzaCh0b0NoYW5nZShjaGFuZ2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBiQ2hhbmdlcztcbn1cbi8qKlxuICogYHRvUkhUTm9kZXNgIGNvbnZlcnRzIHRoZSBnaXZlbiBtb2RlbCB0byBQcm90b2J1ZiBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIHRvUkhUTm9kZXMocmh0KSB7XG4gICAgY29uc3QgcGJSSFROb2RlcyA9IFtdO1xuICAgIGZvciAoY29uc3Qgcmh0Tm9kZSBvZiByaHQpIHtcbiAgICAgICAgcGJSSFROb2Rlcy5wdXNoKG5ldyByZXNvdXJjZXNfcGIuUkhUTm9kZSh7XG4gICAgICAgICAgICBrZXk6IHJodE5vZGUuZ2V0U3RyS2V5KCksXG4gICAgICAgICAgICBlbGVtZW50OiB0b0VsZW1lbnQocmh0Tm9kZS5nZXRWYWx1ZSgpKSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGJSSFROb2Rlcztcbn1cbi8qKlxuICogYHRvUkdBTm9kZXNgIGNvbnZlcnRzIHRoZSBnaXZlbiBtb2RlbCB0byBQcm90b2J1ZiBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIHRvUkdBTm9kZXMocmdhVHJlZUxpc3QpIHtcbiAgICBjb25zdCBwYlJHQU5vZGVzID0gW107XG4gICAgZm9yIChjb25zdCByZ2FUcmVlTGlzdE5vZGUgb2YgcmdhVHJlZUxpc3QpIHtcbiAgICAgICAgcGJSR0FOb2Rlcy5wdXNoKG5ldyByZXNvdXJjZXNfcGIuUkdBTm9kZSh7XG4gICAgICAgICAgICBlbGVtZW50OiB0b0VsZW1lbnQocmdhVHJlZUxpc3ROb2RlLmdldFZhbHVlKCkpLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBwYlJHQU5vZGVzO1xufVxuLyoqXG4gKiBgdG9UZXh0Tm9kZXNgIGNvbnZlcnRzIHRoZSBnaXZlbiBtb2RlbCB0byBQcm90b2J1ZiBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIHRvVGV4dE5vZGVzKHJnYVRyZWVTcGxpdCkge1xuICAgIGNvbnN0IHBiVGV4dE5vZGVzID0gW107XG4gICAgZm9yIChjb25zdCB0ZXh0Tm9kZSBvZiByZ2FUcmVlU3BsaXQpIHtcbiAgICAgICAgY29uc3QgcGJUZXh0Tm9kZSA9IG5ldyByZXNvdXJjZXNfcGIuVGV4dE5vZGUoKTtcbiAgICAgICAgcGJUZXh0Tm9kZS5pZCA9IHRvVGV4dE5vZGVJRCh0ZXh0Tm9kZS5nZXRJRCgpKTtcbiAgICAgICAgcGJUZXh0Tm9kZS52YWx1ZSA9IHRleHROb2RlLmdldFZhbHVlKCkuZ2V0Q29udGVudCgpO1xuICAgICAgICBwYlRleHROb2RlLnJlbW92ZWRBdCA9IHRvVGltZVRpY2tldCh0ZXh0Tm9kZS5nZXRSZW1vdmVkQXQoKSk7XG4gICAgICAgIGNvbnN0IHBiTm9kZUF0dHJzTWFwID0gcGJUZXh0Tm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgICBjb25zdCBhdHRycyA9IHRleHROb2RlLmdldFZhbHVlKCkuZ2V0QXR0cnMoKTtcbiAgICAgICAgZm9yIChjb25zdCBhdHRyIG9mIGF0dHJzKSB7XG4gICAgICAgICAgICBjb25zdCBwYk5vZGVBdHRyID0gbmV3IHJlc291cmNlc19wYi5Ob2RlQXR0cigpO1xuICAgICAgICAgICAgcGJOb2RlQXR0ci52YWx1ZSA9IGF0dHIuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIHBiTm9kZUF0dHIudXBkYXRlZEF0ID0gdG9UaW1lVGlja2V0KGF0dHIuZ2V0VXBkYXRlZEF0KCkpO1xuICAgICAgICAgICAgcGJOb2RlQXR0cnNNYXBbYXR0ci5nZXRLZXkoKV0gPSBwYk5vZGVBdHRyO1xuICAgICAgICB9XG4gICAgICAgIHBiVGV4dE5vZGVzLnB1c2gocGJUZXh0Tm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBwYlRleHROb2Rlcztcbn1cbi8qKlxuICogYHRvVHJlZU5vZGVzV2hlbkVkaXRgIGNvbnZlcnRzIHRoZSBnaXZlbiBtb2RlbCB0byBQcm90b2J1ZiBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIHRvVHJlZU5vZGVzV2hlbkVkaXQobm9kZXMpIHtcbiAgICBjb25zdCBwYlRyZWVOb2Rlc0xpc3QgPSBbXTtcbiAgICBpZiAoIW5vZGVzIHx8ICFub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHBiVHJlZU5vZGVzTGlzdDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgIHBiVHJlZU5vZGVzTGlzdC5wdXNoKG5ldyByZXNvdXJjZXNfcGIuVHJlZU5vZGVzKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRvVHJlZU5vZGVzKG5vZGUpLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBwYlRyZWVOb2Rlc0xpc3Q7XG59XG4vKipcbiAqIGB0b1RyZWVOb2Rlc2AgY29udmVydHMgdGhlIGdpdmVuIG1vZGVsIHRvIFByb3RvYnVmIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gdG9UcmVlTm9kZXMobm9kZSkge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHBiVHJlZU5vZGVzID0gW107XG4gICAgdHJhdmVyc2Uobm9kZSwgKG4sIGRlcHRoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBiVHJlZU5vZGUgPSBuZXcgcmVzb3VyY2VzX3BiLlRyZWVOb2RlKHtcbiAgICAgICAgICAgIGlkOiB0b1RyZWVOb2RlSUQobi5pZCksXG4gICAgICAgICAgICB0eXBlOiBuLnR5cGUsXG4gICAgICAgICAgICByZW1vdmVkQXQ6IHRvVGltZVRpY2tldChuLnJlbW92ZWRBdCksXG4gICAgICAgICAgICBkZXB0aCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChuLmlzVGV4dCkge1xuICAgICAgICAgICAgcGJUcmVlTm9kZS52YWx1ZSA9IG4udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4uaW5zUHJldklEKSB7XG4gICAgICAgICAgICBwYlRyZWVOb2RlLmluc1ByZXZJZCA9IHRvVHJlZU5vZGVJRChuLmluc1ByZXZJRCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4uaW5zTmV4dElEKSB7XG4gICAgICAgICAgICBwYlRyZWVOb2RlLmluc05leHRJZCA9IHRvVHJlZU5vZGVJRChuLmluc05leHRJRCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4uYXR0cnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBuLmF0dHJzKSB7XG4gICAgICAgICAgICAgICAgcGJUcmVlTm9kZS5hdHRyaWJ1dGVzW2F0dHIuZ2V0S2V5KCldID0gbmV3IHJlc291cmNlc19wYi5Ob2RlQXR0cih7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhdHRyLmdldFZhbHVlKCksXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRBdDogdG9UaW1lVGlja2V0KGF0dHIuZ2V0VXBkYXRlZEF0KCkpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBiVHJlZU5vZGVzLnB1c2gocGJUcmVlTm9kZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBiVHJlZU5vZGVzO1xufVxuLyoqXG4gKiBgdG9PYmplY3RgIGNvbnZlcnRzIHRoZSBnaXZlbiBtb2RlbCB0byBQcm90b2J1ZiBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0KG9iaikge1xuICAgIGNvbnN0IHBiRWxlbWVudCA9IG5ldyByZXNvdXJjZXNfcGIuSlNPTkVsZW1lbnQoKTtcbiAgICBwYkVsZW1lbnQuYm9keS5jYXNlID0gJ2pzb25PYmplY3QnO1xuICAgIHBiRWxlbWVudC5ib2R5LnZhbHVlID0gbmV3IHJlc291cmNlc19wYi5KU09ORWxlbWVudF9KU09OT2JqZWN0KHtcbiAgICAgICAgbm9kZXM6IHRvUkhUTm9kZXMob2JqLmdldFJIVCgpKSxcbiAgICAgICAgY3JlYXRlZEF0OiB0b1RpbWVUaWNrZXQob2JqLmdldENyZWF0ZWRBdCgpKSxcbiAgICAgICAgbW92ZWRBdDogdG9UaW1lVGlja2V0KG9iai5nZXRNb3ZlZEF0KCkpLFxuICAgICAgICByZW1vdmVkQXQ6IHRvVGltZVRpY2tldChvYmouZ2V0UmVtb3ZlZEF0KCkpLFxuICAgIH0pO1xuICAgIHJldHVybiBwYkVsZW1lbnQ7XG59XG4vKipcbiAqIGB0b0FycmF5YCBjb252ZXJ0cyB0aGUgZ2l2ZW4gbW9kZWwgdG8gUHJvdG9idWYgZm9ybWF0LlxuICovXG5mdW5jdGlvbiB0b0FycmF5KGFycikge1xuICAgIGNvbnN0IHBiRWxlbWVudCA9IG5ldyByZXNvdXJjZXNfcGIuSlNPTkVsZW1lbnQoKTtcbiAgICBwYkVsZW1lbnQuYm9keS5jYXNlID0gJ2pzb25BcnJheSc7XG4gICAgcGJFbGVtZW50LmJvZHkudmFsdWUgPSBuZXcgcmVzb3VyY2VzX3BiLkpTT05FbGVtZW50X0pTT05BcnJheSh7XG4gICAgICAgIG5vZGVzOiB0b1JHQU5vZGVzKGFyci5nZXRFbGVtZW50cygpKSxcbiAgICAgICAgY3JlYXRlZEF0OiB0b1RpbWVUaWNrZXQoYXJyLmdldENyZWF0ZWRBdCgpKSxcbiAgICAgICAgbW92ZWRBdDogdG9UaW1lVGlja2V0KGFyci5nZXRNb3ZlZEF0KCkpLFxuICAgICAgICByZW1vdmVkQXQ6IHRvVGltZVRpY2tldChhcnIuZ2V0UmVtb3ZlZEF0KCkpLFxuICAgIH0pO1xuICAgIHJldHVybiBwYkVsZW1lbnQ7XG59XG4vKipcbiAqIGB0b1ByaW1pdGl2ZWAgY29udmVydHMgdGhlIGdpdmVuIG1vZGVsIHRvIFByb3RvYnVmIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gdG9QcmltaXRpdmUocHJpbWl0aXZlKSB7XG4gICAgY29uc3QgcGJFbGVtZW50ID0gbmV3IHJlc291cmNlc19wYi5KU09ORWxlbWVudCgpO1xuICAgIHBiRWxlbWVudC5ib2R5LmNhc2UgPSAncHJpbWl0aXZlJztcbiAgICBwYkVsZW1lbnQuYm9keS52YWx1ZSA9IG5ldyByZXNvdXJjZXNfcGIuSlNPTkVsZW1lbnRfUHJpbWl0aXZlKHtcbiAgICAgICAgdHlwZTogdG9WYWx1ZVR5cGUocHJpbWl0aXZlLmdldFR5cGUoKSksXG4gICAgICAgIHZhbHVlOiBwcmltaXRpdmUudG9CeXRlcygpLFxuICAgICAgICBjcmVhdGVkQXQ6IHRvVGltZVRpY2tldChwcmltaXRpdmUuZ2V0Q3JlYXRlZEF0KCkpLFxuICAgICAgICBtb3ZlZEF0OiB0b1RpbWVUaWNrZXQocHJpbWl0aXZlLmdldE1vdmVkQXQoKSksXG4gICAgICAgIHJlbW92ZWRBdDogdG9UaW1lVGlja2V0KHByaW1pdGl2ZS5nZXRSZW1vdmVkQXQoKSksXG4gICAgfSk7XG4gICAgcmV0dXJuIHBiRWxlbWVudDtcbn1cbi8qKlxuICogYHRvVGV4dGAgY29udmVydHMgdGhlIGdpdmVuIG1vZGVsIHRvIFByb3RvYnVmIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gdG9UZXh0KHRleHQpIHtcbiAgICBjb25zdCBwYkVsZW1lbnQgPSBuZXcgcmVzb3VyY2VzX3BiLkpTT05FbGVtZW50KCk7XG4gICAgcGJFbGVtZW50LmJvZHkuY2FzZSA9ICd0ZXh0JztcbiAgICBwYkVsZW1lbnQuYm9keS52YWx1ZSA9IG5ldyByZXNvdXJjZXNfcGIuSlNPTkVsZW1lbnRfVGV4dCh7XG4gICAgICAgIG5vZGVzOiB0b1RleHROb2Rlcyh0ZXh0LmdldFJHQVRyZWVTcGxpdCgpKSxcbiAgICAgICAgY3JlYXRlZEF0OiB0b1RpbWVUaWNrZXQodGV4dC5nZXRDcmVhdGVkQXQoKSksXG4gICAgICAgIG1vdmVkQXQ6IHRvVGltZVRpY2tldCh0ZXh0LmdldE1vdmVkQXQoKSksXG4gICAgICAgIHJlbW92ZWRBdDogdG9UaW1lVGlja2V0KHRleHQuZ2V0UmVtb3ZlZEF0KCkpLFxuICAgIH0pO1xuICAgIHJldHVybiBwYkVsZW1lbnQ7XG59XG4vKipcbiAqIGB0b0NvdW50ZXJgIGNvbnZlcnRzIHRoZSBnaXZlbiBtb2RlbCB0byBQcm90b2J1ZiBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIHRvQ291bnRlcihjb3VudGVyKSB7XG4gICAgY29uc3QgcGJFbGVtZW50ID0gbmV3IHJlc291cmNlc19wYi5KU09ORWxlbWVudCgpO1xuICAgIHBiRWxlbWVudC5ib2R5LmNhc2UgPSAnY291bnRlcic7XG4gICAgcGJFbGVtZW50LmJvZHkudmFsdWUgPSBuZXcgcmVzb3VyY2VzX3BiLkpTT05FbGVtZW50X0NvdW50ZXIoe1xuICAgICAgICB0eXBlOiB0b0NvdW50ZXJUeXBlKGNvdW50ZXIuZ2V0VHlwZSgpKSxcbiAgICAgICAgdmFsdWU6IGNvdW50ZXIudG9CeXRlcygpLFxuICAgICAgICBjcmVhdGVkQXQ6IHRvVGltZVRpY2tldChjb3VudGVyLmdldENyZWF0ZWRBdCgpKSxcbiAgICAgICAgbW92ZWRBdDogdG9UaW1lVGlja2V0KGNvdW50ZXIuZ2V0TW92ZWRBdCgpKSxcbiAgICAgICAgcmVtb3ZlZEF0OiB0b1RpbWVUaWNrZXQoY291bnRlci5nZXRSZW1vdmVkQXQoKSksXG4gICAgfSk7XG4gICAgcmV0dXJuIHBiRWxlbWVudDtcbn1cbi8qKlxuICogYHRvVHJlZWAgY29udmVydHMgdGhlIGdpdmVuIG1vZGVsIHRvIFByb3RvYnVmIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gdG9UcmVlKHRyZWUpIHtcbiAgICBjb25zdCBwYkVsZW1lbnQgPSBuZXcgcmVzb3VyY2VzX3BiLkpTT05FbGVtZW50KCk7XG4gICAgcGJFbGVtZW50LmJvZHkuY2FzZSA9ICd0cmVlJztcbiAgICBwYkVsZW1lbnQuYm9keS52YWx1ZSA9IG5ldyByZXNvdXJjZXNfcGIuSlNPTkVsZW1lbnRfVHJlZSh7XG4gICAgICAgIG5vZGVzOiB0b1RyZWVOb2Rlcyh0cmVlLmdldFJvb3QoKSksXG4gICAgICAgIGNyZWF0ZWRBdDogdG9UaW1lVGlja2V0KHRyZWUuZ2V0Q3JlYXRlZEF0KCkpLFxuICAgICAgICBtb3ZlZEF0OiB0b1RpbWVUaWNrZXQodHJlZS5nZXRNb3ZlZEF0KCkpLFxuICAgICAgICByZW1vdmVkQXQ6IHRvVGltZVRpY2tldCh0cmVlLmdldFJlbW92ZWRBdCgpKSxcbiAgICB9KTtcbiAgICByZXR1cm4gcGJFbGVtZW50O1xufVxuLyoqXG4gKiBgdG9FbGVtZW50YCBjb252ZXJ0cyB0aGUgZ2l2ZW4gbW9kZWwgdG8gUHJvdG9idWYgZm9ybWF0LlxuICovXG5mdW5jdGlvbiB0b0VsZW1lbnQoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgQ1JEVE9iamVjdCkge1xuICAgICAgICByZXR1cm4gdG9PYmplY3QoZWxlbWVudCk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgQ1JEVEFycmF5KSB7XG4gICAgICAgIHJldHVybiB0b0FycmF5KGVsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIFByaW1pdGl2ZSkge1xuICAgICAgICByZXR1cm4gdG9QcmltaXRpdmUoZWxlbWVudCk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgQ1JEVFRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRvVGV4dChlbGVtZW50KTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBDUkRUQ291bnRlcikge1xuICAgICAgICByZXR1cm4gdG9Db3VudGVyKGVsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIENSRFRUcmVlKSB7XG4gICAgICAgIHJldHVybiB0b1RyZWUoZWxlbWVudCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBZb3JraWVFcnJvcihlcnJvcl9Db2RlLlVuaW1wbGVtZW50ZWQsIGB1bmltcGxlbWVudGVkIGVsZW1lbnRgKTtcbn1cbi8qKlxuICogYHRvQ2hhbmdlUGFja2AgY29udmVydHMgdGhlIGdpdmVuIG1vZGVsIHRvIFByb3RvYnVmIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gdG9DaGFuZ2VQYWNrKHBhY2spIHtcbiAgICByZXR1cm4gbmV3IHJlc291cmNlc19wYi5DaGFuZ2VQYWNrKHtcbiAgICAgICAgZG9jdW1lbnRLZXk6IHBhY2suZ2V0RG9jdW1lbnRLZXkoKSxcbiAgICAgICAgY2hlY2twb2ludDogdG9DaGVja3BvaW50KHBhY2suZ2V0Q2hlY2twb2ludCgpKSxcbiAgICAgICAgaXNSZW1vdmVkOiBwYWNrLmdldElzUmVtb3ZlZCgpLFxuICAgICAgICBjaGFuZ2VzOiB0b0NoYW5nZXMocGFjay5nZXRDaGFuZ2VzKCkpLFxuICAgICAgICBzbmFwc2hvdDogcGFjay5nZXRTbmFwc2hvdCgpLFxuICAgICAgICBtaW5TeW5jZWRUaWNrZXQ6IHRvVGltZVRpY2tldChwYWNrLmdldE1pblN5bmNlZFRpY2tldCgpKSxcbiAgICB9KTtcbn1cbi8qKlxuICogYGZyb21DaGFuZ2VJRGAgY29udmVydHMgdGhlIGdpdmVuIFByb3RvYnVmIGZvcm1hdCB0byBtb2RlbCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIGZyb21DaGFuZ2VJRChwYkNoYW5nZUlEKSB7XG4gICAgcmV0dXJuIENoYW5nZUlELm9mKHBiQ2hhbmdlSUQuY2xpZW50U2VxLCBub2RlX21vZHVsZXNfbG9uZy5mcm9tU3RyaW5nKHBiQ2hhbmdlSUQubGFtcG9ydCwgdHJ1ZSksIHRvSGV4U3RyaW5nKHBiQ2hhbmdlSUQuYWN0b3JJZCkpO1xufVxuLyoqXG4gKiBgZnJvbVRpbWVUaWNrZXRgIGNvbnZlcnRzIHRoZSBnaXZlbiBQcm90b2J1ZiBmb3JtYXQgdG8gbW9kZWwgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBmcm9tVGltZVRpY2tldChwYlRpbWVUaWNrZXQpIHtcbiAgICBpZiAoIXBiVGltZVRpY2tldCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBUaW1lVGlja2V0Lm9mKG5vZGVfbW9kdWxlc19sb25nLmZyb21TdHJpbmcocGJUaW1lVGlja2V0LmxhbXBvcnQsIHRydWUpLCBwYlRpbWVUaWNrZXQuZGVsaW1pdGVyLCB0b0hleFN0cmluZyhwYlRpbWVUaWNrZXQuYWN0b3JJZCkpO1xufVxuLyoqXG4gKiBgZnJvbVByZXNlbmNlYCBjb252ZXJ0cyB0aGUgZ2l2ZW4gUHJvdG9idWYgZm9ybWF0IHRvIG1vZGVsIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gZnJvbVByZXNlbmNlKHBiUHJlc2VuY2UpIHtcbiAgICBjb25zdCBkYXRhID0ge307XG4gICAgT2JqZWN0LmVudHJpZXMocGJQcmVzZW5jZS5kYXRhKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgZGF0YVtrZXldID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIGBmcm9tUHJlc2VuY2VDaGFuZ2VgIGNvbnZlcnRzIHRoZSBnaXZlbiBQcm90b2J1ZiBmb3JtYXQgdG8gbW9kZWwgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBmcm9tUHJlc2VuY2VDaGFuZ2UocGJQcmVzZW5jZUNoYW5nZSkge1xuICAgIGNvbnN0IHR5cGUgPSBwYlByZXNlbmNlQ2hhbmdlLnR5cGU7XG4gICAgaWYgKHR5cGUgPT09IHJlc291cmNlc19wYi5QcmVzZW5jZUNoYW5nZV9DaGFuZ2VUeXBlLlBVVCkge1xuICAgICAgICBjb25zdCBwcmVzZW5jZSA9IGZyb21QcmVzZW5jZShwYlByZXNlbmNlQ2hhbmdlLnByZXNlbmNlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFByZXNlbmNlQ2hhbmdlVHlwZS5QdXQsXG4gICAgICAgICAgICBwcmVzZW5jZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IHJlc291cmNlc19wYi5QcmVzZW5jZUNoYW5nZV9DaGFuZ2VUeXBlLkNMRUFSKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBQcmVzZW5jZUNoYW5nZVR5cGUuQ2xlYXIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBZb3JraWVFcnJvcihlcnJvcl9Db2RlLlVuc3VwcG9ydGVkLCBgdW5zdXBwb3J0ZWQgdHlwZTogJHt0eXBlfWApO1xufVxuLyoqXG4gKiBgZnJvbVByZXNlbmNlc2AgY29udmVydHMgdGhlIGdpdmVuIFByb3RvYnVmIGZvcm1hdCB0byBtb2RlbCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIGZyb21QcmVzZW5jZXMocGJQcmVzZW5jZXMpIHtcbiAgICBjb25zdCBwcmVzZW5jZXMgPSBuZXcgTWFwKCk7XG4gICAgT2JqZWN0LmVudHJpZXMocGJQcmVzZW5jZXMpLmZvckVhY2goKFthY3RvcklELCBwYlByZXNlbmNlXSkgPT4ge1xuICAgICAgICBwcmVzZW5jZXMuc2V0KGFjdG9ySUQsIGZyb21QcmVzZW5jZShwYlByZXNlbmNlKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByZXNlbmNlcztcbn1cbi8qKlxuICogYGZyb21WYWx1ZVR5cGVgIGNvbnZlcnRzIHRoZSBnaXZlbiBQcm90b2J1ZiBmb3JtYXQgdG8gbW9kZWwgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBmcm9tVmFsdWVUeXBlKHBiVmFsdWVUeXBlKSB7XG4gICAgc3dpdGNoIChwYlZhbHVlVHlwZSkge1xuICAgICAgICBjYXNlIHJlc291cmNlc19wYi5WYWx1ZVR5cGUuTlVMTDpcbiAgICAgICAgICAgIHJldHVybiBQcmltaXRpdmVUeXBlLk51bGw7XG4gICAgICAgIGNhc2UgcmVzb3VyY2VzX3BiLlZhbHVlVHlwZS5CT09MRUFOOlxuICAgICAgICAgICAgcmV0dXJuIFByaW1pdGl2ZVR5cGUuQm9vbGVhbjtcbiAgICAgICAgY2FzZSByZXNvdXJjZXNfcGIuVmFsdWVUeXBlLklOVEVHRVI6XG4gICAgICAgICAgICByZXR1cm4gUHJpbWl0aXZlVHlwZS5JbnRlZ2VyO1xuICAgICAgICBjYXNlIHJlc291cmNlc19wYi5WYWx1ZVR5cGUuTE9ORzpcbiAgICAgICAgICAgIHJldHVybiBQcmltaXRpdmVUeXBlLkxvbmc7XG4gICAgICAgIGNhc2UgcmVzb3VyY2VzX3BiLlZhbHVlVHlwZS5ET1VCTEU6XG4gICAgICAgICAgICByZXR1cm4gUHJpbWl0aXZlVHlwZS5Eb3VibGU7XG4gICAgICAgIGNhc2UgcmVzb3VyY2VzX3BiLlZhbHVlVHlwZS5TVFJJTkc6XG4gICAgICAgICAgICByZXR1cm4gUHJpbWl0aXZlVHlwZS5TdHJpbmc7XG4gICAgICAgIGNhc2UgcmVzb3VyY2VzX3BiLlZhbHVlVHlwZS5CWVRFUzpcbiAgICAgICAgICAgIHJldHVybiBQcmltaXRpdmVUeXBlLkJ5dGVzO1xuICAgICAgICBjYXNlIHJlc291cmNlc19wYi5WYWx1ZVR5cGUuREFURTpcbiAgICAgICAgICAgIHJldHVybiBQcmltaXRpdmVUeXBlLkRhdGU7XG4gICAgfVxuICAgIHRocm93IG5ldyBZb3JraWVFcnJvcihlcnJvcl9Db2RlLlVuaW1wbGVtZW50ZWQsIGB1bmltcGxlbWVudGVkIHZhbHVlIHR5cGU6ICR7cGJWYWx1ZVR5cGV9YCk7XG59XG4vKipcbiAqIGBmcm9tQ291bnRlclR5cGVgIGNvbnZlcnRzIHRoZSBnaXZlbiBQcm90b2J1ZiBmb3JtYXQgdG8gbW9kZWwgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBmcm9tQ291bnRlclR5cGUocGJWYWx1ZVR5cGUpIHtcbiAgICBzd2l0Y2ggKHBiVmFsdWVUeXBlKSB7XG4gICAgICAgIGNhc2UgcmVzb3VyY2VzX3BiLlZhbHVlVHlwZS5JTlRFR0VSX0NOVDpcbiAgICAgICAgICAgIHJldHVybiBDb3VudGVyVHlwZS5JbnRlZ2VyQ250O1xuICAgICAgICBjYXNlIHJlc291cmNlc19wYi5WYWx1ZVR5cGUuTE9OR19DTlQ6XG4gICAgICAgICAgICByZXR1cm4gQ291bnRlclR5cGUuTG9uZ0NudDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFlvcmtpZUVycm9yKGVycm9yX0NvZGUuVW5pbXBsZW1lbnRlZCwgYHVuaW1wbGVtZW50ZWQgdmFsdWUgdHlwZTogJHtwYlZhbHVlVHlwZX1gKTtcbn1cbi8qKlxuICogYGZyb21FbGVtZW50U2ltcGxlYCBjb252ZXJ0cyB0aGUgZ2l2ZW4gUHJvdG9idWYgZm9ybWF0IHRvIG1vZGVsIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gZnJvbUVsZW1lbnRTaW1wbGUocGJFbGVtZW50U2ltcGxlKSB7XG4gICAgc3dpdGNoIChwYkVsZW1lbnRTaW1wbGUudHlwZSkge1xuICAgICAgICBjYXNlIHJlc291cmNlc19wYi5WYWx1ZVR5cGUuSlNPTl9PQkpFQ1Q6XG4gICAgICAgICAgICBpZiAoIXBiRWxlbWVudFNpbXBsZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDUkRUT2JqZWN0LmNyZWF0ZShmcm9tVGltZVRpY2tldChwYkVsZW1lbnRTaW1wbGUuY3JlYXRlZEF0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXNUb09iamVjdChwYkVsZW1lbnRTaW1wbGUudmFsdWUpO1xuICAgICAgICBjYXNlIHJlc291cmNlc19wYi5WYWx1ZVR5cGUuSlNPTl9BUlJBWTpcbiAgICAgICAgICAgIGlmICghcGJFbGVtZW50U2ltcGxlLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENSRFRBcnJheS5jcmVhdGUoZnJvbVRpbWVUaWNrZXQocGJFbGVtZW50U2ltcGxlLmNyZWF0ZWRBdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzVG9BcnJheShwYkVsZW1lbnRTaW1wbGUudmFsdWUpO1xuICAgICAgICBjYXNlIHJlc291cmNlc19wYi5WYWx1ZVR5cGUuVEVYVDpcbiAgICAgICAgICAgIHJldHVybiBDUkRUVGV4dC5jcmVhdGUoUkdBVHJlZVNwbGl0LmNyZWF0ZSgpLCBmcm9tVGltZVRpY2tldChwYkVsZW1lbnRTaW1wbGUuY3JlYXRlZEF0KSk7XG4gICAgICAgIGNhc2UgcmVzb3VyY2VzX3BiLlZhbHVlVHlwZS5UUkVFOlxuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzVG9UcmVlKHBiRWxlbWVudFNpbXBsZS52YWx1ZSk7XG4gICAgICAgIGNhc2UgcmVzb3VyY2VzX3BiLlZhbHVlVHlwZS5OVUxMOlxuICAgICAgICBjYXNlIHJlc291cmNlc19wYi5WYWx1ZVR5cGUuQk9PTEVBTjpcbiAgICAgICAgY2FzZSByZXNvdXJjZXNfcGIuVmFsdWVUeXBlLklOVEVHRVI6XG4gICAgICAgIGNhc2UgcmVzb3VyY2VzX3BiLlZhbHVlVHlwZS5MT05HOlxuICAgICAgICBjYXNlIHJlc291cmNlc19wYi5WYWx1ZVR5cGUuRE9VQkxFOlxuICAgICAgICBjYXNlIHJlc291cmNlc19wYi5WYWx1ZVR5cGUuU1RSSU5HOlxuICAgICAgICBjYXNlIHJlc291cmNlc19wYi5WYWx1ZVR5cGUuQllURVM6XG4gICAgICAgIGNhc2UgcmVzb3VyY2VzX3BiLlZhbHVlVHlwZS5EQVRFOlxuICAgICAgICAgICAgcmV0dXJuIFByaW1pdGl2ZS5vZihQcmltaXRpdmUudmFsdWVGcm9tQnl0ZXMoZnJvbVZhbHVlVHlwZShwYkVsZW1lbnRTaW1wbGUudHlwZSksIHBiRWxlbWVudFNpbXBsZS52YWx1ZSksIGZyb21UaW1lVGlja2V0KHBiRWxlbWVudFNpbXBsZS5jcmVhdGVkQXQpKTtcbiAgICAgICAgY2FzZSByZXNvdXJjZXNfcGIuVmFsdWVUeXBlLklOVEVHRVJfQ05UOlxuICAgICAgICBjYXNlIHJlc291cmNlc19wYi5WYWx1ZVR5cGUuTE9OR19DTlQ6XG4gICAgICAgICAgICByZXR1cm4gQ1JEVENvdW50ZXIuY3JlYXRlKGZyb21Db3VudGVyVHlwZShwYkVsZW1lbnRTaW1wbGUudHlwZSksIENSRFRDb3VudGVyLnZhbHVlRnJvbUJ5dGVzKGZyb21Db3VudGVyVHlwZShwYkVsZW1lbnRTaW1wbGUudHlwZSksIHBiRWxlbWVudFNpbXBsZS52YWx1ZSksIGZyb21UaW1lVGlja2V0KHBiRWxlbWVudFNpbXBsZS5jcmVhdGVkQXQpKTtcbiAgICB9XG59XG4vKipcbiAqIGBmcm9tVGV4dE5vZGVQb3NgIGNvbnZlcnRzIHRoZSBnaXZlbiBQcm90b2J1ZiBmb3JtYXQgdG8gbW9kZWwgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBmcm9tVGV4dE5vZGVQb3MocGJUZXh0Tm9kZVBvcykge1xuICAgIHJldHVybiBSR0FUcmVlU3BsaXRQb3Mub2YoUkdBVHJlZVNwbGl0Tm9kZUlELm9mKGZyb21UaW1lVGlja2V0KHBiVGV4dE5vZGVQb3MuY3JlYXRlZEF0KSwgcGJUZXh0Tm9kZVBvcy5vZmZzZXQpLCBwYlRleHROb2RlUG9zLnJlbGF0aXZlT2Zmc2V0KTtcbn1cbi8qKlxuICogYGZyb21UZXh0Tm9kZUlEYCBjb252ZXJ0cyB0aGUgZ2l2ZW4gUHJvdG9idWYgZm9ybWF0IHRvIG1vZGVsIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gZnJvbVRleHROb2RlSUQocGJUZXh0Tm9kZUlEKSB7XG4gICAgcmV0dXJuIFJHQVRyZWVTcGxpdE5vZGVJRC5vZihmcm9tVGltZVRpY2tldChwYlRleHROb2RlSUQuY3JlYXRlZEF0KSwgcGJUZXh0Tm9kZUlELm9mZnNldCk7XG59XG4vKipcbiAqIGBmcm9tVGV4dE5vZGVgIGNvbnZlcnRzIHRoZSBnaXZlbiBQcm90b2J1ZiBmb3JtYXQgdG8gbW9kZWwgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBmcm9tVGV4dE5vZGUocGJUZXh0Tm9kZSkge1xuICAgIGNvbnN0IHRleHRWYWx1ZSA9IENSRFRUZXh0VmFsdWUuY3JlYXRlKHBiVGV4dE5vZGUudmFsdWUpO1xuICAgIE9iamVjdC5lbnRyaWVzKHBiVGV4dE5vZGUuYXR0cmlidXRlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIHRleHRWYWx1ZS5zZXRBdHRyKGtleSwgdmFsdWUudmFsdWUsIGZyb21UaW1lVGlja2V0KHZhbHVlLnVwZGF0ZWRBdCkpO1xuICAgIH0pO1xuICAgIGNvbnN0IHRleHROb2RlID0gUkdBVHJlZVNwbGl0Tm9kZS5jcmVhdGUoZnJvbVRleHROb2RlSUQocGJUZXh0Tm9kZS5pZCksIHRleHRWYWx1ZSk7XG4gICAgdGV4dE5vZGUucmVtb3ZlKGZyb21UaW1lVGlja2V0KHBiVGV4dE5vZGUucmVtb3ZlZEF0KSk7XG4gICAgcmV0dXJuIHRleHROb2RlO1xufVxuLyoqXG4gKiBgZnJvbVRyZWVQb3NgIGNvbnZlcnRzIHRoZSBnaXZlbiBQcm90b2J1ZiBmb3JtYXQgdG8gbW9kZWwgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBmcm9tVHJlZVBvcyhwYlRyZWVQb3MpIHtcbiAgICByZXR1cm4gQ1JEVFRyZWVQb3Mub2YoZnJvbVRyZWVOb2RlSUQocGJUcmVlUG9zLnBhcmVudElkKSwgZnJvbVRyZWVOb2RlSUQocGJUcmVlUG9zLmxlZnRTaWJsaW5nSWQpKTtcbn1cbi8qKlxuICogYGZyb21UcmVlTm9kZUlEYCBjb252ZXJ0cyB0aGUgZ2l2ZW4gUHJvdG9idWYgZm9ybWF0IHRvIG1vZGVsIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gZnJvbVRyZWVOb2RlSUQocGJUcmVlTm9kZUlEKSB7XG4gICAgcmV0dXJuIENSRFRUcmVlTm9kZUlELm9mKGZyb21UaW1lVGlja2V0KHBiVHJlZU5vZGVJRC5jcmVhdGVkQXQpLCBwYlRyZWVOb2RlSUQub2Zmc2V0KTtcbn1cbi8qKlxuICogYGZyb21UcmVlTm9kZXNXaGVuRWRpdGAgY29udmVydHMgdGhlIGdpdmVuIFByb3RvYnVmIGZvcm1hdCB0byBtb2RlbCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIGZyb21UcmVlTm9kZXNXaGVuRWRpdChwYlRyZWVOb2Rlcykge1xuICAgIGlmICghcGJUcmVlTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHJlZU5vZGVzID0gW107XG4gICAgcGJUcmVlTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBjb25zdCB0cmVlTm9kZSA9IGZyb21UcmVlTm9kZXMobm9kZS5jb250ZW50KTtcbiAgICAgICAgdHJlZU5vZGVzLnB1c2godHJlZU5vZGUpO1xuICAgIH0pO1xuICAgIHJldHVybiB0cmVlTm9kZXM7XG59XG4vKipcbiAqIGBmcm9tVHJlZU5vZGVzYCBjb252ZXJ0cyB0aGUgZ2l2ZW4gUHJvdG9idWYgZm9ybWF0IHRvIG1vZGVsIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gZnJvbVRyZWVOb2RlcyhwYlRyZWVOb2Rlcykge1xuICAgIGlmIChwYlRyZWVOb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgcGJUcmVlTm9kZSBvZiBwYlRyZWVOb2Rlcykge1xuICAgICAgICBub2Rlcy5wdXNoKGZyb21UcmVlTm9kZShwYlRyZWVOb2RlKSk7XG4gICAgfVxuICAgIGNvbnN0IHJvb3QgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXTtcbiAgICBmb3IgKGxldCBpID0gbm9kZXMubGVuZ3RoIC0gMjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IHBhcmVudDtcbiAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYlRyZWVOb2Rlc1tpXS5kZXB0aCAtIDEgPT09IHBiVHJlZU5vZGVzW2pdLmRlcHRoKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbm9kZXNbal07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50LnByZXBlbmQobm9kZXNbaV0pO1xuICAgIH1cbiAgICAvLyBidWlsZCBDUkRUVHJlZSBmcm9tIHRoZSByb290IHRvIGNvbnN0cnVjdCB0aGUgbGlua3MgYmV0d2VlbiBub2Rlcy5cbiAgICByZXR1cm4gQ1JEVFRyZWUuY3JlYXRlKHJvb3QsIEluaXRpYWxUaW1lVGlja2V0KS5nZXRSb290KCk7XG59XG4vKipcbiAqIGBmcm9tVHJlZU5vZGVgIGNvbnZlcnRzIHRoZSBnaXZlbiBQcm90b2J1ZiBmb3JtYXQgdG8gbW9kZWwgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBmcm9tVHJlZU5vZGUocGJUcmVlTm9kZSkge1xuICAgIGNvbnN0IGlkID0gZnJvbVRyZWVOb2RlSUQocGJUcmVlTm9kZS5pZCk7XG4gICAgY29uc3Qgbm9kZSA9IENSRFRUcmVlTm9kZS5jcmVhdGUoaWQsIHBiVHJlZU5vZGUudHlwZSk7XG4gICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSBwYlRyZWVOb2RlLnZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYXR0cnMgPSBSSFQuY3JlYXRlKCk7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHBiVHJlZU5vZGUuYXR0cmlidXRlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBhdHRycy5zZXQoa2V5LCB2YWx1ZS52YWx1ZSwgZnJvbVRpbWVUaWNrZXQodmFsdWUudXBkYXRlZEF0KSk7XG4gICAgICAgIH0pO1xuICAgICAgICBub2RlLmF0dHJzID0gYXR0cnM7XG4gICAgfVxuICAgIGlmIChwYlRyZWVOb2RlLmluc1ByZXZJZCkge1xuICAgICAgICBub2RlLmluc1ByZXZJRCA9IGZyb21UcmVlTm9kZUlEKHBiVHJlZU5vZGUuaW5zUHJldklkKTtcbiAgICB9XG4gICAgaWYgKHBiVHJlZU5vZGUuaW5zUHJldklkKSB7XG4gICAgICAgIG5vZGUuaW5zTmV4dElEID0gZnJvbVRyZWVOb2RlSUQocGJUcmVlTm9kZS5pbnNOZXh0SWQpO1xuICAgIH1cbiAgICBub2RlLnJlbW92ZWRBdCA9IGZyb21UaW1lVGlja2V0KHBiVHJlZU5vZGUucmVtb3ZlZEF0KTtcbiAgICByZXR1cm4gbm9kZTtcbn1cbi8qKlxuICogYGZyb21PcGVyYXRpb25zYCBjb252ZXJ0cyB0aGUgZ2l2ZW4gUHJvdG9idWYgZm9ybWF0IHRvIG1vZGVsIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gZnJvbU9wZXJhdGlvbnMocGJPcGVyYXRpb25zKSB7XG4gICAgY29uc3Qgb3BlcmF0aW9ucyA9IFtdO1xuICAgIGZvciAoY29uc3QgcGJPcGVyYXRpb24gb2YgcGJPcGVyYXRpb25zKSB7XG4gICAgICAgIGxldCBvcGVyYXRpb247XG4gICAgICAgIGlmIChwYk9wZXJhdGlvbi5ib2R5LmNhc2UgPT09ICdzZXQnKSB7XG4gICAgICAgICAgICBjb25zdCBwYlNldE9wZXJhdGlvbiA9IHBiT3BlcmF0aW9uLmJvZHkudmFsdWU7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBTZXRPcGVyYXRpb24uY3JlYXRlKHBiU2V0T3BlcmF0aW9uLmtleSwgZnJvbUVsZW1lbnRTaW1wbGUocGJTZXRPcGVyYXRpb24udmFsdWUpLCBmcm9tVGltZVRpY2tldChwYlNldE9wZXJhdGlvbi5wYXJlbnRDcmVhdGVkQXQpLCBmcm9tVGltZVRpY2tldChwYlNldE9wZXJhdGlvbi5leGVjdXRlZEF0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGJPcGVyYXRpb24uYm9keS5jYXNlID09PSAnYWRkJykge1xuICAgICAgICAgICAgY29uc3QgcGJBZGRPcGVyYXRpb24gPSBwYk9wZXJhdGlvbi5ib2R5LnZhbHVlO1xuICAgICAgICAgICAgb3BlcmF0aW9uID0gQWRkT3BlcmF0aW9uLmNyZWF0ZShmcm9tVGltZVRpY2tldChwYkFkZE9wZXJhdGlvbi5wYXJlbnRDcmVhdGVkQXQpLCBmcm9tVGltZVRpY2tldChwYkFkZE9wZXJhdGlvbi5wcmV2Q3JlYXRlZEF0KSwgZnJvbUVsZW1lbnRTaW1wbGUocGJBZGRPcGVyYXRpb24udmFsdWUpLCBmcm9tVGltZVRpY2tldChwYkFkZE9wZXJhdGlvbi5leGVjdXRlZEF0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGJPcGVyYXRpb24uYm9keS5jYXNlID09PSAnbW92ZScpIHtcbiAgICAgICAgICAgIGNvbnN0IHBiTW92ZU9wZXJhdGlvbiA9IHBiT3BlcmF0aW9uLmJvZHkudmFsdWU7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBNb3ZlT3BlcmF0aW9uLmNyZWF0ZShmcm9tVGltZVRpY2tldChwYk1vdmVPcGVyYXRpb24ucGFyZW50Q3JlYXRlZEF0KSwgZnJvbVRpbWVUaWNrZXQocGJNb3ZlT3BlcmF0aW9uLnByZXZDcmVhdGVkQXQpLCBmcm9tVGltZVRpY2tldChwYk1vdmVPcGVyYXRpb24uY3JlYXRlZEF0KSwgZnJvbVRpbWVUaWNrZXQocGJNb3ZlT3BlcmF0aW9uLmV4ZWN1dGVkQXQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYk9wZXJhdGlvbi5ib2R5LmNhc2UgPT09ICdyZW1vdmUnKSB7XG4gICAgICAgICAgICBjb25zdCBwYlJlbW92ZU9wZXJhdGlvbiA9IHBiT3BlcmF0aW9uLmJvZHkudmFsdWU7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBSZW1vdmVPcGVyYXRpb24uY3JlYXRlKGZyb21UaW1lVGlja2V0KHBiUmVtb3ZlT3BlcmF0aW9uLnBhcmVudENyZWF0ZWRBdCksIGZyb21UaW1lVGlja2V0KHBiUmVtb3ZlT3BlcmF0aW9uLmNyZWF0ZWRBdCksIGZyb21UaW1lVGlja2V0KHBiUmVtb3ZlT3BlcmF0aW9uLmV4ZWN1dGVkQXQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYk9wZXJhdGlvbi5ib2R5LmNhc2UgPT09ICdlZGl0Jykge1xuICAgICAgICAgICAgY29uc3QgcGJFZGl0T3BlcmF0aW9uID0gcGJPcGVyYXRpb24uYm9keS52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWRBdE1hcEJ5QWN0b3IgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhwYkVkaXRPcGVyYXRpb24uY3JlYXRlZEF0TWFwQnlBY3RvcikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgY3JlYXRlZEF0TWFwQnlBY3Rvci5zZXQoa2V5LCBmcm9tVGltZVRpY2tldCh2YWx1ZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMocGJFZGl0T3BlcmF0aW9uLmF0dHJpYnV0ZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBFZGl0T3BlcmF0aW9uLmNyZWF0ZShmcm9tVGltZVRpY2tldChwYkVkaXRPcGVyYXRpb24ucGFyZW50Q3JlYXRlZEF0KSwgZnJvbVRleHROb2RlUG9zKHBiRWRpdE9wZXJhdGlvbi5mcm9tKSwgZnJvbVRleHROb2RlUG9zKHBiRWRpdE9wZXJhdGlvbi50byksIGNyZWF0ZWRBdE1hcEJ5QWN0b3IsIHBiRWRpdE9wZXJhdGlvbi5jb250ZW50LCBhdHRyaWJ1dGVzLCBmcm9tVGltZVRpY2tldChwYkVkaXRPcGVyYXRpb24uZXhlY3V0ZWRBdCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBiT3BlcmF0aW9uLmJvZHkuY2FzZSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgY29uc3QgcGJTdHlsZU9wZXJhdGlvbiA9IHBiT3BlcmF0aW9uLmJvZHkudmFsdWU7XG4gICAgICAgICAgICBjb25zdCBjcmVhdGVkQXRNYXBCeUFjdG9yID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMocGJTdHlsZU9wZXJhdGlvbi5jcmVhdGVkQXRNYXBCeUFjdG9yKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBjcmVhdGVkQXRNYXBCeUFjdG9yLnNldChrZXksIGZyb21UaW1lVGlja2V0KHZhbHVlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhwYlN0eWxlT3BlcmF0aW9uLmF0dHJpYnV0ZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBTdHlsZU9wZXJhdGlvbi5jcmVhdGUoZnJvbVRpbWVUaWNrZXQocGJTdHlsZU9wZXJhdGlvbi5wYXJlbnRDcmVhdGVkQXQpLCBmcm9tVGV4dE5vZGVQb3MocGJTdHlsZU9wZXJhdGlvbi5mcm9tKSwgZnJvbVRleHROb2RlUG9zKHBiU3R5bGVPcGVyYXRpb24udG8pLCBjcmVhdGVkQXRNYXBCeUFjdG9yLCBhdHRyaWJ1dGVzLCBmcm9tVGltZVRpY2tldChwYlN0eWxlT3BlcmF0aW9uLmV4ZWN1dGVkQXQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYk9wZXJhdGlvbi5ib2R5LmNhc2UgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgICAgICAvLyBUT0RPKGhhY2tlcndpbnMpOiBTZWxlY3QgaXMgZGVwcmVjYXRlZC5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBiT3BlcmF0aW9uLmJvZHkuY2FzZSA9PT0gJ2luY3JlYXNlJykge1xuICAgICAgICAgICAgY29uc3QgcGJJbmNyZWFzZU9wZXJhdGlvbiA9IHBiT3BlcmF0aW9uLmJvZHkudmFsdWU7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBJbmNyZWFzZU9wZXJhdGlvbi5jcmVhdGUoZnJvbVRpbWVUaWNrZXQocGJJbmNyZWFzZU9wZXJhdGlvbi5wYXJlbnRDcmVhdGVkQXQpLCBmcm9tRWxlbWVudFNpbXBsZShwYkluY3JlYXNlT3BlcmF0aW9uLnZhbHVlKSwgZnJvbVRpbWVUaWNrZXQocGJJbmNyZWFzZU9wZXJhdGlvbi5leGVjdXRlZEF0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGJPcGVyYXRpb24uYm9keS5jYXNlID09PSAndHJlZUVkaXQnKSB7XG4gICAgICAgICAgICBjb25zdCBwYlRyZWVFZGl0T3BlcmF0aW9uID0gcGJPcGVyYXRpb24uYm9keS52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWRBdE1hcEJ5QWN0b3IgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhwYlRyZWVFZGl0T3BlcmF0aW9uLmNyZWF0ZWRBdE1hcEJ5QWN0b3IpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGNyZWF0ZWRBdE1hcEJ5QWN0b3Iuc2V0KGtleSwgZnJvbVRpbWVUaWNrZXQodmFsdWUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb3BlcmF0aW9uID0gVHJlZUVkaXRPcGVyYXRpb24uY3JlYXRlKGZyb21UaW1lVGlja2V0KHBiVHJlZUVkaXRPcGVyYXRpb24ucGFyZW50Q3JlYXRlZEF0KSwgZnJvbVRyZWVQb3MocGJUcmVlRWRpdE9wZXJhdGlvbi5mcm9tKSwgZnJvbVRyZWVQb3MocGJUcmVlRWRpdE9wZXJhdGlvbi50byksIGZyb21UcmVlTm9kZXNXaGVuRWRpdChwYlRyZWVFZGl0T3BlcmF0aW9uLmNvbnRlbnRzKSwgcGJUcmVlRWRpdE9wZXJhdGlvbi5zcGxpdExldmVsLCBjcmVhdGVkQXRNYXBCeUFjdG9yLCBmcm9tVGltZVRpY2tldChwYlRyZWVFZGl0T3BlcmF0aW9uLmV4ZWN1dGVkQXQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYk9wZXJhdGlvbi5ib2R5LmNhc2UgPT09ICd0cmVlU3R5bGUnKSB7XG4gICAgICAgICAgICBjb25zdCBwYlRyZWVTdHlsZU9wZXJhdGlvbiA9IHBiT3BlcmF0aW9uLmJvZHkudmFsdWU7XG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMocGJUcmVlU3R5bGVPcGVyYXRpb24uYXR0cmlidXRlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IFRyZWVTdHlsZU9wZXJhdGlvbi5jcmVhdGUoZnJvbVRpbWVUaWNrZXQocGJUcmVlU3R5bGVPcGVyYXRpb24ucGFyZW50Q3JlYXRlZEF0KSwgZnJvbVRyZWVQb3MocGJUcmVlU3R5bGVPcGVyYXRpb24uZnJvbSksIGZyb21UcmVlUG9zKHBiVHJlZVN0eWxlT3BlcmF0aW9uLnRvKSwgYXR0cmlidXRlcywgZnJvbVRpbWVUaWNrZXQocGJUcmVlU3R5bGVPcGVyYXRpb24uZXhlY3V0ZWRBdCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFlvcmtpZUVycm9yKGVycm9yX0NvZGUuVW5pbXBsZW1lbnRlZCwgYHVuaW1wbGVtZW50ZWQgb3BlcmF0aW9uYCk7XG4gICAgICAgIH1cbiAgICAgICAgb3BlcmF0aW9ucy5wdXNoKG9wZXJhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBvcGVyYXRpb25zO1xufVxuLyoqXG4gKiBgZnJvbUNoYW5nZXNgIGNvbnZlcnRzIHRoZSBnaXZlbiBQcm90b2J1ZiBmb3JtYXQgdG8gbW9kZWwgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBmcm9tQ2hhbmdlcyhwYkNoYW5nZXMpIHtcbiAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgZm9yIChjb25zdCBwYkNoYW5nZSBvZiBwYkNoYW5nZXMpIHtcbiAgICAgICAgY2hhbmdlcy5wdXNoKENoYW5nZS5jcmVhdGUoe1xuICAgICAgICAgICAgaWQ6IGZyb21DaGFuZ2VJRChwYkNoYW5nZS5pZCksXG4gICAgICAgICAgICBvcGVyYXRpb25zOiBmcm9tT3BlcmF0aW9ucyhwYkNoYW5nZS5vcGVyYXRpb25zKSxcbiAgICAgICAgICAgIHByZXNlbmNlQ2hhbmdlOiBwYkNoYW5nZS5wcmVzZW5jZUNoYW5nZVxuICAgICAgICAgICAgICAgID8gZnJvbVByZXNlbmNlQ2hhbmdlKHBiQ2hhbmdlLnByZXNlbmNlQ2hhbmdlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbWVzc2FnZTogcGJDaGFuZ2UubWVzc2FnZSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlcztcbn1cbi8qKlxuICogYGZyb21DaGVja3BvaW50YCBjb252ZXJ0cyB0aGUgZ2l2ZW4gUHJvdG9idWYgZm9ybWF0IHRvIG1vZGVsIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gZnJvbUNoZWNrcG9pbnQocGJDaGVja3BvaW50KSB7XG4gICAgcmV0dXJuIENoZWNrcG9pbnQub2Yobm9kZV9tb2R1bGVzX2xvbmcuZnJvbVN0cmluZyhwYkNoZWNrcG9pbnQuc2VydmVyU2VxLCB0cnVlKSwgcGJDaGVja3BvaW50LmNsaWVudFNlcSk7XG59XG4vKipcbiAqIGBmcm9tQ2hhbmdlUGFja2AgY29udmVydHMgdGhlIGdpdmVuIFByb3RvYnVmIGZvcm1hdCB0byBtb2RlbCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIGZyb21DaGFuZ2VQYWNrKHBiUGFjaykge1xuICAgIHJldHVybiBDaGFuZ2VQYWNrLmNyZWF0ZShwYlBhY2suZG9jdW1lbnRLZXksIGZyb21DaGVja3BvaW50KHBiUGFjay5jaGVja3BvaW50KSwgcGJQYWNrLmlzUmVtb3ZlZCwgZnJvbUNoYW5nZXMocGJQYWNrLmNoYW5nZXMpLCBwYlBhY2suc25hcHNob3QsIGZyb21UaW1lVGlja2V0KHBiUGFjay5taW5TeW5jZWRUaWNrZXQpKTtcbn1cbi8qKlxuICogYGZyb21PYmplY3RgIGNvbnZlcnRzIHRoZSBnaXZlbiBQcm90b2J1ZiBmb3JtYXQgdG8gbW9kZWwgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBmcm9tT2JqZWN0KHBiT2JqZWN0KSB7XG4gICAgY29uc3Qgcmh0ID0gbmV3IEVsZW1lbnRSSFQoKTtcbiAgICBmb3IgKGNvbnN0IHBiUkhUTm9kZSBvZiBwYk9iamVjdC5ub2Rlcykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGZyb21FbGVtZW50KHBiUkhUTm9kZS5lbGVtZW50KTtcbiAgICAgICAgcmh0LnNldChwYlJIVE5vZGUua2V5LCB2YWx1ZSwgdmFsdWUuZ2V0UG9zaXRpb25lZEF0KCkpO1xuICAgIH1cbiAgICBjb25zdCBvYmogPSBuZXcgQ1JEVE9iamVjdChmcm9tVGltZVRpY2tldChwYk9iamVjdC5jcmVhdGVkQXQpLCByaHQpO1xuICAgIG9iai5zZXRNb3ZlZEF0KGZyb21UaW1lVGlja2V0KHBiT2JqZWN0Lm1vdmVkQXQpKTtcbiAgICBvYmouc2V0UmVtb3ZlZEF0KGZyb21UaW1lVGlja2V0KHBiT2JqZWN0LnJlbW92ZWRBdCkpO1xuICAgIHJldHVybiBvYmo7XG59XG4vKipcbiAqIGBmcm9tQXJyYXlgIGNvbnZlcnRzIHRoZSBnaXZlbiBQcm90b2J1ZiBmb3JtYXQgdG8gbW9kZWwgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBmcm9tQXJyYXkocGJBcnJheSkge1xuICAgIGNvbnN0IHJnYVRyZWVMaXN0ID0gbmV3IFJHQVRyZWVMaXN0KCk7XG4gICAgZm9yIChjb25zdCBwYlJHQU5vZGUgb2YgcGJBcnJheS5ub2Rlcykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgcmdhVHJlZUxpc3QuaW5zZXJ0KGZyb21FbGVtZW50KHBiUkdBTm9kZS5lbGVtZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IGFyciA9IG5ldyBDUkRUQXJyYXkoZnJvbVRpbWVUaWNrZXQocGJBcnJheS5jcmVhdGVkQXQpLCByZ2FUcmVlTGlzdCk7XG4gICAgYXJyLnNldE1vdmVkQXQoZnJvbVRpbWVUaWNrZXQocGJBcnJheS5tb3ZlZEF0KSk7XG4gICAgYXJyLnNldFJlbW92ZWRBdChmcm9tVGltZVRpY2tldChwYkFycmF5LnJlbW92ZWRBdCkpO1xuICAgIHJldHVybiBhcnI7XG59XG4vKipcbiAqIGBmcm9tUHJpbWl0aXZlYCBjb252ZXJ0cyB0aGUgZ2l2ZW4gUHJvdG9idWYgZm9ybWF0IHRvIG1vZGVsIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gZnJvbVByaW1pdGl2ZShwYlByaW1pdGl2ZSkge1xuICAgIGNvbnN0IHByaW1pdGl2ZSA9IFByaW1pdGl2ZS5vZihQcmltaXRpdmUudmFsdWVGcm9tQnl0ZXMoZnJvbVZhbHVlVHlwZShwYlByaW1pdGl2ZS50eXBlKSwgcGJQcmltaXRpdmUudmFsdWUpLCBmcm9tVGltZVRpY2tldChwYlByaW1pdGl2ZS5jcmVhdGVkQXQpKTtcbiAgICBwcmltaXRpdmUuc2V0TW92ZWRBdChmcm9tVGltZVRpY2tldChwYlByaW1pdGl2ZS5tb3ZlZEF0KSk7XG4gICAgcHJpbWl0aXZlLnNldFJlbW92ZWRBdChmcm9tVGltZVRpY2tldChwYlByaW1pdGl2ZS5yZW1vdmVkQXQpKTtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xufVxuLyoqXG4gKiBgZnJvbVRleHRgIGNvbnZlcnRzIHRoZSBnaXZlbiBQcm90b2J1ZiBmb3JtYXQgdG8gbW9kZWwgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBmcm9tVGV4dChwYlRleHQpIHtcbiAgICBjb25zdCByZ2FUcmVlU3BsaXQgPSBuZXcgUkdBVHJlZVNwbGl0KCk7XG4gICAgbGV0IHByZXYgPSByZ2FUcmVlU3BsaXQuZ2V0SGVhZCgpO1xuICAgIGZvciAoY29uc3QgcGJOb2RlIG9mIHBiVGV4dC5ub2Rlcykge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gcmdhVHJlZVNwbGl0Lmluc2VydEFmdGVyKHByZXYsIGZyb21UZXh0Tm9kZShwYk5vZGUpKTtcbiAgICAgICAgaWYgKHBiTm9kZS5pbnNQcmV2SWQpIHtcbiAgICAgICAgICAgIGN1cnJlbnQuc2V0SW5zUHJldihyZ2FUcmVlU3BsaXQuZmluZE5vZGUoZnJvbVRleHROb2RlSUQocGJOb2RlLmluc1ByZXZJZCkpKTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2ID0gY3VycmVudDtcbiAgICB9XG4gICAgY29uc3QgdGV4dCA9IG5ldyBDUkRUVGV4dChyZ2FUcmVlU3BsaXQsIGZyb21UaW1lVGlja2V0KHBiVGV4dC5jcmVhdGVkQXQpKTtcbiAgICB0ZXh0LnNldE1vdmVkQXQoZnJvbVRpbWVUaWNrZXQocGJUZXh0Lm1vdmVkQXQpKTtcbiAgICB0ZXh0LnNldFJlbW92ZWRBdChmcm9tVGltZVRpY2tldChwYlRleHQucmVtb3ZlZEF0KSk7XG4gICAgcmV0dXJuIHRleHQ7XG59XG4vKipcbiAqIGBmcm9tQ291bnRlcmAgY29udmVydHMgdGhlIGdpdmVuIFByb3RvYnVmIGZvcm1hdCB0byBtb2RlbCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIGZyb21Db3VudGVyKHBiQ291bnRlcikge1xuICAgIGNvbnN0IGNvdW50ZXIgPSBDUkRUQ291bnRlci5jcmVhdGUoZnJvbUNvdW50ZXJUeXBlKHBiQ291bnRlci50eXBlKSwgQ1JEVENvdW50ZXIudmFsdWVGcm9tQnl0ZXMoZnJvbUNvdW50ZXJUeXBlKHBiQ291bnRlci50eXBlKSwgcGJDb3VudGVyLnZhbHVlKSwgZnJvbVRpbWVUaWNrZXQocGJDb3VudGVyLmNyZWF0ZWRBdCkpO1xuICAgIGNvdW50ZXIuc2V0TW92ZWRBdChmcm9tVGltZVRpY2tldChwYkNvdW50ZXIubW92ZWRBdCkpO1xuICAgIGNvdW50ZXIuc2V0UmVtb3ZlZEF0KGZyb21UaW1lVGlja2V0KHBiQ291bnRlci5yZW1vdmVkQXQpKTtcbiAgICByZXR1cm4gY291bnRlcjtcbn1cbi8qKlxuICogYGZyb21UcmVlYCBjb252ZXJ0cyB0aGUgZ2l2ZW4gUHJvdG9idWYgZm9ybWF0IHRvIG1vZGVsIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gZnJvbVRyZWUocGJUcmVlKSB7XG4gICAgY29uc3Qgcm9vdCA9IGZyb21UcmVlTm9kZXMocGJUcmVlLm5vZGVzKTtcbiAgICByZXR1cm4gQ1JEVFRyZWUuY3JlYXRlKHJvb3QsIGZyb21UaW1lVGlja2V0KHBiVHJlZS5jcmVhdGVkQXQpKTtcbn1cbi8qKlxuICogYGZyb21FbGVtZW50YCBjb252ZXJ0cyB0aGUgZ2l2ZW4gUHJvdG9idWYgZm9ybWF0IHRvIG1vZGVsIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gZnJvbUVsZW1lbnQocGJFbGVtZW50KSB7XG4gICAgaWYgKHBiRWxlbWVudC5ib2R5LmNhc2UgPT09ICdqc29uT2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZnJvbU9iamVjdChwYkVsZW1lbnQuYm9keS52YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBiRWxlbWVudC5ib2R5LmNhc2UgPT09ICdqc29uQXJyYXknKSB7XG4gICAgICAgIHJldHVybiBmcm9tQXJyYXkocGJFbGVtZW50LmJvZHkudmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwYkVsZW1lbnQuYm9keS5jYXNlID09PSAncHJpbWl0aXZlJykge1xuICAgICAgICByZXR1cm4gZnJvbVByaW1pdGl2ZShwYkVsZW1lbnQuYm9keS52YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBiRWxlbWVudC5ib2R5LmNhc2UgPT09ICd0ZXh0Jykge1xuICAgICAgICByZXR1cm4gZnJvbVRleHQocGJFbGVtZW50LmJvZHkudmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwYkVsZW1lbnQuYm9keS5jYXNlID09PSAnY291bnRlcicpIHtcbiAgICAgICAgcmV0dXJuIGZyb21Db3VudGVyKHBiRWxlbWVudC5ib2R5LnZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGJFbGVtZW50LmJvZHkuY2FzZSA9PT0gJ3RyZWUnKSB7XG4gICAgICAgIHJldHVybiBmcm9tVHJlZShwYkVsZW1lbnQuYm9keS52YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgWW9ya2llRXJyb3IoZXJyb3JfQ29kZS5VbmltcGxlbWVudGVkLCBgdW5pbXBsZW1lbnRlZCBlbGVtZW50YCk7XG4gICAgfVxufVxuLyoqXG4gKiBgYnl0ZXNUb1NuYXBzaG90YCBjcmVhdGVzIGEgU25hcHNob3QgZnJvbSB0aGUgZ2l2ZW4gYnl0ZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb1NuYXBzaG90KGJ5dGVzKSB7XG4gICAgaWYgKCFieXRlcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm9vdDogQ1JEVE9iamVjdC5jcmVhdGUoSW5pdGlhbFRpbWVUaWNrZXQpLFxuICAgICAgICAgICAgcHJlc2VuY2VzOiBuZXcgTWFwKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHNuYXBzaG90ID0gcmVzb3VyY2VzX3BiLlNuYXBzaG90LmZyb21CaW5hcnkoYnl0ZXMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJvb3Q6IGZyb21FbGVtZW50KHNuYXBzaG90LnJvb3QpLFxuICAgICAgICBwcmVzZW5jZXM6IGZyb21QcmVzZW5jZXMoc25hcHNob3QucHJlc2VuY2VzKSxcbiAgICB9O1xufVxuLyoqXG4gKiBgYnl0ZXNUb09iamVjdGAgY3JlYXRlcyBhbiBKU09OT2JqZWN0IGZyb20gdGhlIGdpdmVuIGJ5dGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9PYmplY3QoYnl0ZXMpIHtcbiAgICBpZiAoIWJ5dGVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYnl0ZXMgaXMgZW1wdHknKTtcbiAgICB9XG4gICAgY29uc3QgcGJFbGVtZW50ID0gcmVzb3VyY2VzX3BiLkpTT05FbGVtZW50LmZyb21CaW5hcnkoYnl0ZXMpO1xuICAgIHJldHVybiBmcm9tT2JqZWN0KHBiRWxlbWVudC5ib2R5LnZhbHVlKTtcbn1cbi8qKlxuICogYG9iamVjdFRvQnl0ZXNgIGNvbnZlcnRzIHRoZSBnaXZlbiBKU09OT2JqZWN0IHRvIGJ5dGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvQnl0ZXMob2JqKSB7XG4gICAgcmV0dXJuIHRvRWxlbWVudChvYmopLnRvQmluYXJ5KCk7XG59XG4vKipcbiAqIGBieXRlc1RvQXJyYXlgIGNyZWF0ZXMgYW4gQ1JEVEFycmF5IGZyb20gdGhlIGdpdmVuIGJ5dGVzLlxuICovXG5mdW5jdGlvbiBieXRlc1RvQXJyYXkoYnl0ZXMpIHtcbiAgICBpZiAoIWJ5dGVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYnl0ZXMgaXMgZW1wdHknKTtcbiAgICB9XG4gICAgY29uc3QgcGJFbGVtZW50ID0gcmVzb3VyY2VzX3BiLkpTT05FbGVtZW50LmZyb21CaW5hcnkoYnl0ZXMpO1xuICAgIHJldHVybiBmcm9tQXJyYXkocGJFbGVtZW50LmJvZHkudmFsdWUpO1xufVxuLyoqXG4gKiBgYXJyYXlUb0J5dGVzYCBjb252ZXJ0cyB0aGUgZ2l2ZW4gQ1JEVEFycmF5IHRvIGJ5dGVzLlxuICovXG5mdW5jdGlvbiBhcnJheVRvQnl0ZXMoYXJyYXkpIHtcbiAgICByZXR1cm4gdG9BcnJheShhcnJheSkudG9CaW5hcnkoKTtcbn1cbi8qKlxuICogYGJ5dGVzVG9UcmVlYCBjcmVhdGVzIGFuIENSRFRUcmVlIGZyb20gdGhlIGdpdmVuIGJ5dGVzLlxuICovXG5mdW5jdGlvbiBieXRlc1RvVHJlZShieXRlcykge1xuICAgIGlmICghYnl0ZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdieXRlcyBpcyBlbXB0eScpO1xuICAgIH1cbiAgICBjb25zdCBwYkVsZW1lbnQgPSByZXNvdXJjZXNfcGIuSlNPTkVsZW1lbnQuZnJvbUJpbmFyeShieXRlcyk7XG4gICAgcmV0dXJuIGZyb21UcmVlKHBiRWxlbWVudC5ib2R5LnZhbHVlKTtcbn1cbi8qKlxuICogYHRyZWVUb0J5dGVzYCBjb252ZXJ0cyB0aGUgZ2l2ZW4gdHJlZSB0byBieXRlcy5cbiAqL1xuZnVuY3Rpb24gdHJlZVRvQnl0ZXModHJlZSkge1xuICAgIHJldHVybiB0b1RyZWUodHJlZSkudG9CaW5hcnkoKTtcbn1cbi8qKlxuICogYGJ5dGVzVG9IZXhgIGNyZWF0ZXMgYW4gaGV4IHN0cmluZyBmcm9tIHRoZSBnaXZlbiBieXRlIGFycmF5LlxuICovXG5mdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgaWYgKCFieXRlcykge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKGJ5dGVzKVxuICAgICAgICAubWFwKChiKSA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKVxuICAgICAgICAuam9pbignJyk7XG59XG4vKipcbiAqIGB0b0hleFN0cmluZ2AgY29udmVydHMgdGhlIGdpdmVuIGJ5dGUgYXJyYXkgdG8gaGV4IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9IZXhTdHJpbmcoYnl0ZXMpIHtcbiAgICByZXR1cm4gYnl0ZXNUb0hleChieXRlcyk7XG59XG4vKipcbiAqIGBoZXhUb0J5dGVzYCBjb252ZXJ0cyB0aGUgZ2l2ZW4gaGV4IHN0cmluZyB0byBieXRlIGFycmF5LlxuICovXG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShoZXgubWF0Y2goLy57MSwyfS9nKS5tYXAoKGJ5dGUpID0+IHBhcnNlSW50KGJ5dGUsIDE2KSkpO1xufVxuLyoqXG4gKiBgdG9Vbml0OEFycmF5YCBjb252ZXJ0cyB0aGUgZ2l2ZW4gaGV4IHN0cmluZyB0byBieXRlIGFycmF5LlxuICovXG5mdW5jdGlvbiB0b1VpbnQ4QXJyYXkoaGV4KSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMoaGV4KTtcbn1cbi8qKlxuICogYGNvbnZlcnRlcmAgaXMgYSBjb252ZXJ0ZXIgdGhhdCBjb252ZXJ0cyB0aGUgZ2l2ZW4gbW9kZWwgdG8gcHJvdG9idWYgZm9ybWF0LlxuICogaXMgYWxzbyB1c2VkIHRvIGNvbnZlcnQgbW9kZWxzIHRvIGJ5dGVzIGFuZCB2aWNlIHZlcnNhLlxuICovXG5jb25zdCBjb252ZXJ0ZXIgPSB7XG4gICAgZnJvbVByZXNlbmNlLFxuICAgIHRvQ2hhbmdlUGFjayxcbiAgICBmcm9tQ2hhbmdlUGFjayxcbiAgICBmcm9tQ2hhbmdlcyxcbiAgICBvYmplY3RUb0J5dGVzLFxuICAgIGJ5dGVzVG9PYmplY3QsXG4gICAgYnl0ZXNUb1NuYXBzaG90LFxuICAgIHRvSGV4U3RyaW5nLFxuICAgIHRvVWludDhBcnJheSxcbn07XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jbGllbnQvYXR0YWNobWVudC50c1xuXG4vKipcbiAqIGBBdHRhY2htZW50YCBpcyBhIGNsYXNzIHRoYXQgbWFuYWdlcyB0aGUgc3RhdGUgb2YgdGhlIGRvY3VtZW50LlxuICovXG5jbGFzcyBBdHRhY2htZW50IHtcbiAgICBjb25zdHJ1Y3RvcihyZWNvbm5lY3RTdHJlYW1EZWxheSwgZG9jLCBkb2NJRCwgaXNSZWFsdGltZVN5bmMpIHtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RTdHJlYW1EZWxheSA9IHJlY29ubmVjdFN0cmVhbURlbGF5O1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5kb2NJRCA9IGRvY0lEO1xuICAgICAgICB0aGlzLmlzUmVhbHRpbWVTeW5jID0gaXNSZWFsdGltZVN5bmM7XG4gICAgICAgIHRoaXMuc3luY01vZGUgPSBTeW5jTW9kZS5QdXNoUHVsbDtcbiAgICAgICAgdGhpcy5yZW1vdGVDaGFuZ2VFdmVudFJlY2VpdmVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBjaGFuZ2VSZWFsdGltZVN5bmNgIGNoYW5nZXMgd2hldGhlciB0byBzeW5jaHJvbml6ZSB0aGUgZG9jdW1lbnQgaW4gcmVhbHRpbWUgb3Igbm90LlxuICAgICAqL1xuICAgIGNoYW5nZVJlYWx0aW1lU3luYyhpc1JlYWx0aW1lU3luYykge1xuICAgICAgICBpZiAodGhpcy5pc1JlYWx0aW1lU3luYyA9PT0gaXNSZWFsdGltZVN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNSZWFsdGltZVN5bmMpIHtcbiAgICAgICAgICAgIHRoaXMuaXNSZWFsdGltZVN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW5jZWxXYXRjaFN0cmVhbSgpO1xuICAgICAgICB0aGlzLmlzUmVhbHRpbWVTeW5jID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgY2hhbmdlU3luY01vZGVgIGNoYW5nZXMgdGhlIHN5bmMgbW9kZSBvZiB0aGUgZG9jdW1lbnQuXG4gICAgICovXG4gICAgY2hhbmdlU3luY01vZGUoc3luY01vZGUpIHtcbiAgICAgICAgdGhpcy5zeW5jTW9kZSA9IHN5bmNNb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgbmVlZFJlYWx0aW1lU3luY2AgcmV0dXJucyB3aGV0aGVyIHRoZSBkb2N1bWVudCBuZWVkcyB0byBiZSBzeW5jZWQgaW4gcmVhbCB0aW1lLlxuICAgICAqL1xuICAgIG5lZWRSZWFsdGltZVN5bmMoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pc1JlYWx0aW1lU3luYyAmJlxuICAgICAgICAgICAgKHRoaXMuZG9jLmhhc0xvY2FsQ2hhbmdlcygpIHx8IHRoaXMucmVtb3RlQ2hhbmdlRXZlbnRSZWNlaXZlZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgcnVuV2F0Y2hMb29wYCBydW5zIHRoZSB3YXRjaCBsb29wLlxuICAgICAqL1xuICAgIGFzeW5jIHJ1bldhdGNoTG9vcCh3YXRjaFN0cmVhbUNyZWF0b3IpIHtcbiAgICAgICAgY29uc3QgZG9Mb29wID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMud2F0Y2hTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy53YXRjaExvb3BUaW1lcklEKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMud2F0Y2hMb29wVGltZXJJRCk7XG4gICAgICAgICAgICAgICAgdGhpcy53YXRjaExvb3BUaW1lcklEID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBbdGhpcy53YXRjaFN0cmVhbSwgdGhpcy53YXRjaEFib3J0Q29udHJvbGxlcl0gPVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB3YXRjaFN0cmVhbUNyZWF0b3IoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53YXRjaFN0cmVhbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud2F0Y2hBYm9ydENvbnRyb2xsZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndhdGNoTG9vcFRpbWVySUQgPSBzZXRUaW1lb3V0KGRvTG9vcCwgdGhpcy5yZWNvbm5lY3RTdHJlYW1EZWxheSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8oaGFja2Vyd2lucyk6IEZvciBub3csIGlmIHRoZSBjcmVhdGlvbiBvZiB0aGUgd2F0Y2ggc3RyZWFtIGZhaWxzLFxuICAgICAgICAgICAgICAgIC8vIGl0IGlzIGNvbnNpZGVyZWQgbm9ybWFsIGFuZCB0aGUgd2F0Y2ggbG9vcCBpcyBleGVjdXRlZCBhZ2FpbiBhZnRlciBhXG4gICAgICAgICAgICAgICAgLy8gY2VydGFpbiBwZXJpb2Qgb2YgdGltZS5cbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgZnV0dXJlLCB3ZSBuZWVkIHRvIGZpbmQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLlxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBhd2FpdCBkb0xvb3AoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGNhbmNlbFdhdGNoU3RyZWFtYCBjYW5jZWxzIHRoZSB3YXRjaCBzdHJlYW0uXG4gICAgICovXG4gICAgY2FuY2VsV2F0Y2hTdHJlYW0oKSB7XG4gICAgICAgIGlmICh0aGlzLndhdGNoU3RyZWFtICYmIHRoaXMud2F0Y2hBYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIHRoaXMud2F0Y2hBYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIHRoaXMud2F0Y2hTdHJlYW0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLndhdGNoQWJvcnRDb250cm9sbGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLndhdGNoTG9vcFRpbWVySUQpO1xuICAgICAgICB0aGlzLndhdGNoTG9vcFRpbWVySUQgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZG9jdW1lbnQvY2hhbmdlL2NvbnRleHQudHNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuXG4vKipcbiAqIGBDaGFuZ2VDb250ZXh0YCBpcyB1c2VkIHRvIHJlY29yZCB0aGUgY29udGV4dCBvZiBtb2RpZmljYXRpb24gd2hlbiBlZGl0aW5nXG4gKiBhIGRvY3VtZW50LiBFYWNoIHRpbWUgd2UgYWRkIGFuIG9wZXJhdGlvbiwgYSBuZXcgdGltZSB0aWNrZXQgaXMgaXNzdWVkLlxuICogRmluYWxseSByZXR1cm5zIGEgQ2hhbmdlIGFmdGVyIHRoZSBtb2RpZmljYXRpb24gaGFzIGJlZW4gY29tcGxldGVkLlxuICovXG5jbGFzcyBDaGFuZ2VDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihpZCwgcm9vdCwgcHJlc2VuY2UsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmRlbGltaXRlciA9IEluaXRpYWxEZWxpbWl0ZXI7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMub3BlcmF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnByZXZpb3VzUHJlc2VuY2UgPSBkZWVwY29weShwcmVzZW5jZSk7XG4gICAgICAgIHRoaXMucHJlc2VuY2VDaGFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmV2ZXJzZVByZXNlbmNlS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGNyZWF0ZWAgY3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBDaGFuZ2VDb250ZXh0LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoaWQsIHJvb3QsIHByZXNlbmNlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlQ29udGV4dChpZCwgcm9vdCwgcHJlc2VuY2UsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgcHVzaGAgcHVzaGVzIHRoZSBnaXZlbiBvcGVyYXRpb24gdG8gdGhpcyBjb250ZXh0LlxuICAgICAqL1xuICAgIHB1c2gob3BlcmF0aW9uKSB7XG4gICAgICAgIHRoaXMub3BlcmF0aW9ucy5wdXNoKG9wZXJhdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGByZWdpc3RlckVsZW1lbnRgIHJlZ2lzdGVycyB0aGUgZ2l2ZW4gZWxlbWVudCB0byB0aGUgcm9vdC5cbiAgICAgKi9cbiAgICByZWdpc3RlckVsZW1lbnQoZWxlbWVudCwgcGFyZW50KSB7XG4gICAgICAgIHRoaXMucm9vdC5yZWdpc3RlckVsZW1lbnQoZWxlbWVudCwgcGFyZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHJlZ2lzdGVyUmVtb3ZlZEVsZW1lbnRgIHJlZ2lzdGVyIHJlbW92ZWQgZWxlbWVudCBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyUmVtb3ZlZEVsZW1lbnQoZGVsZXRlZCkge1xuICAgICAgICB0aGlzLnJvb3QucmVnaXN0ZXJSZW1vdmVkRWxlbWVudChkZWxldGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHJlZ2lzdGVyRWxlbWVudEhhc1JlbW92ZWROb2Rlc2AgcmVnaXN0ZXIgR0MgZWxlbWVudCBoYXMgcmVtb3ZlZCBub2RlIGZvclxuICAgICAqIGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAgICAgKi9cbiAgICByZWdpc3RlckVsZW1lbnRIYXNSZW1vdmVkTm9kZXMoZWxlbSkge1xuICAgICAgICB0aGlzLnJvb3QucmVnaXN0ZXJFbGVtZW50SGFzUmVtb3ZlZE5vZGVzKGVsZW0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0Q2hhbmdlYCBjcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIENoYW5nZSBpbiB0aGlzIGNvbnRleHQuXG4gICAgICovXG4gICAgZ2V0Q2hhbmdlKCkge1xuICAgICAgICByZXR1cm4gQ2hhbmdlLmNyZWF0ZSh7XG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIG9wZXJhdGlvbnM6IHRoaXMub3BlcmF0aW9ucyxcbiAgICAgICAgICAgIHByZXNlbmNlQ2hhbmdlOiB0aGlzLnByZXNlbmNlQ2hhbmdlLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGhhc0NoYW5nZWAgcmV0dXJucyB3aGV0aGVyIHRoaXMgY29udGV4dCBoYXMgY2hhbmdlIG9yIG5vdC5cbiAgICAgKi9cbiAgICBoYXNDaGFuZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbnMubGVuZ3RoID4gMCB8fCB0aGlzLnByZXNlbmNlQ2hhbmdlICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBzZXRQcmVzZW5jZUNoYW5nZWAgcmVnaXN0ZXJzIHRoZSBwcmVzZW5jZSBjaGFuZ2UgdG8gdGhpcyBjb250ZXh0LlxuICAgICAqL1xuICAgIHNldFByZXNlbmNlQ2hhbmdlKHByZXNlbmNlQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMucHJlc2VuY2VDaGFuZ2UgPSBwcmVzZW5jZUNoYW5nZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHNldFJldmVyc2VQcmVzZW5jZWAgcmVnaXN0ZXJzIHRoZSBwcmV2aW91cyBwcmVzZW5jZSB0byB1bmRvIHByZXNlbmNlIHVwZGF0ZXMuXG4gICAgICovXG4gICAgc2V0UmV2ZXJzZVByZXNlbmNlKHByZXNlbmNlLCBvcHRpb24pIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocHJlc2VuY2UpKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uID09PSBudWxsIHx8IG9wdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9uLmFkZFRvSGlzdG9yeSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmV2ZXJzZVByZXNlbmNlS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmV2ZXJzZVByZXNlbmNlS2V5cy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdG9SZXZlcnNlUHJlc2VuY2VgIHJldHVybnMgdGhlIHJldmVyc2UgcHJlc2VuY2Ugb2YgdGhpcyBjb250ZXh0LlxuICAgICAqL1xuICAgIGdldFJldmVyc2VQcmVzZW5jZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmV2ZXJzZVByZXNlbmNlS2V5cy5zaXplID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcmV2ZXJzZVByZXNlbmNlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMucmV2ZXJzZVByZXNlbmNlS2V5cykge1xuICAgICAgICAgICAgcmV2ZXJzZVByZXNlbmNlW2tleV0gPSB0aGlzLnByZXZpb3VzUHJlc2VuY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV2ZXJzZVByZXNlbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgaXNzdWVUaW1lVGlja2V0YCBjcmVhdGVzIGEgdGltZSB0aWNrZXQgdG8gYmUgdXNlZCB0byBjcmVhdGUgYSBuZXcgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGlzc3VlVGltZVRpY2tldCgpIHtcbiAgICAgICAgdGhpcy5kZWxpbWl0ZXIgKz0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQuY3JlYXRlVGltZVRpY2tldCh0aGlzLmRlbGltaXRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRMYXN0VGltZVRpY2tldGAgcmV0dXJucyB0aGUgbGFzdCB0aW1lIHRpY2tldCBpc3N1ZWQgaW4gdGhpcyBjb250ZXh0LlxuICAgICAqL1xuICAgIGdldExhc3RUaW1lVGlja2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZC5jcmVhdGVUaW1lVGlja2V0KHRoaXMuZGVsaW1pdGVyKTtcbiAgICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kb2N1bWVudC9jcmR0L3Jvb3QudHNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuXG5cbi8qKlxuICogYENSRFRSb290YCBpcyBhIHN0cnVjdHVyZSB0aGF0IHJlcHJlc2VudHMgdGhlIHJvb3QuIEl0IGhhcyBhIGhhc2ggdGFibGUgb2ZcbiAqIGFsbCBlbGVtZW50cyB0byBmaW5kIGEgc3BlY2lmaWMgZWxlbWVudCB3aGVuIGFwcGx5aW5nIHJlbW90ZSBjaGFuZ2VzXG4gKiByZWNlaXZlZCBmcm9tIHNlcnZlci5cbiAqXG4gKiBFdmVyeSBlbGVtZW50IGhhcyBhIHVuaXF1ZSBgVGltZVRpY2tldGAgYXQgY3JlYXRpb24sIHdoaWNoIGFsbG93cyB1cyB0byBmaW5kXG4gKiBhIHBhcnRpY3VsYXIgZWxlbWVudC5cbiAqL1xuY2xhc3MgQ1JEVFJvb3Qge1xuICAgIGNvbnN0cnVjdG9yKHJvb3RPYmplY3QpIHtcbiAgICAgICAgdGhpcy5yb290T2JqZWN0ID0gcm9vdE9iamVjdDtcbiAgICAgICAgdGhpcy5lbGVtZW50UGFpck1hcEJ5Q3JlYXRlZEF0ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnJlbW92ZWRFbGVtZW50U2V0QnlDcmVhdGVkQXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZWxlbWVudEhhc1JlbW92ZWROb2Rlc1NldEJ5Q3JlYXRlZEF0ID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLm9wc0ZvclRlc3QgPSBbXTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckVsZW1lbnQocm9vdE9iamVjdCwgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGNyZWF0ZWAgY3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSb290LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ1JEVFJvb3QoQ1JEVE9iamVjdC5jcmVhdGUoSW5pdGlhbFRpbWVUaWNrZXQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGZpbmRCeUNyZWF0ZWRBdGAgcmV0dXJucyB0aGUgZWxlbWVudCBvZiBnaXZlbiBjcmVhdGlvbiB0aW1lLlxuICAgICAqL1xuICAgIGZpbmRCeUNyZWF0ZWRBdChjcmVhdGVkQXQpIHtcbiAgICAgICAgY29uc3QgcGFpciA9IHRoaXMuZWxlbWVudFBhaXJNYXBCeUNyZWF0ZWRBdC5nZXQoY3JlYXRlZEF0LnRvSURTdHJpbmcoKSk7XG4gICAgICAgIGlmICghcGFpcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYWlyLmVsZW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBmaW5kRWxlbWVudFBhaXJCeUNyZWF0ZWRBdGAgcmV0dXJucyB0aGUgZWxlbWVudCBhbmQgcGFyZW50IHBhaXJcbiAgICAgKiBvZiBnaXZlbiBjcmVhdGlvbiB0aW1lLlxuICAgICAqL1xuICAgIGZpbmRFbGVtZW50UGFpckJ5Q3JlYXRlZEF0KGNyZWF0ZWRBdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50UGFpck1hcEJ5Q3JlYXRlZEF0LmdldChjcmVhdGVkQXQudG9JRFN0cmluZygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGNyZWF0ZVN1YlBhdGhzYCBjcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBzdWIgcGF0aHMgZm9yIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqL1xuICAgIGNyZWF0ZVN1YlBhdGhzKGNyZWF0ZWRBdCkge1xuICAgICAgICBsZXQgcGFpciA9IHRoaXMuZWxlbWVudFBhaXJNYXBCeUNyZWF0ZWRBdC5nZXQoY3JlYXRlZEF0LnRvSURTdHJpbmcoKSk7XG4gICAgICAgIGlmICghcGFpcikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1YlBhdGhzID0gW107XG4gICAgICAgIHdoaWxlIChwYWlyLnBhcmVudCkge1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlZEF0ID0gcGFpci5lbGVtZW50LmdldENyZWF0ZWRBdCgpO1xuICAgICAgICAgICAgY29uc3Qgc3ViUGF0aCA9IHBhaXIucGFyZW50LnN1YlBhdGhPZihjcmVhdGVkQXQpO1xuICAgICAgICAgICAgaWYgKHN1YlBhdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5mYXRhbChgY2FudCBmaW5kIHRoZSBnaXZlbiBlbGVtZW50OiAke2NyZWF0ZWRBdC50b0lEU3RyaW5nKCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJQYXRocy51bnNoaWZ0KHN1YlBhdGgpO1xuICAgICAgICAgICAgcGFpciA9IHRoaXMuZWxlbWVudFBhaXJNYXBCeUNyZWF0ZWRBdC5nZXQocGFpci5wYXJlbnQuZ2V0Q3JlYXRlZEF0KCkudG9JRFN0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJQYXRocy51bnNoaWZ0KCckJyk7XG4gICAgICAgIHJldHVybiBzdWJQYXRocztcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGNyZWF0ZVBhdGhgIGNyZWF0ZXMgcGF0aCBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKi9cbiAgICBjcmVhdGVQYXRoKGNyZWF0ZWRBdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTdWJQYXRocyhjcmVhdGVkQXQpLmpvaW4oJy4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHJlZ2lzdGVyRWxlbWVudGAgcmVnaXN0ZXJzIHRoZSBnaXZlbiBlbGVtZW50IGFuZCBpdHMgZGVzY2VuZGFudHMgdG8gaGFzaCB0YWJsZS5cbiAgICAgKi9cbiAgICByZWdpc3RlckVsZW1lbnQoZWxlbWVudCwgcGFyZW50KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudFBhaXJNYXBCeUNyZWF0ZWRBdC5zZXQoZWxlbWVudC5nZXRDcmVhdGVkQXQoKS50b0lEU3RyaW5nKCksIHtcbiAgICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIENSRFRDb250YWluZXIpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuZ2V0RGVzY2VuZGFudHMoKGVsZW0sIHBhcmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJFbGVtZW50KGVsZW0sIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogYGRlcmVnaXN0ZXJFbGVtZW50YCBkZXJlZ2lzdGVyIHRoZSBnaXZlbiBlbGVtZW50IGFuZCBpdHMgZGVzY2VuZGFudHMgZnJvbSBoYXNoIHRhYmxlLlxuICAgICAqL1xuICAgIGRlcmVnaXN0ZXJFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgY29uc3QgZGVyZWdpc3RlckVsZW1lbnRJbnRlcm5hbCA9IChlbGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjcmVhdGVkQXQgPSBlbGVtLmdldENyZWF0ZWRBdCgpLnRvSURTdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudFBhaXJNYXBCeUNyZWF0ZWRBdC5kZWxldGUoY3JlYXRlZEF0KTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlZEVsZW1lbnRTZXRCeUNyZWF0ZWRBdC5kZWxldGUoY3JlYXRlZEF0KTtcbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICBpZiAoZWxlbSBpbnN0YW5jZW9mIENSRFRDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBlbGVtLmdldERlc2NlbmRhbnRzKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRlcmVnaXN0ZXJFbGVtZW50SW50ZXJuYWwoZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZGVyZWdpc3RlckVsZW1lbnRJbnRlcm5hbChlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgcmVnaXN0ZXJSZW1vdmVkRWxlbWVudGAgcmVnaXN0ZXJzIHRoZSBnaXZlbiBlbGVtZW50IHRvIHRoZSBoYXNoIHNldC5cbiAgICAgKi9cbiAgICByZWdpc3RlclJlbW92ZWRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVkRWxlbWVudFNldEJ5Q3JlYXRlZEF0LmFkZChlbGVtZW50LmdldENyZWF0ZWRBdCgpLnRvSURTdHJpbmcoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGByZWdpc3RlckVsZW1lbnRIYXNSZW1vdmVkTm9kZXNgIHJlZ2lzdGVycyB0aGUgZ2l2ZW4gR0MgZWxlbWVudCB0byB0aGVcbiAgICAgKiBoYXNoIHNldC5cbiAgICAgKi9cbiAgICByZWdpc3RlckVsZW1lbnRIYXNSZW1vdmVkTm9kZXMoZWxlbSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRIYXNSZW1vdmVkTm9kZXNTZXRCeUNyZWF0ZWRBdC5hZGQoZWxlbS5nZXRDcmVhdGVkQXQoKS50b0lEU3RyaW5nKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0RWxlbWVudE1hcFNpemVgIHJldHVybnMgdGhlIHNpemUgb2YgZWxlbWVudCBtYXAuXG4gICAgICovXG4gICAgZ2V0RWxlbWVudE1hcFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRQYWlyTWFwQnlDcmVhdGVkQXQuc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldFJlbW92ZWRFbGVtZW50U2V0U2l6ZSgpYCByZXR1cm5zIHRoZSBzaXplIG9mIHJlbW92ZWQgZWxlbWVudCBzZXQuXG4gICAgICovXG4gICAgZ2V0UmVtb3ZlZEVsZW1lbnRTZXRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVkRWxlbWVudFNldEJ5Q3JlYXRlZEF0LnNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRPYmplY3RgIHJldHVybnMgcm9vdCBvYmplY3QuXG4gICAgICovXG4gICAgZ2V0T2JqZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290T2JqZWN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0R2FyYmFnZUxlbmAgcmV0dXJucyBsZW5ndGggb2Ygbm9kZXMgd2hpY2ggY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxuICAgICAqL1xuICAgIGdldEdhcmJhZ2VMZW4oKSB7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgY3JlYXRlZEF0IG9mIHRoaXMucmVtb3ZlZEVsZW1lbnRTZXRCeUNyZWF0ZWRBdCkge1xuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSB0aGlzLmVsZW1lbnRQYWlyTWFwQnlDcmVhdGVkQXQuZ2V0KGNyZWF0ZWRBdCk7XG4gICAgICAgICAgICBpZiAocGFpci5lbGVtZW50IGluc3RhbmNlb2YgQ1JEVENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHBhaXIuZWxlbWVudC5nZXREZXNjZW5kYW50cygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGNyZWF0ZWRBdCBvZiB0aGlzLmVsZW1lbnRIYXNSZW1vdmVkTm9kZXNTZXRCeUNyZWF0ZWRBdCkge1xuICAgICAgICAgICAgY29uc3QgcGFpciA9IHRoaXMuZWxlbWVudFBhaXJNYXBCeUNyZWF0ZWRBdC5nZXQoY3JlYXRlZEF0KTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW0gPSBwYWlyLmVsZW1lbnQ7XG4gICAgICAgICAgICBjb3VudCArPSBlbGVtLmdldFJlbW92ZWROb2Rlc0xlbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGRlZXBjb3B5YCBjb3BpZXMgaXRzZWxmIGRlZXBseS5cbiAgICAgKi9cbiAgICBkZWVwY29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDUkRUUm9vdCh0aGlzLnJvb3RPYmplY3QuZGVlcGNvcHkoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnYXJiYWdlQ29sbGVjdGAgcHVyZ2VzIGVsZW1lbnRzIHRoYXQgd2VyZSByZW1vdmVkIGJlZm9yZSB0aGUgZ2l2ZW4gdGltZS5cbiAgICAgKi9cbiAgICBnYXJiYWdlQ29sbGVjdCh0aWNrZXQpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBjcmVhdGVkQXQgb2YgdGhpcy5yZW1vdmVkRWxlbWVudFNldEJ5Q3JlYXRlZEF0KSB7XG4gICAgICAgICAgICBjb25zdCBwYWlyID0gdGhpcy5lbGVtZW50UGFpck1hcEJ5Q3JlYXRlZEF0LmdldChjcmVhdGVkQXQpO1xuICAgICAgICAgICAgaWYgKHBhaXIuZWxlbWVudC5nZXRSZW1vdmVkQXQoKSAmJlxuICAgICAgICAgICAgICAgIHRpY2tldC5jb21wYXJlKHBhaXIuZWxlbWVudC5nZXRSZW1vdmVkQXQoKSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHBhaXIucGFyZW50LnB1cmdlKHBhaXIuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgY291bnQgKz0gdGhpcy5kZXJlZ2lzdGVyRWxlbWVudChwYWlyLmVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY3JlYXRlZEF0IG9mIHRoaXMuZWxlbWVudEhhc1JlbW92ZWROb2Rlc1NldEJ5Q3JlYXRlZEF0KSB7XG4gICAgICAgICAgICBjb25zdCBwYWlyID0gdGhpcy5lbGVtZW50UGFpck1hcEJ5Q3JlYXRlZEF0LmdldChjcmVhdGVkQXQpO1xuICAgICAgICAgICAgY29uc3QgZWxlbSA9IHBhaXIuZWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWROb2RlQ250ID0gZWxlbS5wdXJnZVJlbW92ZWROb2Rlc0JlZm9yZSh0aWNrZXQpO1xuICAgICAgICAgICAgaWYgKHJlbW92ZWROb2RlQ250ID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudEhhc1JlbW92ZWROb2Rlc1NldEJ5Q3JlYXRlZEF0LmRlbGV0ZShlbGVtLmdldENyZWF0ZWRBdCgpLnRvSURTdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudCArPSByZW1vdmVkTm9kZUNudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0b0pTT05gIHJldHVybnMgdGhlIEpTT04gZW5jb2Rpbmcgb2YgdGhpcyByb290IG9iamVjdC5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RPYmplY3QudG9KU09OKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0b1NvcnRlZEpTT05gIHJldHVybnMgdGhlIHNvcnRlZCBKU09OIGVuY29kaW5nIG9mIHRoaXMgcm9vdCBvYmplY3QuXG4gICAgICovXG4gICAgdG9Tb3J0ZWRKU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290T2JqZWN0LnRvU29ydGVkSlNPTigpO1xuICAgIH1cbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2RvY3VtZW50L2pzb24vb2JqZWN0LnRzXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgVGhlIFlvcmtpZSBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5cblxuXG5cbi8qKlxuICogYGNyZWF0ZUpTT05PYmplY3RgIGNyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgSlNPTk9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSlNPTk9iamVjdChjb250ZXh0LCB0YXJnZXQpIHtcbiAgICBjb25zdCBvYmplY3RQcm94eSA9IG5ldyBPYmplY3RQcm94eShjb250ZXh0KTtcbiAgICByZXR1cm4gbmV3IFByb3h5KHRhcmdldCwgb2JqZWN0UHJveHkuZ2V0SGFuZGxlcnMoKSk7XG59XG4vKipcbiAqIGBPYmplY3RQcm94eWAgaXMgYSBwcm94eSByZXByZXNlbnRpbmcgYE9iamVjdGAuXG4gKi9cbmNsYXNzIE9iamVjdFByb3h5IHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSB7XG4gICAgICAgICAgICBzZXQ6ICh0YXJnZXQsIGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobG9nZ2VyLmlzRW5hYmxlZChMb2dMZXZlbC5Ucml2aWFsKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudHJpdmlhbChgb2JqWyR7a2V5fV09JHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE9iamVjdFByb3h5LnNldEludGVybmFsKGNvbnRleHQsIHRhcmdldCwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0LCBrZXlPck1ldGhvZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsb2dnZXIuaXNFbmFibGVkKExvZ0xldmVsLlRyaXZpYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50cml2aWFsKGBvYmpbJHtrZXlPck1ldGhvZH1dYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrZXlPck1ldGhvZCA9PT0gJ2dldElEJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5nZXRDcmVhdGVkQXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5T3JNZXRob2QgPT09ICd0b0pTT04nIHx8IGtleU9yTWV0aG9kID09PSAndG9TdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LnRvSlNPTigpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXlPck1ldGhvZCA9PT0gJ3RvSlMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LnRvSlMoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5T3JNZXRob2QgPT09ICd0b0pTRm9yVGVzdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQudG9KU0ZvclRlc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvSlNPTkVsZW1lbnQoY29udGV4dCwgdGFyZ2V0LmdldChrZXlPck1ldGhvZCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG93bktleXM6ICh0YXJnZXQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmdldEtleXMoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWxldGVQcm9wZXJ0eTogKHRhcmdldCwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2dlci5pc0VuYWJsZWQoTG9nTGV2ZWwuVHJpdmlhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRyaXZpYWwoYG9ialske2tleX1dYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE9iamVjdFByb3h5LmRlbGV0ZUludGVybmFsKGNvbnRleHQsIHRhcmdldCwga2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBzZXRJbnRlcm5hbGAgc2V0cyBhIG5ldyBPYmplY3QgZm9yIHRoZSBnaXZlbiBrZXlcbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0SW50ZXJuYWwoY29udGV4dCwgdGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChrZXkuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFlvcmtpZUVycm9yKGVycm9yX0NvZGUuSW52YWxpZE9iamVjdEtleSwgYGtleSBtdXN0IG5vdCBjb250YWluIHRoZSAnLicuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3JlYXRlZEF0ID0gY29udGV4dC5pc3N1ZVRpbWVUaWNrZXQoKTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGJ1aWxkQ1JEVEVsZW1lbnQoY29udGV4dCwgdmFsdWUsIGNyZWF0ZWRBdCk7XG4gICAgICAgIGNvbnN0IHJlbW92ZWQgPSB0YXJnZXQuc2V0KGtleSwgZWxlbWVudCwgY3JlYXRlZEF0KTtcbiAgICAgICAgY29udGV4dC5yZWdpc3RlckVsZW1lbnQoZWxlbWVudCwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICAgIGNvbnRleHQucmVnaXN0ZXJSZW1vdmVkRWxlbWVudChyZW1vdmVkKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnB1c2goU2V0T3BlcmF0aW9uLmNyZWF0ZShrZXksIGVsZW1lbnQuZGVlcGNvcHkoKSwgdGFyZ2V0LmdldENyZWF0ZWRBdCgpLCBjcmVhdGVkQXQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGJ1aWxkT2JqZWN0TWVtYmVyc2AgY29uc3RydWN0cyBhbiBvYmplY3Qgd2hlcmUgYWxsIHZhbHVlcyBmcm9tIHRoZVxuICAgICAqIHVzZXItcHJvdmlkZWQgb2JqZWN0IGFyZSB0cmFuc2Zvcm1lZCBpbnRvIENSRFRFbGVtZW50cy5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIG9iamVjdCBhbmQgaXRlcmF0ZXMgdGhyb3VnaCBpdHMgdmFsdWVzLFxuICAgICAqIGNvbnZlcnRpbmcgZWFjaCB2YWx1ZSBpbnRvIGEgY29ycmVzcG9uZGluZyBDUkRURWxlbWVudC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnVpbGRPYmplY3RNZW1iZXJzKGNvbnRleHQsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lbWJlcnMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoay5pbmNsdWRlcygnLicpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFlvcmtpZUVycm9yKGVycm9yX0NvZGUuSW52YWxpZE9iamVjdEtleSwgYGtleSBtdXN0IG5vdCBjb250YWluIHRoZSAnLicuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjcmVhdGVkQXQgPSBjb250ZXh0Lmlzc3VlVGltZVRpY2tldCgpO1xuICAgICAgICAgICAgY29uc3QgZWxlbSA9IGJ1aWxkQ1JEVEVsZW1lbnQoY29udGV4dCwgdiwgY3JlYXRlZEF0KTtcbiAgICAgICAgICAgIG1lbWJlcnNba10gPSBlbGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1iZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZGVsZXRlSW50ZXJuYWxgIGRlbGV0ZXMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBrZXkuXG4gICAgICovXG4gICAgc3RhdGljIGRlbGV0ZUludGVybmFsKGNvbnRleHQsIHRhcmdldCwga2V5KSB7XG4gICAgICAgIGNvbnN0IHRpY2tldCA9IGNvbnRleHQuaXNzdWVUaW1lVGlja2V0KCk7XG4gICAgICAgIGNvbnN0IGRlbGV0ZWQgPSB0YXJnZXQuZGVsZXRlQnlLZXkoa2V5LCB0aWNrZXQpO1xuICAgICAgICBpZiAoIWRlbGV0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnB1c2goUmVtb3ZlT3BlcmF0aW9uLmNyZWF0ZSh0YXJnZXQuZ2V0Q3JlYXRlZEF0KCksIGRlbGV0ZWQuZ2V0Q3JlYXRlZEF0KCksIHRpY2tldCkpO1xuICAgICAgICBjb250ZXh0LnJlZ2lzdGVyUmVtb3ZlZEVsZW1lbnQoZGVsZXRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRIYW5kbGVyc2AgZ2V0cyBoYW5kbGVycy5cbiAgICAgKi9cbiAgICBnZXRIYW5kbGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlcnM7XG4gICAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZG9jdW1lbnQvanNvbi9hcnJheS50c1xuLypcbiAqIENvcHlyaWdodCAyMDIwIFRoZSBZb3JraWUgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuXG5cblxuXG5cbi8qKlxuICogYGNyZWF0ZUpTT05BcnJheWAgY3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBKU09OQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUpTT05BcnJheShjb250ZXh0LCB0YXJnZXQpIHtcbiAgICBjb25zdCBhcnJheVByb3h5ID0gbmV3IEFycmF5UHJveHkoY29udGV4dCwgdGFyZ2V0KTtcbiAgICByZXR1cm4gbmV3IFByb3h5KHRhcmdldCwgYXJyYXlQcm94eS5nZXRIYW5kbGVycygpKTtcbn1cbi8qKlxuICogYGlzTnVtZXJpY1N0cmluZ2AgY2hlY2tzIGlmIHZhbHVlIGlzIG51bWVyaWMgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBpc051bWVyaWNTdHJpbmcodmFsKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHZhbCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICByZXR1cm4gIWlzTmFOKHZhbCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogYGlzUmVhZE9ubHlBcnJheU1ldGhvZGAgY2hlY2tzIGlmIHRoZSBtZXRob2QgaXMgYSBzdGFuZGFyZCBhcnJheSByZWFkLW9ubHkgb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiBpc1JlYWRPbmx5QXJyYXlNZXRob2QobWV0aG9kKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgJ2NvbmNhdCcsXG4gICAgICAgICdlbnRyaWVzJyxcbiAgICAgICAgJ2V2ZXJ5JyxcbiAgICAgICAgJ2ZpbHRlcicsXG4gICAgICAgICdmaW5kJyxcbiAgICAgICAgJ2ZpbmRJbmRleCcsXG4gICAgICAgICdmb3JFYWNoJyxcbiAgICAgICAgJ2pvaW4nLFxuICAgICAgICAna2V5cycsXG4gICAgICAgICdtYXAnLFxuICAgICAgICAncmVkdWNlJyxcbiAgICAgICAgJ3JlZHVjZVJpZ2h0JyxcbiAgICAgICAgJ3NsaWNlJyxcbiAgICAgICAgJ3NvbWUnLFxuICAgICAgICAndG9Mb2NhbGVTdHJpbmcnLFxuICAgICAgICAndG9TdHJpbmcnLFxuICAgICAgICAndmFsdWVzJyxcbiAgICBdLmluY2x1ZGVzKG1ldGhvZCk7XG59XG4vKipcbiAqIGBBcnJheVByb3h5YCBpcyBhIHByb3h5IGZvciBBcnJheS5cbiAqL1xuY2xhc3MgQXJyYXlQcm94eSB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgYXJyYXkpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0ge1xuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0LCBtZXRob2QsIHJlY2VpdmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ2dldElEJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5nZXRDcmVhdGVkQXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWV0aG9kID09PSAnZ2V0RWxlbWVudEJ5SUQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoY3JlYXRlZEF0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGVtID0gdGFyZ2V0LmdldEJ5SUQoY3JlYXRlZEF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZWxlbSB8fCBlbGVtLmlzUmVtb3ZlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvV3JhcHBlZEVsZW1lbnQoY29udGV4dCwgZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1ldGhvZCA9PT0gJ2dldEVsZW1lbnRCeUluZGV4Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGVtID0gdGFyZ2V0LmdldChpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9XcmFwcGVkRWxlbWVudChjb250ZXh0LCBlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWV0aG9kID09PSAnZ2V0TGFzdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b1dyYXBwZWRFbGVtZW50KGNvbnRleHQsIHRhcmdldC5nZXRMYXN0KCkpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXRob2QgPT09ICdkZWxldGVCeUlEJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGNyZWF0ZWRBdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsZXRlZCA9IEFycmF5UHJveHkuZGVsZXRlSW50ZXJuYWxCeUlEKGNvbnRleHQsIHRhcmdldCwgY3JlYXRlZEF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b1dyYXBwZWRFbGVtZW50KGNvbnRleHQsIGRlbGV0ZWQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXRob2QgPT09ICdpbnNlcnRBZnRlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChwcmV2SUQsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnNlcnRlZCA9IEFycmF5UHJveHkuaW5zZXJ0QWZ0ZXJJbnRlcm5hbChjb250ZXh0LCB0YXJnZXQsIHByZXZJRCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvV3JhcHBlZEVsZW1lbnQoY29udGV4dCwgaW5zZXJ0ZWQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXRob2QgPT09ICdpbnNlcnRCZWZvcmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobmV4dElELCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zZXJ0ZWQgPSBBcnJheVByb3h5Lmluc2VydEJlZm9yZUludGVybmFsKGNvbnRleHQsIHRhcmdldCwgbmV4dElELCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9XcmFwcGVkRWxlbWVudChjb250ZXh0LCBpbnNlcnRlZCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1ldGhvZCA9PT0gJ21vdmVCZWZvcmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobmV4dElELCBpZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXlQcm94eS5tb3ZlQmVmb3JlSW50ZXJuYWwoY29udGV4dCwgdGFyZ2V0LCBuZXh0SUQsIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSmF2YVNjcmlwdCBOYXRpdmUgQVBJXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1ldGhvZCA9PT0gJ21vdmVBZnRlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChwcmV2SUQsIGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBcnJheVByb3h5Lm1vdmVBZnRlckludGVybmFsKGNvbnRleHQsIHRhcmdldCwgcHJldklELCBpZCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1ldGhvZCA9PT0gJ21vdmVGcm9udCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXlQcm94eS5tb3ZlRnJvbnRJbnRlcm5hbChjb250ZXh0LCB0YXJnZXQsIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWV0aG9kID09PSAnbW92ZUxhc3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoaWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5UHJveHkubW92ZUxhc3RJbnRlcm5hbChjb250ZXh0LCB0YXJnZXQsIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNOdW1lcmljU3RyaW5nKG1ldGhvZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvSlNPTkVsZW1lbnQoY29udGV4dCwgdGFyZ2V0LmdldChOdW1iZXIobWV0aG9kKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXRob2QgPT09ICdwdXNoJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXlQcm94eS5wdXNoSW50ZXJuYWwoY29udGV4dCwgdGFyZ2V0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1ldGhvZCA9PT0gJ3NwbGljZScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChzdGFydCwgZGVsZXRlQ291bnQsIC4uLml0ZW1zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXlQcm94eS5zcGxpY2UoY29udGV4dCwgdGFyZ2V0LCBzdGFydCwgZGVsZXRlQ291bnQsIC4uLml0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWV0aG9kID09PSAnbGVuZ3RoJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ3N5bWJvbCcgJiYgbWV0aG9kID09PSBTeW1ib2wuaXRlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5UHJveHkuaXRlcmF0b3JJbnRlcm5hbC5iaW5kKHRoaXMsIGNvbnRleHQsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1ldGhvZCA9PT0gJ2luY2x1ZGVzJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5UHJveHkuaW5jbHVkZXMoY29udGV4dCwgdGFyZ2V0LCBzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXRob2QgPT09ICdpbmRleE9mJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5UHJveHkuaW5kZXhPZihjb250ZXh0LCB0YXJnZXQsIHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1ldGhvZCA9PT0gJ2xhc3RJbmRleE9mJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5UHJveHkubGFzdEluZGV4T2YoY29udGV4dCwgdGFyZ2V0LCBzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXRob2QgPT09ICd0b1Rlc3RTdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBBcnJheVByb3h5LnRvVGVzdFN0cmluZyh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbWV0aG9kID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICBpc1JlYWRPbmx5QXJyYXlNZXRob2QobWV0aG9kKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyciA9IEFycmF5LmZyb20odGFyZ2V0KS5tYXAoKGVsZW0pID0+IHRvSlNPTkVsZW1lbnQoY29udGV4dCwgZWxlbSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZVttZXRob2RdLmFwcGx5KGFyciwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRPRE8gd2UgbmVlZCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIHRoZSBjYXNlIHdlIG5lZWQgdG8gY2FsbCBkZWZhdWx0XG4gICAgICAgICAgICAgICAgLy8gYmVoYXZpb3IgYW5kIHRoZSBjYXNlIHdoZXJlIHdlIG5lZWQgdG8gY2FsbCBhbiBpbnRlcm5hbCBtZXRob2RcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCBtZXRob2Q6ICR7U3RyaW5nKG1ldGhvZCl9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgbWV0aG9kLCByZWNlaXZlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVsZXRlUHJvcGVydHk6ICh0YXJnZXQsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsb2dnZXIuaXNFbmFibGVkKExvZ0xldmVsLlRyaXZpYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50cml2aWFsKGBhcnJheVske2tleX1dYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEFycmF5UHJveHkuZGVsZXRlSW50ZXJuYWxCeUluZGV4KGNvbnRleHQsIHRhcmdldCwgTnVtYmVyLnBhcnNlSW50KGtleSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbiAgICBzdGF0aWMgKml0ZXJhdG9ySW50ZXJuYWwoY2hhbmdlLCB0YXJnZXQpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtIG9mIHRhcmdldCkge1xuICAgICAgICAgICAgeWllbGQgdG9XcmFwcGVkRWxlbWVudChjaGFuZ2UsIGVsZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBidWlsZEFycmF5RWxlbWVudHNgIGNvbnN0cnVjdHMgYXJyYXkgZWxlbWVudHMgYmFzZWQgb24gdGhlIHVzZXItcHJvdmlkZWQgYXJyYXkuXG4gICAgICovXG4gICAgc3RhdGljIGJ1aWxkQXJyYXlFbGVtZW50cyhjb250ZXh0LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWRBdCA9IGNvbnRleHQuaXNzdWVUaW1lVGlja2V0KCk7XG4gICAgICAgICAgICBjb25zdCBlbGVtID0gYnVpbGRDUkRURWxlbWVudChjb250ZXh0LCB2LCBjcmVhdGVkQXQpO1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBwdXNoSW50ZXJuYWxgIHB1c2hlcyB0aGUgdmFsdWUgdG8gdGhlIHRhcmdldCBhcnJheS5cbiAgICAgKi9cbiAgICBzdGF0aWMgcHVzaEludGVybmFsKGNvbnRleHQsIHRhcmdldCwgdmFsdWUpIHtcbiAgICAgICAgQXJyYXlQcm94eS5pbnNlcnRBZnRlckludGVybmFsKGNvbnRleHQsIHRhcmdldCwgdGFyZ2V0LmdldExhc3RDcmVhdGVkQXQoKSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0Lmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYG1vdmVCZWZvcmVJbnRlcm5hbGAgbW92ZXMgdGhlIGdpdmVuIGBjcmVhdGVkQXRgIGVsZW1lbnRcbiAgICAgKiBhZnRlciB0aGUgcHJldmlvdXNseSBjcmVhdGVkIGVsZW1lbnQuXG4gICAgICovXG4gICAgc3RhdGljIG1vdmVCZWZvcmVJbnRlcm5hbChjb250ZXh0LCB0YXJnZXQsIG5leHRDcmVhdGVkQXQsIGNyZWF0ZWRBdCkge1xuICAgICAgICBjb25zdCB0aWNrZXQgPSBjb250ZXh0Lmlzc3VlVGltZVRpY2tldCgpO1xuICAgICAgICBjb25zdCBwcmV2Q3JlYXRlZEF0ID0gdGFyZ2V0LmdldFByZXZDcmVhdGVkQXQobmV4dENyZWF0ZWRBdCk7XG4gICAgICAgIHRhcmdldC5tb3ZlQWZ0ZXIocHJldkNyZWF0ZWRBdCwgY3JlYXRlZEF0LCB0aWNrZXQpO1xuICAgICAgICBjb250ZXh0LnB1c2goTW92ZU9wZXJhdGlvbi5jcmVhdGUodGFyZ2V0LmdldENyZWF0ZWRBdCgpLCBwcmV2Q3JlYXRlZEF0LCBjcmVhdGVkQXQsIHRpY2tldCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgbW92ZUFmdGVySW50ZXJuYWxgIG1vdmVzIHRoZSBnaXZlbiBgY3JlYXRlZEF0YCBlbGVtZW50XG4gICAgICogYWZ0ZXIgdGhlIHNwZWNpZmljIGVsZW1lbnQuXG4gICAgICovXG4gICAgc3RhdGljIG1vdmVBZnRlckludGVybmFsKGNvbnRleHQsIHRhcmdldCwgcHJldkNyZWF0ZWRBdCwgY3JlYXRlZEF0KSB7XG4gICAgICAgIGNvbnN0IHRpY2tldCA9IGNvbnRleHQuaXNzdWVUaW1lVGlja2V0KCk7XG4gICAgICAgIHRhcmdldC5tb3ZlQWZ0ZXIocHJldkNyZWF0ZWRBdCwgY3JlYXRlZEF0LCB0aWNrZXQpO1xuICAgICAgICBjb250ZXh0LnB1c2goTW92ZU9wZXJhdGlvbi5jcmVhdGUodGFyZ2V0LmdldENyZWF0ZWRBdCgpLCBwcmV2Q3JlYXRlZEF0LCBjcmVhdGVkQXQsIHRpY2tldCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgbW92ZUZyb250SW50ZXJuYWxgIG1vdmVzIHRoZSBnaXZlbiBgY3JlYXRlZEF0YCBlbGVtZW50XG4gICAgICogYXQgdGhlIGZpcnN0IG9mIGFycmF5LlxuICAgICAqL1xuICAgIHN0YXRpYyBtb3ZlRnJvbnRJbnRlcm5hbChjb250ZXh0LCB0YXJnZXQsIGNyZWF0ZWRBdCkge1xuICAgICAgICBjb25zdCB0aWNrZXQgPSBjb250ZXh0Lmlzc3VlVGltZVRpY2tldCgpO1xuICAgICAgICBjb25zdCBoZWFkID0gdGFyZ2V0LmdldEhlYWQoKTtcbiAgICAgICAgdGFyZ2V0Lm1vdmVBZnRlcihoZWFkLmdldENyZWF0ZWRBdCgpLCBjcmVhdGVkQXQsIHRpY2tldCk7XG4gICAgICAgIGNvbnRleHQucHVzaChNb3ZlT3BlcmF0aW9uLmNyZWF0ZSh0YXJnZXQuZ2V0Q3JlYXRlZEF0KCksIGhlYWQuZ2V0Q3JlYXRlZEF0KCksIGNyZWF0ZWRBdCwgdGlja2V0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBtb3ZlTGFzdEludGVybmFsYCBtb3ZlcyB0aGUgZ2l2ZW4gYGNyZWF0ZWRBdGAgZWxlbWVudFxuICAgICAqIGF0IHRoZSBsYXN0IG9mIGFycmF5LlxuICAgICAqL1xuICAgIHN0YXRpYyBtb3ZlTGFzdEludGVybmFsKGNvbnRleHQsIHRhcmdldCwgY3JlYXRlZEF0KSB7XG4gICAgICAgIGNvbnN0IHRpY2tldCA9IGNvbnRleHQuaXNzdWVUaW1lVGlja2V0KCk7XG4gICAgICAgIGNvbnN0IGxhc3QgPSB0YXJnZXQuZ2V0TGFzdENyZWF0ZWRBdCgpO1xuICAgICAgICB0YXJnZXQubW92ZUFmdGVyKGxhc3QsIGNyZWF0ZWRBdCwgdGlja2V0KTtcbiAgICAgICAgY29udGV4dC5wdXNoKE1vdmVPcGVyYXRpb24uY3JlYXRlKHRhcmdldC5nZXRDcmVhdGVkQXQoKSwgbGFzdCwgY3JlYXRlZEF0LCB0aWNrZXQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGluc2VydEFmdGVySW50ZXJuYWxgIGluc2VydHMgdGhlIHZhbHVlIGFmdGVyIHRoZSBwcmV2aW91c2x5IGNyZWF0ZWQgZWxlbWVudC5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW5zZXJ0QWZ0ZXJJbnRlcm5hbChjb250ZXh0LCB0YXJnZXQsIHByZXZDcmVhdGVkQXQsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNyZWF0ZWRBdCA9IGNvbnRleHQuaXNzdWVUaW1lVGlja2V0KCk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBidWlsZENSRFRFbGVtZW50KGNvbnRleHQsIHZhbHVlLCBjcmVhdGVkQXQpO1xuICAgICAgICB0YXJnZXQuaW5zZXJ0QWZ0ZXIocHJldkNyZWF0ZWRBdCwgZWxlbWVudCk7XG4gICAgICAgIGNvbnRleHQucmVnaXN0ZXJFbGVtZW50KGVsZW1lbnQsIHRhcmdldCk7XG4gICAgICAgIGNvbnRleHQucHVzaChBZGRPcGVyYXRpb24uY3JlYXRlKHRhcmdldC5nZXRDcmVhdGVkQXQoKSwgcHJldkNyZWF0ZWRBdCwgZWxlbWVudC5kZWVwY29weSgpLCBjcmVhdGVkQXQpKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBpbnNlcnRCZWZvcmVJbnRlcm5hbGAgaW5zZXJ0cyB0aGUgdmFsdWUgYmVmb3JlIHRoZSBwcmV2aW91c2x5IGNyZWF0ZWQgZWxlbWVudC5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW5zZXJ0QmVmb3JlSW50ZXJuYWwoY29udGV4dCwgdGFyZ2V0LCBuZXh0Q3JlYXRlZEF0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQXJyYXlQcm94eS5pbnNlcnRBZnRlckludGVybmFsKGNvbnRleHQsIHRhcmdldCwgdGFyZ2V0LmdldFByZXZDcmVhdGVkQXQobmV4dENyZWF0ZWRBdCksIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGRlbGV0ZUludGVybmFsQnlJbmRleGAgZGVsZXRlcyB0YXJnZXQgZWxlbWVudCBvZiBnaXZlbiBpbmRleC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVsZXRlSW50ZXJuYWxCeUluZGV4KGNvbnRleHQsIHRhcmdldCwgaW5kZXgpIHtcbiAgICAgICAgY29uc3QgdGlja2V0ID0gY29udGV4dC5pc3N1ZVRpbWVUaWNrZXQoKTtcbiAgICAgICAgY29uc3QgZGVsZXRlZCA9IHRhcmdldC5kZWxldGVCeUluZGV4KGluZGV4LCB0aWNrZXQpO1xuICAgICAgICBpZiAoIWRlbGV0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnB1c2goUmVtb3ZlT3BlcmF0aW9uLmNyZWF0ZSh0YXJnZXQuZ2V0Q3JlYXRlZEF0KCksIGRlbGV0ZWQuZ2V0Q3JlYXRlZEF0KCksIHRpY2tldCkpO1xuICAgICAgICBjb250ZXh0LnJlZ2lzdGVyUmVtb3ZlZEVsZW1lbnQoZGVsZXRlZCk7XG4gICAgICAgIHJldHVybiBkZWxldGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZGVsZXRlSW50ZXJuYWxCeUlEYCBkZWxldGVzIHRoZSBlbGVtZW50IG9mIHRoZSBnaXZlbiBJRC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVsZXRlSW50ZXJuYWxCeUlEKGNvbnRleHQsIHRhcmdldCwgY3JlYXRlZEF0KSB7XG4gICAgICAgIGNvbnN0IHRpY2tldCA9IGNvbnRleHQuaXNzdWVUaW1lVGlja2V0KCk7XG4gICAgICAgIGNvbnN0IGRlbGV0ZWQgPSB0YXJnZXQuZGVsZXRlKGNyZWF0ZWRBdCwgdGlja2V0KTtcbiAgICAgICAgY29udGV4dC5wdXNoKFJlbW92ZU9wZXJhdGlvbi5jcmVhdGUodGFyZ2V0LmdldENyZWF0ZWRBdCgpLCBkZWxldGVkLmdldENyZWF0ZWRBdCgpLCB0aWNrZXQpKTtcbiAgICAgICAgY29udGV4dC5yZWdpc3RlclJlbW92ZWRFbGVtZW50KGRlbGV0ZWQpO1xuICAgICAgICByZXR1cm4gZGVsZXRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHNwbGljZWAgaXMgYSBtZXRob2QgdG8gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGFycmF5LlxuICAgICAqL1xuICAgIHN0YXRpYyBzcGxpY2UoY29udGV4dCwgdGFyZ2V0LCBzdGFydCwgZGVsZXRlQ291bnQsIC4uLml0ZW1zKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHRhcmdldC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGZyb20gPSBzdGFydCA+PSAwID8gTWF0aC5taW4oc3RhcnQsIGxlbmd0aCkgOiBNYXRoLm1heChsZW5ndGggKyBzdGFydCwgMCk7XG4gICAgICAgIGNvbnN0IHRvID0gZGVsZXRlQ291bnQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBsZW5ndGhcbiAgICAgICAgICAgIDogZGVsZXRlQ291bnQgPCAwXG4gICAgICAgICAgICAgICAgPyBmcm9tXG4gICAgICAgICAgICAgICAgOiBNYXRoLm1pbihmcm9tICsgZGVsZXRlQ291bnQsIGxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHJlbW92ZWRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZCA9IEFycmF5UHJveHkuZGVsZXRlSW50ZXJuYWxCeUluZGV4KGNvbnRleHQsIHRhcmdldCwgZnJvbSk7XG4gICAgICAgICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRFbGVtID0gcmVtb3ZlZC5kZWVwY29weSgpO1xuICAgICAgICAgICAgICAgIHJlbW92ZWRFbGVtLnNldFJlbW92ZWRBdCgpO1xuICAgICAgICAgICAgICAgIHJlbW92ZWRzLnB1c2godG9KU09ORWxlbWVudChjb250ZXh0LCByZW1vdmVkRWxlbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtcykge1xuICAgICAgICAgICAgbGV0IHByZXZpb3VzSUQgPSBmcm9tID09PSAwID8gdGFyZ2V0LmdldEhlYWQoKS5nZXRJRCgpIDogdGFyZ2V0LmdldChmcm9tIC0gMSkuZ2V0SUQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0VsZW0gPSBBcnJheVByb3h5Lmluc2VydEFmdGVySW50ZXJuYWwoY29udGV4dCwgdGFyZ2V0LCBwcmV2aW91c0lELCBpdGVtKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c0lEID0gbmV3RWxlbS5nZXRJRCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW1vdmVkcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGluY2x1ZGVzYCByZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgaW4gdGhlIGFycmF5LlxuICAgICAqL1xuICAgIHN0YXRpYyBpbmNsdWRlcyhjb250ZXh0LCB0YXJnZXQsIHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHRhcmdldC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGZyb20gPSBmcm9tSW5kZXggPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICA6IGZyb21JbmRleCA8IDBcbiAgICAgICAgICAgICAgICA/IE1hdGgubWF4KGZyb21JbmRleCArIGxlbmd0aCwgMClcbiAgICAgICAgICAgICAgICA6IGZyb21JbmRleDtcbiAgICAgICAgaWYgKGZyb20gPj0gbGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoUHJpbWl0aXZlLmlzU3VwcG9ydChzZWFyY2hFbGVtZW50KSkge1xuICAgICAgICAgICAgY29uc3QgYXJyID0gQXJyYXkuZnJvbSh0YXJnZXQpLm1hcCgoZWxlbSkgPT4gdG9KU09ORWxlbWVudChjb250ZXh0LCBlbGVtKSk7XG4gICAgICAgICAgICByZXR1cm4gYXJyLmluY2x1ZGVzKHNlYXJjaEVsZW1lbnQsIGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgoKF9hID0gdGFyZ2V0LmdldChpKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldElEKCkpID09PSBzZWFyY2hFbGVtZW50LmdldElEKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBpbmRleE9mYCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW5kZXhPZihjb250ZXh0LCB0YXJnZXQsIHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHRhcmdldC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGZyb20gPSBmcm9tSW5kZXggPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICA6IGZyb21JbmRleCA8IDBcbiAgICAgICAgICAgICAgICA/IE1hdGgubWF4KGZyb21JbmRleCArIGxlbmd0aCwgMClcbiAgICAgICAgICAgICAgICA6IGZyb21JbmRleDtcbiAgICAgICAgaWYgKGZyb20gPj0gbGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoUHJpbWl0aXZlLmlzU3VwcG9ydChzZWFyY2hFbGVtZW50KSkge1xuICAgICAgICAgICAgY29uc3QgYXJyID0gQXJyYXkuZnJvbSh0YXJnZXQpLm1hcCgoZWxlbSkgPT4gdG9KU09ORWxlbWVudChjb250ZXh0LCBlbGVtKSk7XG4gICAgICAgICAgICByZXR1cm4gYXJyLmluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCgoX2EgPSB0YXJnZXQuZ2V0KGkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0SUQoKSkgPT09IHNlYXJjaEVsZW1lbnQuZ2V0SUQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGxhc3RJbmRleE9mYCByZXR1cm5zIHRoZSBsYXN0IGluZGV4IG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqL1xuICAgIHN0YXRpYyBsYXN0SW5kZXhPZihjb250ZXh0LCB0YXJnZXQsIHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHRhcmdldC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGZyb20gPSBmcm9tSW5kZXggPT09IHVuZGVmaW5lZCB8fCBmcm9tSW5kZXggPj0gbGVuZ3RoXG4gICAgICAgICAgICA/IGxlbmd0aCAtIDFcbiAgICAgICAgICAgIDogZnJvbUluZGV4IDwgMFxuICAgICAgICAgICAgICAgID8gZnJvbUluZGV4ICsgbGVuZ3RoXG4gICAgICAgICAgICAgICAgOiBmcm9tSW5kZXg7XG4gICAgICAgIGlmIChmcm9tIDwgMClcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgaWYgKFByaW1pdGl2ZS5pc1N1cHBvcnQoc2VhcmNoRWxlbWVudCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyciA9IEFycmF5LmZyb20odGFyZ2V0KS5tYXAoKGVsZW0pID0+IHRvSlNPTkVsZW1lbnQoY29udGV4dCwgZWxlbSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFyci5sYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50LCBmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKCgoX2EgPSB0YXJnZXQuZ2V0KGkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0SUQoKSkgPT09IHNlYXJjaEVsZW1lbnQuZ2V0SUQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRvVGVzdFN0cmluZ2AgcmV0dXJucyBhIFN0cmluZyBjb250YWluaW5nIHRoZSBtZXRhIGRhdGEgb2YgdGhlIG5vZGVcbiAgICAgKiBmb3IgZGVidWdnaW5nIHB1cnBvc2UuXG4gICAgICovXG4gICAgc3RhdGljIHRvVGVzdFN0cmluZyh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldC50b1Rlc3RTdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldEhhbmRsZXJzYCBnZXRzIGhhbmRsZXJzLlxuICAgICAqL1xuICAgIGdldEhhbmRsZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVycztcbiAgICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kb2N1bWVudC9qc29uL3RleHQudHNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuXG5cblxuLyoqXG4gKiBgVGV4dGAgaXMgYW4gZXh0ZW5kZWQgZGF0YSB0eXBlIGZvciB0aGUgY29udGVudHMgb2YgYSB0ZXh0IGVkaXRvci5cbiAqL1xuY2xhc3MgVGV4dCB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgdGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgaW5pdGlhbGl6ZWAgaW5pdGlhbGl6ZSB0aGlzIHRleHQgd2l0aCBjb250ZXh0IGFuZCBpbnRlcm5hbCB0ZXh0LlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGluaXRpYWxpemUoY29udGV4dCwgdGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0SURgIHJldHVybnMgdGhlIElEIG9mIHRoaXMgdGV4dC5cbiAgICAgKi9cbiAgICBnZXRJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dC5nZXRJRCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZWRpdGAgZWRpdHMgdGhpcyB0ZXh0IHdpdGggdGhlIGdpdmVuIGNvbnRlbnQuXG4gICAgICovXG4gICAgZWRpdChmcm9tSWR4LCB0b0lkeCwgY29udGVudCwgYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dCB8fCAhdGhpcy50ZXh0KSB7XG4gICAgICAgICAgICBsb2dnZXIuZmF0YWwoJ2l0IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbUlkeCA+IHRvSWR4KSB7XG4gICAgICAgICAgICBsb2dnZXIuZmF0YWwoJ2Zyb20gc2hvdWxkIGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0bycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhbmdlID0gdGhpcy50ZXh0LmluZGV4UmFuZ2VUb1Bvc1JhbmdlKGZyb21JZHgsIHRvSWR4KTtcbiAgICAgICAgaWYgKGxvZ2dlci5pc0VuYWJsZWQoTG9nTGV2ZWwuRGVidWcpKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoYEVESVQ6IGY6JHtmcm9tSWR4fS0+JHtyYW5nZVswXS50b1Rlc3RTdHJpbmcoKX0sIHQ6JHt0b0lkeH0tPiR7cmFuZ2VbMV0udG9UZXN0U3RyaW5nKCl9IGM6JHtjb250ZW50fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0dHJzID0gYXR0cmlidXRlcyA/IHN0cmluZ2lmeU9iamVjdFZhbHVlcyhhdHRyaWJ1dGVzKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgdGlja2V0ID0gdGhpcy5jb250ZXh0Lmlzc3VlVGltZVRpY2tldCgpO1xuICAgICAgICBjb25zdCBbbWF4Q3JlYXRlZEF0TWFwQnlBY3RvciwgLCByYW5nZUFmdGVyRWRpdF0gPSB0aGlzLnRleHQuZWRpdChyYW5nZSwgY29udGVudCwgdGlja2V0LCBhdHRycyk7XG4gICAgICAgIHRoaXMuY29udGV4dC5wdXNoKG5ldyBFZGl0T3BlcmF0aW9uKHRoaXMudGV4dC5nZXRDcmVhdGVkQXQoKSwgcmFuZ2VbMF0sIHJhbmdlWzFdLCBtYXhDcmVhdGVkQXRNYXBCeUFjdG9yLCBjb250ZW50LCBhdHRycyA/IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoYXR0cnMpKSA6IG5ldyBNYXAoKSwgdGlja2V0KSk7XG4gICAgICAgIGlmICghcmFuZ2VbMF0uZXF1YWxzKHJhbmdlWzFdKSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlZ2lzdGVyRWxlbWVudEhhc1JlbW92ZWROb2Rlcyh0aGlzLnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQuZmluZEluZGV4ZXNGcm9tUmFuZ2UocmFuZ2VBZnRlckVkaXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZGVsZXRlYCBkZWxldGVzIHRoZSB0ZXh0IGluIHRoZSBnaXZlbiByYW5nZS5cbiAgICAgKi9cbiAgICBkZWxldGUoZnJvbUlkeCwgdG9JZHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdChmcm9tSWR4LCB0b0lkeCwgJycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZW1wdHlgIG1ha2VzIHRoZSB0ZXh0IGVtcHR5LlxuICAgICAqL1xuICAgIGVtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0KDAsIHRoaXMubGVuZ3RoLCAnJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBzZXRTdHlsZWAgc3R5bGVzIHRoaXMgdGV4dCB3aXRoIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuICAgICAqL1xuICAgIHNldFN0eWxlKGZyb21JZHgsIHRvSWR4LCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0IHx8ICF0aGlzLnRleHQpIHtcbiAgICAgICAgICAgIGxvZ2dlci5mYXRhbCgnaXQgaXMgbm90IGluaXRpYWxpemVkIHlldCcpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tSWR4ID4gdG9JZHgpIHtcbiAgICAgICAgICAgIGxvZ2dlci5mYXRhbCgnZnJvbSBzaG91bGQgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRvJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmFuZ2UgPSB0aGlzLnRleHQuaW5kZXhSYW5nZVRvUG9zUmFuZ2UoZnJvbUlkeCwgdG9JZHgpO1xuICAgICAgICBpZiAobG9nZ2VyLmlzRW5hYmxlZChMb2dMZXZlbC5EZWJ1ZykpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgU1RZTDogZjoke2Zyb21JZHh9LT4ke3JhbmdlWzBdLnRvVGVzdFN0cmluZygpfSwgdDoke3RvSWR4fS0+JHtyYW5nZVsxXS50b1Rlc3RTdHJpbmcoKX0gYToke0pTT04uc3RyaW5naWZ5KGF0dHJpYnV0ZXMpfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0dHJzID0gc3RyaW5naWZ5T2JqZWN0VmFsdWVzKGF0dHJpYnV0ZXMpO1xuICAgICAgICBjb25zdCB0aWNrZXQgPSB0aGlzLmNvbnRleHQuaXNzdWVUaW1lVGlja2V0KCk7XG4gICAgICAgIGNvbnN0IFttYXhDcmVhdGVkQXRNYXBCeUFjdG9yXSA9IHRoaXMudGV4dC5zZXRTdHlsZShyYW5nZSwgYXR0cnMsIHRpY2tldCk7XG4gICAgICAgIHRoaXMuY29udGV4dC5wdXNoKG5ldyBTdHlsZU9wZXJhdGlvbih0aGlzLnRleHQuZ2V0Q3JlYXRlZEF0KCksIHJhbmdlWzBdLCByYW5nZVsxXSwgbWF4Q3JlYXRlZEF0TWFwQnlBY3RvciwgbmV3IE1hcChPYmplY3QuZW50cmllcyhhdHRycykpLCB0aWNrZXQpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBpbmRleFJhbmdlVG9Qb3NSYW5nZWAgcmV0dXJucyBUZXh0UmFuZ2VTdHJ1Y3Qgb2YgdGhlIGdpdmVuIGluZGV4IHJhbmdlLlxuICAgICAqL1xuICAgIGluZGV4UmFuZ2VUb1Bvc1JhbmdlKHJhbmdlKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0IHx8ICF0aGlzLnRleHQpIHtcbiAgICAgICAgICAgIGxvZ2dlci5mYXRhbCgnaXQgaXMgbm90IGluaXRpYWxpemVkIHlldCcpO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRleHRSYW5nZSA9IHRoaXMudGV4dC5pbmRleFJhbmdlVG9Qb3NSYW5nZShyYW5nZVswXSwgcmFuZ2VbMV0pO1xuICAgICAgICByZXR1cm4gW3RleHRSYW5nZVswXS50b1N0cnVjdCgpLCB0ZXh0UmFuZ2VbMV0udG9TdHJ1Y3QoKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBwb3NSYW5nZVRvSW5kZXhSYW5nZWAgcmV0dXJucyBpbmRleGVzIG9mIHRoZSBnaXZlbiBUZXh0UmFuZ2VTdHJ1Y3QuXG4gICAgICovXG4gICAgcG9zUmFuZ2VUb0luZGV4UmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQgfHwgIXRoaXMudGV4dCkge1xuICAgICAgICAgICAgbG9nZ2VyLmZhdGFsKCdpdCBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0Jyk7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dFJhbmdlID0gdGhpcy50ZXh0LmZpbmRJbmRleGVzRnJvbVJhbmdlKFtcbiAgICAgICAgICAgIFJHQVRyZWVTcGxpdFBvcy5mcm9tU3RydWN0KHJhbmdlWzBdKSxcbiAgICAgICAgICAgIFJHQVRyZWVTcGxpdFBvcy5mcm9tU3RydWN0KHJhbmdlWzFdKSxcbiAgICAgICAgXSk7XG4gICAgICAgIHJldHVybiBbdGV4dFJhbmdlWzBdLCB0ZXh0UmFuZ2VbMV1dO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdG9UZXN0U3RyaW5nYCByZXR1cm5zIGEgU3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1ldGEgZGF0YSBvZiB0aGUgbm9kZVxuICAgICAqIGZvciBkZWJ1Z2dpbmcgcHVycG9zZS5cbiAgICAgKi9cbiAgICB0b1Rlc3RTdHJpbmcoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0IHx8ICF0aGlzLnRleHQpIHtcbiAgICAgICAgICAgIGxvZ2dlci5mYXRhbCgnaXQgaXMgbm90IGluaXRpYWxpemVkIHlldCcpO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQudG9UZXN0U3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB2YWx1ZXNgIHJldHVybnMgdmFsdWVzIG9mIHRoaXMgdGV4dC5cbiAgICAgKi9cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0IHx8ICF0aGlzLnRleHQpIHtcbiAgICAgICAgICAgIGxvZ2dlci5mYXRhbCgnaXQgaXMgbm90IGluaXRpYWxpemVkIHlldCcpO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQudmFsdWVzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBsZW5ndGhgIHJldHVybnMgc2l6ZSBvZiBSR0FUcmVlTGlzdC5cbiAgICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGNoZWNrV2VpZ2h0YCByZXR1cm5zIGZhbHNlIHdoZW4gdGhlcmUgaXMgYW4gaW5jb3JyZWN0IHdlaWdodCBub2RlLlxuICAgICAqIGZvciBkZWJ1Z2dpbmcgcHVycG9zZS5cbiAgICAgKi9cbiAgICBjaGVja1dlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dC5jaGVja1dlaWdodCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdG9TdHJpbmdgIHJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHRleHQuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0IHx8ICF0aGlzLnRleHQpIHtcbiAgICAgICAgICAgIGxvZ2dlci5mYXRhbCgnaXQgaXMgbm90IGluaXRpYWxpemVkIHlldCcpO1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGNyZWF0ZVJhbmdlRm9yVGVzdGAgcmV0dXJucyBwYWlyIG9mIFJHQVRyZWVTcGxpdE5vZGVQb3Mgb2YgdGhlIGdpdmVuIGluZGV4ZXNcbiAgICAgKiBmb3IgdGVzdGluZyBwdXJwb3NlLlxuICAgICAqL1xuICAgIGNyZWF0ZVJhbmdlRm9yVGVzdChmcm9tSWR4LCB0b0lkeCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dCB8fCAhdGhpcy50ZXh0KSB7XG4gICAgICAgICAgICBsb2dnZXIuZmF0YWwoJ2l0IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQnKTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50ZXh0LmluZGV4UmFuZ2VUb1Bvc1JhbmdlKGZyb21JZHgsIHRvSWR4KTtcbiAgICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kb2N1bWVudC9qc29uL2NvdW50ZXIudHNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuXG4vKipcbiAqIGBDb3VudGVyYCBpcyBhIGN1c3RvbSBkYXRhIHR5cGUgdGhhdCBpcyB1c2VkIHRvIGNvdW50ZXIuXG4gKi9cbmNsYXNzIENvdW50ZXIge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlVHlwZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZVR5cGUgPSB2YWx1ZVR5cGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGluaXRpYWxpemVgIGluaXRpYWxpemUgdGhpcyB0ZXh0IHdpdGggY29udGV4dCBhbmQgaW50ZXJuYWwgdGV4dC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBpbml0aWFsaXplKGNvbnRleHQsIGNvdW50ZXIpIHtcbiAgICAgICAgdGhpcy52YWx1ZVR5cGUgPSBjb3VudGVyLmdldFZhbHVlVHlwZSgpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmNvdW50ZXIgPSBjb3VudGVyO1xuICAgICAgICB0aGlzLnZhbHVlID0gY291bnRlci5nZXRWYWx1ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0SURgIHJldHVybnMgdGhlIElEIG9mIHRoaXMgdGV4dC5cbiAgICAgKi9cbiAgICBnZXRJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY291bnRlci5nZXRJRCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0VmFsdWVgIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoaXMgY291bnRlcjtcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRWYWx1ZVR5cGVgIHJldHVybnMgdGhlIHZhbHVlIHR5cGUgb2YgdGhpcyBjb3VudGVyLlxuICAgICAqL1xuICAgIGdldFZhbHVlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVUeXBlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgaW5jcmVhc2VgIGluY3JlYXNlcyBudW1lcmljIGRhdGEuXG4gICAgICovXG4gICAgaW5jcmVhc2Uodikge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dCB8fCAhdGhpcy5jb3VudGVyKSB7XG4gICAgICAgICAgICBsb2dnZXIuZmF0YWwoJ2l0IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQnKTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aWNrZXQgPSB0aGlzLmNvbnRleHQuaXNzdWVUaW1lVGlja2V0KCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gUHJpbWl0aXZlLm9mKHYsIHRpY2tldCk7XG4gICAgICAgIGlmICghdmFsdWUuaXNOdW1lcmljVHlwZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0eXBlIG9mIHZhbHVlOiAke3R5cGVvZiB2YWx1ZS5nZXRWYWx1ZSgpfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY291bnRlci5pbmNyZWFzZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuY29udGV4dC5wdXNoKEluY3JlYXNlT3BlcmF0aW9uLmNyZWF0ZSh0aGlzLmNvdW50ZXIuZ2V0Q3JlYXRlZEF0KCksIHZhbHVlLCB0aWNrZXQpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZG9jdW1lbnQvanNvbi90cmVlLnRzXG4vKlxuICogQ29weXJpZ2h0IDIwMjMgVGhlIFlvcmtpZSBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5cblxuXG5cblxuXG4vKipcbiAqIGBidWlsZERlc2NlbmRhbnRzYCBidWlsZHMgZGVzY2VuZGFudHMgb2YgdGhlIGdpdmVuIHRyZWUgbm9kZS5cbiAqL1xuZnVuY3Rpb24gYnVpbGREZXNjZW5kYW50cyh0cmVlTm9kZSwgcGFyZW50LCBjb250ZXh0KSB7XG4gICAgY29uc3QgeyB0eXBlIH0gPSB0cmVlTm9kZTtcbiAgICBjb25zdCB0aWNrZXQgPSBjb250ZXh0Lmlzc3VlVGltZVRpY2tldCgpO1xuICAgIGlmICh0eXBlID09PSBEZWZhdWx0VGV4dFR5cGUpIHtcbiAgICAgICAgdmFsaWRhdGVUZXh0Tm9kZSh0cmVlTm9kZSk7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IHRyZWVOb2RlO1xuICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9IENSRFRUcmVlTm9kZS5jcmVhdGUoQ1JEVFRyZWVOb2RlSUQub2YodGlja2V0LCAwKSwgdHlwZSwgdmFsdWUpO1xuICAgICAgICBwYXJlbnQuYXBwZW5kKHRleHROb2RlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW4gPSBbXSB9ID0gdHJlZU5vZGU7XG4gICAgICAgIGxldCB7IGF0dHJpYnV0ZXMgfSA9IHRyZWVOb2RlO1xuICAgICAgICBsZXQgYXR0cnM7XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cmlidXRlcyA9PT0gJ29iamVjdCcgJiYgIWlzRW1wdHkoYXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSBzdHJpbmdpZnlPYmplY3RWYWx1ZXMoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICBhdHRycyA9IG5ldyBSSFQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICAgICAgYXR0cnMuc2V0KGtleSwgdmFsdWUsIHRpY2tldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxlbWVudE5vZGUgPSBDUkRUVHJlZU5vZGUuY3JlYXRlKENSRFRUcmVlTm9kZUlELm9mKHRpY2tldCwgMCksIHR5cGUsIHVuZGVmaW5lZCwgYXR0cnMpO1xuICAgICAgICBwYXJlbnQuYXBwZW5kKGVsZW1lbnROb2RlKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgICAgICAgYnVpbGREZXNjZW5kYW50cyhjaGlsZCwgZWxlbWVudE5vZGUsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBjcmVhdGVDUkRUVHJlZU5vZGUgcmV0dXJucyBDUkRUVHJlZU5vZGUgYnkgZ2l2ZW4gVHJlZU5vZGUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNSRFRUcmVlTm9kZShjb250ZXh0LCBjb250ZW50KSB7XG4gICAgY29uc3QgeyB0eXBlIH0gPSBjb250ZW50O1xuICAgIGNvbnN0IHRpY2tldCA9IGNvbnRleHQuaXNzdWVUaW1lVGlja2V0KCk7XG4gICAgbGV0IHJvb3Q7XG4gICAgaWYgKGNvbnRlbnQudHlwZSA9PT0gRGVmYXVsdFRleHRUeXBlKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IGNvbnRlbnQ7XG4gICAgICAgIHJvb3QgPSBDUkRUVHJlZU5vZGUuY3JlYXRlKENSRFRUcmVlTm9kZUlELm9mKHRpY2tldCwgMCksIHR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGVudCkge1xuICAgICAgICBjb25zdCB7IGNoaWxkcmVuID0gW10gfSA9IGNvbnRlbnQ7XG4gICAgICAgIGxldCB7IGF0dHJpYnV0ZXMgfSA9IGNvbnRlbnQ7XG4gICAgICAgIGxldCBhdHRycztcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzID09PSAnb2JqZWN0JyAmJiAhaXNFbXB0eShhdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgYXR0cmlidXRlcyA9IHN0cmluZ2lmeU9iamVjdFZhbHVlcyhhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIGF0dHJzID0gbmV3IFJIVCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgICAgICBhdHRycy5zZXQoa2V5LCB2YWx1ZSwgdGlja2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByb290ID0gQ1JEVFRyZWVOb2RlLmNyZWF0ZShDUkRUVHJlZU5vZGVJRC5vZihjb250ZXh0Lmlzc3VlVGltZVRpY2tldCgpLCAwKSwgdHlwZSwgdW5kZWZpbmVkLCBhdHRycyk7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGJ1aWxkRGVzY2VuZGFudHMoY2hpbGQsIHJvb3QsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByb290O1xufVxuLyoqXG4gKiBgdmFsaWRhdGVUZXh0Tm9kZWAgZW5zdXJlcyB0aGF0IGEgdGV4dCBub2RlIGhhcyBhIG5vbi1lbXB0eSBzdHJpbmcgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlVGV4dE5vZGUodGV4dE5vZGUpIHtcbiAgICBpZiAoIXRleHROb2RlLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RleHQgbm9kZSBjYW5ub3QgaGF2ZSBlbXB0eSB2YWx1ZScpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogYHZhbGlkYXRlVHJlZU5vZGVzYCBlbnN1cmVzIHRoYXQgdHJlZU5vZGVzIGNvbnNpc3RzIG9mIG9ubHkgb25lIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlVHJlZU5vZGVzKHRyZWVOb2Rlcykge1xuICAgIGlmICghdHJlZU5vZGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RUcmVlTm9kZVR5cGUgPSB0cmVlTm9kZXNbMF0udHlwZTtcbiAgICBpZiAoZmlyc3RUcmVlTm9kZVR5cGUgPT09IERlZmF1bHRUZXh0VHlwZSkge1xuICAgICAgICBmb3IgKGNvbnN0IHRyZWVOb2RlIG9mIHRyZWVOb2Rlcykge1xuICAgICAgICAgICAgY29uc3QgeyB0eXBlIH0gPSB0cmVlTm9kZTtcbiAgICAgICAgICAgIGlmICh0eXBlICE9PSBEZWZhdWx0VGV4dFR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VsZW1lbnQgbm9kZSBhbmQgdGV4dCBub2RlIGNhbm5vdCBiZSBwYXNzZWQgdG9nZXRoZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbGlkYXRlVGV4dE5vZGUodHJlZU5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IHRyZWVOb2RlIG9mIHRyZWVOb2Rlcykge1xuICAgICAgICAgICAgY29uc3QgeyB0eXBlIH0gPSB0cmVlTm9kZTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBEZWZhdWx0VGV4dFR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VsZW1lbnQgbm9kZSBhbmQgdGV4dCBub2RlIGNhbm5vdCBiZSBwYXNzZWQgdG9nZXRoZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogYFRyZWVgIGlzIGEgQ1JEVC1iYXNlZCB0cmVlIHN0cnVjdHVyZSB0aGF0IGlzIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBkb2N1bWVudFxuICogdHJlZSBvZiB0ZXh0LWJhc2VkIGVkaXRvciBzdWNoIGFzIFByb3NlTWlycm9yLlxuICovXG5jbGFzcyBUcmVlIHtcbiAgICBjb25zdHJ1Y3Rvcihpbml0aWFsUm9vdCkge1xuICAgICAgICB0aGlzLmluaXRpYWxSb290ID0gaW5pdGlhbFJvb3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBpbml0aWFsaXplYCBpbml0aWFsaXplIHRoaXMgdHJlZSB3aXRoIGNvbnRleHQgYW5kIGludGVybmFsIHRyZWUuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZShjb250ZXh0LCB0cmVlKSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRJRGAgcmV0dXJucyB0aGUgSUQgb2YgdGhpcyB0cmVlLlxuICAgICAqL1xuICAgIGdldElEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlLmdldElEKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBidWlsZFJvb3RgIGJ1aWxkcyB0aGUgcm9vdCBvZiB0aGlzIHRyZWUgd2l0aCB0aGUgZ2l2ZW4gaW5pdGlhbCByb290XG4gICAgICogd2hpY2ggc2V0IGJ5IHRoZSB1c2VyLlxuICAgICAqL1xuICAgIGJ1aWxkUm9vdChjb250ZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy5pbml0aWFsUm9vdCkge1xuICAgICAgICAgICAgcmV0dXJuIENSRFRUcmVlTm9kZS5jcmVhdGUoQ1JEVFRyZWVOb2RlSUQub2YoY29udGV4dC5pc3N1ZVRpbWVUaWNrZXQoKSwgMCksIERlZmF1bHRSb290VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyhoYWNrZXJ3aW5zKTogTmVlZCB0byB1c2UgdGhlIHRpY2tldCBvZiBvcGVyYXRpb24gb2YgY3JlYXRpbmcgdHJlZS5cbiAgICAgICAgY29uc3Qgcm9vdCA9IENSRFRUcmVlTm9kZS5jcmVhdGUoQ1JEVFRyZWVOb2RlSUQub2YoY29udGV4dC5pc3N1ZVRpbWVUaWNrZXQoKSwgMCksIHRoaXMuaW5pdGlhbFJvb3QudHlwZSk7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5pbml0aWFsUm9vdC5jaGlsZHJlbikge1xuICAgICAgICAgICAgYnVpbGREZXNjZW5kYW50cyhjaGlsZCwgcm9vdCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRTaXplYCByZXR1cm5zIHRoZSBzaXplIG9mIHRoaXMgdHJlZS5cbiAgICAgKi9cbiAgICBnZXRTaXplKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dCB8fCAhdGhpcy50cmVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2l0IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50cmVlLmdldFNpemUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldEluZGV4VHJlZWAgcmV0dXJucyB0aGUgaW5kZXggdHJlZSBvZiB0aGlzIHRyZWUuXG4gICAgICovXG4gICAgZ2V0SW5kZXhUcmVlKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dCB8fCAhdGhpcy50cmVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2l0IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50cmVlLmdldEluZGV4VHJlZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgc3R5bGVCeVBhdGhgIHNldHMgdGhlIGF0dHJpYnV0ZXMgdG8gdGhlIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBwYXRoLlxuICAgICAqL1xuICAgIHN0eWxlQnlQYXRoKHBhdGgsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQgfHwgIXRoaXMudHJlZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpdCBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXRoIHNob3VsZCBub3QgYmUgZW1wdHknKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbZnJvbVBvcywgdG9Qb3NdID0gdGhpcy50cmVlLnBhdGhUb1Bvc1JhbmdlKHBhdGgpO1xuICAgICAgICBjb25zdCB0aWNrZXQgPSB0aGlzLmNvbnRleHQuaXNzdWVUaW1lVGlja2V0KCk7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gYXR0cmlidXRlcyA/IHN0cmluZ2lmeU9iamVjdFZhbHVlcyhhdHRyaWJ1dGVzKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy50cmVlLnN0eWxlKFtmcm9tUG9zLCB0b1Bvc10sIGF0dHJzLCB0aWNrZXQpO1xuICAgICAgICB0aGlzLmNvbnRleHQucHVzaChUcmVlU3R5bGVPcGVyYXRpb24uY3JlYXRlKHRoaXMudHJlZS5nZXRDcmVhdGVkQXQoKSwgZnJvbVBvcywgdG9Qb3MsIGF0dHJzID8gbmV3IE1hcChPYmplY3QuZW50cmllcyhhdHRycykpIDogbmV3IE1hcCgpLCB0aWNrZXQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHN0eWxlYCBzZXRzIHRoZSBhdHRyaWJ1dGVzIHRvIHRoZSBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gcmFuZ2UuXG4gICAgICovXG4gICAgc3R5bGUoZnJvbUlkeCwgdG9JZHgsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQgfHwgIXRoaXMudHJlZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpdCBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21JZHggPiB0b0lkeCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmcm9tIHNob3VsZCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdG8nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcm9tUG9zID0gdGhpcy50cmVlLmZpbmRQb3MoZnJvbUlkeCk7XG4gICAgICAgIGNvbnN0IHRvUG9zID0gdGhpcy50cmVlLmZpbmRQb3ModG9JZHgpO1xuICAgICAgICBjb25zdCB0aWNrZXQgPSB0aGlzLmNvbnRleHQuaXNzdWVUaW1lVGlja2V0KCk7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gYXR0cmlidXRlcyA/IHN0cmluZ2lmeU9iamVjdFZhbHVlcyhhdHRyaWJ1dGVzKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy50cmVlLnN0eWxlKFtmcm9tUG9zLCB0b1Bvc10sIGF0dHJzLCB0aWNrZXQpO1xuICAgICAgICB0aGlzLmNvbnRleHQucHVzaChUcmVlU3R5bGVPcGVyYXRpb24uY3JlYXRlKHRoaXMudHJlZS5nZXRDcmVhdGVkQXQoKSwgZnJvbVBvcywgdG9Qb3MsIGF0dHJzID8gbmV3IE1hcChPYmplY3QuZW50cmllcyhhdHRycykpIDogbmV3IE1hcCgpLCB0aWNrZXQpKTtcbiAgICB9XG4gICAgZWRpdEludGVybmFsKGZyb21Qb3MsIHRvUG9zLCBjb250ZW50cywgc3BsaXRMZXZlbCA9IDApIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoY29udGVudHMubGVuZ3RoICE9PSAwICYmIGNvbnRlbnRzWzBdKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZVRyZWVOb2Rlcyhjb250ZW50cyk7XG4gICAgICAgICAgICBpZiAoY29udGVudHNbMF0udHlwZSAhPT0gRGVmYXVsdFRleHRUeXBlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb250ZW50IG9mIGNvbnRlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgY2hpbGRyZW4gPSBbXSB9ID0gY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVUcmVlTm9kZXMoY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aWNrZXQgPSB0aGlzLmNvbnRleHQuZ2V0TGFzdFRpbWVUaWNrZXQoKTtcbiAgICAgICAgbGV0IGNyZHROb2RlcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICBpZiAoKChfYSA9IGNvbnRlbnRzWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgPT09IERlZmF1bHRUZXh0VHlwZSkge1xuICAgICAgICAgICAgbGV0IGNvbXBWYWwgPSAnJztcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29udGVudCBvZiBjb250ZW50cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgY29tcFZhbCArPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNyZHROb2Rlcy5wdXNoKENSRFRUcmVlTm9kZS5jcmVhdGUoQ1JEVFRyZWVOb2RlSUQub2YodGhpcy5jb250ZXh0Lmlzc3VlVGltZVRpY2tldCgpLCAwKSwgRGVmYXVsdFRleHRUeXBlLCBjb21wVmFsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjcmR0Tm9kZXMgPSBjb250ZW50c1xuICAgICAgICAgICAgICAgIC5tYXAoKGNvbnRlbnQpID0+IGNvbnRlbnQgJiYgY3JlYXRlQ1JEVFRyZWVOb2RlKHRoaXMuY29udGV4dCwgY29udGVudCkpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoYSkgPT4gYSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgWywgbWF4Q3JlYXRlZEF0TWFwQnlBY3Rvcl0gPSB0aGlzLnRyZWUuZWRpdChbZnJvbVBvcywgdG9Qb3NdLCBjcmR0Tm9kZXMubGVuZ3RoXG4gICAgICAgICAgICA/IGNyZHROb2Rlcy5tYXAoKGNyZHROb2RlKSA9PiBjcmR0Tm9kZSA9PT0gbnVsbCB8fCBjcmR0Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3JkdE5vZGUuZGVlcGNvcHkoKSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLCBzcGxpdExldmVsLCB0aWNrZXQsICgpID0+IHRoaXMuY29udGV4dC5pc3N1ZVRpbWVUaWNrZXQoKSk7XG4gICAgICAgIHRoaXMuY29udGV4dC5wdXNoKFRyZWVFZGl0T3BlcmF0aW9uLmNyZWF0ZSh0aGlzLnRyZWUuZ2V0Q3JlYXRlZEF0KCksIGZyb21Qb3MsIHRvUG9zLCBjcmR0Tm9kZXMubGVuZ3RoID8gY3JkdE5vZGVzIDogdW5kZWZpbmVkLCBzcGxpdExldmVsLCBtYXhDcmVhdGVkQXRNYXBCeUFjdG9yLCB0aWNrZXQpKTtcbiAgICAgICAgaWYgKCFmcm9tUG9zLmVxdWFscyh0b1BvcykpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZWdpc3RlckVsZW1lbnRIYXNSZW1vdmVkTm9kZXModGhpcy50cmVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGVkaXRCeVBhdGhgIGVkaXRzIHRoaXMgdHJlZSB3aXRoIHRoZSBnaXZlbiBub2RlIGFuZCBwYXRoLlxuICAgICAqL1xuICAgIGVkaXRCeVBhdGgoZnJvbVBhdGgsIHRvUGF0aCwgY29udGVudCwgc3BsaXRMZXZlbCA9IDApIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQgfHwgIXRoaXMudHJlZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpdCBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21QYXRoLmxlbmd0aCAhPT0gdG9QYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXRoIGxlbmd0aCBzaG91bGQgYmUgZXF1YWwnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZyb21QYXRoLmxlbmd0aCB8fCAhdG9QYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXRoIHNob3VsZCBub3QgYmUgZW1wdHknKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcm9tUG9zID0gdGhpcy50cmVlLnBhdGhUb1Bvcyhmcm9tUGF0aCk7XG4gICAgICAgIGNvbnN0IHRvUG9zID0gdGhpcy50cmVlLnBhdGhUb1Bvcyh0b1BhdGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0SW50ZXJuYWwoZnJvbVBvcywgdG9Qb3MsIGNvbnRlbnQgPyBbY29udGVudF0gOiBbXSwgc3BsaXRMZXZlbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBlZGl0QnVsa0J5UGF0aGAgZWRpdHMgdGhpcyB0cmVlIHdpdGggdGhlIGdpdmVuIG5vZGUgYW5kIHBhdGguXG4gICAgICovXG4gICAgZWRpdEJ1bGtCeVBhdGgoZnJvbVBhdGgsIHRvUGF0aCwgY29udGVudHMsIHNwbGl0TGV2ZWwgPSAwKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0IHx8ICF0aGlzLnRyZWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXQgaXMgbm90IGluaXRpYWxpemVkIHlldCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tUGF0aC5sZW5ndGggIT09IHRvUGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGF0aCBsZW5ndGggc2hvdWxkIGJlIGVxdWFsJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmcm9tUGF0aC5sZW5ndGggfHwgIXRvUGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGF0aCBzaG91bGQgbm90IGJlIGVtcHR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJvbVBvcyA9IHRoaXMudHJlZS5wYXRoVG9Qb3MoZnJvbVBhdGgpO1xuICAgICAgICBjb25zdCB0b1BvcyA9IHRoaXMudHJlZS5wYXRoVG9Qb3ModG9QYXRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdEludGVybmFsKGZyb21Qb3MsIHRvUG9zLCBjb250ZW50cywgc3BsaXRMZXZlbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBlZGl0YCBlZGl0cyB0aGlzIHRyZWUgd2l0aCB0aGUgZ2l2ZW4gbm9kZXMuXG4gICAgICovXG4gICAgZWRpdChmcm9tSWR4LCB0b0lkeCwgY29udGVudCwgc3BsaXRMZXZlbCA9IDApIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQgfHwgIXRoaXMudHJlZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpdCBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21JZHggPiB0b0lkeCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmcm9tIHNob3VsZCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdG8nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcm9tUG9zID0gdGhpcy50cmVlLmZpbmRQb3MoZnJvbUlkeCk7XG4gICAgICAgIGNvbnN0IHRvUG9zID0gdGhpcy50cmVlLmZpbmRQb3ModG9JZHgpO1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0SW50ZXJuYWwoZnJvbVBvcywgdG9Qb3MsIGNvbnRlbnQgPyBbY29udGVudF0gOiBbXSwgc3BsaXRMZXZlbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBlZGl0QnVsa2AgZWRpdHMgdGhpcyB0cmVlIHdpdGggdGhlIGdpdmVuIG5vZGVzLlxuICAgICAqL1xuICAgIGVkaXRCdWxrKGZyb21JZHgsIHRvSWR4LCBjb250ZW50cywgc3BsaXRMZXZlbCA9IDApIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQgfHwgIXRoaXMudHJlZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpdCBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21JZHggPiB0b0lkeCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmcm9tIHNob3VsZCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdG8nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcm9tUG9zID0gdGhpcy50cmVlLmZpbmRQb3MoZnJvbUlkeCk7XG4gICAgICAgIGNvbnN0IHRvUG9zID0gdGhpcy50cmVlLmZpbmRQb3ModG9JZHgpO1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0SW50ZXJuYWwoZnJvbVBvcywgdG9Qb3MsIGNvbnRlbnRzLCBzcGxpdExldmVsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRvWE1MYCByZXR1cm5zIHRoZSBYTUwgc3RyaW5nIG9mIHRoaXMgdHJlZS5cbiAgICAgKi9cbiAgICB0b1hNTCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQgfHwgIXRoaXMudHJlZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpdCBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZS50b1hNTCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdG9KU09OYCByZXR1cm5zIHRoZSBKU09OIHN0cmluZyBvZiB0aGlzIHRyZWUuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dCB8fCAhdGhpcy50cmVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2l0IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50cmVlLnRvSlNPTigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0Um9vdFRyZWVOb2RlYCByZXR1cm5zIFRyZWVOb2RlIG9mIHRoaXMgdHJlZS5cbiAgICAgKi9cbiAgICBnZXRSb290VHJlZU5vZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0IHx8ICF0aGlzLnRyZWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXQgaXMgbm90IGluaXRpYWxpemVkIHlldCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWUuZ2V0Um9vdFRyZWVOb2RlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBpbmRleFRvUGF0aGAgcmV0dXJucyB0aGUgcGF0aCBvZiB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgICovXG4gICAgaW5kZXhUb1BhdGgoaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQgfHwgIXRoaXMudHJlZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpdCBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5pbmRleFRvUGF0aChpbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBwYXRoVG9JbmRleGAgcmV0dXJucyB0aGUgaW5kZXggb2YgZ2l2ZW4gcGF0aC5cbiAgICAgKi9cbiAgICBwYXRoVG9JbmRleChwYXRoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0IHx8ICF0aGlzLnRyZWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXQgaXMgbm90IGluaXRpYWxpemVkIHlldCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWUucGF0aFRvSW5kZXgocGF0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBwYXRoUmFuZ2VUb1Bvc1JhbmdlYCBjb252ZXJ0cyB0aGUgcGF0aCByYW5nZSBpbnRvIHRoZSBwb3NpdGlvbiByYW5nZS5cbiAgICAgKi9cbiAgICBwYXRoUmFuZ2VUb1Bvc1JhbmdlKHJhbmdlKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0IHx8ICF0aGlzLnRyZWUpIHtcbiAgICAgICAgICAgIGxvZ2dlci5mYXRhbCgnaXQgaXMgbm90IGluaXRpYWxpemVkIHlldCcpO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4UmFuZ2UgPSBbXG4gICAgICAgICAgICB0aGlzLnRyZWUucGF0aFRvSW5kZXgocmFuZ2VbMF0pLFxuICAgICAgICAgICAgdGhpcy50cmVlLnBhdGhUb0luZGV4KHJhbmdlWzFdKSxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgcG9zUmFuZ2UgPSB0aGlzLnRyZWUuaW5kZXhSYW5nZVRvUG9zUmFuZ2UoaW5kZXhSYW5nZSk7XG4gICAgICAgIHJldHVybiBbcG9zUmFuZ2VbMF0udG9TdHJ1Y3QoKSwgcG9zUmFuZ2VbMV0udG9TdHJ1Y3QoKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBpbmRleFJhbmdlVG9Qb3NSYW5nZWAgY29udmVydHMgdGhlIGluZGV4IHJhbmdlIGludG8gdGhlIHBvc2l0aW9uIHJhbmdlLlxuICAgICAqL1xuICAgIGluZGV4UmFuZ2VUb1Bvc1JhbmdlKHJhbmdlKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0IHx8ICF0aGlzLnRyZWUpIHtcbiAgICAgICAgICAgIGxvZ2dlci5mYXRhbCgnaXQgaXMgbm90IGluaXRpYWxpemVkIHlldCcpO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWUuaW5kZXhSYW5nZVRvUG9zU3RydWN0UmFuZ2UocmFuZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgcG9zUmFuZ2VUb0luZGV4UmFuZ2VgIGNvbnZlcnRzIHRoZSBwb3NpdGlvbiByYW5nZSBpbnRvIHRoZSBpbmRleCByYW5nZS5cbiAgICAgKi9cbiAgICBwb3NSYW5nZVRvSW5kZXhSYW5nZShyYW5nZSkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dCB8fCAhdGhpcy50cmVlKSB7XG4gICAgICAgICAgICBsb2dnZXIuZmF0YWwoJ2l0IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQnKTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3NSYW5nZSA9IFtcbiAgICAgICAgICAgIENSRFRUcmVlUG9zLmZyb21TdHJ1Y3QocmFuZ2VbMF0pLFxuICAgICAgICAgICAgQ1JEVFRyZWVQb3MuZnJvbVN0cnVjdChyYW5nZVsxXSksXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWUucG9zUmFuZ2VUb0luZGV4UmFuZ2UocG9zUmFuZ2UsIHRoaXMuY29udGV4dC5nZXRMYXN0VGltZVRpY2tldCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHBvc1JhbmdlVG9QYXRoUmFuZ2VgIGNvbnZlcnRzIHRoZSBwb3NpdGlvbiByYW5nZSBpbnRvIHRoZSBwYXRoIHJhbmdlLlxuICAgICAqL1xuICAgIHBvc1JhbmdlVG9QYXRoUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQgfHwgIXRoaXMudHJlZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmZhdGFsKCdpdCBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0Jyk7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zUmFuZ2UgPSBbXG4gICAgICAgICAgICBDUkRUVHJlZVBvcy5mcm9tU3RydWN0KHJhbmdlWzBdKSxcbiAgICAgICAgICAgIENSRFRUcmVlUG9zLmZyb21TdHJ1Y3QocmFuZ2VbMV0pLFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlLnBvc1JhbmdlVG9QYXRoUmFuZ2UocG9zUmFuZ2UsIHRoaXMuY29udGV4dC5nZXRMYXN0VGltZVRpY2tldCgpKTtcbiAgICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kb2N1bWVudC9qc29uL2VsZW1lbnQudHNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vKipcbiAqIGBjcmVhdGVKU09OYCBjcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgSlNPTk9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSlNPTihjb250ZXh0LCB0YXJnZXQpIHtcbiAgICByZXR1cm4gY3JlYXRlSlNPTk9iamVjdChjb250ZXh0LCB0YXJnZXQpO1xufVxuLyoqXG4gKiBgdG9XcmFwcGVkRWxlbWVudGAgY29udmVydHMgdGhlIENSRFQgdHlwZSB0byBgV3JhcHBlZEVsZW1lbnRgLlxuICovXG5mdW5jdGlvbiB0b1dyYXBwZWRFbGVtZW50KGNvbnRleHQsIGVsZW0pIHtcbiAgICBpZiAoIWVsZW0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmIChlbGVtIGluc3RhbmNlb2YgUHJpbWl0aXZlKSB7XG4gICAgICAgIHJldHVybiBlbGVtO1xuICAgIH1cbiAgICBlbHNlIGlmIChlbGVtIGluc3RhbmNlb2YgQ1JEVE9iamVjdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlSlNPTk9iamVjdChjb250ZXh0LCBlbGVtKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZWxlbSBpbnN0YW5jZW9mIENSRFRBcnJheSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlSlNPTkFycmF5KGNvbnRleHQsIGVsZW0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChlbGVtIGluc3RhbmNlb2YgQ1JEVFRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0KGNvbnRleHQsIGVsZW0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChlbGVtIGluc3RhbmNlb2YgQ1JEVENvdW50ZXIpIHtcbiAgICAgICAgY29uc3QgY291bnRlciA9IG5ldyBDb3VudGVyKENvdW50ZXJUeXBlLkludGVnZXJDbnQsIDApO1xuICAgICAgICBjb3VudGVyLmluaXRpYWxpemUoY29udGV4dCwgZWxlbSk7XG4gICAgICAgIHJldHVybiBjb3VudGVyO1xuICAgIH1cbiAgICBlbHNlIGlmIChlbGVtIGluc3RhbmNlb2YgQ1JEVFRyZWUpIHtcbiAgICAgICAgY29uc3QgdHJlZSA9IG5ldyBUcmVlKCk7XG4gICAgICAgIHRyZWUuaW5pdGlhbGl6ZShjb250ZXh0LCBlbGVtKTtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHR5cGUgb2YgZWxlbWVudDogJHt0eXBlb2YgZWxlbX1gKTtcbn1cbi8qKlxuICogYHRvSlNPTkVsZW1lbnRgIGNvbnZlcnRzIHRoZSBDUkRUIHR5cGUgdG8gYEpTT05FbGVtZW50YC5cbiAqL1xuZnVuY3Rpb24gdG9KU09ORWxlbWVudChjb250ZXh0LCBlbGVtKSB7XG4gICAgY29uc3Qgd3JhcHBlZEVsZW1lbnQgPSB0b1dyYXBwZWRFbGVtZW50KGNvbnRleHQsIGVsZW0pO1xuICAgIGlmICh3cmFwcGVkRWxlbWVudCBpbnN0YW5jZW9mIFByaW1pdGl2ZSkge1xuICAgICAgICByZXR1cm4gd3JhcHBlZEVsZW1lbnQuZ2V0VmFsdWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyYXBwZWRFbGVtZW50O1xufVxuLyoqXG4gKiBgYnVpbGRDUkRURWxlbWVudGAgY29uc3RydWN0cyBhIENSRFRFbGVtZW50IGZyb20gdGhlIGdpdmVuIHZhbHVlLlxuICovXG5mdW5jdGlvbiBidWlsZENSRFRFbGVtZW50KGNvbnRleHQsIHZhbHVlLCBjcmVhdGVkQXQpIHtcbiAgICBsZXQgZWxlbWVudDtcbiAgICBpZiAoUHJpbWl0aXZlLmlzU3VwcG9ydCh2YWx1ZSkpIHtcbiAgICAgICAgZWxlbWVudCA9IFByaW1pdGl2ZS5vZih2YWx1ZSwgY3JlYXRlZEF0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZWxlbWVudCA9IENSRFRBcnJheS5jcmVhdGUoY3JlYXRlZEF0LCBBcnJheVByb3h5LmJ1aWxkQXJyYXlFbGVtZW50cyhjb250ZXh0LCB2YWx1ZSkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFRleHQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBDUkRUVGV4dC5jcmVhdGUoUkdBVHJlZVNwbGl0LmNyZWF0ZSgpLCBjcmVhdGVkQXQpO1xuICAgICAgICAgICAgdmFsdWUuaW5pdGlhbGl6ZShjb250ZXh0LCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIENvdW50ZXIpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBDUkRUQ291bnRlci5jcmVhdGUodmFsdWUuZ2V0VmFsdWVUeXBlKCksIHZhbHVlLmdldFZhbHVlKCksIGNyZWF0ZWRBdCk7XG4gICAgICAgICAgICB2YWx1ZS5pbml0aWFsaXplKGNvbnRleHQsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgVHJlZSkge1xuICAgICAgICAgICAgZWxlbWVudCA9IENSRFRUcmVlLmNyZWF0ZSh2YWx1ZS5idWlsZFJvb3QoY29udGV4dCksIGNyZWF0ZWRBdCk7XG4gICAgICAgICAgICB2YWx1ZS5pbml0aWFsaXplKGNvbnRleHQsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudCA9IENSRFRPYmplY3QuY3JlYXRlKGNyZWF0ZWRBdCwgT2JqZWN0UHJveHkuYnVpbGRPYmplY3RNZW1iZXJzKGNvbnRleHQsIHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHR5cGUgb2YgdmFsdWU6ICR7dHlwZW9mIHZhbHVlfWApO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2RvY3VtZW50L2hpc3RvcnkudHNcbi8qKlxuICogYE1heFVuZG9SZWRvU3RhY2tEZXB0aGAgaXMgdGhlIG1heGltdW0gZGVwdGggb2YgdW5kby9yZWRvIHN0YWNrLlxuICovXG5jb25zdCBNYXhVbmRvUmVkb1N0YWNrRGVwdGggPSA1MDtcbi8qKlxuICogYEhpc3RvcnlgIGlzIGEgY2xhc3MgdGhhdCBzdG9yZXMgdGhlIGhpc3Rvcnkgb2YgdGhlIGRvY3VtZW50LlxuICovXG5jbGFzcyBIaXN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy51bmRvU3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5yZWRvU3RhY2sgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGhhc1VuZG9gIHJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUgdW5kbyBvcGVyYXRpb25zLlxuICAgICAqL1xuICAgIGhhc1VuZG8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuZG9TdGFjay5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgaGFzUmVkb2AgcmV0dXJucyB0cnVlIGlmIHRoZXJlIGFyZSByZWRvIG9wZXJhdGlvbnMuXG4gICAgICovXG4gICAgaGFzUmVkbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVkb1N0YWNrLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBwdXNoVW5kb2AgcHVzaGVzIG5ldyB1bmRvIG9wZXJhdGlvbnMgb2YgYSBjaGFuZ2UgdG8gdW5kbyBzdGFjay5cbiAgICAgKi9cbiAgICBwdXNoVW5kbyh1bmRvT3BzKSB7XG4gICAgICAgIGlmICh0aGlzLnVuZG9TdGFjay5sZW5ndGggPj0gTWF4VW5kb1JlZG9TdGFja0RlcHRoKSB7XG4gICAgICAgICAgICB0aGlzLnVuZG9TdGFjay5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW5kb1N0YWNrLnB1c2godW5kb09wcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBwb3BVbmRvYCBwb3BzIHRoZSBsYXN0IHVuZG8gb3BlcmF0aW9ucyBvZiBhIGNoYW5nZSBmcm9tIHVuZG8gc3RhY2suXG4gICAgICovXG4gICAgcG9wVW5kbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5kb1N0YWNrLnBvcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgcHVzaFJlZG9gIHB1c2hlcyBuZXcgcmVkbyBvcGVyYXRpb25zIG9mIGEgY2hhbmdlIHRvIHJlZG8gc3RhY2suXG4gICAgICovXG4gICAgcHVzaFJlZG8ocmVkb09wcykge1xuICAgICAgICBpZiAodGhpcy5yZWRvU3RhY2subGVuZ3RoID49IE1heFVuZG9SZWRvU3RhY2tEZXB0aCkge1xuICAgICAgICAgICAgdGhpcy5yZWRvU3RhY2suc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZG9TdGFjay5wdXNoKHJlZG9PcHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgcG9wUmVkb2AgcG9wcyB0aGUgbGFzdCByZWRvIG9wZXJhdGlvbnMgb2YgYSBjaGFuZ2UgZnJvbSByZWRvIHN0YWNrLlxuICAgICAqL1xuICAgIHBvcFJlZG8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZG9TdGFjay5wb3AoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGNsZWFyUmVkb2AgZmx1c2hlcyByZW1haW5pbmcgcmVkbyBvcGVyYXRpb25zLlxuICAgICAqL1xuICAgIGNsZWFyUmVkbygpIHtcbiAgICAgICAgdGhpcy5yZWRvU3RhY2sgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldFVuZG9TdGFja0ZvclRlc3RgIHJldHVybnMgdGhlIHVuZG8gc3RhY2sgZm9yIHRlc3QuXG4gICAgICovXG4gICAgZ2V0VW5kb1N0YWNrRm9yVGVzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5kb1N0YWNrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0UmVkb1N0YWNrRm9yVGVzdGAgcmV0dXJucyB0aGUgcmVkbyBzdGFjayBmb3IgdGVzdC5cbiAgICAgKi9cbiAgICBnZXRSZWRvU3RhY2tGb3JUZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWRvU3RhY2s7XG4gICAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZG9jdW1lbnQvZG9jdW1lbnQudHNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vKipcbiAqIGBEb2N1bWVudFN0YXR1c2AgcmVwcmVzZW50cyB0aGUgc3RhdHVzIG9mIHRoZSBkb2N1bWVudC5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIERvY3VtZW50U3RhdHVzO1xuKGZ1bmN0aW9uIChEb2N1bWVudFN0YXR1cykge1xuICAgIC8qKlxuICAgICAqIERldGFjaGVkIG1lYW5zIHRoYXQgdGhlIGRvY3VtZW50IGlzIG5vdCBhdHRhY2hlZCB0byB0aGUgY2xpZW50LlxuICAgICAqIFRoZSBhY3RvciBvZiB0aGUgdGlja2V0IGlzIGNyZWF0ZWQgd2l0aG91dCBiZWluZyBhc3NpZ25lZC5cbiAgICAgKi9cbiAgICBEb2N1bWVudFN0YXR1c1tcIkRldGFjaGVkXCJdID0gXCJkZXRhY2hlZFwiO1xuICAgIC8qKlxuICAgICAqIEF0dGFjaGVkIG1lYW5zIHRoYXQgdGhpcyBkb2N1bWVudCBpcyBhdHRhY2hlZCB0byB0aGUgY2xpZW50LlxuICAgICAqIFRoZSBhY3RvciBvZiB0aGUgdGlja2V0IGlzIGNyZWF0ZWQgd2l0aCBiZWluZyBhc3NpZ25lZCBieSB0aGUgY2xpZW50LlxuICAgICAqL1xuICAgIERvY3VtZW50U3RhdHVzW1wiQXR0YWNoZWRcIl0gPSBcImF0dGFjaGVkXCI7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlZCBtZWFucyB0aGF0IHRoaXMgZG9jdW1lbnQgaXMgcmVtb3ZlZC4gSWYgdGhlIGRvY3VtZW50IGlzIHJlbW92ZWQsXG4gICAgICogaXQgY2Fubm90IGJlIGVkaXRlZC5cbiAgICAgKi9cbiAgICBEb2N1bWVudFN0YXR1c1tcIlJlbW92ZWRcIl0gPSBcInJlbW92ZWRcIjtcbn0pKERvY3VtZW50U3RhdHVzIHx8IChEb2N1bWVudFN0YXR1cyA9IHt9KSk7XG4vKipcbiAqIGBEb2NFdmVudFR5cGVgIHJlcHJlc2VudHMgdGhlIHR5cGUgb2YgdGhlIGV2ZW50IHRoYXQgb2NjdXJzIGluIGBEb2N1bWVudGAuXG4gKiBAcHVibGljXG4gKi9cbnZhciBEb2NFdmVudFR5cGU7XG4oZnVuY3Rpb24gKERvY0V2ZW50VHlwZSkge1xuICAgIC8qKlxuICAgICAqIHNuYXBzaG90IGV2ZW50IHR5cGVcbiAgICAgKi9cbiAgICBEb2NFdmVudFR5cGVbXCJTbmFwc2hvdFwiXSA9IFwic25hcHNob3RcIjtcbiAgICAvKipcbiAgICAgKiBsb2NhbCBkb2N1bWVudCBjaGFuZ2UgZXZlbnQgdHlwZVxuICAgICAqL1xuICAgIERvY0V2ZW50VHlwZVtcIkxvY2FsQ2hhbmdlXCJdID0gXCJsb2NhbC1jaGFuZ2VcIjtcbiAgICAvKipcbiAgICAgKiByZW1vdGUgZG9jdW1lbnQgY2hhbmdlIGV2ZW50IHR5cGVcbiAgICAgKi9cbiAgICBEb2NFdmVudFR5cGVbXCJSZW1vdGVDaGFuZ2VcIl0gPSBcInJlbW90ZS1jaGFuZ2VcIjtcbiAgICAvKipcbiAgICAgKiBgSW5pdGlhbGl6ZWRgIG1lYW5zIHRoYXQgb25saW5lIGNsaWVudHMgaGF2ZSBiZWVuIGxvYWRlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgRG9jRXZlbnRUeXBlW1wiSW5pdGlhbGl6ZWRcIl0gPSBcImluaXRpYWxpemVkXCI7XG4gICAgLyoqXG4gICAgICogYFdhdGNoZWRgIG1lYW5zIHRoYXQgdGhlIGNsaWVudCBoYXMgZXN0YWJsaXNoZWQgYSBjb25uZWN0aW9uIHdpdGggdGhlIHNlcnZlcixcbiAgICAgKiBlbmFibGluZyByZWFsLXRpbWUgc3luY2hyb25pemF0aW9uLlxuICAgICAqL1xuICAgIERvY0V2ZW50VHlwZVtcIldhdGNoZWRcIl0gPSBcIndhdGNoZWRcIjtcbiAgICAvKipcbiAgICAgKiBgVW53YXRjaGVkYCBtZWFucyB0aGF0IHRoZSBjb25uZWN0aW9uIGhhcyBiZWVuIGRpc2Nvbm5lY3RlZC5cbiAgICAgKi9cbiAgICBEb2NFdmVudFR5cGVbXCJVbndhdGNoZWRcIl0gPSBcInVud2F0Y2hlZFwiO1xuICAgIC8qKlxuICAgICAqIGBQcmVzZW5jZUNoYW5nZWRgIG1lYW5zIHRoYXQgdGhlIHByZXNlbmNlcyBvZiB0aGUgY2xpZW50IGhhcyB1cGRhdGVkLlxuICAgICAqL1xuICAgIERvY0V2ZW50VHlwZVtcIlByZXNlbmNlQ2hhbmdlZFwiXSA9IFwicHJlc2VuY2UtY2hhbmdlZFwiO1xufSkoRG9jRXZlbnRUeXBlIHx8IChEb2NFdmVudFR5cGUgPSB7fSkpO1xuLyoqXG4gKiBgRG9jdW1lbnRgIGlzIGEgQ1JEVC1iYXNlZCBkYXRhIHR5cGUuIFdlIGNhbiByZXByZXNlbnQgdGhlIG1vZGVsXG4gKiBvZiB0aGUgYXBwbGljYXRpb24gYW5kIGVkaXQgaXQgZXZlbiB3aGlsZSBvZmZsaW5lLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgRG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgb3B0cykge1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBEb2N1bWVudFN0YXR1cy5EZXRhY2hlZDtcbiAgICAgICAgdGhpcy5yb290ID0gQ1JEVFJvb3QuY3JlYXRlKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlSUQgPSBJbml0aWFsQ2hhbmdlSUQ7XG4gICAgICAgIHRoaXMuY2hlY2twb2ludCA9IEluaXRpYWxDaGVja3BvaW50O1xuICAgICAgICB0aGlzLmxvY2FsQ2hhbmdlcyA9IFtdO1xuICAgICAgICB0aGlzLmV2ZW50U3RyZWFtID0gY3JlYXRlT2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTdHJlYW1PYnNlcnZlciA9IG9ic2VydmVyO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbmxpbmVDbGllbnRzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLnByZXNlbmNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pc1VwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxIaXN0b3J5ID0gbmV3IEhpc3RvcnkoKTtcbiAgICAgICAgdGhpcy5oaXN0b3J5ID0ge1xuICAgICAgICAgICAgY2FuVW5kbzogdGhpcy5jYW5VbmRvLmJpbmQodGhpcyksXG4gICAgICAgICAgICBjYW5SZWRvOiB0aGlzLmNhblJlZG8uYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHVuZG86IHRoaXMudW5kby5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgcmVkbzogdGhpcy5yZWRvLmJpbmQodGhpcyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB1cGRhdGVgIGV4ZWN1dGVzIHRoZSBnaXZlbiB1cGRhdGVyIHRvIHVwZGF0ZSB0aGlzIGRvY3VtZW50LlxuICAgICAqL1xuICAgIHVwZGF0ZSh1cGRhdGVyLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLmdldFN0YXR1cygpID09PSBEb2N1bWVudFN0YXR1cy5SZW1vdmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgWW9ya2llRXJyb3IoZXJyb3JfQ29kZS5Eb2N1bWVudFJlbW92ZWQsIGAke3RoaXMua2V5fSBpcyByZW1vdmVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMDEuIFVwZGF0ZSB0aGUgY2xvbmUgb2JqZWN0IGFuZCBjcmVhdGUgYSBjaGFuZ2UuXG4gICAgICAgIHRoaXMuZW5zdXJlQ2xvbmUoKTtcbiAgICAgICAgY29uc3QgYWN0b3JJRCA9IHRoaXMuY2hhbmdlSUQuZ2V0QWN0b3JJRCgpO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gQ2hhbmdlQ29udGV4dC5jcmVhdGUodGhpcy5jaGFuZ2VJRC5uZXh0KCksIHRoaXMuY2xvbmUucm9vdCwgdGhpcy5jbG9uZS5wcmVzZW5jZXMuZ2V0KGFjdG9ySUQpIHx8IHt9LCBtZXNzYWdlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHByb3h5ID0gY3JlYXRlSlNPTihjb250ZXh0LCB0aGlzLmNsb25lLnJvb3QuZ2V0T2JqZWN0KCkpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnByZXNlbmNlcy5oYXMoYWN0b3JJRCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb25lLnByZXNlbmNlcy5zZXQoYWN0b3JJRCwge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTk9URShoYWNrZXJ3aW5zKTogVGhlIHVwZGF0ZXIgc2hvdWxkIG5vdCBiZSBhYmxlIHRvIGNhbGwgdW5kby9yZWRvLlxuICAgICAgICAgICAgLy8gSWYgdGhlIHVwZGF0ZXIgY2FsbHMgdW5kby9yZWRvLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICAgICAgICAgIHRoaXMuaXNVcGRhdGluZyA9IHRydWU7XG4gICAgICAgICAgICB1cGRhdGVyKHByb3h5LCBuZXcgUHJlc2VuY2UoY29udGV4dCwgdGhpcy5jbG9uZS5wcmVzZW5jZXMuZ2V0KGFjdG9ySUQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gZHJvcCBjbG9uZSBiZWNhdXNlIGl0IGlzIGNvbnRhbWluYXRlZC5cbiAgICAgICAgICAgIHRoaXMuY2xvbmUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuaXNVcGRhdGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIDAyLiBVcGRhdGUgdGhlIHJvb3Qgb2JqZWN0IGFuZCBwcmVzZW5jZXMgZnJvbSBjaGFuZ2VzLlxuICAgICAgICBpZiAoY29udGV4dC5oYXNDaGFuZ2UoKSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlci5pc0VuYWJsZWQoTG9nTGV2ZWwuVHJpdmlhbCkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudHJpdmlhbChgdHJ5aW5nIHRvIHVwZGF0ZSBhIGxvY2FsIGNoYW5nZTogJHt0aGlzLnRvSlNPTigpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hhbmdlID0gY29udGV4dC5nZXRDaGFuZ2UoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgb3BJbmZvcywgcmV2ZXJzZU9wcyB9ID0gY2hhbmdlLmV4ZWN1dGUodGhpcy5yb290LCB0aGlzLnByZXNlbmNlcywgT3BTb3VyY2UuTG9jYWwpO1xuICAgICAgICAgICAgY29uc3QgcmV2ZXJzZVByZXNlbmNlID0gY29udGV4dC5nZXRSZXZlcnNlUHJlc2VuY2UoKTtcbiAgICAgICAgICAgIGlmIChyZXZlcnNlUHJlc2VuY2UpIHtcbiAgICAgICAgICAgICAgICByZXZlcnNlT3BzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAncHJlc2VuY2UnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmV2ZXJzZVByZXNlbmNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2NhbENoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgICAgICAgaWYgKHJldmVyc2VPcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxIaXN0b3J5LnB1c2hVbmRvKHJldmVyc2VPcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTk9URShjaGFjaGE5MTIpOiBDbGVhciByZWRvIHdoZW4gYSBuZXcgbG9jYWwgb3BlcmF0aW9uIGlzIGFwcGxpZWQuXG4gICAgICAgICAgICBpZiAob3BJbmZvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEhpc3RvcnkuY2xlYXJSZWRvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoYW5nZUlEID0gY2hhbmdlLmdldElEKCk7XG4gICAgICAgICAgICAvLyAwMy4gUHVibGlzaCB0aGUgZG9jdW1lbnQgY2hhbmdlIGV2ZW50LlxuICAgICAgICAgICAgLy8gTk9URShjaGFjaGE5MTIpOiBDaGVjayBvcEluZm9zLCB3aGljaCByZXByZXNlbnQgdGhlIGFjdHVhbGx5IGV4ZWN1dGVkIG9wZXJhdGlvbnMuXG4gICAgICAgICAgICBpZiAob3BJbmZvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRG9jRXZlbnRUeXBlLkxvY2FsQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hhbmdlLmdldE1lc3NhZ2UoKSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbnM6IG9wSW5mb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RvcjogYWN0b3JJRCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFuZ2UuaGFzUHJlc2VuY2VDaGFuZ2UoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IERvY0V2ZW50VHlwZS5QcmVzZW5jZUNoYW5nZWQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRJRDogYWN0b3JJRCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbmNlOiB0aGlzLmdldFByZXNlbmNlKGFjdG9ySUQpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxvZ2dlci5pc0VuYWJsZWQoTG9nTGV2ZWwuVHJpdmlhbCkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudHJpdmlhbChgYWZ0ZXIgdXBkYXRlIGEgbG9jYWwgY2hhbmdlOiAke3RoaXMudG9KU09OKCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogYHN1YnNjcmliZWAgcmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gc3Vic2NyaWJlIHRvIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnQuXG4gICAgICovXG4gICAgc3Vic2NyaWJlKGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcxID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIGNhbGxiYWNrIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJnMSA9PT0gJ3ByZXNlbmNlJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gYXJnMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudFN0cmVhbS5zdWJzY3JpYmUoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC50eXBlICE9PSBEb2NFdmVudFR5cGUuSW5pdGlhbGl6ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgIT09IERvY0V2ZW50VHlwZS5XYXRjaGVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC50eXBlICE9PSBEb2NFdmVudFR5cGUuVW53YXRjaGVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC50eXBlICE9PSBEb2NFdmVudFR5cGUuUHJlc2VuY2VDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXZlbnQpO1xuICAgICAgICAgICAgICAgIH0sIGFyZzMsIGFyZzQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZzEgPT09ICdteS1wcmVzZW5jZScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGFyZzI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRTdHJlYW0uc3Vic2NyaWJlKChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQudHlwZSAhPT0gRG9jRXZlbnRUeXBlLkluaXRpYWxpemVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC50eXBlICE9PSBEb2NFdmVudFR5cGUuV2F0Y2hlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQudHlwZSAhPT0gRG9jRXZlbnRUeXBlLlVud2F0Y2hlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQudHlwZSAhPT0gRG9jRXZlbnRUeXBlLlByZXNlbmNlQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC50eXBlICE9PSBEb2NFdmVudFR5cGUuSW5pdGlhbGl6ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnZhbHVlLmNsaWVudElEICE9PSB0aGlzLmNoYW5nZUlELmdldEFjdG9ySUQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9LCBhcmczLCBhcmc0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcmcxID09PSAnb3RoZXJzJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gYXJnMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudFN0cmVhbS5zdWJzY3JpYmUoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC50eXBlICE9PSBEb2NFdmVudFR5cGUuV2F0Y2hlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQudHlwZSAhPT0gRG9jRXZlbnRUeXBlLlVud2F0Y2hlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQudHlwZSAhPT0gRG9jRXZlbnRUeXBlLlByZXNlbmNlQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC52YWx1ZS5jbGllbnRJRCAhPT0gdGhpcy5jaGFuZ2VJRC5nZXRBY3RvcklEKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGFyZzMsIGFyZzQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gYXJnMTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gYXJnMjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50U3RyZWFtLnN1YnNjcmliZSgoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gRG9jRXZlbnRUeXBlLkluaXRpYWxpemVkIHx8XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPT09IERvY0V2ZW50VHlwZS5XYXRjaGVkIHx8XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPT09IERvY0V2ZW50VHlwZS5VbndhdGNoZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQudHlwZSA9PT0gRG9jRXZlbnRUeXBlLlByZXNlbmNlQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSBEb2NFdmVudFR5cGUuU25hcHNob3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID09PSAnJCcgJiYgY2FsbGJhY2soZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgbWVzc2FnZSwgb3BlcmF0aW9ucywgYWN0b3IgfSA9IGV2ZW50LnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldE9wcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgb3Agb2Ygb3BlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NhbWVFbGVtZW50T3JDaGlsZE9mKG9wLnBhdGgsIHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE9wcy5wdXNoKG9wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXJnZXRPcHMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGV2ZW50LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uczogdGFyZ2V0T3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBhcmczLCBhcmc0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gYXJnMTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gYXJnMjtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRlID0gYXJnMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50U3RyZWFtLnN1YnNjcmliZSgoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gRG9jRXZlbnRUeXBlLkluaXRpYWxpemVkIHx8XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPT09IERvY0V2ZW50VHlwZS5XYXRjaGVkIHx8XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPT09IERvY0V2ZW50VHlwZS5VbndhdGNoZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQudHlwZSA9PT0gRG9jRXZlbnRUeXBlLlByZXNlbmNlQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICAgICAgICAgIH0sIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7YXJnMX1cIiBpcyBub3QgYSB2YWxpZGApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgcHVibGlzaGAgdHJpZ2dlcnMgYW4gZXZlbnQgaW4gdGhpcyBkb2N1bWVudCwgd2hpY2ggY2FuIGJlIHJlY2VpdmVkIGJ5XG4gICAgICogY2FsbGJhY2sgZnVuY3Rpb25zIGZyb20gZG9jdW1lbnQuc3Vic2NyaWJlKCkuXG4gICAgICovXG4gICAgcHVibGlzaChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5ldmVudFN0cmVhbU9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50U3RyZWFtT2JzZXJ2ZXIubmV4dChldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNTYW1lRWxlbWVudE9yQ2hpbGRPZihlbGVtLCBwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZVBhdGggPSBlbGVtLnNwbGl0KCcuJyk7XG4gICAgICAgIGNvbnN0IHRhcmdldFBhdGggPSBwYXJlbnQuc3BsaXQoJy4nKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldFBhdGguZXZlcnkoKHBhdGgsIGluZGV4KSA9PiBwYXRoID09PSBub2RlUGF0aFtpbmRleF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgYXBwbHlDaGFuZ2VQYWNrYCBhcHBsaWVzIHRoZSBnaXZlbiBjaGFuZ2UgcGFjayBpbnRvIHRoaXMgZG9jdW1lbnQuXG4gICAgICogMS4gUmVtb3ZlIGxvY2FsIGNoYW5nZXMgYXBwbGllZCB0byBzZXJ2ZXIuXG4gICAgICogMi4gVXBkYXRlIHRoZSBjaGVja3BvaW50LlxuICAgICAqIDMuIERvIEdhcmJhZ2UgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYWNrIC0gY2hhbmdlIHBhY2tcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBhcHBseUNoYW5nZVBhY2socGFjaykge1xuICAgICAgICBpZiAocGFjay5oYXNTbmFwc2hvdCgpKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGx5U25hcHNob3QocGFjay5nZXRDaGVja3BvaW50KCkuZ2V0U2VydmVyU2VxKCksIHBhY2suZ2V0U25hcHNob3QoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFjay5oYXNDaGFuZ2VzKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlDaGFuZ2VzKHBhY2suZ2V0Q2hhbmdlcygpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAwMi4gUmVtb3ZlIGxvY2FsIGNoYW5nZXMgYXBwbGllZCB0byBzZXJ2ZXIuXG4gICAgICAgIHdoaWxlICh0aGlzLmxvY2FsQ2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IHRoaXMubG9jYWxDaGFuZ2VzWzBdO1xuICAgICAgICAgICAgaWYgKGNoYW5nZS5nZXRJRCgpLmdldENsaWVudFNlcSgpID4gcGFjay5nZXRDaGVja3BvaW50KCkuZ2V0Q2xpZW50U2VxKCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubG9jYWxDaGFuZ2VzLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMDMuIFVwZGF0ZSB0aGUgY2hlY2twb2ludC5cbiAgICAgICAgdGhpcy5jaGVja3BvaW50ID0gdGhpcy5jaGVja3BvaW50LmZvcndhcmQocGFjay5nZXRDaGVja3BvaW50KCkpO1xuICAgICAgICAvLyAwNC4gRG8gR2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgICAgICB0aGlzLmdhcmJhZ2VDb2xsZWN0KHBhY2suZ2V0TWluU3luY2VkVGlja2V0KCkpO1xuICAgICAgICAvLyAwNS4gVXBkYXRlIHRoZSBzdGF0dXMuXG4gICAgICAgIGlmIChwYWNrLmdldElzUmVtb3ZlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhEb2N1bWVudFN0YXR1cy5SZW1vdmVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9nZ2VyLmlzRW5hYmxlZChMb2dMZXZlbC5Ucml2aWFsKSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRyaXZpYWwoYCR7dGhpcy5yb290LnRvSlNPTigpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRDaGVja3BvaW50YCByZXR1cm5zIHRoZSBjaGVja3BvaW50IG9mIHRoaXMgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBnZXRDaGVja3BvaW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGVja3BvaW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0Q2hhbmdlSURgIHJldHVybnMgdGhlIGNoYW5nZSBpZCBvZiB0aGlzIGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZ2V0Q2hhbmdlSUQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZUlEO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgaGFzTG9jYWxDaGFuZ2VzYCByZXR1cm5zIHdoZXRoZXIgdGhpcyBkb2N1bWVudCBoYXMgbG9jYWwgY2hhbmdlcyBvciBub3QuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBoYXNMb2NhbENoYW5nZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsQ2hhbmdlcy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZW5zdXJlQ2xvbmVgIG1ha2UgYSBjbG9uZSBvZiByb290LlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZW5zdXJlQ2xvbmUoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb25lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbG9uZSA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHRoaXMucm9vdC5kZWVwY29weSgpLFxuICAgICAgICAgICAgcHJlc2VuY2VzOiBkZWVwY29weSh0aGlzLnByZXNlbmNlcyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBjcmVhdGVDaGFuZ2VQYWNrYCBjcmVhdGUgY2hhbmdlIHBhY2sgb2YgdGhlIGxvY2FsIGNoYW5nZXMgdG8gc2VuZCB0byB0aGVcbiAgICAgKiByZW1vdGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY3JlYXRlQ2hhbmdlUGFjaygpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IEFycmF5LmZyb20odGhpcy5sb2NhbENoYW5nZXMpO1xuICAgICAgICBjb25zdCBjaGVja3BvaW50ID0gdGhpcy5jaGVja3BvaW50LmluY3JlYXNlQ2xpZW50U2VxKGNoYW5nZXMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIENoYW5nZVBhY2suY3JlYXRlKHRoaXMua2V5LCBjaGVja3BvaW50LCBmYWxzZSwgY2hhbmdlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBzZXRBY3RvcmAgc2V0cyBhY3RvciBpbnRvIHRoaXMgZG9jdW1lbnQuIFRoaXMgaXMgYWxzbyBhcHBsaWVkIGluIHRoZSBsb2NhbFxuICAgICAqIGNoYW5nZXMgdGhlIGRvY3VtZW50IGhhcy5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHNldEFjdG9yKGFjdG9ySUQpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGFuZ2Ugb2YgdGhpcy5sb2NhbENoYW5nZXMpIHtcbiAgICAgICAgICAgIGNoYW5nZS5zZXRBY3RvcihhY3RvcklEKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYW5nZUlEID0gdGhpcy5jaGFuZ2VJRC5zZXRBY3RvcihhY3RvcklEKTtcbiAgICAgICAgLy8gVE9ETyBhbHNvIGFwcGx5IGludG8gcm9vdC5cbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldEtleWAgcmV0dXJucyB0aGUga2V5IG9mIHRoaXMgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBnZXRLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHNldFN0YXR1c2AgdXBkYXRlcyB0aGUgc3RhdHVzIG9mIHRoaXMgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzZXRTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0U3RhdHVzYCByZXR1cm5zIHRoZSBzdGF0dXMgb2YgdGhpcyBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGdldFN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0Q2xvbmVgIHJldHVybiBjbG9uZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBnZXRDbG9uZVJvb3QoKSB7XG4gICAgICAgIGlmICghdGhpcy5jbG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lLnJvb3QuZ2V0T2JqZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRSb290YCByZXR1cm5zIGEgbmV3IHByb3h5IG9mIGNsb25lZCByb290LlxuICAgICAqL1xuICAgIGdldFJvb3QoKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlQ2xvbmUoKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IENoYW5nZUNvbnRleHQuY3JlYXRlKHRoaXMuY2hhbmdlSUQubmV4dCgpLCB0aGlzLmNsb25lLnJvb3QsIHRoaXMuY2xvbmUucHJlc2VuY2VzLmdldCh0aGlzLmNoYW5nZUlELmdldEFjdG9ySUQoKSkgfHwge30pO1xuICAgICAgICByZXR1cm4gY3JlYXRlSlNPTihjb250ZXh0LCB0aGlzLmNsb25lLnJvb3QuZ2V0T2JqZWN0KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0T3BzRm9yVGVzdGAgcmV0dXJucyB0aGUgb3BlcmF0aW9ucyBvZiB0aGlzIGRvY3VtZW50IGZvciB0ZXN0aW5nLlxuICAgICAqL1xuICAgIGdldE9wc0ZvclRlc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3Qub3BzRm9yVGVzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdhcmJhZ2VDb2xsZWN0YCBwdXJnZXMgZWxlbWVudHMgdGhhdCB3ZXJlIHJlbW92ZWQgYmVmb3JlIHRoZSBnaXZlbiB0aW1lLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZ2FyYmFnZUNvbGxlY3QodGlja2V0KSB7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuZGlzYWJsZUdDKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jbG9uZSkge1xuICAgICAgICAgICAgdGhpcy5jbG9uZS5yb290LmdhcmJhZ2VDb2xsZWN0KHRpY2tldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5nYXJiYWdlQ29sbGVjdCh0aWNrZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0Um9vdE9iamVjdGAgcmV0dXJucyByb290IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGdldFJvb3RPYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuZ2V0T2JqZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRHYXJiYWdlTGVuYCByZXR1cm5zIHRoZSBsZW5ndGggb2YgZWxlbWVudHMgc2hvdWxkIGJlIHB1cmdlZC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGdldEdhcmJhZ2VMZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuZ2V0R2FyYmFnZUxlbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0R2FyYmFnZUxlbkZyb21DbG9uZWAgcmV0dXJucyB0aGUgbGVuZ3RoIG9mIGVsZW1lbnRzIHNob3VsZCBiZSBwdXJnZWQgZnJvbSBjbG9uZS5cbiAgICAgKi9cbiAgICBnZXRHYXJiYWdlTGVuRnJvbUNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZS5yb290LmdldEdhcmJhZ2VMZW4oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRvSlNPTmAgcmV0dXJucyB0aGUgSlNPTiBlbmNvZGluZyBvZiB0aGlzIGRvY3VtZW50LlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC50b0pTT04oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRvU29ydGVkSlNPTmAgcmV0dXJucyB0aGUgc29ydGVkIEpTT04gZW5jb2Rpbmcgb2YgdGhpcyBkb2N1bWVudC5cbiAgICAgKi9cbiAgICB0b1NvcnRlZEpTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QudG9Tb3J0ZWRKU09OKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBhcHBseVNuYXBzaG90YCBhcHBsaWVzIHRoZSBnaXZlbiBzbmFwc2hvdCBpbnRvIHRoaXMgZG9jdW1lbnQuXG4gICAgICovXG4gICAgYXBwbHlTbmFwc2hvdChzZXJ2ZXJTZXEsIHNuYXBzaG90KSB7XG4gICAgICAgIGNvbnN0IHsgcm9vdCwgcHJlc2VuY2VzIH0gPSBjb252ZXJ0ZXIuYnl0ZXNUb1NuYXBzaG90KHNuYXBzaG90KTtcbiAgICAgICAgdGhpcy5yb290ID0gbmV3IENSRFRSb290KHJvb3QpO1xuICAgICAgICB0aGlzLnByZXNlbmNlcyA9IHByZXNlbmNlcztcbiAgICAgICAgdGhpcy5jaGFuZ2VJRCA9IHRoaXMuY2hhbmdlSUQuc3luY0xhbXBvcnQoc2VydmVyU2VxKTtcbiAgICAgICAgLy8gZHJvcCBjbG9uZSBiZWNhdXNlIGl0IGlzIGNvbnRhbWluYXRlZC5cbiAgICAgICAgdGhpcy5jbG9uZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wdWJsaXNoKHtcbiAgICAgICAgICAgIHR5cGU6IERvY0V2ZW50VHlwZS5TbmFwc2hvdCxcbiAgICAgICAgICAgIHZhbHVlOiBzbmFwc2hvdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBhcHBseUNoYW5nZXNgIGFwcGxpZXMgdGhlIGdpdmVuIGNoYW5nZXMgaW50byB0aGlzIGRvY3VtZW50LlxuICAgICAqL1xuICAgIGFwcGx5Q2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChsb2dnZXIuaXNFbmFibGVkKExvZ0xldmVsLkRlYnVnKSkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGB0cnlpbmcgdG8gYXBwbHkgJHtjaGFuZ2VzLmxlbmd0aH0gcmVtb3RlIGNoYW5nZXMuYCArXG4gICAgICAgICAgICAgICAgYGVsZW1lbnRzOiR7dGhpcy5yb290LmdldEVsZW1lbnRNYXBTaXplKCl9LCBgICtcbiAgICAgICAgICAgICAgICBgcmVtb3ZlZHM6JHt0aGlzLnJvb3QuZ2V0UmVtb3ZlZEVsZW1lbnRTZXRTaXplKCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvZ2dlci5pc0VuYWJsZWQoTG9nTGV2ZWwuVHJpdmlhbCkpIHtcbiAgICAgICAgICAgIGxvZ2dlci50cml2aWFsKGNoYW5nZXNcbiAgICAgICAgICAgICAgICAubWFwKChjaGFuZ2UpID0+IGAke2NoYW5nZS5nZXRJRCgpLnRvVGVzdFN0cmluZygpfVxcdCR7Y2hhbmdlLnRvVGVzdFN0cmluZygpfWApXG4gICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVuc3VyZUNsb25lKCk7XG4gICAgICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGNoYW5nZS5leGVjdXRlKHRoaXMuY2xvbmUucm9vdCwgdGhpcy5jbG9uZS5wcmVzZW5jZXMsIE9wU291cmNlLlJlbW90ZSk7XG4gICAgICAgICAgICBsZXQgcHJlc2VuY2VFdmVudDtcbiAgICAgICAgICAgIGNvbnN0IGFjdG9ySUQgPSBjaGFuZ2UuZ2V0SUQoKS5nZXRBY3RvcklEKCk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlLmhhc1ByZXNlbmNlQ2hhbmdlKCkgJiYgdGhpcy5vbmxpbmVDbGllbnRzLmhhcyhhY3RvcklEKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXNlbmNlQ2hhbmdlID0gY2hhbmdlLmdldFByZXNlbmNlQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcmVzZW5jZUNoYW5nZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJlc2VuY2VDaGFuZ2VUeXBlLlB1dDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEUoY2hhY2hhOTEyKTogV2hlbiB0aGUgdXNlciBleGlzdHMgaW4gb25saW5lQ2xpZW50cywgYnV0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVpciBwcmVzZW5jZSB3YXMgaW5pdGlhbGx5IGFic2VudCwgd2UgY2FuIGNvbnNpZGVyIHRoYXQgd2UgaGF2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVjZWl2ZWQgdGhlaXIgaW5pdGlhbCBwcmVzZW5jZSwgc28gdHJpZ2dlciB0aGUgJ3dhdGNoZWQnIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VuY2VFdmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnByZXNlbmNlcy5oYXMoYWN0b3JJRClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBEb2NFdmVudFR5cGUuUHJlc2VuY2VDaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogRG9jRXZlbnRUeXBlLldhdGNoZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50SUQ6IGFjdG9ySUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbmNlOiBwcmVzZW5jZUNoYW5nZS5wcmVzZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFByZXNlbmNlQ2hhbmdlVHlwZS5DbGVhcjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEUoY2hhY2hhOTEyKTogV2hlbiB0aGUgdXNlciBleGlzdHMgaW4gb25saW5lQ2xpZW50cywgYnV0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmVzZW5jZUNoYW5nZShjbGVhcikgaXMgcmVjZWl2ZWQsIHdlIGNhbiBjb25zaWRlciBpdCBhcyBkZXRhY2htZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvY2N1cnJpbmcgYmVmb3JlIHVud2F0Y2hpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXRhY2hlZCB1c2VyIGlzIG5vIGxvbmdlciBwYXJ0aWNpcGF0aW5nIGluIHRoZSBkb2N1bWVudCwgd2UgcmVtb3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVtIGZyb20gdGhlIG9ubGluZSBjbGllbnRzIGFuZCB0cmlnZ2VyIHRoZSAndW53YXRjaGVkJyBldmVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbmNlRXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRG9jRXZlbnRUeXBlLlVud2F0Y2hlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRJRDogYWN0b3JJRCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VuY2U6IHRoaXMuZ2V0UHJlc2VuY2UoYWN0b3JJRCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU9ubGluZUNsaWVudChhY3RvcklEKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBvcEluZm9zIH0gPSBjaGFuZ2UuZXhlY3V0ZSh0aGlzLnJvb3QsIHRoaXMucHJlc2VuY2VzLCBPcFNvdXJjZS5SZW1vdGUpO1xuICAgICAgICAgICAgLy8gRG9jRXZlbnQgc2hvdWxkIGJlIGVtaXR0ZWQgc3luY2hyb25vdXNseSB3aXRoIGFwcGx5aW5nIGNoYW5nZXMuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGJlY2F1c2UgM3JkIHBhcnR5IG1vZGVsIHNob3VsZCBiZSBzeW5jZWQgd2l0aCB0aGUgRG9jdW1lbnRcbiAgICAgICAgICAgIC8vIGFmdGVyIFJlbW90ZUNoYW5nZSBldmVudCBpcyBlbWl0dGVkLiBJZiB0aGUgZXZlbnQgaXMgZW1pdHRlZFxuICAgICAgICAgICAgLy8gYXN5bmNocm9ub3VzbHksIHRoZSBtb2RlbCBjYW4gYmUgY2hhbmdlZCBhbmQgYnJlYWtpbmcgY29uc2lzdGVuY3kuXG4gICAgICAgICAgICBpZiAob3BJbmZvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRG9jRXZlbnRUeXBlLlJlbW90ZUNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yOiBhY3RvcklELFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hhbmdlLmdldE1lc3NhZ2UoKSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbnM6IG9wSW5mb3MsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJlc2VuY2VFdmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaChwcmVzZW5jZUV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2hhbmdlSUQgPSB0aGlzLmNoYW5nZUlELnN5bmNMYW1wb3J0KGNoYW5nZS5nZXRJRCgpLmdldExhbXBvcnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvZ2dlci5pc0VuYWJsZWQoTG9nTGV2ZWwuRGVidWcpKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoYGFmdGVyIGFwcGxpbmcgJHtjaGFuZ2VzLmxlbmd0aH0gcmVtb3RlIGNoYW5nZXMuYCArXG4gICAgICAgICAgICAgICAgYGVsZW1lbnRzOiR7dGhpcy5yb290LmdldEVsZW1lbnRNYXBTaXplKCl9LCBgICtcbiAgICAgICAgICAgICAgICBgIHJlbW92ZWRzOiR7dGhpcy5yb290LmdldFJlbW92ZWRFbGVtZW50U2V0U2l6ZSgpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRWYWx1ZUJ5UGF0aGAgcmV0dXJucyB0aGUgSlNPTkVsZW1lbnQgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gcGF0aC5cbiAgICAgKi9cbiAgICBnZXRWYWx1ZUJ5UGF0aChwYXRoKSB7XG4gICAgICAgIGlmICghcGF0aC5zdGFydHNXaXRoKCckJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBZb3JraWVFcnJvcihlcnJvcl9Db2RlLkludmFsaWRBcmd1bWVudCwgYHBhdGggbXVzdCBzdGFydCB3aXRoIFwiJFwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF0aEFyciA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgcGF0aEFyci5zaGlmdCgpO1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmdldFJvb3QoKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgcGF0aEFycikge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBzZXRPbmxpbmVDbGllbnRzYCBzZXRzIHRoZSBnaXZlbiBvbmxpbmUgY2xpZW50IHNldC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHNldE9ubGluZUNsaWVudHMob25saW5lQ2xpZW50cykge1xuICAgICAgICB0aGlzLm9ubGluZUNsaWVudHMgPSBvbmxpbmVDbGllbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgYWRkT25saW5lQ2xpZW50YCBhZGRzIHRoZSBnaXZlbiBjbGllbnRJRCBpbnRvIHRoZSBvbmxpbmUgY2xpZW50IHNldC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGFkZE9ubGluZUNsaWVudChjbGllbnRJRCkge1xuICAgICAgICB0aGlzLm9ubGluZUNsaWVudHMuYWRkKGNsaWVudElEKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHJlbW92ZU9ubGluZUNsaWVudGAgcmVtb3ZlcyB0aGUgY2xpZW50SUQgZnJvbSB0aGUgb25saW5lIGNsaWVudCBzZXQuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICByZW1vdmVPbmxpbmVDbGllbnQoY2xpZW50SUQpIHtcbiAgICAgICAgdGhpcy5vbmxpbmVDbGllbnRzLmRlbGV0ZShjbGllbnRJRCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBoYXNQcmVzZW5jZWAgcmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBjbGllbnRJRCBoYXMgYSBwcmVzZW5jZSBvciBub3QuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBoYXNQcmVzZW5jZShjbGllbnRJRCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmVzZW5jZXMuaGFzKGNsaWVudElEKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldE15UHJlc2VuY2VgIHJldHVybnMgdGhlIHByZXNlbmNlIG9mIHRoZSBjdXJyZW50IGNsaWVudC5cbiAgICAgKi9cbiAgICBnZXRNeVByZXNlbmNlKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT09IERvY3VtZW50U3RhdHVzLkF0dGFjaGVkKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcCA9IHRoaXMucHJlc2VuY2VzLmdldCh0aGlzLmNoYW5nZUlELmdldEFjdG9ySUQoKSk7XG4gICAgICAgIHJldHVybiBkZWVwY29weShwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldFByZXNlbmNlYCByZXR1cm5zIHRoZSBwcmVzZW5jZSBvZiB0aGUgZ2l2ZW4gY2xpZW50SUQuXG4gICAgICovXG4gICAgZ2V0UHJlc2VuY2UoY2xpZW50SUQpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9ubGluZUNsaWVudHMuaGFzKGNsaWVudElEKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMucHJlc2VuY2VzLmdldChjbGllbnRJRCk7XG4gICAgICAgIHJldHVybiBwID8gZGVlcGNvcHkocCkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRQcmVzZW5jZUZvclRlc3RgIHJldHVybnMgdGhlIHByZXNlbmNlIG9mIHRoZSBnaXZlbiBjbGllbnRJRFxuICAgICAqIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgY2xpZW50IGlzIG9ubGluZSBvciBub3QuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBnZXRQcmVzZW5jZUZvclRlc3QoY2xpZW50SUQpIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMucHJlc2VuY2VzLmdldChjbGllbnRJRCk7XG4gICAgICAgIHJldHVybiBwID8gZGVlcGNvcHkocCkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRQcmVzZW5jZXNgIHJldHVybnMgdGhlIHByZXNlbmNlcyBvZiBvbmxpbmUgY2xpZW50cy5cbiAgICAgKi9cbiAgICBnZXRQcmVzZW5jZXMoKSB7XG4gICAgICAgIGNvbnN0IHByZXNlbmNlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGNsaWVudElEIG9mIHRoaXMub25saW5lQ2xpZW50cykge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJlc2VuY2VzLmhhcyhjbGllbnRJRCkpIHtcbiAgICAgICAgICAgICAgICBwcmVzZW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudElELFxuICAgICAgICAgICAgICAgICAgICBwcmVzZW5jZTogZGVlcGNvcHkodGhpcy5wcmVzZW5jZXMuZ2V0KGNsaWVudElEKSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZXNlbmNlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGNhblVuZG9gIHJldHVybnMgd2hldGhlciB0aGVyZSBhcmUgYW55IG9wZXJhdGlvbnMgdG8gdW5kby5cbiAgICAgKi9cbiAgICBjYW5VbmRvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEhpc3RvcnkuaGFzVW5kbygpICYmICF0aGlzLmlzVXBkYXRpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBjYW5SZWRvYCByZXR1cm5zIHdoZXRoZXIgdGhlcmUgYXJlIGFueSBvcGVyYXRpb25zIHRvIHJlZG8uXG4gICAgICovXG4gICAgY2FuUmVkbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxIaXN0b3J5Lmhhc1JlZG8oKSAmJiAhdGhpcy5pc1VwZGF0aW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdW5kb2AgdW5kb2VzIHRoZSBsYXN0IG9wZXJhdGlvbiBleGVjdXRlZCBieSB0aGUgY3VycmVudCBjbGllbnQuXG4gICAgICogSXQgZG9lcyBub3QgaW1wYWN0IG9wZXJhdGlvbnMgbWFkZSBieSBvdGhlciBjbGllbnRzLlxuICAgICAqL1xuICAgIHVuZG8oKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVXBkYXRpbmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5kbyBpcyBub3QgYWxsb3dlZCBkdXJpbmcgYW4gdXBkYXRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdW5kb09wcyA9IHRoaXMuaW50ZXJuYWxIaXN0b3J5LnBvcFVuZG8oKTtcbiAgICAgICAgaWYgKHVuZG9PcHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGVyZSBpcyBubyBvcGVyYXRpb24gdG8gYmUgdW5kb25lJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbnN1cmVDbG9uZSgpO1xuICAgICAgICAvLyBUT0RPKGNoYWNoYTkxMik6IEFmdGVyIHJlc29sdmluZyB0aGUgcHJlc2VuY2UgaW5pdGlhbGl6YXRpb24gaXNzdWUsXG4gICAgICAgIC8vIHJlbW92ZSBkZWZhdWx0IHByZXNlbmNlLigjNjA4KVxuICAgICAgICBjb25zdCBjb250ZXh0ID0gQ2hhbmdlQ29udGV4dC5jcmVhdGUodGhpcy5jaGFuZ2VJRC5uZXh0KCksIHRoaXMuY2xvbmUucm9vdCwgdGhpcy5jbG9uZS5wcmVzZW5jZXMuZ2V0KHRoaXMuY2hhbmdlSUQuZ2V0QWN0b3JJRCgpKSB8fCB7fSk7XG4gICAgICAgIC8vIGFwcGx5IHVuZG8gb3BlcmF0aW9uIGluIHRoZSBjb250ZXh0IHRvIGdlbmVyYXRlIGEgY2hhbmdlXG4gICAgICAgIGZvciAoY29uc3QgdW5kb09wIG9mIHVuZG9PcHMpIHtcbiAgICAgICAgICAgIGlmICghKHVuZG9PcCBpbnN0YW5jZW9mIE9wZXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgICAvLyBhcHBseSBwcmVzZW5jZSBjaGFuZ2UgdG8gdGhlIGNvbnRleHRcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVzZW5jZSA9IG5ldyBQcmVzZW5jZShjb250ZXh0LCBkZWVwY29weSh0aGlzLmNsb25lLnByZXNlbmNlcy5nZXQodGhpcy5jaGFuZ2VJRC5nZXRBY3RvcklEKCkpKSk7XG4gICAgICAgICAgICAgICAgcHJlc2VuY2Uuc2V0KHVuZG9PcC52YWx1ZSwgeyBhZGRUb0hpc3Rvcnk6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0aWNrZXQgPSBjb250ZXh0Lmlzc3VlVGltZVRpY2tldCgpO1xuICAgICAgICAgICAgdW5kb09wLnNldEV4ZWN1dGVkQXQodGlja2V0KTtcbiAgICAgICAgICAgIGNvbnRleHQucHVzaCh1bmRvT3ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoYW5nZSA9IGNvbnRleHQuZ2V0Q2hhbmdlKCk7XG4gICAgICAgIGNoYW5nZS5leGVjdXRlKHRoaXMuY2xvbmUucm9vdCwgdGhpcy5jbG9uZS5wcmVzZW5jZXMsIE9wU291cmNlLlVuZG9SZWRvKTtcbiAgICAgICAgY29uc3QgeyBvcEluZm9zLCByZXZlcnNlT3BzIH0gPSBjaGFuZ2UuZXhlY3V0ZSh0aGlzLnJvb3QsIHRoaXMucHJlc2VuY2VzLCBPcFNvdXJjZS5VbmRvUmVkbyk7XG4gICAgICAgIGNvbnN0IHJldmVyc2VQcmVzZW5jZSA9IGNvbnRleHQuZ2V0UmV2ZXJzZVByZXNlbmNlKCk7XG4gICAgICAgIGlmIChyZXZlcnNlUHJlc2VuY2UpIHtcbiAgICAgICAgICAgIHJldmVyc2VPcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3ByZXNlbmNlJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmV2ZXJzZVByZXNlbmNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJldmVyc2VPcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEhpc3RvcnkucHVzaFJlZG8ocmV2ZXJzZU9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9URShjaGFjaGE5MTIpOiBXaGVuIHRoZXJlIGlzIG5vIGFwcGxpZWQgb3BlcmF0aW9uIG9yIHByZXNlbmNlXG4gICAgICAgIC8vIGR1cmluZyB1bmRvL3JlZG8sIHNraXAgcHJvcGFnYXRpbmcgY2hhbmdlIHJlbW90ZWx5LlxuICAgICAgICBpZiAoIWNoYW5nZS5oYXNQcmVzZW5jZUNoYW5nZSgpICYmIG9wSW5mb3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2NhbENoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgICB0aGlzLmNoYW5nZUlEID0gY2hhbmdlLmdldElEKCk7XG4gICAgICAgIGNvbnN0IGFjdG9ySUQgPSB0aGlzLmNoYW5nZUlELmdldEFjdG9ySUQoKTtcbiAgICAgICAgaWYgKG9wSW5mb3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBEb2NFdmVudFR5cGUuTG9jYWxDaGFuZ2UsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hhbmdlLmdldE1lc3NhZ2UoKSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uczogb3BJbmZvcyxcbiAgICAgICAgICAgICAgICAgICAgYWN0b3I6IGFjdG9ySUQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2UuaGFzUHJlc2VuY2VDaGFuZ2UoKSkge1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBEb2NFdmVudFR5cGUuUHJlc2VuY2VDaGFuZ2VkLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudElEOiBhY3RvcklELFxuICAgICAgICAgICAgICAgICAgICBwcmVzZW5jZTogdGhpcy5nZXRQcmVzZW5jZShhY3RvcklEKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogYHJlZG9gIHJlZG9lcyB0aGUgbGFzdCBvcGVyYXRpb24gZXhlY3V0ZWQgYnkgdGhlIGN1cnJlbnQgY2xpZW50LlxuICAgICAqIEl0IGRvZXMgbm90IGltcGFjdCBvcGVyYXRpb25zIG1hZGUgYnkgb3RoZXIgY2xpZW50cy5cbiAgICAgKi9cbiAgICByZWRvKCkge1xuICAgICAgICBpZiAodGhpcy5pc1VwZGF0aW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZG8gaXMgbm90IGFsbG93ZWQgZHVyaW5nIGFuIHVwZGF0ZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlZG9PcHMgPSB0aGlzLmludGVybmFsSGlzdG9yeS5wb3BSZWRvKCk7XG4gICAgICAgIGlmIChyZWRvT3BzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgaXMgbm8gb3BlcmF0aW9uIHRvIGJlIHJlZG9uZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW5zdXJlQ2xvbmUoKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IENoYW5nZUNvbnRleHQuY3JlYXRlKHRoaXMuY2hhbmdlSUQubmV4dCgpLCB0aGlzLmNsb25lLnJvb3QsIHRoaXMuY2xvbmUucHJlc2VuY2VzLmdldCh0aGlzLmNoYW5nZUlELmdldEFjdG9ySUQoKSkgfHwge30pO1xuICAgICAgICAvLyBhcHBseSByZWRvIG9wZXJhdGlvbiBpbiB0aGUgY29udGV4dCB0byBnZW5lcmF0ZSBhIGNoYW5nZVxuICAgICAgICBmb3IgKGNvbnN0IHJlZG9PcCBvZiByZWRvT3BzKSB7XG4gICAgICAgICAgICBpZiAoIShyZWRvT3AgaW5zdGFuY2VvZiBPcGVyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgLy8gYXBwbHkgcHJlc2VuY2UgY2hhbmdlIHRvIHRoZSBjb250ZXh0XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlc2VuY2UgPSBuZXcgUHJlc2VuY2UoY29udGV4dCwgZGVlcGNvcHkodGhpcy5jbG9uZS5wcmVzZW5jZXMuZ2V0KHRoaXMuY2hhbmdlSUQuZ2V0QWN0b3JJRCgpKSkpO1xuICAgICAgICAgICAgICAgIHByZXNlbmNlLnNldChyZWRvT3AudmFsdWUsIHsgYWRkVG9IaXN0b3J5OiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGlja2V0ID0gY29udGV4dC5pc3N1ZVRpbWVUaWNrZXQoKTtcbiAgICAgICAgICAgIHJlZG9PcC5zZXRFeGVjdXRlZEF0KHRpY2tldCk7XG4gICAgICAgICAgICBjb250ZXh0LnB1c2gocmVkb09wKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGFuZ2UgPSBjb250ZXh0LmdldENoYW5nZSgpO1xuICAgICAgICBjaGFuZ2UuZXhlY3V0ZSh0aGlzLmNsb25lLnJvb3QsIHRoaXMuY2xvbmUucHJlc2VuY2VzLCBPcFNvdXJjZS5VbmRvUmVkbyk7XG4gICAgICAgIGNvbnN0IHsgb3BJbmZvcywgcmV2ZXJzZU9wcyB9ID0gY2hhbmdlLmV4ZWN1dGUodGhpcy5yb290LCB0aGlzLnByZXNlbmNlcywgT3BTb3VyY2UuVW5kb1JlZG8pO1xuICAgICAgICBjb25zdCByZXZlcnNlUHJlc2VuY2UgPSBjb250ZXh0LmdldFJldmVyc2VQcmVzZW5jZSgpO1xuICAgICAgICBpZiAocmV2ZXJzZVByZXNlbmNlKSB7XG4gICAgICAgICAgICByZXZlcnNlT3BzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdwcmVzZW5jZScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJldmVyc2VQcmVzZW5jZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXZlcnNlT3BzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxIaXN0b3J5LnB1c2hVbmRvKHJldmVyc2VPcHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5PVEUoY2hhY2hhOTEyKTogV2hlbiB0aGVyZSBpcyBubyBhcHBsaWVkIG9wZXJhdGlvbiBvciBwcmVzZW5jZVxuICAgICAgICAvLyBkdXJpbmcgdW5kby9yZWRvLCBza2lwIHByb3BhZ2F0aW5nIGNoYW5nZSByZW1vdGVseS5cbiAgICAgICAgaWYgKCFjaGFuZ2UuaGFzUHJlc2VuY2VDaGFuZ2UoKSAmJiBvcEluZm9zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9jYWxDaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VJRCA9IGNoYW5nZS5nZXRJRCgpO1xuICAgICAgICBjb25zdCBhY3RvcklEID0gdGhpcy5jaGFuZ2VJRC5nZXRBY3RvcklEKCk7XG4gICAgICAgIGlmIChvcEluZm9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogRG9jRXZlbnRUeXBlLkxvY2FsQ2hhbmdlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoYW5nZS5nZXRNZXNzYWdlKCkgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbnM6IG9wSW5mb3MsXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yOiBhY3RvcklELFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlLmhhc1ByZXNlbmNlQ2hhbmdlKCkpIHtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogRG9jRXZlbnRUeXBlLlByZXNlbmNlQ2hhbmdlZCxcbiAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICBjbGllbnRJRDogYWN0b3JJRCxcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VuY2U6IHRoaXMuZ2V0UHJlc2VuY2UoYWN0b3JJRCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRVbmRvU3RhY2tGb3JUZXN0YCByZXR1cm5zIHRoZSB1bmRvIHN0YWNrIGZvciB0ZXN0LlxuICAgICAqL1xuICAgIGdldFVuZG9TdGFja0ZvclRlc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsSGlzdG9yeS5nZXRVbmRvU3RhY2tGb3JUZXN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRSZWRvU3RhY2tGb3JUZXN0YCByZXR1cm5zIHRoZSByZWRvIHN0YWNrIGZvciB0ZXN0LlxuICAgICAqL1xuICAgIGdldFJlZG9TdGFja0ZvclRlc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsSGlzdG9yeS5nZXRSZWRvU3RhY2tGb3JUZXN0KCk7XG4gICAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY2xpZW50L2F1dGhfaW50ZXJjZXB0b3IudHNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIGBjcmVhdGVBdXRoSW50ZXJjZXB0b3JgIGNyZWF0ZXMgYW4gaW50ZXJjZXB0b3IgdG8gYWRkIHRoZSBBdXRob3JpemF0aW9uIGhlYWRlciBmb3IgZWFjaFxuICogcmVxdWVzdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXV0aEludGVyY2VwdG9yKGFwaUtleSwgdG9rZW4pIHtcbiAgICByZXR1cm4gKG5leHQpID0+IGFzeW5jIChyZXEpID0+IHtcbiAgICAgICAgaWYgKGFwaUtleSkge1xuICAgICAgICAgICAgcmVxLmhlYWRlci5zZXQoJ3gtYXBpLWtleScsIGFwaUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICByZXEuaGVhZGVyLnNldCgnYXV0aG9yaXphdGlvbicsIHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgbmV4dChyZXEpO1xuICAgIH07XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2UuanNvblxuY29uc3QgcGFja2FnZV9uYW1lc3BhY2VPYmplY3QgPSBKU09OLnBhcnNlKCd7XCJ1MlwiOlwieW9ya2llLWpzLXNka1wiLFwiaThcIjpcIjAuNC4xMVwifScpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NsaWVudC9tZXRyaWNfaW50ZXJjZXB0b3IudHNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogYGNyZWF0ZU1ldHJpY0ludGVyY2VwdG9yYCBjcmVhdGVzIGFuIGludGVyY2VwdG9yIHRvIGFkZCB0aGUgeC15b3JraWUtdXNlci1hZ2VudCBoZWFkZXIgZm9yIGVhY2hcbiAqIHJlcXVlc3QuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1ldHJpY0ludGVyY2VwdG9yKCkge1xuICAgIHJldHVybiAobmV4dCkgPT4gYXN5bmMgKHJlcSkgPT4ge1xuICAgICAgICByZXEuaGVhZGVyLnNldCgneC15b3JraWUtdXNlci1hZ2VudCcsIHBhY2thZ2VfbmFtZXNwYWNlT2JqZWN0LnUyICsgJy8nICsgcGFja2FnZV9uYW1lc3BhY2VPYmplY3QuaTgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgbmV4dChyZXEpO1xuICAgIH07XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jbGllbnQvY2xpZW50LnRzXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgVGhlIFlvcmtpZSBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8qKlxuICogYFN5bmNNb2RlYCBpcyB0aGUgbW9kZSBvZiBzeW5jaHJvbml6YXRpb24uIEl0IGlzIHVzZWQgdG8gZGV0ZXJtaW5lXG4gKiB3aGV0aGVyIHRvIHB1c2ggYW5kIHB1bGwgY2hhbmdlcyBpbiBQdXNoUHVsbENoYW5nZXMgQVBJLlxuICogQHB1YmxpY1xuICovXG52YXIgU3luY01vZGU7XG4oZnVuY3Rpb24gKFN5bmNNb2RlKSB7XG4gICAgLyoqXG4gICAgICogYFB1c2hQdWxsYCBpcyB0aGUgbW9kZSB0aGF0IHB1c2hlcyBhbmQgcHVsbHMgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBTeW5jTW9kZVtcIlB1c2hQdWxsXCJdID0gXCJwdXNocHVsbFwiO1xuICAgIC8qKlxuICAgICAqIGBQdXNoT25seWAgaXMgdGhlIG1vZGUgdGhhdCBwdXNoZXMgY2hhbmdlcyBvbmx5LlxuICAgICAqL1xuICAgIFN5bmNNb2RlW1wiUHVzaE9ubHlcIl0gPSBcInB1c2hvbmx5XCI7XG59KShTeW5jTW9kZSB8fCAoU3luY01vZGUgPSB7fSkpO1xuLyoqXG4gKiBgQ2xpZW50U3RhdHVzYCByZXByZXNlbnRzIHRoZSBzdGF0dXMgb2YgdGhlIGNsaWVudC5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIENsaWVudFN0YXR1cztcbihmdW5jdGlvbiAoQ2xpZW50U3RhdHVzKSB7XG4gICAgLyoqXG4gICAgICogYERlYWN0aXZhdGVkYCBtZWFucyB0aGF0IHRoZSBjbGllbnQgaXMgbm90IGFjdGl2YXRlZC4gSXQgaXMgdGhlIGluaXRpYWxcbiAgICAgKiBzdGF0dXMgb2YgdGhlIGNsaWVudC4gSWYgdGhlIGNsaWVudCBpcyBkZWFjdGl2YXRlZCwgYWxsIGBEb2N1bWVudGBzIG9mIHRoZVxuICAgICAqIGNsaWVudCBhcmUgYWxzbyBub3QgdXNlZC5cbiAgICAgKi9cbiAgICBDbGllbnRTdGF0dXNbXCJEZWFjdGl2YXRlZFwiXSA9IFwiZGVhY3RpdmF0ZWRcIjtcbiAgICAvKipcbiAgICAgKiBgQWN0aXZhdGVkYCBtZWFucyB0aGF0IHRoZSBjbGllbnQgaXMgYWN0aXZhdGVkLiBJZiB0aGUgY2xpZW50IGlzIGFjdGl2YXRlZCxcbiAgICAgKiBhbGwgYERvY3VtZW50YHMgb2YgdGhlIGNsaWVudCBhcmUgYWxzbyByZWFkeSB0byBiZSB1c2VkLlxuICAgICAqL1xuICAgIENsaWVudFN0YXR1c1tcIkFjdGl2YXRlZFwiXSA9IFwiYWN0aXZhdGVkXCI7XG59KShDbGllbnRTdGF0dXMgfHwgKENsaWVudFN0YXR1cyA9IHt9KSk7XG4vKipcbiAqIGBTdHJlYW1Db25uZWN0aW9uU3RhdHVzYCByZXByZXNlbnRzIHdoZXRoZXIgdGhlIHN0cmVhbSBjb25uZWN0aW9uIGJldHdlZW4gdGhlXG4gKiBjbGllbnQgYW5kIHRoZSBzZXJ2ZXIgaXMgY29ubmVjdGVkIG9yIG5vdC5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIFN0cmVhbUNvbm5lY3Rpb25TdGF0dXM7XG4oZnVuY3Rpb24gKFN0cmVhbUNvbm5lY3Rpb25TdGF0dXMpIHtcbiAgICAvKipcbiAgICAgKiBgQ29ubmVjdGVkYCBtZWFucyB0aGF0IHRoZSBzdHJlYW0gY29ubmVjdGlvbiBpcyBjb25uZWN0ZWQuXG4gICAgICovXG4gICAgU3RyZWFtQ29ubmVjdGlvblN0YXR1c1tcIkNvbm5lY3RlZFwiXSA9IFwiY29ubmVjdGVkXCI7XG4gICAgLyoqXG4gICAgICogYERpc2Nvbm5lY3RlZGAgbWVhbnMgdGhhdCB0aGUgc3RyZWFtIGNvbm5lY3Rpb24gaXMgZGlzY29ubmVjdGVkLlxuICAgICAqL1xuICAgIFN0cmVhbUNvbm5lY3Rpb25TdGF0dXNbXCJEaXNjb25uZWN0ZWRcIl0gPSBcImRpc2Nvbm5lY3RlZFwiO1xufSkoU3RyZWFtQ29ubmVjdGlvblN0YXR1cyB8fCAoU3RyZWFtQ29ubmVjdGlvblN0YXR1cyA9IHt9KSk7XG4vKipcbiAqIGBEb2N1bWVudFN5bmNSZXN1bHRUeXBlYCByZXByZXNlbnRzIHRoZSByZXN1bHQgb2Ygc3luY2hyb25pemluZyB0aGUgZG9jdW1lbnRcbiAqICB3aXRoIHRoZSBzZXJ2ZXIuXG4gKiBAcHVibGljXG4gKi9cbnZhciBEb2N1bWVudFN5bmNSZXN1bHRUeXBlO1xuKGZ1bmN0aW9uIChEb2N1bWVudFN5bmNSZXN1bHRUeXBlKSB7XG4gICAgLyoqXG4gICAgICogdHlwZSB3aGVuIERvY3VtZW50IHN5bmNlZCBzdWNjZXNzZnVsbHkuXG4gICAgICovXG4gICAgRG9jdW1lbnRTeW5jUmVzdWx0VHlwZVtcIlN5bmNlZFwiXSA9IFwic3luY2VkXCI7XG4gICAgLyoqXG4gICAgICogdHlwZSB3aGVuIERvY3VtZW50IHN5bmMgZmFpbGVkLlxuICAgICAqL1xuICAgIERvY3VtZW50U3luY1Jlc3VsdFR5cGVbXCJTeW5jRmFpbGVkXCJdID0gXCJzeW5jLWZhaWxlZFwiO1xufSkoRG9jdW1lbnRTeW5jUmVzdWx0VHlwZSB8fCAoRG9jdW1lbnRTeW5jUmVzdWx0VHlwZSA9IHt9KSk7XG4vKipcbiAqIGBDbGllbnRFdmVudFR5cGVgIHJlcHJlc2VudHMgdGhlIHR5cGUgb2YgdGhlIGV2ZW50IHRoYXQgdGhlIGNsaWVudCBjYW4gZW1pdC5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIENsaWVudEV2ZW50VHlwZTtcbihmdW5jdGlvbiAoQ2xpZW50RXZlbnRUeXBlKSB7XG4gICAgLyoqXG4gICAgICogYFN0YXR1c0NoYW5nZWRgIG1lYW5zIHRoYXQgdGhlIHN0YXR1cyBvZiB0aGUgY2xpZW50IGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIENsaWVudEV2ZW50VHlwZVtcIlN0YXR1c0NoYW5nZWRcIl0gPSBcInN0YXR1cy1jaGFuZ2VkXCI7XG4gICAgLyoqXG4gICAgICogYERvY3VtZW50Q2hhbmdlZGAgbWVhbnMgdGhhdCB0aGUgZG9jdW1lbnQgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgQ2xpZW50RXZlbnRUeXBlW1wiRG9jdW1lbnRDaGFuZ2VkXCJdID0gXCJkb2N1bWVudC1jaGFuZ2VkXCI7XG4gICAgLyoqXG4gICAgICogYFN0cmVhbUNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkYCBtZWFucyB0aGF0IHRoZSBzdHJlYW0gY29ubmVjdGlvbiBzdGF0dXMgb2ZcbiAgICAgKiB0aGUgY2xpZW50IGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIENsaWVudEV2ZW50VHlwZVtcIlN0cmVhbUNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkXCJdID0gXCJzdHJlYW0tY29ubmVjdGlvbi1zdGF0dXMtY2hhbmdlZFwiO1xuICAgIC8qKlxuICAgICAqIGBEb2N1bWVudFN5bmNlZGAgbWVhbnMgdGhhdCB0aGUgZG9jdW1lbnQgaGFzIGJlZW4gc3luY2VkIHdpdGggdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBDbGllbnRFdmVudFR5cGVbXCJEb2N1bWVudFN5bmNlZFwiXSA9IFwiZG9jdW1lbnQtc3luY2VkXCI7XG59KShDbGllbnRFdmVudFR5cGUgfHwgKENsaWVudEV2ZW50VHlwZSA9IHt9KSk7XG4vKipcbiAqIGBEZWZhdWx0Q2xpZW50T3B0aW9uc2AgaXMgdGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgQ2xpZW50LlxuICovXG5jb25zdCBEZWZhdWx0Q2xpZW50T3B0aW9ucyA9IHtcbiAgICBzeW5jTG9vcER1cmF0aW9uOiA1MCxcbiAgICByZXRyeVN5bmNMb29wRGVsYXk6IDEwMDAsXG4gICAgcmVjb25uZWN0U3RyZWFtRGVsYXk6IDEwMDAsXG59O1xuLyoqXG4gKiBgQ2xpZW50YCBpcyBhIG5vcm1hbCBjbGllbnQgdGhhdCBjYW4gY29tbXVuaWNhdGUgd2l0aCB0aGUgc2VydmVyLlxuICogSXQgaGFzIGRvY3VtZW50cyBhbmQgc2VuZHMgY2hhbmdlcyBvZiB0aGUgZG9jdW1lbnRzIGluIGxvY2FsXG4gKiB0byB0aGUgc2VydmVyIHRvIHN5bmNocm9uaXplIHdpdGggb3RoZXIgcmVwbGljYXMgaW4gcmVtb3RlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcnBjQWRkciAtIHRoZSBhZGRyZXNzIG9mIHRoZSBSUEMgc2VydmVyLlxuICAgICAqIEBwYXJhbSBvcHRzIC0gdGhlIG9wdGlvbnMgb2YgdGhlIGNsaWVudC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihycGNBZGRyLCBvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IERlZmF1bHRDbGllbnRPcHRpb25zO1xuICAgICAgICB0aGlzLmtleSA9IG9wdHMua2V5ID8gb3B0cy5rZXkgOiB1dWlkKCk7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gQ2xpZW50U3RhdHVzLkRlYWN0aXZhdGVkO1xuICAgICAgICB0aGlzLmF0dGFjaG1lbnRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIFRPRE8oaGFja2Vyd2lucyk6IENvbnNpZGVyIHRvIGdyb3VwIHRoZSBvcHRpb25zIGFzIGEgc2luZ2xlIG9iamVjdC5cbiAgICAgICAgdGhpcy5hcGlLZXkgPSBvcHRzLmFwaUtleSB8fCAnJztcbiAgICAgICAgdGhpcy5zeW5jTG9vcER1cmF0aW9uID1cbiAgICAgICAgICAgIG9wdHMuc3luY0xvb3BEdXJhdGlvbiB8fCBEZWZhdWx0Q2xpZW50T3B0aW9ucy5zeW5jTG9vcER1cmF0aW9uO1xuICAgICAgICB0aGlzLnJlY29ubmVjdFN0cmVhbURlbGF5ID1cbiAgICAgICAgICAgIG9wdHMucmVjb25uZWN0U3RyZWFtRGVsYXkgfHwgRGVmYXVsdENsaWVudE9wdGlvbnMucmVjb25uZWN0U3RyZWFtRGVsYXk7XG4gICAgICAgIHRoaXMucmV0cnlTeW5jTG9vcERlbGF5ID1cbiAgICAgICAgICAgIG9wdHMucmV0cnlTeW5jTG9vcERlbGF5IHx8IERlZmF1bHRDbGllbnRPcHRpb25zLnJldHJ5U3luY0xvb3BEZWxheTtcbiAgICAgICAgLy8gSGVyZSB3ZSBtYWtlIHRoZSBjbGllbnQgaXRzZWxmLCBjb21iaW5pbmcgdGhlIHNlcnZpY2VcbiAgICAgICAgLy8gZGVmaW5pdGlvbiB3aXRoIHRoZSB0cmFuc3BvcnQuXG4gICAgICAgIHRoaXMucnBjQ2xpZW50ID0gY3JlYXRlUHJvbWlzZUNsaWVudCh5b3JraWVfY29ubmVjdC8qIFlvcmtpZVNlcnZpY2UgKi8uViwgY3JlYXRlR3JwY1dlYlRyYW5zcG9ydCh7XG4gICAgICAgICAgICBiYXNlVXJsOiBycGNBZGRyLFxuICAgICAgICAgICAgaW50ZXJjZXB0b3JzOiBbXG4gICAgICAgICAgICAgICAgY3JlYXRlQXV0aEludGVyY2VwdG9yKG9wdHMuYXBpS2V5LCBvcHRzLnRva2VuKSxcbiAgICAgICAgICAgICAgICBjcmVhdGVNZXRyaWNJbnRlcmNlcHRvcigpLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmV2ZW50U3RyZWFtID0gY3JlYXRlT2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTdHJlYW1PYnNlcnZlciA9IG9ic2VydmVyO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGFjdGl2YXRlYCBhY3RpdmF0ZXMgdGhpcyBjbGllbnQuIFRoYXQgaXMsIGl0IHJlZ2lzdGVycyBpdHNlbGYgdG8gdGhlIHNlcnZlclxuICAgICAqIGFuZCByZWNlaXZlcyBhIHVuaXF1ZSBJRCBmcm9tIHRoZSBzZXJ2ZXIuIFRoZSBnaXZlbiBJRCBpcyB1c2VkIHRvXG4gICAgICogZGlzdGluZ3Vpc2ggZGlmZmVyZW50IGNsaWVudHMuXG4gICAgICovXG4gICAgYWN0aXZhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ycGNDbGllbnRcbiAgICAgICAgICAgIC5hY3RpdmF0ZUNsaWVudCh7XG4gICAgICAgICAgICBjbGllbnRLZXk6IHRoaXMua2V5LFxuICAgICAgICB9LCB7IGhlYWRlcnM6IHsgJ3gtc2hhcmQta2V5JzogdGhpcy5hcGlLZXkgfSB9KVxuICAgICAgICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgdGhpcy5pZCA9IHJlcy5jbGllbnRJZDtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gQ2xpZW50U3RhdHVzLkFjdGl2YXRlZDtcbiAgICAgICAgICAgIHRoaXMucnVuU3luY0xvb3AoKTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTdHJlYW1PYnNlcnZlci5uZXh0KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBDbGllbnRFdmVudFR5cGUuU3RhdHVzQ2hhbmdlZCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5zdGF0dXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBbQUNdIGM6XCIke3RoaXMuZ2V0S2V5KCl9XCIgYWN0aXZhdGVkLCBpZDpcIiR7dGhpcy5pZH1cImApO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgW0FDXSBjOlwiJHt0aGlzLmdldEtleSgpfVwiIGVyciA6YCwgZXJyKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBkZWFjdGl2YXRlYCBkZWFjdGl2YXRlcyB0aGlzIGNsaWVudC5cbiAgICAgKi9cbiAgICBkZWFjdGl2YXRlKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IENsaWVudFN0YXR1cy5EZWFjdGl2YXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2tleV0gb2YgdGhpcy5hdHRhY2htZW50TWFwKSB7XG4gICAgICAgICAgICB0aGlzLmRldGFjaEludGVybmFsKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucnBjQ2xpZW50XG4gICAgICAgICAgICAuZGVhY3RpdmF0ZUNsaWVudCh7XG4gICAgICAgICAgICBjbGllbnRJZDogdGhpcy5pZCxcbiAgICAgICAgfSwgeyBoZWFkZXJzOiB7ICd4LXNoYXJkLWtleSc6IHRoaXMuYXBpS2V5IH0gfSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gQ2xpZW50U3RhdHVzLkRlYWN0aXZhdGVkO1xuICAgICAgICAgICAgdGhpcy5ldmVudFN0cmVhbU9ic2VydmVyLm5leHQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IENsaWVudEV2ZW50VHlwZS5TdGF0dXNDaGFuZ2VkLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYFtEQ10gY1wiJHt0aGlzLmdldEtleSgpfVwiIGRlYWN0aXZhdGVkYCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBbRENdIGM6XCIke3RoaXMuZ2V0S2V5KCl9XCIgZXJyIDpgLCBlcnIpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGF0dGFjaGAgYXR0YWNoZXMgdGhlIGdpdmVuIGRvY3VtZW50IHRvIHRoaXMgY2xpZW50LiBJdCB0ZWxscyB0aGUgc2VydmVyIHRoYXRcbiAgICAgKiB0aGlzIGNsaWVudCB3aWxsIHN5bmNocm9uaXplIHRoZSBnaXZlbiBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBhdHRhY2goZG9jLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFlvcmtpZUVycm9yKGVycm9yX0NvZGUuQ2xpZW50Tm90QWN0aXZlLCBgJHt0aGlzLmtleX0gaXMgbm90IGFjdGl2ZWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb2MuZ2V0U3RhdHVzKCkgIT09IERvY3VtZW50U3RhdHVzLkRldGFjaGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgWW9ya2llRXJyb3IoZXJyb3JfQ29kZS5Eb2N1bWVudE5vdERldGFjaGVkLCBgJHtkb2MuZ2V0S2V5KCl9IGlzIG5vdCBkZXRhY2hlZGApO1xuICAgICAgICB9XG4gICAgICAgIGRvYy5zZXRBY3Rvcih0aGlzLmlkKTtcbiAgICAgICAgZG9jLnVwZGF0ZSgoXywgcCkgPT4gcC5zZXQob3B0aW9ucy5pbml0aWFsUHJlc2VuY2UgfHwge30pKTtcbiAgICAgICAgY29uc3QgaXNSZWFsdGltZVN5bmMgPSAoX2EgPSBvcHRpb25zLmlzUmVhbHRpbWVTeW5jKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5ycGNDbGllbnRcbiAgICAgICAgICAgIC5hdHRhY2hEb2N1bWVudCh7XG4gICAgICAgICAgICBjbGllbnRJZDogdGhpcy5pZCxcbiAgICAgICAgICAgIGNoYW5nZVBhY2s6IGNvbnZlcnRlci50b0NoYW5nZVBhY2soZG9jLmNyZWF0ZUNoYW5nZVBhY2soKSksXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ3gtc2hhcmQta2V5JzogYCR7dGhpcy5hcGlLZXl9LyR7ZG9jLmdldEtleSgpfWAgfSxcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGFzeW5jIChyZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhY2sgPSBjb252ZXJ0ZXIuZnJvbUNoYW5nZVBhY2socmVzLmNoYW5nZVBhY2spO1xuICAgICAgICAgICAgZG9jLmFwcGx5Q2hhbmdlUGFjayhwYWNrKTtcbiAgICAgICAgICAgIGlmIChkb2MuZ2V0U3RhdHVzKCkgPT09IERvY3VtZW50U3RhdHVzLlJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9jLnNldFN0YXR1cyhEb2N1bWVudFN0YXR1cy5BdHRhY2hlZCk7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaG1lbnRNYXAuc2V0KGRvYy5nZXRLZXkoKSwgbmV3IEF0dGFjaG1lbnQodGhpcy5yZWNvbm5lY3RTdHJlYW1EZWxheSwgZG9jLCByZXMuZG9jdW1lbnRJZCwgaXNSZWFsdGltZVN5bmMpKTtcbiAgICAgICAgICAgIGlmIChpc1JlYWx0aW1lU3luYykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucnVuV2F0Y2hMb29wKGRvYy5nZXRLZXkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgW0FEXSBjOlwiJHt0aGlzLmdldEtleSgpfVwiIGF0dGFjaGVzIGQ6XCIke2RvYy5nZXRLZXkoKX1cImApO1xuICAgICAgICAgICAgcmV0dXJuIGRvYztcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFtBRF0gYzpcIiR7dGhpcy5nZXRLZXkoKX1cIiBlcnIgOmAsIGVycik7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZGV0YWNoYCBkZXRhY2hlcyB0aGUgZ2l2ZW4gZG9jdW1lbnQgZnJvbSB0aGlzIGNsaWVudC4gSXQgdGVsbHMgdGhlXG4gICAgICogc2VydmVyIHRoYXQgdGhpcyBjbGllbnQgd2lsbCBubyBsb25nZXIgc3luY2hyb25pemUgdGhlIGdpdmVuIGRvY3VtZW50LlxuICAgICAqXG4gICAgICogVG8gY29sbGVjdCBnYXJiYWdlIHRoaW5ncyBsaWtlIENSRFQgdG9tYnN0b25lcyBsZWZ0IG9uIHRoZSBkb2N1bWVudCwgYWxsXG4gICAgICogdGhlIGNoYW5nZXMgc2hvdWxkIGJlIGFwcGxpZWQgdG8gb3RoZXIgcmVwbGljYXMgYmVmb3JlIEdDIHRpbWUuIEZvciB0aGlzLFxuICAgICAqIGlmIHRoZSBkb2N1bWVudCBpcyBubyBsb25nZXIgdXNlZCBieSB0aGlzIGNsaWVudCwgaXQgc2hvdWxkIGJlIGRldGFjaGVkLlxuICAgICAqL1xuICAgIGRldGFjaChkb2MsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgWW9ya2llRXJyb3IoZXJyb3JfQ29kZS5DbGllbnROb3RBY3RpdmUsIGAke3RoaXMua2V5fSBpcyBub3QgYWN0aXZlYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXR0YWNobWVudCA9IHRoaXMuYXR0YWNobWVudE1hcC5nZXQoZG9jLmdldEtleSgpKTtcbiAgICAgICAgaWYgKCFhdHRhY2htZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgWW9ya2llRXJyb3IoZXJyb3JfQ29kZS5Eb2N1bWVudE5vdEF0dGFjaGVkLCBgJHtkb2MuZ2V0S2V5KCl9IGlzIG5vdCBhdHRhY2hlZGApO1xuICAgICAgICB9XG4gICAgICAgIGRvYy51cGRhdGUoKF8sIHApID0+IHAuY2xlYXIoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJwY0NsaWVudFxuICAgICAgICAgICAgLmRldGFjaERvY3VtZW50KHtcbiAgICAgICAgICAgIGNsaWVudElkOiB0aGlzLmlkLFxuICAgICAgICAgICAgZG9jdW1lbnRJZDogYXR0YWNobWVudC5kb2NJRCxcbiAgICAgICAgICAgIGNoYW5nZVBhY2s6IGNvbnZlcnRlci50b0NoYW5nZVBhY2soZG9jLmNyZWF0ZUNoYW5nZVBhY2soKSksXG4gICAgICAgICAgICByZW1vdmVJZk5vdEF0dGFjaGVkOiAoX2EgPSBvcHRpb25zLnJlbW92ZUlmTm90QXR0YWNoZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7ICd4LXNoYXJkLWtleSc6IGAke3RoaXMuYXBpS2V5fS8ke2RvYy5nZXRLZXkoKX1gIH0sXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYWNrID0gY29udmVydGVyLmZyb21DaGFuZ2VQYWNrKHJlcy5jaGFuZ2VQYWNrKTtcbiAgICAgICAgICAgIGRvYy5hcHBseUNoYW5nZVBhY2socGFjayk7XG4gICAgICAgICAgICBpZiAoZG9jLmdldFN0YXR1cygpICE9PSBEb2N1bWVudFN0YXR1cy5SZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgZG9jLnNldFN0YXR1cyhEb2N1bWVudFN0YXR1cy5EZXRhY2hlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRldGFjaEludGVybmFsKGRvYy5nZXRLZXkoKSk7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgW0REXSBjOlwiJHt0aGlzLmdldEtleSgpfVwiIGRldGFjaGVzIGQ6XCIke2RvYy5nZXRLZXkoKX1cImApO1xuICAgICAgICAgICAgcmV0dXJuIGRvYztcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFtERF0gYzpcIiR7dGhpcy5nZXRLZXkoKX1cIiBlcnIgOmAsIGVycik7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgcGF1c2VgIGNoYW5nZXMgdGhlIHN5bmNocm9uaXphdGlvbiBtb2RlIG9mIHRoZSBnaXZlbiBkb2N1bWVudCB0byBtYW51YWwuXG4gICAgICovXG4gICAgcGF1c2UoZG9jKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgWW9ya2llRXJyb3IoZXJyb3JfQ29kZS5DbGllbnROb3RBY3RpdmUsIGAke3RoaXMua2V5fSBpcyBub3QgYWN0aXZlYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlUmVhbHRpbWVTeW5jKGRvYywgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgcmVzdW1lYCBjaGFuZ2VzIHRoZSBzeW5jaHJvbml6YXRpb24gbW9kZSBvZiB0aGUgZ2l2ZW4gZG9jdW1lbnQgdG8gcmVhbHRpbWUuXG4gICAgICovXG4gICAgcmVzdW1lKGRvYykge1xuICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFlvcmtpZUVycm9yKGVycm9yX0NvZGUuQ2xpZW50Tm90QWN0aXZlLCBgJHt0aGlzLmtleX0gaXMgbm90IGFjdGl2ZWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZVJlYWx0aW1lU3luYyhkb2MsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgcGF1c2VSZW1vdGVDaGFuZ2VzYCBwYXVzZXMgdGhlIHN5bmNocm9uaXphdGlvbiBvZiByZW1vdGUgY2hhbmdlcyxcbiAgICAgKiBhbGxvd2luZyBvbmx5IGxvY2FsIGNoYW5nZXMgdG8gYmUgYXBwbGllZC5cbiAgICAgKi9cbiAgICBwYXVzZVJlbW90ZUNoYW5nZXMoZG9jKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgWW9ya2llRXJyb3IoZXJyb3JfQ29kZS5DbGllbnROb3RBY3RpdmUsIGAke3RoaXMua2V5fSBpcyBub3QgYWN0aXZlYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXR0YWNobWVudCA9IHRoaXMuYXR0YWNobWVudE1hcC5nZXQoZG9jLmdldEtleSgpKTtcbiAgICAgICAgaWYgKCFhdHRhY2htZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgWW9ya2llRXJyb3IoZXJyb3JfQ29kZS5Eb2N1bWVudE5vdEF0dGFjaGVkLCBgJHtkb2MuZ2V0S2V5KCl9IGlzIG5vdCBhdHRhY2hlZGApO1xuICAgICAgICB9XG4gICAgICAgIGF0dGFjaG1lbnQuY2hhbmdlU3luY01vZGUoU3luY01vZGUuUHVzaE9ubHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgcmVzdW1lUmVtb3RlQ2hhbmdlc2AgcmVzdW1lcyB0aGUgc3luY2hyb25pemF0aW9uIG9mIHJlbW90ZSBjaGFuZ2VzLFxuICAgICAqIGFsbG93aW5nIGJvdGggbG9jYWwgYW5kIHJlbW90ZSBjaGFuZ2VzIHRvIGJlIGFwcGxpZWQuXG4gICAgICovXG4gICAgcmVzdW1lUmVtb3RlQ2hhbmdlcyhkb2MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBZb3JraWVFcnJvcihlcnJvcl9Db2RlLkNsaWVudE5vdEFjdGl2ZSwgYCR7dGhpcy5rZXl9IGlzIG5vdCBhY3RpdmVgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdHRhY2htZW50ID0gdGhpcy5hdHRhY2htZW50TWFwLmdldChkb2MuZ2V0S2V5KCkpO1xuICAgICAgICBpZiAoIWF0dGFjaG1lbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBZb3JraWVFcnJvcihlcnJvcl9Db2RlLkRvY3VtZW50Tm90QXR0YWNoZWQsIGAke2RvYy5nZXRLZXkoKX0gaXMgbm90IGF0dGFjaGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0YWNobWVudC5jaGFuZ2VTeW5jTW9kZShTeW5jTW9kZS5QdXNoUHVsbCk7XG4gICAgICAgIGF0dGFjaG1lbnQucmVtb3RlQ2hhbmdlRXZlbnRSZWNlaXZlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBjaGFuZ2VSZWFsdGltZVN5bmNgIGNoYW5nZXMgdGhlIHN5bmNocm9uaXphdGlvbiBtb2RlIG9mIHRoZSBnaXZlbiBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBhc3luYyBjaGFuZ2VSZWFsdGltZVN5bmMoZG9jLCBpc1JlYWx0aW1lU3luYykge1xuICAgICAgICAvLyBUT0RPKGhhY2tlcndpbnMpOiBXZSBuZWVkIHRvIGNvbnNpZGVyIGV4dHJhY3RpbmcgdGhpcyBtZXRob2QgdG8gYGF0dGFjaG1lbnRgXG4gICAgICAgIC8vIHdpdGggb3RoZXIgbWV0aG9kcyBsaWtlIHJ1bldhdGNoTG9vcCwgZGlzY29ubmVjdFdhdGNoU3RyZWFtLlxuICAgICAgICBjb25zdCBhdHRhY2htZW50ID0gdGhpcy5hdHRhY2htZW50TWFwLmdldChkb2MuZ2V0S2V5KCkpO1xuICAgICAgICBpZiAoIWF0dGFjaG1lbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBZb3JraWVFcnJvcihlcnJvcl9Db2RlLkRvY3VtZW50Tm90QXR0YWNoZWQsIGAke2RvYy5nZXRLZXkoKX0gaXMgbm90IGF0dGFjaGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhdHRhY2htZW50LmNoYW5nZVJlYWx0aW1lU3luYyhpc1JlYWx0aW1lU3luYykpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUmVhbHRpbWVTeW5jKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJ1bldhdGNoTG9vcChkb2MuZ2V0S2V5KCkpO1xuICAgICAgICAgICAgcmV0dXJuIGRvYztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50U3RyZWFtT2JzZXJ2ZXIubmV4dCh7XG4gICAgICAgICAgICB0eXBlOiBDbGllbnRFdmVudFR5cGUuU3RyZWFtQ29ubmVjdGlvblN0YXR1c0NoYW5nZWQsXG4gICAgICAgICAgICB2YWx1ZTogU3RyZWFtQ29ubmVjdGlvblN0YXR1cy5EaXNjb25uZWN0ZWQsXG4gICAgICAgIH0pO1xuICAgICAgICBsb2dnZXIuZGVidWcoYFtXRF0gYzpcIiR7dGhpcy5nZXRLZXkoKX1cIiB1bndhdGNoZXNgKTtcbiAgICAgICAgcmV0dXJuIGRvYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHN5bmNgIHB1c2hlcyBsb2NhbCBjaGFuZ2VzIG9mIHRoZSBhdHRhY2hlZCBkb2N1bWVudHMgdG8gdGhlIHNlcnZlciBhbmRcbiAgICAgKiByZWNlaXZlcyBjaGFuZ2VzIG9mIHRoZSByZW1vdGUgcmVwbGljYSBmcm9tIHRoZSBzZXJ2ZXIgdGhlbiBhcHBseSB0aGVtIHRvXG4gICAgICogbG9jYWwgZG9jdW1lbnRzLlxuICAgICAqL1xuICAgIHN5bmMoZG9jLCBzeW5jTW9kZSA9IFN5bmNNb2RlLlB1c2hQdWxsKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgWW9ya2llRXJyb3IoZXJyb3JfQ29kZS5DbGllbnROb3RBY3RpdmUsIGAke3RoaXMua2V5fSBpcyBub3QgYWN0aXZlYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgaWYgKGRvYykge1xuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBhdHRhY2htZW50ID0gdGhpcy5hdHRhY2htZW50TWFwLmdldChkb2MuZ2V0S2V5KCkpO1xuICAgICAgICAgICAgaWYgKCFhdHRhY2htZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFlvcmtpZUVycm9yKGVycm9yX0NvZGUuRG9jdW1lbnROb3RBdHRhY2hlZCwgYCR7ZG9jLmdldEtleSgpfSBpcyBub3QgYXR0YWNoZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5zeW5jSW50ZXJuYWwoYXR0YWNobWVudCwgc3luY01vZGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNobWVudE1hcC5mb3JFYWNoKChhdHRhY2htZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnN5bmNJbnRlcm5hbChhdHRhY2htZW50LCBhdHRhY2htZW50LnN5bmNNb2RlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTdHJlYW1PYnNlcnZlci5uZXh0KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBDbGllbnRFdmVudFR5cGUuRG9jdW1lbnRTeW5jZWQsXG4gICAgICAgICAgICAgICAgdmFsdWU6IERvY3VtZW50U3luY1Jlc3VsdFR5cGUuU3luY0ZhaWxlZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHJlbW92ZWAgcmVtb3ZlcyB0aGUgZ2l2ZW4gZG9jdW1lbnQuXG4gICAgICovXG4gICAgcmVtb3ZlKGRvYykge1xuICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFlvcmtpZUVycm9yKGVycm9yX0NvZGUuQ2xpZW50Tm90QWN0aXZlLCBgJHt0aGlzLmtleX0gaXMgbm90IGFjdGl2ZWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0dGFjaG1lbnQgPSB0aGlzLmF0dGFjaG1lbnRNYXAuZ2V0KGRvYy5nZXRLZXkoKSk7XG4gICAgICAgIGlmICghYXR0YWNobWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFlvcmtpZUVycm9yKGVycm9yX0NvZGUuRG9jdW1lbnROb3RBdHRhY2hlZCwgYCR7ZG9jLmdldEtleSgpfSBpcyBub3QgYXR0YWNoZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBkb2Muc2V0QWN0b3IodGhpcy5pZCk7XG4gICAgICAgIGNvbnN0IHBiQ2hhbmdlUGFjayA9IGNvbnZlcnRlci50b0NoYW5nZVBhY2soZG9jLmNyZWF0ZUNoYW5nZVBhY2soKSk7XG4gICAgICAgIHBiQ2hhbmdlUGFjay5pc1JlbW92ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5ycGNDbGllbnRcbiAgICAgICAgICAgIC5yZW1vdmVEb2N1bWVudCh7XG4gICAgICAgICAgICBjbGllbnRJZDogdGhpcy5pZCxcbiAgICAgICAgICAgIGRvY3VtZW50SWQ6IGF0dGFjaG1lbnQuZG9jSUQsXG4gICAgICAgICAgICBjaGFuZ2VQYWNrOiBwYkNoYW5nZVBhY2ssXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ3gtc2hhcmQta2V5JzogYCR7dGhpcy5hcGlLZXl9LyR7ZG9jLmdldEtleSgpfWAgfSxcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhY2sgPSBjb252ZXJ0ZXIuZnJvbUNoYW5nZVBhY2socmVzLmNoYW5nZVBhY2spO1xuICAgICAgICAgICAgZG9jLmFwcGx5Q2hhbmdlUGFjayhwYWNrKTtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoSW50ZXJuYWwoZG9jLmdldEtleSgpKTtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBbUkRdIGM6XCIke3RoaXMuZ2V0S2V5KCl9XCIgcmVtb3ZlcyBkOlwiJHtkb2MuZ2V0S2V5KCl9XCJgKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFtSRF0gYzpcIiR7dGhpcy5nZXRLZXkoKX1cIiBlcnIgOmAsIGVycik7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgc3Vic2NyaWJlYCBzdWJzY3JpYmVzIHRvIHRoZSBnaXZlbiB0b3BpY3MuXG4gICAgICovXG4gICAgc3Vic2NyaWJlKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRTdHJlYW0uc3Vic2NyaWJlKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0SURgIHJldHVybnMgYSBBY3RvcklEIG9mIGNsaWVudC5cbiAgICAgKi9cbiAgICBnZXRJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBnZXRLZXlgIHJldHVybnMgYSBrZXkgb2YgY2xpZW50LlxuICAgICAqL1xuICAgIGdldEtleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgaXNBY3RpdmVgIGNoZWNrcyBpZiB0aGUgY2xpZW50IGlzIGFjdGl2ZS5cbiAgICAgKi9cbiAgICBpc0FjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSBDbGllbnRTdGF0dXMuQWN0aXZhdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ2V0U3RhdHVzYCByZXR1cm5zIHRoZSBzdGF0dXMgb2YgdGhpcyBjbGllbnQuXG4gICAgICovXG4gICAgZ2V0U3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXM7XG4gICAgfVxuICAgIHJ1blN5bmNMb29wKCkge1xuICAgICAgICBjb25zdCBkb0xvb3AgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgW1NMXSBjOlwiJHt0aGlzLmdldEtleSgpfVwiIGV4aXQgc3luYyBsb29wYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3luY0pvYnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgWywgYXR0YWNobWVudF0gb2YgdGhpcy5hdHRhY2htZW50TWFwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnQubmVlZFJlYWx0aW1lU3luYygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQucmVtb3RlQ2hhbmdlRXZlbnRSZWNlaXZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzeW5jSm9icy5wdXNoKHRoaXMuc3luY0ludGVybmFsKGF0dGFjaG1lbnQsIGF0dGFjaG1lbnQuc3luY01vZGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQcm9taXNlLmFsbChzeW5jSm9icylcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiBzZXRUaW1lb3V0KGRvTG9vcCwgdGhpcy5zeW5jTG9vcER1cmF0aW9uKSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgW1NMXSBjOlwiJHt0aGlzLmdldEtleSgpfVwiIHN5bmMgZmFpbGVkOmAsIGVycik7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudFN0cmVhbU9ic2VydmVyLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBDbGllbnRFdmVudFR5cGUuRG9jdW1lbnRTeW5jZWQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBEb2N1bWVudFN5bmNSZXN1bHRUeXBlLlN5bmNGYWlsZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChkb0xvb3AsIHRoaXMucmV0cnlTeW5jTG9vcERlbGF5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoYFtTTF0gYzpcIiR7dGhpcy5nZXRLZXkoKX1cIiBydW4gc3luYyBsb29wYCk7XG4gICAgICAgIGRvTG9vcCgpO1xuICAgIH1cbiAgICBhc3luYyBydW5XYXRjaExvb3AoZG9jS2V5KSB7XG4gICAgICAgIGNvbnN0IGF0dGFjaG1lbnQgPSB0aGlzLmF0dGFjaG1lbnRNYXAuZ2V0KGRvY0tleSk7XG4gICAgICAgIGlmICghYXR0YWNobWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFlvcmtpZUVycm9yKGVycm9yX0NvZGUuRG9jdW1lbnROb3RBdHRhY2hlZCwgYCR7ZG9jS2V5fSBpcyBub3QgYXR0YWNoZWRgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXR0YWNobWVudC5ydW5XYXRjaExvb3AoKG9uRGlzY29ubmVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFlvcmtpZUVycm9yKGVycm9yX0NvZGUuQ2xpZW50Tm90QWN0aXZlLCBgJHt0aGlzLmtleX0gaXMgbm90IGFjdGl2ZWApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gdGhpcy5ycGNDbGllbnQud2F0Y2hEb2N1bWVudCh7XG4gICAgICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRJZDogYXR0YWNobWVudC5kb2NJRCxcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICd4LXNoYXJkLWtleSc6IGAke3RoaXMuYXBpS2V5fS8ke2RvY0tleX1gIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBhYy5zaWduYWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTdHJlYW1PYnNlcnZlci5uZXh0KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBDbGllbnRFdmVudFR5cGUuU3RyZWFtQ29ubmVjdGlvblN0YXR1c0NoYW5nZWQsXG4gICAgICAgICAgICAgICAgdmFsdWU6IFN0cmVhbUNvbm5lY3Rpb25TdGF0dXMuQ29ubmVjdGVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgW1dEXSBjOlwiJHt0aGlzLmdldEtleSgpfVwiIHdhdGNoZXMgZDpcIiR7ZG9jS2V5fVwiYCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZVN0cmVhbSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgcmVzcCBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVdhdGNoRG9jdW1lbnRzUmVzcG9uc2UoYXR0YWNobWVudCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URShoYWNrZXJ3aW5zKTogV2hlbiB0aGUgZmlyc3QgcmVzcG9uc2UgaXMgcmVjZWl2ZWQsIHdlIG5lZWQgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXNvbHZlIHRoZSBwcm9taXNlIHRvIG5vdGlmeSB0aGF0IHRoZSB3YXRjaCBzdHJlYW0gaXMgcmVhZHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3AuYm9keS5jYXNlID09PSAnaW5pdGlhbGl6YXRpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoW3N0cmVhbSwgYWNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudFN0cmVhbU9ic2VydmVyLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IENsaWVudEV2ZW50VHlwZS5TdHJlYW1Db25uZWN0aW9uU3RhdHVzQ2hhbmdlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogU3RyZWFtQ29ubmVjdGlvblN0YXR1cy5EaXNjb25uZWN0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgW1dEXSBjOlwiJHt0aGlzLmdldEtleSgpfVwiIHVud2F0Y2hlc2ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25EaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaGFuZGxlU3RyZWFtKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZVdhdGNoRG9jdW1lbnRzUmVzcG9uc2UoYXR0YWNobWVudCwgcmVzcCkge1xuICAgICAgICBjb25zdCBkb2NLZXkgPSBhdHRhY2htZW50LmRvYy5nZXRLZXkoKTtcbiAgICAgICAgaWYgKHJlc3AuYm9keS5jYXNlID09PSAnaW5pdGlhbGl6YXRpb24nKSB7XG4gICAgICAgICAgICBjb25zdCBjbGllbnRJRHMgPSByZXNwLmJvZHkudmFsdWUuY2xpZW50SWRzO1xuICAgICAgICAgICAgY29uc3Qgb25saW5lQ2xpZW50cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2xpZW50SUQgb2YgY2xpZW50SURzKSB7XG4gICAgICAgICAgICAgICAgb25saW5lQ2xpZW50cy5hZGQoY2xpZW50SUQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXR0YWNobWVudC5kb2Muc2V0T25saW5lQ2xpZW50cyhvbmxpbmVDbGllbnRzKTtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQuZG9jLnB1Ymxpc2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IERvY0V2ZW50VHlwZS5Jbml0aWFsaXplZCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogYXR0YWNobWVudC5kb2MuZ2V0UHJlc2VuY2VzKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNwLmJvZHkuY2FzZSA9PT0gJ2V2ZW50Jykge1xuICAgICAgICAgICAgY29uc3QgcGJXYXRjaEV2ZW50ID0gcmVzcC5ib2R5LnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgZXZlbnRUeXBlID0gcGJXYXRjaEV2ZW50LnR5cGU7XG4gICAgICAgICAgICBjb25zdCBwdWJsaXNoZXIgPSBwYldhdGNoRXZlbnQucHVibGlzaGVyO1xuICAgICAgICAgICAgc3dpdGNoIChldmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHJlc291cmNlc19wYi5Eb2NFdmVudFR5cGUuRE9DVU1FTlRfQ0hBTkdFRDpcbiAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudC5yZW1vdGVDaGFuZ2VFdmVudFJlY2VpdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudFN0cmVhbU9ic2VydmVyLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQ2xpZW50RXZlbnRUeXBlLkRvY3VtZW50Q2hhbmdlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBbZG9jS2V5XSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgcmVzb3VyY2VzX3BiLkRvY0V2ZW50VHlwZS5ET0NVTUVOVF9XQVRDSEVEOlxuICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50LmRvYy5hZGRPbmxpbmVDbGllbnQocHVibGlzaGVyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URShjaGFjaGE5MTIpOiBXZSBhZGRlZCB0byBvbmxpbmVDbGllbnRzLCBidXQgd2Ugd29uJ3QgdHJpZ2dlciB3YXRjaGVkIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHVubGVzcyB3ZSBhbHNvIGtub3cgdGhlaXIgaW5pdGlhbCBwcmVzZW5jZSBkYXRhIGF0IHRoaXMgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRhY2htZW50LmRvYy5oYXNQcmVzZW5jZShwdWJsaXNoZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50LmRvYy5wdWJsaXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBEb2NFdmVudFR5cGUuV2F0Y2hlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRJRDogcHVibGlzaGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW5jZTogYXR0YWNobWVudC5kb2MuZ2V0UHJlc2VuY2UocHVibGlzaGVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSByZXNvdXJjZXNfcGIuRG9jRXZlbnRUeXBlLkRPQ1VNRU5UX1VOV0FUQ0hFRDoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVzZW5jZSA9IGF0dGFjaG1lbnQuZG9jLmdldFByZXNlbmNlKHB1Ymxpc2hlcik7XG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQuZG9jLnJlbW92ZU9ubGluZUNsaWVudChwdWJsaXNoZXIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFKGNoYWNoYTkxMik6IFRoZXJlIGlzIG5vIHByZXNlbmNlLCB3aGVuIFByZXNlbmNlQ2hhbmdlKGNsZWFyKSBpcyBhcHBsaWVkIGJlZm9yZSB1bndhdGNoaW5nLlxuICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGF0IGNhc2UsIHRoZSAndW53YXRjaGVkJyBldmVudCBpcyB0cmlnZ2VyZWQgd2hpbGUgaGFuZGxpbmcgdGhlIFByZXNlbmNlQ2hhbmdlLlxuICAgICAgICAgICAgICAgICAgICBpZiAocHJlc2VuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQuZG9jLnB1Ymxpc2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IERvY0V2ZW50VHlwZS5VbndhdGNoZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHsgY2xpZW50SUQ6IHB1Ymxpc2hlciwgcHJlc2VuY2UgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXRhY2hJbnRlcm5hbChkb2NLZXkpIHtcbiAgICAgICAgLy8gTk9URShoYWNrZXJ3aW5zKTogSWYgYXR0YWNobWVudCBpcyBub3QgZm91bmQsIGl0IG1lYW5zIHRoYXQgdGhlIGRvY3VtZW50XG4gICAgICAgIC8vIGhhcyBiZWVuIGFscmVhZHkgZGV0YWNoZWQgYnkgYW5vdGhlciByb3V0aW5lLlxuICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiBkZXRhY2ggb3IgcmVtb3ZlIGlzIGNhbGxlZCB3aGlsZSB0aGUgd2F0Y2ggbG9vcCBpc1xuICAgICAgICAvLyBydW5uaW5nLlxuICAgICAgICBjb25zdCBhdHRhY2htZW50ID0gdGhpcy5hdHRhY2htZW50TWFwLmdldChkb2NLZXkpO1xuICAgICAgICBpZiAoIWF0dGFjaG1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhdHRhY2htZW50LmNhbmNlbFdhdGNoU3RyZWFtKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgW1dEXSBjOlwiJHt0aGlzLmdldEtleSgpfVwiIHVud2F0Y2hlc2ApO1xuICAgICAgICB0aGlzLmV2ZW50U3RyZWFtT2JzZXJ2ZXIubmV4dCh7XG4gICAgICAgICAgICB0eXBlOiBDbGllbnRFdmVudFR5cGUuU3RyZWFtQ29ubmVjdGlvblN0YXR1c0NoYW5nZWQsXG4gICAgICAgICAgICB2YWx1ZTogU3RyZWFtQ29ubmVjdGlvblN0YXR1cy5EaXNjb25uZWN0ZWQsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmF0dGFjaG1lbnRNYXAuZGVsZXRlKGRvY0tleSk7XG4gICAgfVxuICAgIHN5bmNJbnRlcm5hbChhdHRhY2htZW50LCBzeW5jTW9kZSkge1xuICAgICAgICBjb25zdCB7IGRvYywgZG9jSUQgfSA9IGF0dGFjaG1lbnQ7XG4gICAgICAgIGNvbnN0IHJlcVBhY2sgPSBkb2MuY3JlYXRlQ2hhbmdlUGFjaygpO1xuICAgICAgICByZXR1cm4gdGhpcy5ycGNDbGllbnRcbiAgICAgICAgICAgIC5wdXNoUHVsbENoYW5nZXMoe1xuICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICBkb2N1bWVudElkOiBkb2NJRCxcbiAgICAgICAgICAgIGNoYW5nZVBhY2s6IGNvbnZlcnRlci50b0NoYW5nZVBhY2socmVxUGFjayksXG4gICAgICAgICAgICBwdXNoT25seTogc3luY01vZGUgPT09IFN5bmNNb2RlLlB1c2hPbmx5LFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7ICd4LXNoYXJkLWtleSc6IGAke3RoaXMuYXBpS2V5fS8ke2RvYy5nZXRLZXkoKX1gIH0sXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXNwUGFjayA9IGNvbnZlcnRlci5mcm9tQ2hhbmdlUGFjayhyZXMuY2hhbmdlUGFjayk7XG4gICAgICAgICAgICAvLyAoY2hhY2hhOTEyLCBoYWNrZXJ3aW5zKTogSWYgc3luY0xvb3AgYWxyZWFkeSBleGVjdXRlZCB3aXRoXG4gICAgICAgICAgICAvLyBQdXNoUHVsbCwgaWdub3JlIHRoZSByZXNwb25zZSB3aGVuIHRoZSBzeW5jTW9kZSBpcyBQdXNoT25seS5cbiAgICAgICAgICAgIGlmIChyZXNwUGFjay5oYXNDaGFuZ2VzKCkgJiYgc3luY01vZGUgPT09IFN5bmNNb2RlLlB1c2hPbmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvYy5hcHBseUNoYW5nZVBhY2socmVzcFBhY2spO1xuICAgICAgICAgICAgdGhpcy5ldmVudFN0cmVhbU9ic2VydmVyLm5leHQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IENsaWVudEV2ZW50VHlwZS5Eb2N1bWVudFN5bmNlZCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogRG9jdW1lbnRTeW5jUmVzdWx0VHlwZS5TeW5jZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIChjaGFjaGE5MTIpOiBJZiBhIGRvY3VtZW50IGhhcyBiZWVuIHJlbW92ZWQsIHdhdGNoU3RyZWFtIHNob3VsZFxuICAgICAgICAgICAgLy8gYmUgZGlzY29ubmVjdGVkIHRvIG5vdCByZWNlaXZlIGFuIGV2ZW50IGZvciB0aGF0IGRvY3VtZW50LlxuICAgICAgICAgICAgaWYgKGRvYy5nZXRTdGF0dXMoKSA9PT0gRG9jdW1lbnRTdGF0dXMuUmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoSW50ZXJuYWwoZG9jLmdldEtleSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRvY0tleSA9IGRvYy5nZXRLZXkoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlbW90ZVNpemUgPSByZXNwUGFjay5nZXRDaGFuZ2VTaXplKCk7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgW1BQXSBjOlwiJHt0aGlzLmdldEtleSgpfVwiIHN5bmMgZDpcIiR7ZG9jS2V5fVwiLCBwdXNoOiR7cmVxUGFjay5nZXRDaGFuZ2VTaXplKCl9IHB1bGw6JHtyZW1vdGVTaXplfSBjcDoke3Jlc3BQYWNrXG4gICAgICAgICAgICAgICAgLmdldENoZWNrcG9pbnQoKVxuICAgICAgICAgICAgICAgIC50b1Rlc3RTdHJpbmcoKX1gKTtcbiAgICAgICAgICAgIHJldHVybiBkb2M7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBbUFBdIGM6XCIke3RoaXMuZ2V0S2V5KCl9XCIgZXJyIDpgLCBlcnIpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy95b3JraWUudHNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBUaGUgWW9ya2llIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8qKlxuICogVGhlIHRvcC1sZXZlbCB5b3JraWUgbmFtZXNwYWNlIHdpdGggYWRkaXRpb25hbCBwcm9wZXJ0aWVzLlxuICpcbiAqIEluIHByb2R1Y3Rpb24sIHRoaXMgd2lsbCBiZSBjYWxsZWQgZXhhY3RseSBvbmNlIGFuZCB0aGUgcmVzdWx0XG4gKiBhc3NpZ25lZCB0byB0aGUgYHlvcmtpZWAgZ2xvYmFsLlxuICpcbiAqIGUuZykgYG5ldyB5b3JraWUuQ2xpZW50KC4uLik7YFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgeW9ya2llID0ge1xuICAgIENsaWVudDogQ2xpZW50LFxuICAgIERvY3VtZW50OiBEb2N1bWVudCxcbiAgICBQcmltaXRpdmU6IFByaW1pdGl2ZSxcbiAgICBUZXh0OiBUZXh0LFxuICAgIENvdW50ZXI6IENvdW50ZXIsXG4gICAgVHJlZTogVHJlZSxcbiAgICBJbnRUeXBlOiBDb3VudGVyVHlwZS5JbnRlZ2VyQ250LFxuICAgIExvbmdUeXBlOiBDb3VudGVyVHlwZS5Mb25nQ250LFxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3Qgc3JjX3lvcmtpZSA9ICh5b3JraWUpO1xuXG59KSgpO1xuXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD15b3JraWUtanMtc2RrLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/yorkie-js-sdk/dist/yorkie-js-sdk.js\n");

/***/ })

};
;